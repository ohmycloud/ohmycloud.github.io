<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[operator on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/tags/operator/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/tags/operator/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/tags/operator/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/tags/operator/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-13T22:14:20+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/tags/operator/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的操作符]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-16-operator-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-16-operator-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Operator in Raku</blockquote><h2 id="操作符httpsdocsrakuorglanguageoperators"><a href="https://docs.raku.org/language/operators">操作符</a></h2>
<h3 id="操作符优先级">操作符优先级</h3>
<p>在像 <code>1 + 2 * 3</code> 这样的表达式中, <code>2 * 3</code> 被首先计算, 因为中缀操作符  <code>*</code> 的优先级比 <code>+</code> 的优先级高。下面的表中总结了 Perl  6 中  的优先级级别, 从最牢固到最松散：</p>
<pre><code>A	Level	           Examples
N	Terms	           42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array
L	方法后缀	        .meth .+ .? .* .() .[] .{} .&lt;&gt; .«» .:: .= .^ .:
N	自增	              ++ --
R	求幂	              **
L	Symbolic unary	   ! + - ~ ? | || +^ ~^ ?^ ^
L	乘法	              * / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm
L	加法	              + - +| +^ ~| ~^ ?| ?^
L	重复	              x xx
X	连结                ~
X	Junctive and	   &amp;
X	Junctive or	       | ^
L	Named unary	       temp let
N	Structural infix   but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^
C	Chaining infix	   != == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv
X	Tight and	       &amp;&amp;
X	Tight or	       || ^^ // min max
R	Conditional	       ?? !! ff fff
R	Item assignment	   = =&gt; += -= **= xx= .=
L	Loose unary	       so not
X	Comma operator	   , :
X	List infix	       Z minmax X X~ X* Xeqv ...
R	List prefix	       print push say die map substr ... [+] [*] any Z=
X	Loose and	       and andthen
X	Loose or	       or xor orelse
X	Sequencer	       &lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;
N	Terminator	       ; {...}, unless, extra ), ], }
</code></pre><p>下面使用的两处 <code>!</code> 符号一般代表任何一对儿拥有相同优先级的操作符, 上表指定的二元操作符的结合性解释如下(其中 A 代表结合性, associativities )：</p>
<pre><code>A	Assoc	Meaning of $a ! $b ! $c
L	left	($a ! $b) ! $c
R	right	$a ! ($b ! $c)
N	non	    ILLEGAL
C	chain	($a ! $b) and ($b ! $c)
X	list	infix:&lt;!&gt;($a; $b; $)
</code></pre><p>对于一元操作符, 这解释为:</p>
<pre><code>A	Assoc	Meaning of !$a!
L	left	(!$a)!
R	right	!($a!)
N	non	    ILLEGAL
</code></pre><p>下面描述的操作符, 默认假定为 left 结合性。</p>
<h3 id="操作符种类">操作符种类</h3>
<p>操作符能出现在相对于 term 的几个位置处：</p>
<pre><code>+term	        prefix         (后缀)
term1 + term2	infix          (中缀)
term++	        postfix        (后缀)
(term)	        circumfix      (环缀)
term1[term2]	postcircumfix  (后环缀)
</code></pre><p>每个操作符也可以用作子例程。这样的子例程的名字由操作符的种类, 然后后跟一个冒号, 再加上一组引号结构, 引号结构中是组成操作符的符号(s):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>                           <span class="c1"># same as 1 + 2</span>
<span class="n">circumfix:</span><span class="p">«</span><span class="s2">( )</span><span class="p">»(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;)</span>            <span class="c1"># same as (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), 目前编译错误。</span>
<span class="n">circumfix:</span><span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">raku</span><span class="o">.</span><span class="nb">say</span>   <span class="c1"># [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]</span>
</code></pre></div><p>作为一种特殊情况, listop(列表操作符)既能作为 term 又能作为前缀。子例程调用是最常见的列表操作符。其它情况包括元运算中缀操作符 <code>[+]| 1, 2, 3</code> 和 <code>prefix</code> 等 stub 操作符。</p>
<p>定义自定义操作符在 <a href="http://doc.raku.org/language/functions#Defining_Operators"> /language/functions#Defining_Operators.</a>  中有涉及。</p>
<h3 id="term-优先级">Term 优先级</h3>
<h4 id="环缀--">环缀 &lt; &gt;</h4>
<p>引起单词的结构, 以空白隔开内容。如果单词看起来像数字字面量或 <code>Pair</code> 字面量, 那么它会被转为合适的数字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>  <span class="c1"># b</span>
</code></pre></div><h3 id="环缀---1">环缀 ( )</h3>
<p>分组操作符。</p>
<p>在参数列表中, 在参数周围放上圆括号防止了参数被解释为具名参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">p</span><span class="p">(</span><span class="o">:</span><span class="nv">$a</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">named</span><span class="p">&#39;</span>      <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">p</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span>   <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">positional</span><span class="p">&#39;</span> <span class="p">}</span>
<span class="n">p</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1"># named</span>
<span class="n">p</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>     <span class="c1"># positional</span>
</code></pre></div><h3 id="环缀---2">环缀 { }</h3>
<p>Block 或 散列构造器。</p>
<p>如果 <code>{}</code> 里面的内容看起来像一组 pairs 并且没有 <code>$_</code> 或其它占位符参数, 就返回一个散列, 这个散列由逐项逐项的 Pair 组成。</p>
<p>否则就返回一个 Block。</p>
<p>注意, 这个结构没有重新解析内容; 而里面的内容总是被解析为一组句子（例如, 像一个 block）, 并且如果后面的分析表明它需要被解析成一个散列, 那么 block 就会被执行并强转为散列。</p>
<h3 id="环缀---3">环缀 [ ]</h3>
<p>数组构造器。在列表上下文中返回一个不会展平的 item 化的数组。</p>
<h2 id="方法后缀优先级">方法后缀优先级</h2>
<h3 id="后环缀--">后环缀 [ ]</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">postcircumfix:</span><span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;(</span><span class="nv">@container</span><span class="o">,</span> <span class="o">**</span><span class="nv">@index</span><span class="o">,</span>
                        <span class="o">:</span><span class="nv">$k</span><span class="o">,</span> <span class="o">:</span><span class="nv">$v</span><span class="o">,</span> <span class="o">:</span><span class="nv">$kv</span><span class="o">,</span> <span class="o">:</span><span class="nv">$p</span><span class="o">,</span> <span class="o">:</span><span class="nv">$exists</span><span class="o">,</span> <span class="o">:</span><span class="nv">$delete</span><span class="p">)</span>
</code></pre></div><p><code>:$k</code> 会创建一个 Pair, 它是散列中的一个条目。键是 <code>k</code>, 键值为 <code>$kv</code>。所以, <code>$k</code> 等价于 <code>k</code> =&gt; <code>$k</code></p>
<p>访问 <code>@container</code>  中的一个或多个元素, 即数组索引操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>                   <span class="c1">#-&gt; a</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>                   <span class="c1">#-&gt; b</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>                 <span class="c1">#-&gt; z</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>          <span class="c1">#-&gt; False</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">11</span><span class="o">].</span><span class="nb">join</span><span class="p">;</span>  <span class="c1">#-&gt; perl</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">23</span> <span class="o">..</span> <span class="o">*].</span><span class="nb">raku</span><span class="p">;</span>        <span class="c1">#-&gt; (&#34;x&#34;, &#34;y&#34;, &#34;z&#34;)</span>

<span class="nv">@alphabet</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">B</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">C</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="o">].</span><span class="nb">raku</span>            <span class="c1">#-&gt; (&#34;a&#34;, &#34;B&#34;, &#34;C&#34;, &#34;d&#34;)</span>
</code></pre></div><p>查看 <a href="http://doc.raku.org/language/subscripts">Subscripts</a> 获取关于该操作符行为的更详细的解释, 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---1">后环缀 { }</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">postcircumfix:</span><span class="p">&lt;</span><span class="s">{ }</span><span class="p">&gt;(</span><span class="nv">%container</span><span class="o">,</span> <span class="o">**</span><span class="nv">@key</span><span class="o">,</span>
                        <span class="o">:</span><span class="nv">$k</span><span class="o">,</span> <span class="o">:</span><span class="nv">$v</span><span class="o">,</span> <span class="o">:</span><span class="nv">$kv</span><span class="o">,</span> <span class="o">:</span><span class="nv">$p</span><span class="o">,</span> <span class="o">:</span><span class="nv">$exists</span><span class="o">,</span> <span class="o">:</span><span class="nv">$delete</span><span class="p">)</span>
</code></pre></div><p>访问 <code>%container</code> 的一个或多个元素, 即散列索引操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">banana</span><span class="p">&#34;};</span>               <span class="c1">#-&gt; yellow</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;}</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">strawberry</span><span class="p">&#34;}:</span><span class="s">exists</span><span class="p">;</span>    <span class="c1">#-&gt; False</span>

<span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">banana</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">lime</span><span class="p">&#34;}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">yellowish</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;;</span>
<span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;}:</span><span class="s">delete</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">;</span>  <span class="c1">#-&gt; banana =&gt; yellowish, kiwi =&gt; green, lime =&gt; green</span>
</code></pre></div><p>查看后环缀 <code>&lt; &gt;</code> 和后环缀 <code>« »</code> 作为便捷形式, 查看 <code>Subscripts</code> 获取这个操作符行为的更详细解释, 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---2">后环缀 &lt; &gt;</h3>
<p>后环缀 <code>{ }</code> 的简写形式, 它会引起它的参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">banana</span><span class="p">&gt;;</span>             <span class="c1">#-&gt; yellow</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">cherry kiwi</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">strawberry</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1">#-&gt; False</span>
</code></pre></div><p>这不是一个真正的操作符, 它仅仅是一个在编译时把 <code>&lt; &gt;</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---3">后环缀 « »</h3>
<p>后环缀 <code>{ }</code> 的简写形式。它会引起它的参数, 并且 <code>« »</code> 中能进行变量插值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$fruit</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">«</span><span class="s2">cherry </span><span class="nv">$fruit</span><span class="p">»</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
</code></pre></div><p>这不是一个真正的操作符, 它仅仅是一个在编译时把 <code>« »</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---4">后环缀 ( )</h3>
<p>调用操作符。把调用者当作 <code>Callable</code> 并引用它, 它使用圆括号之间的表达式作为参数。</p>
<p>注意, 标识符后面直接跟着一对儿圆括号总是被解析为子例程调用。</p>
<p>如果你想要你的对象响应该调用操作符, 你需要实现 <code>CALL-ME</code> 方法。</p>
<h3 id="postfix-">postfix .</h3>
<p>该操作符用于调用一个方法, <code>$invocant.method</code>。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--1">postfix .=</h3>
<p>可变的方法调用。<code>$invocant.=method</code>, 脱去语法糖后就是 <code>$invocant = $invocant.method</code>, 这与 <a href="http://doc.raku.org/routine/op%3D">op=.</a> 类似。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--2">postfix .^</h3>
<p>元方法调用。<code> $invocant.^method</code> 在 <code>$invocant</code> 的元类身上调用方法。脱去语法糖后, 它就是 <code>$invocant.HOW.method($invocant, ...)</code>。查看 <a href="http://doc.raku.org/type/HOW">HOW</a> 获取更多信息。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--3">postfix .?</h3>
<p>有可能被调用的方法调用。如果有名为 <code>method</code> 的方法, <code>$invocant.?method</code> 就在 <code>$invocant</code> 上调用 <code>method</code> 方法。否则它就返回 <code>Nil</code>。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--4">postfix .+</h3>
<p><code>$invocant.+method </code> 从 <code>$invocant</code> 身上调用所有叫做 <code>method</code> 的方法。如果没有找到这个名字的方法, 就会死掉。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--5">postfix .*</h3>
<p><code>$invocant.*method</code> 从 <code>$invocant</code> 身上调用所有叫做 <code>method</code> 的方法。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-postfix">postfix .postfix</h3>
<p>大多数情况下, 可以在后缀或后环缀前面放上一个点：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span>
<span class="nv">@a</span><span class="o">.[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Same</span>
</code></pre></div><p>这对于视觉清晰或简洁很有帮助。例如, 如果对象的属性是一个函数, 在属性名后面放置一对儿圆括号会变成方法调用的一部分。所以要么使用两对儿圆括号, 要么在圆括号前面放上一个点来阻止方法调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Operation</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.symbol</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">&amp;.function</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$addition</span> <span class="o">=</span> <span class="n">Operation</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">symbol</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;</span><span class="o">,</span> 
                             <span class="p">:</span><span class="s">function</span><span class="p">{</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="p">});</span>
<span class="nb">say</span> <span class="nv">$addition</span><span class="o">.</span><span class="nf">function</span><span class="p">()(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># 3</span>
</code></pre></div><p>或者:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$addition</span><span class="o">.</span><span class="nf">function</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1"># 3</span>
</code></pre></div><p>然而, 如果后缀是一个标识符, 那么它会被解释为一个普通的方法调用。</p>
<pre><code>1.i # No such method 'i' for invocant of type 'Int'
</code></pre><p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-prefix">postfix .:<!-- raw HTML omitted --></h3>
<p>前缀能够像方法那样, 使用冒号对儿标记法来调用。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">++</span><span class="nv">$a</span><span class="p">;</span>     <span class="c1"># 2</span>
<span class="nb">say</span> <span class="nv">$a</span><span class="o">.:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;;</span> <span class="c1"># 3</span>
</code></pre></div><p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--6">postfix .::</h3>
<p>一个类限定的方法调用, 用于调用一个定义在父类或 role 中的方法, 甚至在子类中重新定义了之后。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">baz</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="k">is</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">baz</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">nope</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Foo</span><span class="o">.</span><span class="nf">Bar::baz</span><span class="p">;</span> <span class="c1"># 42</span>
</code></pre></div><h2 id="自增优先级">自增优先级</h2>
<h3 id="prefix-">prefix ++</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数增加 1, 并返回增加后的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">++</span><span class="nv">$x</span><span class="p">;</span>    <span class="c1"># 4</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>      <span class="c1"># 4</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法, 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<h3 id="prefix---">prefix &ndash;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">--</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数减少 1, 并返回减少后的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">--</span><span class="nv">$x</span><span class="p">;</span>       <span class="c1"># 2</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 2</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法, 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<h3 id="postfix--7">postfix ++</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数增加 1, 并返回 <code>unincremented</code> 的那个值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>       <span class="c1"># 3</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 4</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法, 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<p>注意这并不一定返回它的参数。例如, 对于未定义的值, 它返回 0:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>       <span class="c1"># 0</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 1</span>
</code></pre></div><h3 id="postfix---">postfix &ndash;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">--</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数减少 1, 并返回 <code>undecremented</code> 的那个值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x--</span><span class="p">;</span>       <span class="c1"># 3</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 2</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法, 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<p>注意这并不一定返回它的参数。例如, 对于未定义的值, 它返回 0:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x--</span><span class="p">;</span>       <span class="c1"># 0</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># -1</span>
</code></pre></div><h2 id="求幂优先级">求幂优先级</h2>
<h3 id="infix-">infix **</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">**</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">right</span><span class="p">&gt;</span>
</code></pre></div><p>求幂操作符把它的两个参数都强制转为 <code>Numeric</code> , 然后计算, 右侧为幂。</p>
<p>如果 <code>**</code> 右边是一个非负整数, 并且左侧是任意精度类型(Int, FatRat), 那么计算不会损失精度。</p>
<h2 id="象形一元操作符的优先级">象形一元操作符的优先级</h2>
<h3 id="prefix--1">prefix ?</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool。注意, 这会使 Junctions 失效。</p>
<h3 id="prefix--2">prefix !</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>否定的布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool, 并返回结果的否定值。注意, 这会使 Junctions 失效。</p>
<h3 id="prefix--3">prefix +</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型。</p>
<h3 id="prefix--">prefix -</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>否定的 Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型, 并返回结果的否定值。</p>
<h3 id="prefix--4">prefix ~</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>字符串上下文操作符。</p>
<p>通过在参数身上调用 <code>Str</code> 方法强制把参数转为 <code>Str</code> 类型。</p>
<h3 id="prefix--5">prefix |</h3>
<p>将 Capture, Enum, Pair, List, EnumMap 和 Hash 展平到参数列表中。</p>
<p>（在 Rakudo 中, 这不是作为一个合适的操作符来实现的, 而是编译器中的一种特殊情况, 这意味着它只对参数列表有效, 而非在任意代码中都有效。）</p>
<h3 id="prefix--6">prefix +^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+^</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>整数按位取反。</p>
<p>将参数强转为 Int 类型并对结果按位取反, 假设两者互补。</p>
<h3 id="prefix--7">prefix ?^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?^</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>布尔按位取反。</p>
<p>将参数强转为 Bool, 然后按位反转, 这使它和 prefix:&lt;!&gt;  一样。</p>
<h3 id="prefix--8">prefix ^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span>
</code></pre></div><p>upto 操作符.</p>
<p>强制把它的参数转为 Numeric, 生成一个从 0 直到（但是排除） 参数为止的范围。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">^</span><span class="mi">5</span><span class="p">;</span>         <span class="c1"># 0..^5</span>
<span class="k">for</span> <span class="o">^</span><span class="mi">5</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 5 iterations</span>
</code></pre></div><h2 id="乘法优先级">乘法优先级</h2>
<h3 id="infix--1">infix *</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">*</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>把两边的参数都强转为 Numeric 并把它们相乘。结果是一个更宽的类型。查看 Numeric 获取更详细信息。</p>
<h3 id="infix--2">infix /</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">/</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>把两边的参数都强制为 Numeric, 并用左边除以右边的数。整数相除返回 Rat, 否则返回&quot;更宽类型&quot;的结果。</p>
<h3 id="infix-div">infix div</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">div</span><span class="p">&gt;(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>整除。向下取整。</p>
<h3 id="infix--3">infix %</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">%</span><span class="p">&gt;(</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="p">)</span> <span class="k">return</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>模操作符。首先强制为 Numeric。</p>
<p>通常, 下面的等式是成立的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$x</span> <span class="nv">%</span> <span class="nv">$y</span> <span class="o">==</span> <span class="nv">$x</span> <span class="o">-</span> <span class="nb">floor</span><span class="p">(</span><span class="nv">$x</span> <span class="o">/</span> <span class="nv">$y</span><span class="p">)</span> <span class="o">*</span> <span class="nv">$y</span>
</code></pre></div><h3 id="infix--4">infix %%</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">%%</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>整除操作符, 如果 <code>$a % $b == 0</code> 则返回 True.</p>
<h3 id="infix-mod">infix mod</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">mod</span><span class="p">&gt;(</span><span class="nb">Int:D</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Int:D</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>整数取模操作符。返回整数取模操作的剩余部分。</p>
<h3 id="infix--5">infix +&amp;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+&amp;</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>Numeric 按位 <code>AND</code>。把两个参数都强转为 Int 并执行按位 AND 操作, 假定两者是互补的。</p>
<h3 id="infix--6">infix +&lt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2"> +&lt; </span><span class="p">&gt;&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>向左移动整数个位。</p>
<h3 id="infix--7">infix +&gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2"> +&gt; </span><span class="p">&gt;&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>向右移动整数个位。</p>
<h3 id="infix-gcd">infix gcd</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gcd</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数都为 Int 并返回最大公分母（greatest common denominator）。</p>
<h3 id="infix-lcm">infix lcm</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lcm</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数为 Int 并返回最小公倍数(least common multiple)</p>
<h2 id="加法优先级">加法优先级</h2>
<h3 id="infix--8">infix +</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>强制两个参数为 Numeric 并把它们相加。</p>
<h3 id="infix--">infix -</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>强制两个参数为 Numeric 并用第一个参数减去第二个参数。</p>
<h3 id="infix--9">infix +|</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数为 Int 并执行按位 OR（包括 OR）</p>
<h3 id="infix--10">infix +^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数为 Int 并执行按位 XOR（不包括 OR）</p>
<h3 id="infix--11">infix ?|</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>强制两个参数为 Bool 并执行逻辑 OR（不包括 OR）</p>
<h2 id="重复操作符优先级">重复操作符优先级</h2>
<h3 id="infix-x">infix x</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
</code></pre></div><p>把 <code>$a</code> 强转为 Str , 把 <code>$b</code> 强转为 Int, 并重复字符串 <code>$b</code> 次。如果 <code>$b &lt;= 0</code> 则返回空字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">3</span><span class="p">;</span>       <span class="c1"># ababab</span>
<span class="nb">say</span> <span class="mi">42</span> <span class="nb">x</span> <span class="mi">3</span><span class="p">;</span>         <span class="c1"># 424242</span>
</code></pre></div><h3 id="infix-xx">infix xx</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">xx</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一组重复的 <code>$a</code> 并计算 <code>$b</code> 次（<code>$b</code> 被强转为 Int）。如果 <code>$b &lt;= 0</code> ,则返回一个空列表。</p>
<p>每次重复都会计算左侧的值, 所以</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="ow">xx</span> <span class="mi">5</span>
</code></pre></div><p>返回 5 个不同的数组（但是每次都是相同的内容）并且</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">rand</span> <span class="ow">xx</span> <span class="mi">3</span>
</code></pre></div><p>返回 3 个独立的伪随机数。右侧可以是 <code>*</code>, 这时会返回一个惰性的, 无限的列表。</p>
<h2 id="连结">连结</h2>
<h3 id="infix--12">infix ~</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>  <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强制两个参数为 Str 并连结它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>     <span class="c1"># abc</span>
</code></pre></div><h2 id="junctive-and-all-优先级">Junctive AND (all) 优先级</h2>
<h3 id="infix--13">infix &amp;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">&amp;</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>用它的参数创建一个 <code>all</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="junctive-or-any-precedence">Junctive OR (any) Precedence</h2>
<h3 id="infix--14">infix |</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>用它的参数创建一个 <code>any</code> Junction。查看 Junctions 获取更多详情。</p>
<h3 id="infix--15">infix ^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>用它的参数创建一个 <code>one</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="named-unary-precedence">Named Unary Precedence</h2>
<h3 id="prefix-temp">prefix temp</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">temp</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span>
</code></pre></div><p>temporizes 传入的变量作为参数, 这意味着退出作用域后它被重置为旧值。（这和 Perl 5 中的 local 操作符类似, 除了 temp 不重置值之外。）</p>
<h3 id="prefix-let">prefix let</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">let</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span>
</code></pre></div><p>假定重置：如果通过异常或 fail() 退出当前作用域, 旧值就会被恢复。</p>
<h2 id="nonchaining-binary-precedence">Nonchaining Binary Precedence</h2>
<h3 id="infix-does">infix does</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">does</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$obj</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$role</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>在运行时把 <code>$role</code> 混合进 <code>$obj</code> 中。要求 <code>$obj</code> 是可变的。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role, 它可以表现的像是一个 role, 例如枚举值。</p>
<h3 id="infix-but">infix but</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">but</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$obj</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$role</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把 <code>$role</code> 混合进 <code>$obj</code> 并创建一个 <code>$obj</code> 的副本。因为 <code>$obj</code> 是不能修改的, 但是能使用 mixins 用于创建不可变值。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role, 它可以表现的像是一个 role, 例如枚举值。</p>
<h3 id="infix-cmp">infix cmp</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>      <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span>   <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span>    <span class="nb">Str:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>   <span class="n">Enum:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Version:D</span><span class="o">,</span> <span class="nb">Version:D</span><span class="p">)</span>
</code></pre></div><p>一般的, “智能的” 三路比较器。</p>
<p>比较字符串时使用字符串语义, 比较数字时使用数字语义, 比较 Pair 对象时, 先比较键, 再比较值, 等等。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$a</span> <span class="ow">eqv</span> <span class="nv">$b</span><span class="o">,</span> <span class="nb">then</span> <span class="nv">$a</span> <span class="ow">cmp</span> <span class="nv">$b</span> <span class="n">always</span> <span class="k">returns</span> <span class="n">Order::Same</span><span class="o">.</span>
<span class="nb">say</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">cmp</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">);</span>      <span class="c1"># Less</span>
<span class="nb">say</span> <span class="mi">4</span>        <span class="ow">cmp</span> <span class="mf">4.0</span><span class="p">;</span>           <span class="c1"># Same</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span>      <span class="ow">cmp</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>           <span class="c1"># More</span>
</code></pre></div><h3 id="infix-leg">infix leg</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>  <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>字符串三路比较器。leg 是  less, equal 还有 greater 的简写形式？</p>
<p>把两个参数都强转为 <code>Str</code>, 然后按照字母次序比较。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>        <span class="nb">Less</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>        <span class="nb">Same</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>        <span class="nb">More</span>
</code></pre></div><h3 id="infix--16">infix &lt;=&gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=&gt;</span><span class="p">»(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>Numeric 三路比较器。</p>
<p>把两个参数强转为 Real, 并执行数值比较。</p>
<h3 id="infix--17">infix ..</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">..</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range。</p>
<h3 id="infix--18">infix ..^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">..^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range, 不包含末端。</p>
<h3 id="infix--19">infix ^..</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^..</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range, 不包含开始端点。</p>
<h3 id="infix--20">infix ^..^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^..^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range, 不包含开端和末端。</p>
<h2 id="chaining-binary-precedence">Chaining Binary Precedence</h2>
<h3 id="infix--21">infix ==</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nv">$</span><span class="o">,</span> <span class="nv">$</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc:</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Rational:D</span><span class="o">,</span> <span class="nb">Rational:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Complex:D</span><span class="o">,</span> <span class="nb">Complex:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Numeric:D</span><span class="o">,</span> <span class="nb">Numeric:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Numeric（如果必要）, 并返回 True 如果它们相等。</p>
<h3 id="infix--22">infix !=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!=</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</code></pre></div><p>强转两个参数为 Numeric（如果必要）, 并返回 True 如果它们不相等。</p>
<h3 id="infix--23">infix &lt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--24">infix &lt;=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--25">infix &gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数大于第二个参数。</p>
<h3 id="infix--26">infix &gt;=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数大于或等于第二个参数。</p>
<h3 id="infix-eq">infix eq</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>  <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数等于第二个参数。</p>
<p>助记法: equal</p>
<h3 id="infix-ne">infix ne</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 False 如果第一个参数等于第二个参数。</p>
<p>助记法: not equal</p>
<h3 id="infix-gt">infix gt</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater than</p>
<h3 id="infix-ge">infix ge</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater or equal</p>
<h3 id="infix-lt">infix lt</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数小于第二个参数。</p>
<p>助记法: less than</p>
<h3 id="infix-le">infix le</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数小于或等于第二个参数。</p>
<p>助记法: less or equal</p>
<h3 id="infix-before">infix before</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>      <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span>   <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span>    <span class="nb">Str:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>   <span class="n">Enum:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Version:D</span><span class="o">,</span> <span class="nb">Version:D</span><span class="p">)</span>
</code></pre></div><p>一般的排序, 使用和 cmp 相同的语义。如果第一个参数小于第二个参数则返回 True。</p>
<h3 id="infix-after">infix after</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>      <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span>   <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span>    <span class="nb">Str:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>   <span class="n">Enum:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Version:D</span><span class="o">,</span> <span class="nb">Version:D</span><span class="p">)</span>
</code></pre></div><p>一般的排序, 使用和 cmp 相同的语义。如果第一个参数大于第二个参数则返回 True。</p>
<h3 id="infix-eqv">infix eqv</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
</code></pre></div><p>等值操作符。如果两个参数在结构上相同就返回 True。例如, 相同类型（并且递归）包含相同的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="ow">eqv</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># True</span>
<span class="nb">say</span> <span class="nb">Any</span> <span class="ow">eqv</span> <span class="nb">Any</span><span class="p">;</span>                    <span class="c1"># True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="ow">eqv</span> <span class="mi">2</span><span class="p">;</span>                        <span class="c1"># False</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="ow">eqv</span> <span class="mf">1.0</span><span class="p">;</span>                      <span class="c1"># False</span>
</code></pre></div><p>对于任意对象使用默认的 eqv 操作是不可能的。例如, eqv 不认为同一对象的两个实例在结构上是相等的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">eqv</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>  <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> False</span>
</code></pre></div><p>要得到这个类的对象相等（eqv）语义, 需要实现一个合适的中缀 eqv 操作符：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="n">A</span> <span class="nv">$l</span><span class="o">,</span> <span class="n">A</span> <span class="nv">$r</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$l</span><span class="o">.</span><span class="nf">a</span> <span class="ow">eqv</span> <span class="nv">$r</span><span class="o">.</span><span class="nf">a</span> <span class="p">}</span>
<span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">eqv</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>  <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> True</span>
</code></pre></div><h3 id="infix--27">infix ===</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">===</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">===</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
</code></pre></div><p>值相等。如果两个参数都是同一个对象则返回 True。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">===</span> <span class="nv">$a</span><span class="p">;</span>              <span class="c1"># True</span>
<span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span> <span class="o">===</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>        <span class="c1"># False</span>
<span class="nb">say</span> <span class="n">A</span> <span class="o">===</span> <span class="n">A</span><span class="p">;</span>                <span class="c1"># True</span>
</code></pre></div><p>对于值的类型,  <code>===</code> 表现的和 eqv 一样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>            <span class="c1"># True</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>            <span class="c1"># False</span>

<span class="c1"># different types</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">===</span> <span class="mf">1.0</span><span class="p">;</span>              <span class="c1"># False</span>
</code></pre></div><p><code>===</code> 使用 <code>WHICH</code> 方法来获取对象相等, 所以所有的值类型必须重写方法 <code>WHICH</code>。</p>
<h3 id="infix--28">infix =:=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=:=</span><span class="p">&gt;(</span><span class="nb">Mu</span> \<span class="n">a</span><span class="o">,</span> <span class="nb">Mu</span> \<span class="n">b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=:=</span><span class="p">&gt;(</span><span class="nb">Mu</span> \<span class="n">a</span><span class="o">,</span> <span class="nb">Mu</span> \<span class="n">b</span><span class="p">)</span>
</code></pre></div><p>容器相等。返回 True 如果两个参数都绑定到同一个容器上。如果它返回 True, 那通常意味着修改一个参数也会同时修改另外一个。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">=:=</span> <span class="nv">$b</span><span class="p">;</span>      <span class="c1"># False</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>             <span class="c1"># 1</span>
<span class="nv">$b</span> <span class="o">:=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">=:=</span> <span class="nv">$b</span><span class="p">;</span>      <span class="c1"># True</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$b</span><span class="p">;</span>             <span class="c1"># 5</span>
</code></pre></div><h3 id="infix--29">infix ~~</h3>
<p>智能匹配操作符。把左侧参数起别名为 <code>$_</code> , 然后计算右侧的值, 并在它身上调用 <code>.ACCEPTS($_)</code> 。匹配的语义由右侧操作数的类型决定。</p>
<p>这儿有一个内建智能匹配函数的摘要：</p>
<pre><code>右侧      比较语义
Mu:U	  类型检查
Str	      字符串相等
Numeric	  数值相等
Regex	  正则匹配
Callable  调用的布尔结果
Any:D	  对象相等
</code></pre><h2 id="tight-and-precedence">Tight AND Precedence</h2>
<h3 id="infix--30">infix &amp;&amp;</h3>
<p>在布尔上下文中返回第一个求值为 False 的参数, 否则返回最后一个参数。</p>
<p>注意这是短路操作符, 如果其中的一个参数计算为 false 值, 那么该参数右侧的值绝不会被计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">c</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">never called</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nf">a</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">b</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">c</span><span class="p">();</span>      <span class="c1"># 0</span>
</code></pre></div><h2 id="tight-or-precedence">Tight OR Precedence</h2>
<h3 id="infix--31">infix ||</h3>
<p>在布尔上下文中返回第一个求值为 True 的参数, 否则返回最后一个参数。</p>
<p>注意这是短路操作符, 如果其中的一个参数计算为 true 值, 那么该参数右侧的值绝不会被计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">c</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">never called</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nf">a</span><span class="p">()</span> <span class="o">||</span> <span class="nf">b</span><span class="p">()</span> <span class="o">||</span> <span class="nf">c</span><span class="p">();</span>      <span class="c1"># 1</span>
</code></pre></div><h3 id="infix--32">infix ^^</h3>
<p>返回第一个值为 true 的参数如果只有一个的话, 否则返回 Nil。只要找到两个值为 true 的参数就发生短路。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">0</span> <span class="o">^^</span> <span class="mi">42</span><span class="p">;</span>                <span class="c1"># 42</span>
<span class="nb">say</span> <span class="mi">0</span> <span class="o">^^</span> <span class="mi">42</span> <span class="o">^^</span> <span class="mi">1</span> <span class="o">^^</span> <span class="nb">die</span> <span class="mi">8</span><span class="p">;</span>  <span class="c1"># (empty line)</span>
</code></pre></div><p>注意, 这个操作符的语义可能不是你假想的那样： infix <code>^^</code> 翻到它找到的第一个 true 值, 找到第二个 true 值后永远地反转为 Nil 值, 不管还有多少 true 值。（换句话说, 它的语义是&quot;找到一个真值&quot;, 而不是布尔起奇偶校验语义）</p>
<h3 id="infix--33">infix //</h3>
<p>Defined-or  操作符。返回第一个定义了的操作数, 否则返回最后一个操作数。短路操作符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">Any</span> <span class="o">//</span> <span class="mi">0</span> <span class="o">//</span> <span class="mi">42</span><span class="p">;</span>         <span class="c1"># 0</span>
</code></pre></div><h3 id="infix-min">infix min</h3>
<p>返回参数的最小值。语义由 cmp 语义决定。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$foo</span> <span class="nb">min</span><span class="o">=</span> <span class="mi">0</span>  <span class="c1"># read as: $foo decreases to 0</span>
</code></pre></div><h3 id="infix-max">infix max</h3>
<p>返回参数的最大值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$foo</span> <span class="nb">max</span><span class="o">=</span> <span class="mi">0</span>  <span class="c1"># read as: $foo increases to 0</span>
</code></pre></div><h2 id="conditional-operator-precedence">Conditional Operator Precedence</h2>
<h3 id="infix---1">infix ?? !!</h3>
<p>三目操作符, 条件操作符。</p>
<p><code>$condition ?? $true !! $false</code> 计算并返回 <code>$true</code> 表达式, 如果 <code>$condition</code> 为真的话。否则计算并返回 <code>$false</code> 分支。</p>
<h3 id="infix-ff">infix ff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>触发器操作符。</p>
<p>把两个参数都跟 <code>$_</code> 进行比较（即, <code>$_ ~~ $a</code> 和 <code>$_ ~~ $b</code>）。求值为 False 直到左侧的智能匹配为真, 这时, 它求值为真, 直到右侧的智能匹配为真。</p>
<p>实际上, 左边的参数是&quot;开始”条件, 右侧的参数是”停止” 条件。这种结构一般用于收集只在特定区域的行。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$excerpt</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/END/;</span><span class="s">
</span><span class="s">Here&#39;s some unimportant text.
</span><span class="s">=begin code
</span><span class="s">    This code block is what we&#39;re after.
</span><span class="s">    We&#39;ll use &#39;ff&#39; to get it.
</span><span class="s">=end code
</span><span class="s">More unimportant text.
</span><span class="s"></span><span class="p">END</span>

<span class="k">my</span> <span class="nv">@codelines</span> <span class="o">=</span> <span class="k">gather</span> <span class="k">for</span> <span class="nv">$excerpt</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>
    <span class="nb">take</span> <span class="nv">$_</span> <span class="k">if</span> <span class="p">&#34;</span><span class="s2">=begin code</span><span class="p">&#34;</span> <span class="ow">ff</span> <span class="p">&#34;</span><span class="s2">=end code</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="c1"># this will print four lines,</span>
<span class="c1"># starting with &#34;=begin code&#34; and ending with &#34;=end code&#34;</span>
<span class="nb">say</span> <span class="nv">@codelines</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
</code></pre></div><p>匹配开始条件之后, 操作符会继续将停止条件与 <code>$_</code> 进行匹配, 如果成功就做相应地表现。在这个例子中, 只有第一个元素被打印了：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">AB C D B E F</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">B</span><span class="o">/</span><span class="p">;</span>  <span class="c1"># prints only &#34;AB&#34;</span>
<span class="p">}</span>
</code></pre></div><p>如果你想测试开始条件, 并且没有结束条件, <code>*</code> 能用作 “停止” 条件。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">A B C D E</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># prints C, D, and E</span>
<span class="p">}</span>
</code></pre></div><p>对于 sed-like 版本, 在开始条件匹配成功之后, 它不会使用停止条件与 <code>$_</code> 进行匹配。</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-1">infix ^ff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^ff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 <code>ff</code> 那样工作, 除了它不会在条目匹配开始条件时返回真。（包括匹配停止条件的条目）</p>
<p>一个比较:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B and C</span>
</code></pre></div><p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-2">infix ff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 ff 那样工作, 除了它不会在条目匹配停止条件时返回真。（包括第一次匹配开始条件的条目）</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints A and B</span>
</code></pre></div><p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-3">infix ^ff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^ff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 ff 那样工作, 除了它不会在条目匹配停止条件时返回真, 也不会在条目匹配开始时返回真。（或者两者）</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^ff</span><span class="o">^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B</span>
</code></pre></div><p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff">infix fff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>执行 sed-like 那样的 flipflop 操作, 在其中, 它返回 False 直到左侧的参数与 <code>$_</code> 智能匹配, 并且在那之后返回 True 直到右侧的参数和 <code>$_</code>  智能匹配。</p>
<p>像 ff 那样工作, 除了它每次调用只尝试一个参数之外。即, 如果 <code>$_</code> 和左侧的参数智能匹配, fff 随后不会尝试将同一个 <code>$_</code> 和右侧的参数进行匹配。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">AB C D B E F</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">B</span><span class="o">/</span><span class="p">;</span>  <span class="c1"># Prints &#34;AB&#34;, &#34;C&#34;, &#34;D&#34;, and &#34;B&#34;</span>
<span class="p">}</span>
</code></pre></div><p>对于 non-sed-like 版本, 查看 <code>ff</code>.</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-1">infix ^fff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^fff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 fff 那样, 除了它对于左侧的匹配不返回真之外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B and C</span>
</code></pre></div><p>对于 non-sed 版本, 查看 <code>^ff</code>。</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-2">infix fff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 fff 那样, 除了它对于右侧的匹配不返回真之外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints A and B</span>
</code></pre></div><p>对于 non-sed 版本, 查看 <code>ff^</code>。</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-3">infix ^fff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^fff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 fff 那样, 除了它对于左侧和右侧的匹配都不返回真之外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>   <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^fff</span><span class="o">^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B</span>
</code></pre></div><p>对于 non-sed 版本, 查看 <code>^ff^</code>.</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h2 id="item-assignment-precedence">Item Assignment Precedence</h2>
<h3 id="infix--34">infix =</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>Item 赋值。</p>
<p>把 = 号右侧的值放入左侧的容器中。它真正的语义是由左侧的容器类型决定的。</p>
<p>（注意 item 赋值和列表赋值的优先级级别不同, 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符）。</p>
<h3 id="infix--35">infix =&gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">=&gt;</span><span class="p">»(</span><span class="nv">$key</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$value</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Pair:D</span>
</code></pre></div><p>Pair 构造器。</p>
<p>使用左侧值作为键, 右侧值作为值, 构造一个 Pair 对象。</p>
<p>注意 <code>=&gt;</code> 操作符是语法上的特例, 在这个结构中, 它允许左侧是一个未被引起的标识符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nb">key</span><span class="p">;</span>         <span class="c1"># a</span>
<span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nb">value</span><span class="p">;</span>       <span class="c1"># 1</span>
</code></pre></div><p>在参数列表中, 在 <code>=&gt;</code> 左侧使用未被引起的标识符构建的 Pair 会被解释为一个具名参数。</p>
<p>查看 Terms 语言文档了解更多创建 Pair 对象的方式。</p>
<h2 id="loose-unary-precedence">Loose Unary Precedence</h2>
<h3 id="prefix-not">prefix not</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">not</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$x</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）, 并返回否定的结果。</p>
<h3 id="prefix-so">prefix so</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">so</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$x</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）, 并返回结果。</p>
<h2 id="逗号操作符优先级">逗号操作符优先级</h2>
<h3 id="infix--36">infix :</h3>
<p>就像中缀操作符 <code>,</code> 那样, <code>:</code> 用作参数分隔符, 并把它左侧的参数标记为调用者。</p>
<p>那会把函数调用转为方法调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">substr</span><span class="p">(&#39;</span><span class="s1">abc</span><span class="p">&#39;</span><span class="o">:</span> <span class="mi">1</span><span class="p">);</span> <span class="c1"># same as &#39;abc&#39;.substr(1)</span>
</code></pre></div><p>Infix <code>:</code> 只允许出现在非方法调用的第一个参数后面。在其它位置它会是语法错误。</p>
<h2 id="list-infix-precedence">List Infix Precedence</h2>
<h3 id="infix-z">infix Z</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">Z</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@lists</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</code></pre></div><p>Zip operator。</p>
<p>Z 像一个拉链那样把列表插入进来, 只要第一个输入列表耗尽就停止：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span> <span class="ow">Z</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">Z</span> <span class="p">&lt;</span><span class="s">+ -</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="c1"># ((1, &#34;a&#34;, &#34;+&#34;), (2, &#34;b&#34;, &#34;-&#34;)).list</span>
</code></pre></div><p><code>Z</code> 操作符也作为元操作符存在：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">200</span> <span class="ow">Z</span><span class="o">+</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">23</span><span class="p">;</span>             <span class="c1"># 142, 223</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">Z</span><span class="o">~</span> <span class="p">&#39;</span><span class="s1">x</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1"># 1ax 2bx 3cx</span>
</code></pre></div><h3 id="infix-x-1">infix X</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">X</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@lists</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</code></pre></div><p>从所有列表创建一个外积。最右边的元素变化得最迅速。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">X</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">X</span> <span class="mi">9</span>

<span class="c1"># produces   (1, &#39;a&#39;, 9), (1, &#39;b&#39;, 9), (1, &#39;c&#39;, 9),</span>
<span class="c1">#         (2, &#39;a&#39;, 9), (2, &#39;b&#39;, 9), (2, &#39;c&#39;, 9),</span>
<span class="c1">#         (3, &#39;a&#39;, 9), (3, &#39;b&#39;, 9), (3, &#39;c&#39;, 9)</span>

</code></pre></div><p>X 操作符也可以作为元操作符：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">X</span><span class="o">~</span> <span class="mi">9</span>

<span class="c1"># produces   &#39;1a9&#39;, &#39;1b9&#39;, &#39;1c9&#39;,</span>

         <span class="p">&#39;</span><span class="s1">2a9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">2b9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">2c9</span><span class="p">&#39;</span><span class="o">,</span>
         <span class="p">&#39;</span><span class="s1">3a9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">3b9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">3c9</span><span class="p">&#39;</span>
</code></pre></div><h3 id="infix--37">infix &hellip;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">...</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">...^</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>序列操作符是一个用于产生惰性列表的普通操作符。</p>
<p>它可以有一个初始元素和一个生成器在 <code>…</code> 的左侧, 在右侧是一个端点。</p>
<p>序列操作符会使用尽可能多的参数来调用生成器。参数会从初始元素和已生成元素中获取。</p>
<p>默认的生成器是 <code>*.succ</code> 或 <code>*.pred</code>, 取决于末端怎么比较：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">4</span><span class="p">;</span>        <span class="c1"># 1 2 3 4</span>
<span class="nb">say</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1"># 4 3 2 1</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">...</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;;</span>    <span class="c1"># a b c d e</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span> <span class="o">...</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>    <span class="c1"># e d c b a</span>
</code></pre></div><p><code>*</code> (Whatever) 末端生成一个无限序列, 使用的是默认的生成器 <code>*.succ</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 1 2 3 4 5</span>
</code></pre></div><p>自定义生成器是在 <code>…</code> 操作符之前的最后一个参数。下面这个自定义生成器接收两个参数, 生成了斐波纳契数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">8</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 1 1 2 3 5 8 13 21</span>
<span class="c1"># same but shorter</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">8</span><span class="o">]</span><span class="p">;</span>                      <span class="c1"># 1 1 2 3 5 8 13 21</span>
</code></pre></div><p>当然自定义生成器也能只接收一个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">5</span><span class="o">,</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">...</span> <span class="mi">40</span><span class="p">;</span>                       <span class="c1"># 5 10 20 40</span>
</code></pre></div><p>生成器的参数个数至少要和初始元素的个数一样多。</p>
<p>如果没有生成器, 并且有不止一个初始元素, 所有的初始元素都是数值, 那么序列操作符会尝试推导出生成器。它知道数学和几何序列。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span> <span class="o">...</span> <span class="mi">12</span><span class="p">;</span>     <span class="c1"># 2 4 6 8 10 12</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">32</span><span class="p">;</span>     <span class="c1"># 1 2 4 8 16 32</span>
</code></pre></div><p>如果末端不是 <code>*</code>, 它会和每个生成的元素进行智能匹配, 当智能匹配成功的时候序列就被终止。对于 <code>...</code>  操作符, 会包含最后一个元素, 对于 <code>...^</code> 操作符, 会排除最后的那个元素。</p>
<p>这允许你这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...^</span> <span class="o">*&gt;=</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div><p>来生成所有直到 100 但不包括 100 的斐波纳契数。</p>
<p><code>...</code> 操作符还会把初始值看作”已生成的元素”, 所以它们也会对末端进行检查：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$end</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">16</span> <span class="o">...</span> <span class="nv">$end</span><span class="p">;</span>
<span class="c1"># outputs 1 2 4</span>
</code></pre></div><h2 id="list-prefix-precedence">List Prefix Precedence</h2>
<h3 id="infix--38">infix =</h3>
<p>列表赋值。 它真正的语义是由左侧的容器类型决定的。查看 Array 和 Hash 获取普通案例。</p>
<p>item 赋值和列表赋值的优先级级别不同, 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符。</p>
<h3 id="infix--39">infix :=</h3>
<p>绑定。而 <code>$x = $y</code> 是把 <code>$y</code> 中的值放到 <code>$x</code> 里面, <code>$x := $y</code> 会让 <code>$x</code> 和 <code>$y</code> 引用同一个值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$b</span><span class="o">++</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>
</code></pre></div><p>这会输出 42, 因为 <code>$a</code> 和 <code>$b</code> 都包含了数字 42, 但是容器是不同的。</p>
<pre><code>my $a = 42;
my $b := $a;
$b++;
say $a;
</code></pre><p>这会打印 43, 因为 <code>$b</code> 和 <code>$a</code> 都代表着<code>同一个对象</code>。</p>
<h3 id="infix--40">infix ::=</h3>
<p>只读绑定. 查看 infix :=.</p>
<h3 id="listop-">listop &hellip;</h3>
<p>这是 yada, yada, yada 操作符 或 stub 操作符。如果它在子例程或类型中是唯一的语句, 它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>...</code> 语句被执行了, 它会调用 <code>&amp;fail</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--1">listop !!!</h3>
<p>如果它在子例程或类型中是唯一的语句, 它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>!!!</code> 语句被执行了, 它会调用 <code>&amp;die</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--2">listop ???</h3>
<p>如果它在子例程或类型中是唯一的语句, 它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>???</code> 语句被执行了, 它会调用 <code>&amp;warn</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h2 id="loose-and-precedence">Loose AND precedence</h2>
<h3 id="infix-and">infix and</h3>
<p>和中缀操作符 <code>&amp;&amp;</code> 一样, 除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 False 的操作数, 否则返回最后一个操作数。短路操作符。</p>
<h3 id="infix-andthen">infix andthen</h3>
<p>返回第一个未定义的参数, 否则返回最后一个参数。短路操作符。左侧的结果被绑定到 <code>$_</code> 身上, 在右侧中使用, 或者作为参数被传递, 如果右侧是一个 block 或 pointy block.</p>
<h2 id="loose-or-precedence">Loose OR Precedence</h2>
<h3 id="infix-or">infix or</h3>
<p>和中缀操作符 <code>||</code> 一样, 除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 True 的参数, 否则返回最后一个参数。短路操作符。</p>
<h3 id="infix-orelse">infix orelse</h3>
<p>和中缀操作符 <code>//</code> 一样, 除了优先级更宽松之外。</p>
<p>返回第一个定义过的参数, 否则返回最后一个参数。短路操作符。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/operator" term="operator" label="operator" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Operators]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-22-operators/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-java-lambda-expressions/?utm_source=atom_feed" rel="related" type="text/html" title="Java Lambda 表达式" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-joining/?utm_source=atom_feed" rel="related" type="text/html" title="Joining" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-scala-api-extensions/?utm_source=atom_feed" rel="related" type="text/html" title="Scala API 扩展" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-22-side-outputs/?utm_source=atom_feed" rel="related" type="text/html" title="侧输出" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-queryable-state-beta/?utm_source=atom_feed" rel="related" type="text/html" title="可查询状态" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-22-operators/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-22T00:00:00+08:00</published>
            <updated>2020-08-22T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Operators</blockquote><h2 id="操作符">操作符</h2>
<p>操作符将一个或多个 DataStream 转换为一个新的 DataStream。程序可以将多个变换组合成复杂的数据流拓扑。</p>
<p>本节给出了基本变换的描述，应用这些变换后的有效物理分区，以及对 Flink 的操作符链的见解。</p>
<h2 id="datastream-转换">DataStream 转换</h2>
<ul>
<li>Map</li>
</ul>
<p>DataStream → DataStream</p>
<p>接受一个元素并产生一个元素。一个将输入流的值翻倍的 <code>map</code> 函数:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">}</span>
</code></pre></div><ul>
<li>FlatMap</li>
</ul>
<p>DataStream → DataStream</p>
<p>接受一个元素并产生零个、一个或多个元素。一个将句子分割成单词的 <code>flatMap</code> 函数:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">str</span> <span class="k">=&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&#34; &#34;</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div><ul>
<li>Filter</li>
</ul>
<p>DataStream → DataStream</p>
<p>评估每个元素的布尔函数，并保留那些函数返回值为真的元素。一个过滤掉零值的 <code>filter</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">_</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">}</span>
</code></pre></div><ul>
<li>KeyBy</li>
</ul>
<p>DataStream → KeyedStream</p>
<p>在逻辑上将一个流划分为互斥的分区，每个分区包含相同键的元素。在内部，这是通过哈希分区实现的。关于如何指定键，请参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#keyed-state">keys</a>。这个转换会返回一个 <code>KeyedStream</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="s">&#34;someKey&#34;</span><span class="o">)</span> <span class="c1">// Key by field &#34;someKey&#34;
</span><span class="c1"></span><span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>         <span class="c1">// Key by the first element of a Tuple
</span></code></pre></div><ul>
<li>Reduce</li>
</ul>
<p>KeyedStream → DataStream</p>
<p>在 keyed 数据流上进行&quot;滚动&quot;换算(reduce)。将当前元素与最后一个换算的值合并，并发出新的值。</p>
<p>一个创建部分和(sum)流的 <code>reduce</code> 函数:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyedStream</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span> <span class="o">}</span>
</code></pre></div><ul>
<li>Fold</li>
</ul>
<p>KeyedStream → DataStream</p>
<p>在一个带有初始值的 keyed 数据流上进行&quot;滚动&quot;折叠。将当前元素与最后一个折叠的值结合起来，并发出新的值。</p>
<p>一个折叠函数，当应用于序列(1,2,3,4,5)时，发出序列 &ldquo;start-1&rdquo;、&ldquo;start-1-2&rdquo;、&ldquo;start-1-2-3&rdquo;、&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">keyedStream</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">&#34;start&#34;</span><span class="o">)((</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">})</span>
</code></pre></div><ul>
<li>Aggregations</li>
</ul>
<p>KeyedStream → DataStream</p>
<p>在 keyed 数据流上进行滚动聚合。<code>min</code> 和 <code>minBy</code> 的区别在于 <code>min</code> 返回最小值，而 <code>minBy</code> 则返回该字段中具有最小值的元素（<code>max</code> 和 <code>maxBy</code> 也一样）。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">keyedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
</code></pre></div><ul>
<li>Window</li>
</ul>
<p>KeyedStream → WindowedStream</p>
<p>可以在已经分区的 <code>KeyedStream</code> 上定义 <code>Window</code>。窗口根据一些特征（例如，最近5秒内到达的数据）对每个键中的数据进行分组。关于窗口的描述，请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">窗口</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)))</span> <span class="c1">// Last 5 seconds of data
</span></code></pre></div><ul>
<li>WindowAll</li>
</ul>
<p>DataStream → AllWindowedStream</p>
<p>可以在常规的 DataStream 上定义窗口。窗口根据一些特征（例如，在过去5秒内到达的数据）对所有流事件进行分组。关于窗口的完整描述，请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">窗口</a>。</p>
<p>警告：在许多情况下，这是一个非并行的转换。所有的记录将被收集在 <code>windowAll</code> 操作符的一个任务(task)中。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">windowAll</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)))</span> <span class="c1">// Last 5 seconds of data
</span></code></pre></div><ul>
<li>Window Apply</li>
</ul>
<p>WindowedStream → DataStream</p>
<p>AllWindowedStream → DataStream</p>
<p>将一般函数应用于整个窗口。下面是一个手动求和窗口元素的函数。</p>
<p>注意：如果您使用的是 <code>windowAll</code> 转换，您需要使用 <code>AllWindowFunction</code> 来代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="nc">WindowFunction</span> <span class="o">}</span>

<span class="c1">// applying an AllWindowFunction on non-keyed window stream
</span><span class="c1"></span><span class="n">allWindowedStream</span><span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="nc">AllWindowFunction</span> <span class="o">}</span>
</code></pre></div><ul>
<li>Window Reduce</li>
</ul>
<p>WindowedStream → DataStream</p>
<p>对窗口应用函数式的 <code>reduce </code> 函数，并返回换算后的值:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span> <span class="o">}</span>
</code></pre></div><ul>
<li>Window Fold</li>
</ul>
<p>WindowedStream → DataStream</p>
<p>对窗口应用功能 <code>fold</code> 函数并返回折叠后的值。示例函数应用于序列 <code>(1,2,3,4,5)</code> 时，将序列折叠成字符串 &ldquo;start-1-2-3-4-5&rdquo;:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">windowedStream</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">&#34;start&#34;</span><span class="o">,</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">})</span>
</code></pre></div><ul>
<li>窗口上的聚合</li>
</ul>
<p>WindowedStream → DataStream</p>
<p>聚合一个窗口的内容。<code>min</code> 和 <code>minBy</code> 的区别在于 <code>min</code> 返回最小值，而 <code>minBy</code> 返回在该字段中具有最小值的元素（<code>max</code> 和 <code>maxBy</code> 相同）。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">windowedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">min</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">minBy</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">windowedStream</span><span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="s">&#34;key&#34;</span><span class="o">)</span>
</code></pre></div><ul>
<li>Union</li>
</ul>
<p>DataStream* → DataStream</p>
<p>联合两个或多个数据流，创建一个新的流，包含所有流的所有元素。注意：如果你把一个数据流和它自己联合起来，你将在生成的数据流中得到每个元素两次。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">union</span><span class="o">(</span><span class="n">otherStream1</span><span class="o">,</span> <span class="n">otherStream2</span><span class="o">,</span> <span class="o">...)</span>
</code></pre></div><ul>
<li>Window Join</li>
</ul>
<p>DataStream,DataStream → DataStream</p>
<p>在一个给定的键和一个公共窗口上连接(join)两个数据流。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="n">where</span><span class="o">(&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;).</span><span class="n">equalTo</span><span class="o">(&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="n">apply</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div><ul>
<li>Window CoGroup</li>
</ul>
<p>DataStream,DataStream → DataStream</p>
<p>在一个给定的键和一个共同的窗口上将两个数据流串联(Cogroups)起来。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">coGroup</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
    <span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="nc">TumblingEventTimeWindows</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">3</span><span class="o">)))</span>
    <span class="o">.</span><span class="n">apply</span> <span class="o">{}</span>
</code></pre></div><ul>
<li>Connect</li>
</ul>
<p>DataStream,DataStream → ConnectedStreams</p>
<p>&ldquo;连接&rdquo;(connect)两个数据流，保留其类型，允许两个数据流之间共享状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">someStream</span> <span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="n">otherStream</span> <span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">connectedStreams</span> <span class="k">=</span> <span class="n">someStream</span><span class="o">.</span><span class="n">connect</span><span class="o">(</span><span class="n">otherStream</span><span class="o">)</span>
</code></pre></div><ul>
<li>CoMap, CoFlatMap</li>
</ul>
<p>ConnectedStreams → DataStream</p>
<p>类似于连接(connected)数据流上的 <code>map</code> 和 <code>flatMap</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">connectedStreams</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">,</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">)</span>
<span class="n">connectedStreams</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">,</span>
    <span class="o">(</span><span class="k">_</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">)</span>
</code></pre></div><ul>
<li>Split</li>
</ul>
<p>DataStream → SplitStream</p>
<p>根据某种标准，将流分成两个或多个流。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">split</span> <span class="k">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="n">split</span><span class="o">(</span>
  <span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;even&#34;</span><span class="o">)</span>
      <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;odd&#34;</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">)</span>
</code></pre></div><ul>
<li>Select</li>
</ul>
<p>SplitStream → DataStream</p>
<p>从分割流中选择一个或多个流。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">even</span> <span class="k">=</span> <span class="n">split</span> <span class="n">select</span> <span class="s">&#34;even&#34;</span>
<span class="k">val</span> <span class="n">odd</span> <span class="k">=</span> <span class="n">split</span> <span class="n">select</span> <span class="s">&#34;odd&#34;</span>
<span class="k">val</span> <span class="n">all</span> <span class="k">=</span> <span class="n">split</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="s">&#34;even&#34;</span><span class="o">,</span><span class="s">&#34;odd&#34;</span><span class="o">)</span>
</code></pre></div><ul>
<li>Iterate</li>
</ul>
<p>DataStream → IterativeStream → DataStream</p>
<p>在流(flow)中创建一个&quot;反馈&quot;循环，将一个操作符的输出重定向到之前的某个操作符。这对于定义持续更新模型的算法特别有用。下面的代码从一个流(stream)开始，连续应用迭代体。大于0的元素被送回反馈通道，其余元素被转发到下游。参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/#iterations">迭代</a>的完整描述。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">initialStream</span><span class="o">.</span><span class="n">iterate</span> <span class="o">{</span>
  <span class="n">iteration</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">iterationBody</span> <span class="k">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span><span class="cm">/*do something*/</span><span class="o">}</span>
    <span class="o">(</span><span class="n">iterationBody</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="n">iterationBody</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>通过匿名模式匹配从 tuple、case 类和集合中提取，比如下面:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">data</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span> <span class="c1">// [...]
</span><span class="c1"></span><span class="n">data</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">temperature</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// [...]
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>不受 API 开箱即用的支持。要使用这个功能，你应该使用 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/scala_api_extensions.html">Scala API 扩展</a>。</p>
<p>以下转换可用于 Tuples 的数据流:</p>
<ul>
<li>Project</li>
</ul>
<p>DataStream → DataStream</p>
<p>从元组中选择一个字段的子集。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Double</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">in</span> <span class="o">=</span> <span class="c1">// [...]
</span><span class="c1"></span><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">out</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">project</span><span class="o">(</span><span class="n">2</span><span class="o">,</span><span class="n">0</span><span class="o">);</span>
</code></pre></div><h2 id="物理分区">物理分区</h2>
<p>Flink 还可以通过以下函数对转换后的准确流分区进行低级控制（如果需要）。</p>
<ul>
<li>自定义分区</li>
</ul>
<p>DataStream → DataStream</p>
<p>使用用户定义的 Partitioner 为每个元素选择目标任务。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="s">&#34;someKey&#34;</span><span class="o">)</span>
<span class="n">dataStream</span><span class="o">.</span><span class="n">partitionCustom</span><span class="o">(</span><span class="n">partitioner</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</code></pre></div><ul>
<li>随机分区</li>
</ul>
<p>DataStream → DataStream</p>
<p>将元素按照均匀分布随机分区。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">shuffle</span><span class="o">()</span>
</code></pre></div><ul>
<li>Rebalancing (循环分区)</li>
</ul>
<p>DataStream → DataStream</p>
<p>对元素进行循环分区，使每个分区的负载相等。在数据倾斜的情况下，对性能优化很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">rebalance</span><span class="o">()</span>
</code></pre></div><ul>
<li>Rescaling</li>
</ul>
<p>DataStream → DataStream</p>
<p>将元素，轮回分区到下游操作的子集。如果你想拥有管道，例如，从源的每个并行实例向几个映射器(mappers)的子集扇出，以分配负载，但又不想进行 <code>rebalance()</code> 会引起的完全再平衡，那么这就很有用。这将只需要本地数据传输，而不是通过网络传输数据，这取决于其他配置值，如 TaskManagers 的槽数(slots)。</p>
<p>上游操作向其发送元素的下游操作子集取决于上游和下游操作的并行程度。例如，如果上游操作的并行度为2，下游操作的并行度为4，那么一个上游操作将向两个下游操作分发元素，而另一个上游操作将向另外两个下游操作分发。另一方面，如果下游操作具有并行度2，而上游操作具有并行度4，那么两个上游操作将分配给一个下游操作，而其他两个上游操作将分配给其他下游操作。</p>
<p>在不同的并行度不是彼此的倍数的情况下，一个或几个下游操作将从上游操作中获得不同数量的输入。</p>
<p>请看此图，可以直观地看到上例中的连接(connection)模式。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/rescale.svg" alt="img"></p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">rescale</span><span class="o">()</span>
</code></pre></div><ul>
<li>Broadcasting</li>
</ul>
<p>DataStream → DataStream</p>
<p>将元素广播到每个分区。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">dataStream</span><span class="o">.</span><span class="n">broadcast</span><span class="o">()</span>
</code></pre></div><h2 id="任务链和资源组">任务链和资源组</h2>
<p>链式的两个后续变换意味着将它们共同放置在同一个线程中以获得更好的性能。如果可能的话，Flink 默认会将操作符链起来（例如，两个后续的 map 变换）。如果需要的话，API 提供了对链式操作的精细控制。</p>
<p>如果你想在整个作业(job)中禁用链，请使用 <code>StreamExecutionEnvironment.disableOperatorChaining()</code>。对于更细粒度的控制，以下函数是可用的。请注意，这些函数只能在 DataStream 转换之后使用，因为它们引用了之前的转换。例如，你可以使用 <code>someStream.map(...).startNewChain()</code>，但你不能使用 <code>someStream.startNewChain()</code>。</p>
<p>资源组是 Flink 中的一个槽，参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/config.html#configuring-taskmanager-processing-slots">slots</a>。如果需要，你可以在单独的槽中手动隔离操作符。</p>
<ul>
<li>Start new chain</li>
</ul>
<p>开始一个新的链，从这个操作符开始。两个映射器(mappers)将被连锁，<code>filter</code> 将不会被连锁到第一个映射器(mapper)。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">filter</span><span class="o">(...).</span><span class="n">map</span><span class="o">(...).</span><span class="n">startNewChain</span><span class="o">().</span><span class="n">map</span><span class="o">(...)</span>
</code></pre></div><ul>
<li>Disable chaining</li>
</ul>
<p>不将 <code>map</code> 运算符连锁化。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">map</span><span class="o">(...).</span><span class="n">disableChaining</span><span class="o">()</span>
</code></pre></div><ul>
<li>Set slot sharing group</li>
</ul>
<p>设置操作的槽位共享组。Flink 会将具有相同槽位共享组的操作放入同一个槽位，而将没有槽位共享组的操作保留在其他槽位。这可以用来隔离槽位。如果所有的输入操作都在同一个槽共享组中，槽共享组就会从输入操作中继承。缺省槽共享组的名称是 &ldquo;default&rdquo;，操作可以通过调用 <code>slotSharingGroup(&quot;default&quot;)</code> 来明确地放入这个组。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">someStream</span><span class="o">.</span><span class="n">filter</span><span class="o">(...).</span><span class="n">slotSharingGroup</span><span class="o">(</span><span class="s">&#34;name&#34;</span><span class="o">)</span>
</code></pre></div><p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/">https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/flink" term="flink" label="Flink" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Flink 官方文档" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/datastream-api" term="datastream-api" label="DataStream API" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/operator" term="operator" label="Operator" />
                            
                        
                    
                
            
        </entry>
    
</feed>
