<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.123.7">Hugo</generator><title type="html"><![CDATA[Rakus on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[Wait the light to fall]]></subtitle>
    
    
    
            <link href="http://localhost:1313/raku/" rel="alternate" type="text/html" title="html" />
            <link href="http://localhost:1313/raku/index.xml" rel="alternate" type="application/rss+xml" title="rss" />
            <link href="http://localhost:1313/raku/atom.xml" rel="self" type="application/atom+xml" title="atom" />
            <link href="http://localhost:1313/raku/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2024-03-02T16:54:47+08:00</updated>
    
    
    
    
        <id>http://localhost:1313/raku/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 面向对象简单入门]]></title>
            <link href="http://localhost:1313/raku/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/posts/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 面向对象简单入门" />
                <link href="http://localhost:1313/raku/2018-09-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0.-%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/?utm_source=atom_feed" rel="related" type="text/html" title="第二十章. 高级话题" />
                <link href="http://localhost:1313/raku/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="第十七章. Grammars" />
                <link href="http://localhost:1313/raku/2018-09-02-%E7%AC%AC%E4%BA%8C%E7%AB%A0.-%E7%8C%9C%E6%95%B0%E5%AD%97/?utm_source=atom_feed" rel="related" type="text/html" title="第二章. 猜数字" />
                <link href="http://localhost:1313/raku/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的容器" />
            
                <id>http://localhost:1313/raku/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-10-03T21:13:31+08:00</published>
            <updated>2018-10-03T21:13:31+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="序言">序言</h1>
<h2 id="介绍">介绍</h2>
<p>本教程最多只关注 Raku 中的面向对象编程(OOP)的基本知识。因此，对语句/表达式、变量、条件、循环、子例程(函数)等有一个基本的了解是很重要的，如果不在 Raku 中，至少在另一种编程语言中是这样的。此外，您至少应该对类、属性和方法有一般的了解。作为对 Raku 的介绍，我强烈推荐 <a href="https://rakuintro.com/">Raku introduction</a>。下一步是 Raku 文档。</p>
<p>确保你已经设置好了 Raku 编译器。如果你还没有设置好，请看<a href="https://raku.org/getting-started/">这里</a>。
从这里开始，你可能会厌倦代词“我们”，但它的使用是经过深思熟虑的。这是一个教程，希望你能跟上。所以，是的，我们在一起工作，你应该做好准备。顺便说一下，本教程是冗长的，这是故意的，但也是手把手教程的副产品。</p>
<h2 id="问题陈述">问题陈述</h2>
<p>我们将从现实生活中的问题开始，并尝试以面向对象的方式对其进行建模。问题陈述如下:
在她的数学101课程中，一位教授记录了三个作业(2个作业和1个考试)的分数，按照学生交作业的顺序:</p>
<pre><code>Bill Jones:1:35
Sara Tims:2:45
Sara Tims:1:39
Bill Jones:1:42
Bill Jones:E1:72
</code></pre>
<p>在一个名为 MATH-101 的简单文本文件中。您可以假设有更多的学生，而这只是数据文件的一个代表性块。在这个文件中，每行记录学生的姓名、作业编号(作业编号为1,2，第一次考试为E1)和学生获得的原始分数。
教授使用另一个扩展名为 .std 的文件存储她课程的学生名单:</p>
<pre><code>Bill Jones
Ana Smith
Sara Tims
Frank Horza
</code></pre>
<p>除了 MATH-101，这位教授还教其他课程，并设计了一个扩展名为 .cfg 的配置文件来存储给定课程的配置格式。她这样做的目的是在她的其他课程中也使用它。配置文件格式指定了作业的类型、作业编号、作业的总分以及作业对最终课程成绩的贡献。她的数学101课程的 .cfg 文件如下:</p>
<pre><code>Homework:1:50:25
Homework:2:50:25
Exam:1:75:50
</code></pre>
<p>您的任务是创建一个名为 report.p6 的程序。该程序生成一个报告，其中列出了班级中每个学生的姓名、每次作业的分数和最终成绩。该程序应该假设具有扩展名 .cgf 和 .std 的文件在执行该程序的目录中可用。另一方面，包含学生成绩的文件必须通过命令行传递给程序。为了简单起见，您可以假设每个文件都是根据课程命名的。对于她的数学101课程，教授会有以下的文件: MATH-101, MATH-101.std 和 MATH-101.cfg，还有脚本 report.p6。</p>
<h2 id="分析">分析</h2>
<p>如果我们看问题陈述，我们可以把所有的东西分成三类:课程，学生和作业。就目前而言，每个类别都可以被视为具有状态和行为的类。我们将从最简单的类别，作业类别，到最一般的类别，课程类别。为了做到这一点，我们首先学习 Raku 中类的定义。</p>
<h1 id="raku-类">Raku 类</h1>
<h2 id="类定义">类定义</h2>
<p>在 Raku 中，类是用 class 关键字定义的，通常后面跟着类名（通常以首字母大写形式）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="属性定义">属性定义</h2>
<p>所有的 Raku 属性默认都是私有的，这意味着它们只能在类中访问。属性是使用 <code>has</code> 关键字和 <code>!</code> twigil 定义的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!attribute-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>属性也可以使用 <code>.</code> twigil。这个 twigil 声明，应该生成一个以属性命名的只读访问器方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.attribute-name</span><span class="p">;</span> <span class="c1"># $!attribute-name + attribute-name()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这等价于:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Name-of-class</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!attribute-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">attribute-name</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$!attribute-name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>生成的访问器方法是只读的，因为属性默认是只读的(从类的外部)。为了允许通过访问器方法修改属性，必须向属性添加 <code>is rw</code> 特质。其他特质也可以用于属性。有关特质的更多信息，请参阅文档。</p>
<h1 id="作业类">作业类</h1>
<p>让我们从详细描述 <code>Assignment</code> 类所需的属性开始:</p>
<ul>
<li><code>type</code>——作业的类型(作业或考试)。</li>
<li><code>number</code>——作业编号(1,2等)。</li>
<li><code>score</code>——这个作业的分数。</li>
<li><code>raw</code>——给定作业的最大点数。</li>
<li><code>contrib</code>——作业对最终成绩的贡献。</li>
<li><code>adjusted-score</code>——基于 <code>score</code>，<code>raw</code> 和 <code>contrib</code> 属性的格式化的分数。</li>
<li><code>config</code>——一个包含课程配置文件的散列。</li>
</ul>
<p>关于 <code>config</code> 哈希，每个赋值的信息将存储在一个数组中，这个数组将根据每个赋值(作业或考试)在数组中的赋值号进行索引。由于没有零赋值，这个槽将用于存储已处理的赋值总数。MATH-101.cfg 的 <code>config</code> 散列是这样的:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">%</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">Homework</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl">    <span class="s">Exam</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">75</span><span class="o">,</span> <span class="mi">50</span><span class="p">)</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>这导致了下面的类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># attributes with a read-only accessor</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%.config</span><span class="p">;</span>   <span class="c1"># given that a hash is used, the $ (scalar) is replaced</span>
</span></span><span class="line"><span class="cl">                    <span class="c1"># with a % (hash).</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># private attributes hence the ! twigil.</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!raw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!contrib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!adjusted-score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>为了创建 <code>Assignment</code> 类的实例并初始化它，我们将命名参数传递给 Raku 提供的默认的 <code>new</code> 构造函数方法，并由所有类继承:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># create a new instance object and initialize its attributes. </span>
</span></span><span class="line"><span class="cl"><span class="c1"># The new constructor is called on Assignment, the type object of </span>
</span></span><span class="line"><span class="cl"><span class="c1"># the class Assignment.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$assign01</span> <span class="o">=</span> <span class="n">Assignment</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;</span><span class="o">,</span> <span class="c1"># named argument </span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="s">number</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">,</span>         <span class="c1"># Alternate colon-pair syntax for named arguments</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="s">score</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">:</span><span class="s">config</span><span class="p">(</span><span class="nv">%</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="s">Homework</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="mi">50</span><span class="o">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">],</span>
</span></span><span class="line"><span class="cl">        <span class="s">Exam</span> <span class="o">=&gt;</span> <span class="o">[</span> <span class="p">{</span><span class="s">total</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">75</span><span class="o">,</span> <span class="mi">50</span><span class="p">)</span> <span class="o">]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># accessing the instance object&#39;s attributes </span>
</span></span><span class="line"><span class="cl"><span class="c1"># through their accessor method:</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$assign01</span><span class="o">.</span><span class="nb">type</span><span class="p">();</span>     <span class="c1"># OUTPUT: &#39;Homework&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$assign01</span><span class="o">.</span><span class="nf">number</span><span class="p">();</span>   <span class="c1"># OUTPUT: 2</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$assign01</span><span class="o">.</span><span class="nf">score</span><span class="p">();</span>    <span class="c1"># OUTPUT: 45</span>
</span></span></code></pre></div><blockquote>
<p><strong>注意</strong>: 如果属性是用 <code>!</code> twigil 定义的，那么不能使用 <code>new</code> 构造函数方法来初始化它。正如前面提到的，这是由于属性是私有的，这意味着它不能从类外部访问，甚至不能通过<code>new</code> 构造函数访问。但是，这个默认行为可以用 <code>BUILD</code> 子方法重写。有关 <code>BUILD</code> 子方法的更多信息，请参阅<a href="https://docs.raku.org/language/objects#Object_Construction">文档</a>。</p>
</blockquote>
<p>我们已经知道赋值的类型总是字符串，数字总是整数，调整后的分数是 rational 等等，所以我们也可以相应地键入属性:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$.number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%.config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!raw</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$!contrib</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Rat</span> <span class="nv">$!adjusted-score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>有关类型的更多信息，请参阅<a href="https://docs.raku.org/language/typesystem">文档</a>。
<code>Assignment</code> 类的行为在很大程度上取决于每个学生的数据，但我们对 <code>Student</code> 类的结构还一无所知。出于这个原因，我们将继续学习 <code>Student</code> 类，稍后再回到这个话题。</p>
<h1 id="student-类">Student 类</h1>
<p>与 <code>Assignment</code> 类类似，让我们从详细描述 <code>Assignment</code> 类将具有的属性开始:</p>
<ul>
<li><code>name</code>——表示学生名字的字符串。</li>
<li><code>assign-num</code>——作业的数量(一个整数)。</li>
<li><code>assignments</code>——我们希望将作业分成不同的类型(作业或考试)，所以我们将使用哈希。每个键将指向它们各自的赋值对象的数组。</li>
<li><code>config</code>——在 <code>Assignment</code> 类中描述的课程的配置文件。</li>
</ul>
<p>这导致了下面的类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$!assign-num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%!assignments</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%.config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们应该能够将作业附加到 <code>Student</code> 类的一个实例中，并从中获得作业、考试等等。这些行为表示类的行为，并通过使用方法来实现。</p>
<h2 id="公共和私有方法">公共和私有方法</h2>
<p>正如在 <a href="https://rakuintro.com/#_methods">Raku 介绍</a>中所述，“方法是对象的子例程，就像子例程一样，它们是打包一组功能的方法，它们接受参数，具有签名，可以定义为 <code>multi</code>。”</p>
<p>Raku 方法是使用 <code>method</code> 关键字定义的，它是在 invocant 上使用点(<code>.</code>)调用的。默认情况下，所有方法都是公共的。但是，方法可以通过在名称前面加上感叹号(<code>!</code>)来定义为私有的。在这种情况下，使用感叹号而不是点来调用它们。</p>
<p>有了这些知识，我们现在将向 <code>Student</code> 类添加一个 <code>add-assignment</code> 方法。这个方法需要作业的编号(1、2、3等，或者E1、E2等)和收到的分数。不会提供作业的类别，但我们可以使用编号来确定:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same attributes as before.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-assignment</span><span class="p">(</span> <span class="nv">$number</span> <span class="k">is</span> <span class="nb">copy</span><span class="o">,</span> <span class="nv">$score</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="c1"># determine the assignment type.</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">$number</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="ni">^</span><span class="sr">E</span><span class="p">//</span> <span class="p">{</span>   <span class="c1"># do replacement in place</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$type</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Exam</span><span class="p">&#39;;</span>      <span class="c1"># to obtain the exam&#39;s number.</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$type</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># coerce assignment number to an integer.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$number</span> <span class="o">.=</span> <span class="kt">Int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># create an Assignment object from available information.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$assign-obj</span> <span class="o">=</span> <span class="n">Assignment</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">type</span>   <span class="o">=&gt;</span> <span class="nv">$type</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">number</span> <span class="o">=&gt;</span> <span class="nv">$number</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">score</span>  <span class="o">=&gt;</span> <span class="nv">$score</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%!config</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># add assignment into its type indexed by its number.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%!assignments</span><span class="p">{</span><span class="nv">$type</span><span class="p">}</span><span class="o">[</span><span class="nv">$number</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$assign-obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># increment number of assignments by 1.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!assign-num</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>为了展示私有方法的创建，我们将在 <code>add-assignment</code> 方法中把创建 <code>Assignment</code> 对象外包给一个名为 <code>create-assignment</code> 的私有方法，该方法返回一个 <code>Assignment</code> 对象:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same as before</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># notice the ! twigil before the method&#39;s name.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!create-assignment</span><span class="p">(</span> <span class="kt">Str</span> <span class="nv">$type</span><span class="o">,</span> <span class="kt">Int</span> <span class="nv">$number</span><span class="o">,</span> <span class="nv">$score</span> <span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">Assignment</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">type</span>   <span class="o">=&gt;</span> <span class="nv">$type</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">number</span> <span class="o">=&gt;</span> <span class="nv">$number</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">score</span>  <span class="o">=&gt;</span> <span class="nv">$score</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%!config</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-assignment</span><span class="p">(</span> <span class="nv">$number</span> <span class="k">is</span> <span class="nb">copy</span><span class="o">,</span> <span class="nv">$score</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># same code as before.</span>
</span></span><span class="line"><span class="cl">  		        
</span></span><span class="line"><span class="cl">        <span class="c1"># create an Assignment object with this information.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$assign-obj</span> <span class="o">=</span> <span class="nb">self</span><span class="o">!</span><span class="nf">create-assignment</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$number</span><span class="o">,</span> <span class="nv">$score</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># same code as before.</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><p>正如您可能已经注意到的，<code>self</code> 关键字用于调用 <code>add-assignment</code> 方法中的 <code>create-assignment</code> 方法。<code>self</code> 是绑定到 invocant 的特殊变量，在方法内部可用。此变量可用于调用程序上的进一步方法。其内部方法调用如下:</p>
<ul>
<li>
<p><code>self!method($arg)</code> 用于私有方法。</p>
</li>
<li>
<p><code>self.method($arg)</code> 用于公共方法。 <code>$.method($arg)</code> 是它的快捷形式。注意，方法参数(位置和命名)的冒号语法只支持在使用 <code>self</code> 时调用方法，而不支持快捷形式。所以:</p>
</li>
<li>
<p>self.method: arg1, arg2&hellip; is supported.</p>
</li>
<li>
<p>$.method: arg1, arg2&hellip; is not supported.</p>
</li>
</ul>
<p>方法的签名总是传递 <code>self</code> 作为它的第一个参数。但是，我们可以通过提供第一个参数和一个冒号来为方法指定一个显式调用者。此参数将充当方法的调用方，并允许方法引用显式调用的对象。
例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;;</span>    <span class="c1"># attributes can be set to default values.</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># here self refers to the object, albeit implicitly.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">introduce</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi, my name&#39;s </span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">self</span><span class="o">.</span><span class="nb">name</span><span class="p">()</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#                     ^^^^^^^^^^^ calling method on self</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># here $person explicitly refers to the object.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">alt-introduce</span><span class="p">(</span> <span class="nv">$person:</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi, my name&#39;s </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">()</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">!</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">#                     ^^^^^^^^^^^^^^ calling method on $person</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">introduce</span><span class="p">();</span>      <span class="c1"># OUTPUT: Hi, my name&#39;s John!</span>
</span></span><span class="line"><span class="cl"><span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">alt-introduce</span><span class="p">();</span>  <span class="c1"># OUTPUT: Hi, my name&#39;s John!</span>
</span></span></code></pre></div><h2 id="tweak-子方法">TWEAK 子方法</h2>
<p>我们回到 <code>Assignment</code> 类。目前，类的使用者可以在创建 <code>Assignment</code> 对象时传递他们想要的任何东西。出于这个原因，我们可能想检查作业类型和作业编号是否已知。我们可能要做的另一件事是修改 <code>raw</code> 属性和 <code>contrib</code> 属性，它们的值依赖于来自配置文件的数据。同样的情况也适用于 <code> adjusted-score</code> 属性，其值取决于 <code>raw</code> 属性、<code>contrib</code> 属性和 <code>score</code> 属性。</p>
<p>Raku 提供了一种通过 <code>TWEAK</code> 子方法检查对象构造后的内容或修改属性的简单方法。简单地说，子方法是不被子类继承的方法。查看<a href="https://docs.raku.org/language/objects#Object_construction">文档</a>以获得关于 <code>TWEAK</code> 子方法的更多信息。
让我们在 <code>Assignment</code> 类中添加 <code>TWEAK</code> 子方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same attributes as before.</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># use submethod keyword, instead of method.</span>
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">TWEAK</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># assignment type is either &#39;Homework&#39; or &#39;Exam&#39;.</span>
</span></span><span class="line"><span class="cl">        <span class="k">unless</span> <span class="nv">$!type</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&#39;</span><span class="s1">Exam</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">unknown assignment type: </span><span class="nv">$!type</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># check if provided assignment type is known.</span>
</span></span><span class="line"><span class="cl">        <span class="k">unless</span> <span class="nv">%!config</span><span class="p">{</span><span class="nv">$!type</span><span class="p">}</span><span class="o">[</span><span class="nv">$!number</span><span class="o">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">unrecognized </span><span class="nv">$!type</span><span class="s2"> number: </span><span class="nv">$!number</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># update raw and contrib value from configuration data.</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="nv">$!raw</span><span class="o">,</span> <span class="nv">$!contrib</span><span class="p">)</span> <span class="o">=</span> <span class="nv">%!config</span><span class="p">{</span><span class="nv">$!type</span><span class="p">}</span><span class="o">[</span><span class="nv">$!number</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># calculate the value of the adjusted score (rounded to two </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># decimal places).</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!adjusted-score</span> <span class="o">=</span> <span class="nb">sprintf</span> <span class="p">&#34;</span><span class="nv">%.2f</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$!score</span> <span class="o">/</span> <span class="p">(</span><span class="nv">$!raw</span><span class="o">/</span><span class="nv">$!contrib</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># update type with assignment number. This will be useful </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># when printing the report for a specific assignment.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$!type</span> <span class="o">=</span> <span class="nv">$!type</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">Homework</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl">            <span class="o">??</span> <span class="p">&#34;</span><span class="s2">Homework </span><span class="nv">$!number</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">Exam </span><span class="nv">$!number</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="完成-assignment-和-student-类">完成 ASSIGNMENT 和 STUDENT 类</h2>
<h2 id="assignment-类">ASSIGNMENT 类</h2>
<p>我们想为特定的作业打印一个报告，因此我们将添加一个 <code>formatted-score</code> 方法，它将返回调整后的分数，并将一个 <code>print-report</code> 方法返回给 <code>Assignment</code> 类。<code>print-report</code> 方法应打印以下格式的作业报告:</p>
<pre tabindex="0"><code>type number: Raw = score/raw : Adjusted = adjusted-score/contrib-final
</code></pre><p>例子:</p>
<pre tabindex="0"><code>Homework 1: Raw = 42/50 : Adjusted = 8.40/10
Exam 1: Raw = 70/75 : Adjusted = 8.40/10
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Assignment</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">formatted-score</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$!adjusted-score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">print-report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span> <span class="p">&#34;</span><span class="nv">$!type:</span><span class="s2"> raw = </span><span class="nv">$!score</span><span class="s2">/</span><span class="nv">$!raw</span><span class="s2"> : </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Adjusted = </span><span class="nv">$!adjusted-score</span><span class="s2">/contrib</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="student-类-1">STUDENT 类</h2>
<p>现在，我们将添加 <code>get-home-works</code> 和 <code>get-exams</code> 方法，这些方法将返回 <code>Assignment</code> 对象列表。我们还将为打印学生报告添加 <code>print-report</code> 方法。此方法应以下列格式打印学生报告:</p>
<pre tabindex="0"><code>student:
    type number: Raw = score/raw : Adjusted = adjusted-score/100 
    ...
    Final Course Grade: final-total/100
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="c1"># we use the grep() function to discard possibly empty </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># elements in either array.</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">get-homeworks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">%!assignments</span><span class="p">&lt;</span><span class="s">Homework</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">..*].</span><span class="nb">grep</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$_</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">get-exams</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">%!assignments</span><span class="p">&lt;</span><span class="s">Exam</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">..*].</span><span class="nb">grep</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$_</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">print-report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$!name</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">: </span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># print message and return if student&#39;s doesn&#39;t have</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># neither assignment type</span>
</span></span><span class="line"><span class="cl">        <span class="k">unless</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-homeworks</span><span class="p">()</span> <span class="o">||</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-exams</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="se">\t</span><span class="s2">No records for this student.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span><span class="nv">$final-total</span><span class="o">,</span> <span class="nv">$a_count</span><span class="o">,</span> <span class="nv">$e_count</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Loop over student&#39;s assignments (either Homework or Exam),</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># print assignment&#39;s report and update final total.</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-homeworks</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$homework</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span> <span class="p">&#34;</span><span class="se">\t</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$homework</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$final-total</span> <span class="o">+=</span> <span class="nv">$homework</span><span class="o">.</span><span class="nf">formatted-score</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$a_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-exams</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$exam</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span> <span class="p">&#34;</span><span class="se">\t</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$exam</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$final-total</span> <span class="o">+=</span> <span class="nv">$exam</span><span class="o">.</span><span class="nf">formatted-score</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$e_count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># check if number of homeworks and exams in config file</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># matches student&#39;s record of returned homeworks and taken exams.</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nv">%!config</span><span class="p">&lt;</span><span class="s">Homework</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&lt;</span><span class="s">total</span><span class="p">&gt;</span> <span class="o">==</span> <span class="nv">$a_count</span> <span class="ow">and</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%!config</span><span class="p">&lt;</span><span class="s">Exam</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&lt;</span><span class="s">total</span><span class="p">&gt;</span>   <span class="o">==</span> <span class="nv">$e_count</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="se">\t</span><span class="s2">Final Course Grade: </span><span class="nv">$final-total</span><span class="s2">/100</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">say</span> <span class="p">&#34;</span><span class="se">\t</span><span class="s2">* Incomplete Record *</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># print newline after student&#39;s report.</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="course-类">Course 类</h1>
<p><code>Course</code> 类有以下属性:</p>
<p><code>course</code>——表示课程名称的字符串。
<code>students</code>——学生和 <code>Students</code> 对象的哈希。
<code>number</code>——这个课程的学生人数。</p>
<p>这是带有其属性的类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Str</span> <span class="nv">$.course</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="kt">Int</span> <span class="nv">$.number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">%!students</span> <span class="k">of</span> <span class="nc">Student</span><span class="p">;</span> <span class="c1"># specifying the type of the hash&#39;s values.</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>关于方法，我们需要以下几点:</p>
<ul>
<li><code>configure-course</code>——使用当前目录中的 <code>.cfg</code>(配置)和 <code>.std</code> (学生列表)文件来配置课程。</li>
<li><code>student</code>——接受一个学生的名字，并返回一个 <code>Student</code> 对象，前提是它存在。在该类的内部使用所以定义为私有的。</li>
<li><code>get-roster</code>——返回学生名字的排序列表。</li>
<li><code>add-student-record</code>——接受一个学生记录(例如，<code>Bill Jones:1:45</code>)，为那个学生查找 <code>Student</code> 对象并添加一个作业。</li>
<li><code>print-report</code>——打印整个类的报告。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">configure-course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># read content of configuration file. We are to assume that </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># it has the same name as the course with &#39;.cfg&#39; extension.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$course_file</span> <span class="o">=</span> <span class="nv">$!course</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">.cfg</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$course_data</span> <span class="o">=</span> <span class="nv">$course_file</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span> <span class="o">||</span> 
</span></span><span class="line"><span class="cl">                          <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">cannot open </span><span class="nv">$course_file</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># extract the data from file and store it into the </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># configuration hash. The structure of the configuration</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># file was discussed in the &#39;The Assignment class&#39; section.</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">%cfg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$course_data</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$datum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">my</span> <span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">@data</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$datum</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Example: type = &#39;Homework&#39;, data = (1, 50, 25)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="nv">%cfg</span><span class="p">{</span><span class="nv">$type</span><span class="p">}</span><span class="o">[</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">]</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">..*]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%cfg</span><span class="p">{</span><span class="nv">$type</span><span class="p">}</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&lt;</span><span class="s">total</span><span class="p">&gt;</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># read student list file which has the same name as the course.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$stud_file</span> <span class="o">=</span> <span class="nv">$!course</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">.std</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$stud_data</span> <span class="o">=</span> <span class="nv">$stud_file</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">slurp</span> <span class="o">||</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">cannot open </span><span class="nv">$stud_file</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="c1"># Loop over the student list and create a Student object for </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># each student and populate the hash of students and Student objects.</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$stud_data</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">%!students</span><span class="p">{</span> <span class="nv">$student</span><span class="o">.</span><span class="nb">trim</span> <span class="p">}</span> <span class="o">=</span> <span class="n">Student</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">                <span class="s">name</span>   <span class="o">=&gt;</span> <span class="nv">$student</span><span class="o">.</span><span class="nb">trim</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%cfg</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$!number</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># return Student object if it exists.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">!student</span><span class="p">(</span> <span class="kt">Str</span> <span class="nv">$stud-name</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">%!students</span><span class="p">{</span><span class="nv">$stud-name</span><span class="p">}</span> <span class="o">||</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># order student names by last name and return list.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">get-roster</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">%!students</span><span class="o">.</span><span class="nb">keys</span>                         <span class="c1"># student names list</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">({</span> <span class="p">(</span> <span class="nv">$_</span><span class="o">,</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">words</span> <span class="p">)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">})</span> <span class="c1"># (full name, first, last)</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="nb">sort</span> <span class="p">({</span> <span class="nv">$^a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="ow">cmp</span> <span class="nv">$^b</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="p">})</span>    <span class="c1"># sort list by last names</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">({</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">})</span>                 <span class="c1"># get name from sorted list</span>
</span></span><span class="line"><span class="cl">            <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">@list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># add record to Student object.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-student-record</span><span class="p">(</span> <span class="nv">@record</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">@remaining</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@record</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># get Student object and add assignment to it.</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$student</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="nf">student</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span><span class="nv">$num</span><span class="o">,</span> <span class="nv">$score</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@remaining</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$student</span><span class="o">.</span><span class="nf">add-assignment</span><span class="p">(</span><span class="nv">$num</span><span class="o">,</span> <span class="nv">$score</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># print report for all students in the course.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">print-report</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Class report: course = </span><span class="nv">$!course</span><span class="s2">, students = </span><span class="nv">$!number</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># loop over sorted students list and print each student&#39;s report.</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nb">self</span><span class="o">.</span><span class="nf">get-roster</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$name</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">self</span><span class="o">!</span><span class="nf">student</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="自定义构造函数">自定义构造函数</h2>
<p>我们希望使用反映所创建内容的构造函数方法，而不是使用 <code>new</code> 构造函数从特定的类创建对象。例如，<code>Course</code> 类的 <code>create-course</code> 构造函数。我们还希望使用位置参数，而不是在 <code>new</code> 构造函数中使用命名参数。在 Raku 中创建构造函数相当容易;只需要创建一个方法并返回 <em>blessed</em> 后的参数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">create-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># In addition to:</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$class01</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">course</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">GEO-102</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># We can also create a Course instance like this now:</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$class02</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">Math-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span></code></pre></div><p>我们不只是写 <code>return self.bless($course)</code>，因为 <code>bless</code> 方法需要一组命名参数来为每个属性提供初始值。正如前面提到的，私有属性实际上是私有的，因此对于用<code>!</code> twigil 定义的属性这还不够。为此，必须使用 <code>BUILD</code> 子方法，<code>bless</code> 方法调用这个全新的对象。有关 <code>BUILD</code> 子方法的更多信息，请参阅<a href="https://docs.raku.org/language/objects#Submethods">子方法</a>和<a href="https://docs.raku.org/language/classtut#Constructors">构造函数</a>。</p>
<h2 id="实例和类属性">实例和类属性</h2>
<p>我们已经讨论了实例属性，只是没有将它们标识为实例属性。<strong>实例属性</strong>是一个类的特定实例所拥有的属性，这意味着同一个类的两个不同的对象实例是不同的。例如，前几节中的实例 <code>$class01</code> 和 <code>$class02</code> 都具有相同的实例属性(<code>course</code>、<code>number</code> 等)，但是值不同。在 Raku 中，任何用关键字 <code>has</code> 声明的属性都是一个实例属性。</p>
<p>另一方面，<strong>类属性</strong>是属于类本身而不是它的对象的属性。与实例属性不同，类属性由类的所有实例共享。</p>
<p>在 Raku 中，类属性是使用关键字 <code>my</code> 或 <code>our</code>(而不是 <code>has</code>)来声明的，这取决于作用域(例如，<code>my $class-var;</code>)。与实例属性类似，用 <code>.</code> twigil 生成一个访问器方法(例如，<code>my $.class-var;</code>)的类属性。有关类属性的更多信息，请参阅<a href="https://docs.raku.org/language/classtut#Static_fields?">文档</a>。</p>
<p>我们还没有看到类属性，但是我们现在要创建一个。例如，我们想知道我们实例化的课程的数量。为此，我们可以在 <code>Course</code> 类中创建一个类属性，它跟踪实例化的 <code>Course</code> 对象的数量。</p>
<p>每当创建新对象时这个类属性必须更新，因此我们必须修改默认的 <code>new</code> 和 <code>create-course</code> 构造函数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># other attributes.</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Int</span> <span class="nv">$.course-count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># class attribute with read-only accessor</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">create-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>      <span class="c1"># updating the class attribute.</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># we still want to pass named parameters to the new </span>
</span></span><span class="line"><span class="cl">    <span class="c1"># hence the &#39;:&#39; before the parameter.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span> <span class="o">:</span><span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(&#39;</span><span class="s1">PHYS-110</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">course</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">BIO-112</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># accessing the class attribute&#39;s value by calling </span>
</span></span><span class="line"><span class="cl"><span class="c1"># its accessor method on the class itself.</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="n">Course</span><span class="o">.</span><span class="nf">course-count</span><span class="p">();</span>  <span class="c1"># OUTPUT: 10</span>
</span></span></code></pre></div><h2 id="实例方法和类方法">实例方法和类方法</h2>
<p><strong>实例方法</strong>需要在其上调用对象实例。它通常以 <code>$object.instance-method()</code> 的形式表示。例如，<code>print-report()</code> 是 <code>Course</code> 类的一个实例方法，需要调用该类的一个实例(例如，<code>$class.print-report()</code>)。</p>
<p>另一方面，<strong>类方法</strong>作为一个整体属于类，因此它不需要类的实例。它通常用 <code>class.class-method()</code> 表示。例如，<code>new</code> 构造函数是直接在类上调用的类方法，而不是类的实例。</p>
<p>前面我们提到，显式调用者可以传递给方法。除了显式地引用对象外，方法签名中提供的调用者还允许通过使用类型约束将方法定义为实例方法或类方法。特殊变量 <code>::?CLASS</code> 可用于在编译时提供类名，并结合 <code>:U</code> (如 <code>::?CLASS:U</code>)用于类方法，或 <code>:D</code>(如 <code>::?CLASS:D</code>)用于实例方法。顺便说一下，在 Raku 行话中，<code>:U</code> 和 <code>:D</code> 被称为 <em>smileys</em>。</p>
<p><code>create-course</code> 方法打算仅作为类方法使用，但是，到目前为止，没有任何东西阻止它在实例中使用。为了避免这种情况，我们可以在 invocant 上使用带有 <code>:U</code> 类型修饰符的特殊变量 <code>?::CLASS</code>，这会导致方法主动拒绝对实例的调用，并且只允许通过type 对象进行调用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># other attributes </span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">create-course</span><span class="p">(</span> <span class="vg">::?CLASS:U</span><span class="o">:</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span> <span class="vg">::?CLASS:U</span><span class="o">:</span> <span class="o">:</span><span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$.course-count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="s">course</span> <span class="o">=&gt;</span> <span class="nv">$course</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Invocations on the Course class works as expected.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$math</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">MATH-302</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$phys</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(&#39;</span><span class="s1">LING-202</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Invocations on Course instances fail.</span>
</span></span><span class="line"><span class="cl"><span class="nv">$math</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">MATH-302</span><span class="p">&#39;);</span>   <span class="c1"># OUTPUT: Invocant of method &#39;new&#39; must be </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># a type object of type &#39;Course&#39;, not an </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># object instance of type &#39;Course&#39;.  Did you</span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># forget a &#39;multi&#39;?</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$phys</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(&#39;</span><span class="s1">LING-202</span><span class="p">&#39;);</span> <span class="c1"># OUTPUT: Type check failed in binding to </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># parameter &#39;$course&#39;; expected Course but </span>
</span></span><span class="line"><span class="cl">                                 <span class="c1"># got Str (&#34;Phys-302&#34;)</span>
</span></span></code></pre></div><h2 id="使用-course-类">使用 COURSE 类</h2>
<p>假设我们有 <code>MATH-101.cfg</code>(课程设置)，<code>MATH-101.std</code>(学生名单)和 <code>MATH-101</code>(学生记录)有了问题陈述中提供的信息，我们可以使用 <code>Course</code> 类(与 <code>Student</code> 和 <code>Assignment</code> 在同一个文件中)，如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># For now, we&#39;ll specify the course name manually.</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$class</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">course</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">MATH-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1"># set up the course. Remember that the script assumes </span>
</span></span><span class="line"><span class="cl"><span class="c1"># &#39;MATH-101.cfg&#39; and &#39;MATH-101.std&#39; are in the current directory.</span>
</span></span><span class="line"><span class="cl"><span class="nv">$class</span><span class="o">.</span><span class="nf">configure-course</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># filename of student record. </span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">MATH-101</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># loop over each line of student record and feed it to</span>
</span></span><span class="line"><span class="cl"><span class="c1"># the corresponding student.</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">$data</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$class</span><span class="o">.</span><span class="nf">add-student-record</span><span class="p">(</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># print course report.</span>
</span></span><span class="line"><span class="cl"><span class="nv">$class</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span></code></pre></div><p>运行该程序之后，它打印出：</p>
<pre tabindex="0"><code>Class report: course = MATH-101, students = 4
Frank Horza: 
	No records for this student.
Bill Jones: 
	Homework 1: Raw = 35/50 : Adjusted = 17.50/25
	Homework 2: Raw = 42/50 : Adjusted = 21.00/25
	Exam 1: Raw = 72/75 : Adjusted = 48.00/50
	Final Course Grade: 86.5/100

Anne Smith: 
	No records for this student.
Sara Tims: 
	Homework 1: Raw = 39/50 : Adjusted = 19.50/25
	Homework 2: Raw = 45/50 : Adjusted = 22.50/25
	* Incomplete Record *
</code></pre><h2 id="完成程序">完成程序</h2>
<p>您可能注意到，在创建 <code>Course</code> 实例之后，我们必须调用 <code>configure-course</code>。每次创建一个 <code>Course</code> 实例后都要这样做，这样我们就可以添加一个 <code>TWEAK</code> 方法来执行这个任务:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">submethod</span> <span class="nb">TWEAK</span><span class="p">(</span><span class="nv">$course:</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	<span class="c1"># set up course after object creation</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$course</span><span class="o">.</span><span class="nf">configure-course</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># same code as before</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>问题陈述说明程序应该通过命令行接收学生的成绩。Raku 使命令行参数解析非常容易，我们只需要定义一个 <code>MAIN</code> 子例程来获取一个位置参数，即以包含学生成绩的课程命名的文件。要了解关于 <code>MAIN</code> 子例程的更多信息，请阅读<a href="https://uzluisf.gitlab.io/posts/command-line-raku/">本文</a>或<a href="https://docs.raku.org/language/functions#sub_MAIN">参考文档</a>。</p>
<p>让我们创建一个 <code>report.p6</code> 文件，其中也存储了 <code>Assignment</code>, <code>Student</code> 和 <code>Course</code> 类:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="k">v</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># assume the Assignment, Student, and Course class are here.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># CLI arguments are stored in @*ARGS. We take the first one. </span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$class</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nf">create-course</span><span class="p">(</span> <span class="vg">@*ARGS</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">$course</span><span class="o">.</span><span class="kt">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$class</span><span class="o">.</span><span class="nf">add-student-record</span><span class="p">(</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1"># printing the class report.</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$class</span><span class="o">.</span><span class="nf">print-report</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>假设这样:</p>
<pre tabindex="0"><code>$ ls
MATH-101  MATH-101.cfg  MATH-101.std  report.p6
</code></pre><p>然后:</p>
<pre tabindex="0"><code>$ raku report.p6 MATH-101
</code></pre><p>应该打印出报告。</p>
<h1 id="继承">继承</h1>
<p>我们已经完成了问题陈述所提出的任务，但是我们将在这里讨论的主题在OOP范例中非常重要。<code>Student</code> 类有一个属性，用于存储学生已经注册的课程。现在，让我们假设我们想为兼职学生创建一个 <code>PTStudent</code> 类，它限制了一个学生可以注册的课程数量。考虑到兼职学生肯定是学生，我们可能会被诱使将 <code>Student</code> 类中的代码复制到 <code>PTStudent</code> 中，然后添加必要的约束。虽然技术上很好，但是代码的重复被认为是次优的、容易出错的和概念上有缺陷的工作。相反，我们可以使用一种称为<strong>继承</strong>的机制。</p>
<p>简单地说，继承允许从现有类派生一个新类(带有修改)。这意味着您不必创建完整的新类来复制现有类的部分。在这个过程中，继承的类是<strong>父类</strong>的<strong>孩子</strong>(或子类)。</p>
<p>在 Raku 中，<code>is</code> 关键字定义了继承。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Assume Student is defined here.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PTStudent</span> <span class="k">is</span> <span class="nc">Student</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># new attributes particular to PTStudent.</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">@.courses</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$.course-limit</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># new method too.</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@.courses</span> <span class="o">==</span> <span class="nv">$.course-limit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Number of courses exceeds limit of </span><span class="nv">$.course-limit</span><span class="s2">.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="nb">push</span> <span class="nv">@.courses</span><span class="o">,</span> <span class="nv">$course</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$student2</span> <span class="o">=</span> <span class="n">PTStudent</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Tim Polaz</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%</span><span class="p">()</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">BIO-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">GEO-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">PHY-102</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">courses</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>       <span class="c1"># OUTPUT: &#39;BIO-101 GEO-101 PHY-102&#39;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">ENG-220</span><span class="p">&#39;</span> <span class="p">);</span> <span class="c1"># (error) OUTPUT: Number of courses exceeds </span>
</span></span><span class="line"><span class="cl">                                   <span class="c1"># limit of 3.</span>
</span></span></code></pre></div><p><code>PTStudent</code> 类继承了其父类 <code>Student</code> 的属性和方法。除此之外，我们还为它添加了两个新属性和一个新方法。</p>
<p>如果我们愿意，我们可以重新定义从 <code>Student</code> 类继承的方法。这个概念被称为<strong>覆盖</strong>，它允许为父类和子类提供每个类的通用方法实现。</p>
<p>除了单继承之外，Raku 中还可以有多重继承(一次从多个类继承)。查看<a href="https://docs.raku.org/language/classtut#Multiple_inheritance">文档</a>以获得关于它的更多信息。</p>
<h1 id="角色">角色</h1>
<p>与类类似，角色携带状态和行为。然而，与类不同，角色是用来描述对象行为的特定组件的。在 Raku 中，角色是用 <code>role</code> 关键字定义的，并使用 <code>does</code> 特质(与用于继承的 <code>is</code> 相反)应用于类或对象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Assume Student is defined here</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">role</span> <span class="nc">course-limitation</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">has</span> <span class="nv">@.courses</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="kt">Int</span> <span class="nv">$.course-limit</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">add-course</span><span class="p">(</span> <span class="nv">$course</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nv">@.courses</span> <span class="o">==</span> <span class="nv">$.course-limit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Number of courses exceeds limit of </span><span class="nv">$.course-limit</span><span class="s2">.</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@.courses</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$course</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># inheriting from the Student class and applying role.</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PTStudent</span> <span class="k">is</span> <span class="nc">Student</span> <span class="k">does</span> <span class="nc">course-limitation</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$student2</span> <span class="o">=</span> <span class="n">PTStudent</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Tim Polaz</span><span class="p">&#34;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">config</span> <span class="o">=&gt;</span> <span class="nv">%</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">MATH-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">GEO-101</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">PHY-102</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.</span><span class="nf">courses</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>   <span class="c1"># OUTPUT: &#39;MATH-101 GEO-101 PHY-102&#39;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="nv">$student2</span><span class="o">.</span><span class="nf">add-course</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">ENG-220</span><span class="p">&#39;</span> <span class="p">);</span> <span class="c1"># (error) OUTPUT: Number of courses exceeds </span>
</span></span><span class="line"><span class="cl">                                   <span class="c1"># limit of 3.</span>
</span></span></code></pre></div><p>我们已经演示了角色是如何工作的，但这并没有展示它们的完整画面。例如，就像多重继承一样，角色可以在一个类中多次实现(例如，<code>class Name does role1 does role2 does ...</code>)。但是，与多重继承不同的是，如果多个角色的应用程序出现冲突，则会抛出编译时错误。对于多重继承，冲突不会被认为是错误，而是会在运行时解决。</p>
<p>简而言之，角色可以被认为是继承的另一种选择; 程序员不是通过子类化来扩展类层次结构，而是使用为类的行为提供补充行为的角色来组成类。</p>
<h1 id="内省">内省</h1>
<p><strong>内省</strong> 是一个对象能够收集关于自身和其他对象的信息的过程，如类型、方法、属性等。</p>
<p>在 Raku 中，内省可以通过以下结构得到促进:</p>
<ul>
<li><code>.WHAT</code>——返回与对象关联的类型对象。</li>
<li><code>.perl</code>——返回一个字符串，该字符串可以作为 Raku 代码执行。</li>
<li><code>.^name</code>——返回类名。</li>
<li><code>^attributes</code>——返回对象的所有属性。</li>
<li><code>^methods</code>——返回可以在该对象上调用的所有方法。</li>
<li><code>^parents</code>——返回对象的父类。</li>
<li><code>~~</code> 是智能匹配操作符。如果对象是由正在进行比较的类或其任何它的继承类创建的，则计算为 <code>True</code>。</li>
</ul>
<p><code>.^</code> 语法是元方法调用。使用这种语法而不是单个点表示对其元类的方法调用，元类是管理所有类的属性的类。事实上, <code>obj.^meth</code> 相当于<code>obj.HOW.meth(obj)</code>, 其中 <code>meth</code> 是一个特定的方法。</p>
<p>使用上一节中的对象 <code>$student2</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>         <span class="c1"># OUTPUT: (PTStudent)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>         <span class="c1"># OUTPUT: PTStudent.new(name =&gt; &#34;Tim Polaz&#34;, </span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#         config =&gt; {}, courses =&gt; [])</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>        <span class="c1"># OUTPUT: PTStudent</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">attributes</span><span class="p">;</span>  <span class="c1"># OUTPUT: (Str $!name Associative %!config Mu </span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          $!assig-num Associative %!assignments</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          Positional @!courses)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>     <span class="c1"># OUTPUT: (course-limit add-course name </span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          add-assignment courses config get-exams</span>
</span></span><span class="line"><span class="cl">                            <span class="c1">#          print-report get-homeworks BUILDALL)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span><span class="o">.^</span><span class="nb">parents</span><span class="p">;</span>     <span class="c1"># OUTPUT: ((Student))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span> <span class="o">~~</span> <span class="n">PTStudent</span><span class="p">;</span> <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span> <span class="o">~~</span> <span class="n">Student</span><span class="p">;</span>   <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$student2</span> <span class="o">~~</span> <span class="kt">Str</span><span class="p">;</span>       <span class="c1"># False</span>
</span></span></code></pre></div><p>如您所见，通过内省，您可以从类的实例中学到很多东西。</p>
<p>内省并不仅限于程序员定义的类。内省是 Raku 的核心，它是一个非常有用的工具，可以帮助您了解内置类型，并从整体上了解该语言。</p>
<h1 id="结论">结论</h1>
<p>在这篇文章中，我们学习了如何定义类、私有和公共属性以及私有和公共方法。我们还学习了如何创建自定义构造函数，并将其调用限制在类或类的实例中。此外，我们还简要讨论了如何通过继承和 Raku 中的角色来促进代码重用。最后，我们讨论了内省的过程，以及如何以最简单的形式学习对象。</p>
<p>关于 <code>report.p6</code>，我们局限于问题陈述，但是程序的用户可以从额外的功能中获益。例如，可以修改程序，为单个学生提供交互式查询，以便学生从命令行查找。此外，该程序可以读取多个课程，然后查询它们，检索并打印一个特定学生的记录。</p>
<p>下面我链接了我们在这里创建的程序和实现前面提到的额外功能的程序。希望这整个教程是有益的和有用的。</p>
<p>链接:</p>
<ul>
<li>整个 report.p6</li>
<li><code>report.p6</code> 有额外的功能。我还添加了一个简单的函数来给课程名称上色，以便更好地将它们与其他文本区分开来。对于一些课程文件，输出结果如下:</li>
</ul>
<p><img src="https://i.imgur.com/3BVTxB0.jpg" alt="img"></p>
<h1 id="资源">资源</h1>
<ul>
<li>Raku Introduction</li>
<li>Raku Documentation
<ul>
<li>Classes and objects</li>
<li>Object orientation</li>
</ul>
</li>
<li>Raku Advent Calendar
<ul>
<li>The humble type object</li>
<li>Classes, attributes, methods and more</li>
<li>Introspection</li>
</ul>
</li>
<li>Basic OO in Raku (slides)</li>
<li>Let’s build an object</li>
<li>Think Raku</li>
<li>The problem statement was an adaptation from a section titled Grades: an object example in the book Elements of Programming with Perl by Andrew L. Johnson.</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[第二十章. 高级话题]]></title>
            <link href="http://localhost:1313/raku/2018-09-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0.-%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="第十七章. Grammars" />
                <link href="http://localhost:1313/raku/2018-09-02-%E7%AC%AC%E4%BA%8C%E7%AB%A0.-%E7%8C%9C%E6%95%B0%E5%AD%97/?utm_source=atom_feed" rel="related" type="text/html" title="第二章. 猜数字" />
                <link href="http://localhost:1313/raku/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的容器" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/raku/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 连接 Kafka" />
            
                <id>http://localhost:1313/raku/2018-09-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0.-%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-09-20T00:10:09+08:00</published>
            <updated>2018-09-20T00:10:09+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="声明">声明</h1>
<p>本章翻译仅用于 Raku 学习和研究, 请支持电子版或<a href="https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8&amp;qid=1536753267&amp;sr=8-1&amp;keywords=Learning+Perl+6">纸质版</a>。</p>
<h1 id="第二十章-高级话题">第二十章. 高级话题</h1>
<p>In such a short book I don’t have enough pages to show you everything that you can do. This chapter is a brief survey of some of the features I would have liked to explain in more detail. You now know these exist and you can investigate them further on your own.</p>
<p>在这么短的书中，我没有足够的页面向你展示你可以做的一切。本章简要介绍了一些我希望更详细解释的功能。你现在知道这些存在，你可以自己进一步研究它们。</p>
<h1 id="单行">单行</h1>
<p>You can run <em>raku</em> one-liners. These are programs that you compose completely on the command line. The <code>-e</code>switch takes an argument that is the program:</p>
<p>你可以运行 raku 单行。这些完全是你在命令行上编写的程序。 <code>-e</code> 开关接受一个参数，即程序：</p>
<pre tabindex="0"><code>% raku -e &#39;put &#34;Hello Raku&#34;&#39;
Hello Raku
</code></pre><p>The <code>-n</code> switch runs the program once for each line of input. The current line is in <code>$_</code>. This one uppercases and outputs the line:</p>
<p><code>-n</code> 开关为每行输入运行一次程序。当前行是 <code>$_</code>。这个单行大写一行并输出该行：</p>
<pre tabindex="0"><code>% raku -n -e &#39;.uc.put&#39; *.pod
</code></pre><p>You can load a module with <code>-M</code>:</p>
<p>你可以使用 <code>-M</code> 加载模块：</p>
<pre tabindex="0"><code>% raku -MMath::Constants -e &#39;put α&#39;
0.0072973525664
</code></pre><h1 id="declarator-block-comments">Declarator Block Comments</h1>
<p>The parser doesn’t discard all comments. It remembers special comments and attaches them to the subroutine. <code>#|</code> comments attach themselves to the subroutine after them and <code>#=</code> comments attach themselves to the subroutine before them. These comments are available through the <code>.WHY</code> meta-method:</p>
<p>解析器不会丢弃所有的注释。它会记住特殊注释并将它们附加到子例程中。 <code>#|</code> 注释将它们附加到它们之后的子例程中，并且 <code>#=</code> 注释将它们自身附加到它们之前的子例程中。这些注释可通过 <code>.WHY</code> 元方法获得：</p>
<pre tabindex="0"><code>#| Hamadryas is a sort of butterfly
class Hamadryas {

    #| Flap makes the butterfly go
    method flap () {

        }
    }

Hamadryas.WHY.put;
Hamadryas.^find_method(&#39;flap&#39;).WHY.put;
</code></pre><p>The output is the combination of all the comments attached to that subroutine:</p>
<p>输出是附加到该子例程的所有注释的组合：</p>
<pre tabindex="0"><code>Hamadryas is a sort of butterfly
Flap makes the butterfly go
</code></pre><p>This is the sort of thing that’s handy in an integrated development environment to grab a description of the thing you are trying to use. It’s also useful when you are debugging something—that is, it’s useful if the developer documented their code.</p>
<p>在集成开发环境中，这种方法很方便，可以获取你尝试使用的内容的描述。当你调试某些内容时，它也很有用 - 也就是说，如果开发人员记录了他们的代码，那么它很有用。</p>
<h1 id="feed-operators">Feed Operators</h1>
<p>The feed operators decide which way information flows. Here’s a list-processing pipeline that has a <code>.grep</code>, a <code>.sort</code>, and finally a <code>.map</code>. What they do doesn’t matter as much as their order:</p>
<p>feed 操作符决定信息的流向。这是一个列表处理管道，它有一个 <code>.grep</code>，一个 <code>.sort</code>，最后一个 <code>.map</code>。他们所做的事与顺序无关紧要：</p>
<pre tabindex="0"><code>my @array = @some-array
    .grep( *.chars &gt; 5 )
    .sort( *.fc )
    .map( *.uc )
    ;
</code></pre><p>The final step is farthest away from the assignment. You might not like that. The leftward feed operator allows you to write this in a way where the data flows in one direction. This flows bottom to top into the new variable:</p>
<p>最后一步是离赋值最远的。你可能不喜欢那样。向左的 feed 操作符允许你以数据在一个方向上流动的方式编写代码。下面这个从底部到顶部流入新到变量：</p>
<pre tabindex="0"><code>my @array &lt;==
    map(  *.uc         ) &lt;==
    sort( *.fc         ) &lt;==
    grep( *.chars &gt; 5  ) &lt;==
    @some-array
    ;
</code></pre><p>Notice that the assignment operator disappeared because the feed operator took care of that.</p>
<p>请注意，赋值运算符已消失，因为 feed 运算符负责处理了。</p>
<p>The rightward feed operator goes the other way. The new variable is at the end this time. This is the same thing in the other direction:</p>
<p>向右的 feed 操作符走另一条路。这次这个新变量在最后。在另一方向上也是如此：</p>
<pre tabindex="0"><code>@some-array
    ==&gt; grep( *.chars &gt; 5  )
    ==&gt; sort( *.fc         )
    ==&gt; map(  *.uc         )
    ==&gt; my @array;
</code></pre><h1 id="destructuring-signatures">Destructuring Signatures</h1>
<p>You can group parameters with square brackets to create a subsignature. Inside the <code>[]</code> you can break down the aggregate into a smaller signature:</p>
<p>你可以使用方括号对参数进行分组以创建子签名。在 <code>[]</code>内部，你可以将总体分解为较小的签名：</p>
<pre tabindex="0"><code>sub show-the-arguments ( $i, [$j, *@args] ) {  # slurpy
    put &#34;The arguments are i: $i j: $j and @args[]&#34;;
    }

my @a = ( 3, 7, 5 );
show-the-arguments( 1, @a );
</code></pre><p>With that, <code>$i</code> gets the first parameter and the <code>[]</code> gets the rest. The <code>[]</code> destructures the remaining arguments into <code>$j</code> and <code>@args</code>.</p>
<p>有了它，<code>$i</code> 获得第一个参数，<code>[]</code> 获得其余参数。 <code>[]</code> 将剩余的参数解构为 <code>$j</code> 和 <code>@args</code>。</p>
<h1 id="defining-your-own-operators">Defining Your Own Operators</h1>
<p>You can create new operators. Almost all of the things that we call “operators” are methods.</p>
<p>The <code>↑</code> and <code>↑↑</code> represent Knuth arrows. These are higher levels of exponentiation:</p>
<p>你可以创建新的运算符。几乎所有我们称之为“运算符”的东西都是方法。</p>
<p><code>↑</code> 和 <code>↑↑</code> 代表高德纳箭头。这些是更高的取幂水平：</p>
<pre tabindex="0"><code>multi infix:&lt;↑&gt; ( Int:D \n, Int:D \m  --&gt; Int:D )
    is equiv(&amp;infix:&lt;**&gt;)
    is assoc&lt;right&gt;
    { n ** m }

proto infix:&lt;↑↑&gt; ( Int:D \n, Int:D \m --&gt; Int:D )
    is tighter(&amp;infix:&lt;↑&gt;)
    is assoc&lt;right&gt;
    { * }
multi infix:&lt;↑↑&gt; ( \n,  0 ) { 1 }
multi infix:&lt;↑↑&gt; ( \n,  1 ) { n }
multi infix:&lt;↑↑&gt; ( \n, \m ) { [↑] n xx m }

put 2↑3;  # 2 ** 3 = 8
put 2↑↑3; # 2 ** 2 ** 2 = 2 ** 4 = 16
</code></pre><p>Notice that the definitions allow you to set traits for precedence and associativity. As with other subroutines these are lexically scoped, so they won’t affect other parts of your program.</p>
<p>请注意，这些定义允许你设置优先级和关联性的特征。与其他子例程一样，它们是词法作用域的，因此它们不会影响程序的其他部分。</p>
<h1 id="perl-5-patterns">Perl 5 Patterns</h1>
<p>If you like Perl 5 patterns better, or already have some good ones that you’d like to reuse, you can do that. The <code>:Perl5</code> adverb tells the match operator to interpret the pattern as a Perl 5 regular expression:</p>
<p>如果你更喜欢 Perl 5 模式，或者已经有一些你想要重用的好模式，你可以这样做。 <code>:Perl5</code> 副词告诉匹配操作符将模式解释为 Perl 5 正则表达式：</p>
<pre tabindex="0"><code>my $file = ...;
for $file.IO.lines {
    next unless m:Perl5/\A\s+#/;  # no quoting the # in Perl 5
    .put;
    }
</code></pre><h1 id="shaped-arrays">Shaped Arrays</h1>
<p>Want a multidimensional matrix? You can create a shaped array that knows how wide it is in any dimension. Use the <code>;</code> to separate the dimensions:</p>
<p>想要一个多维矩阵？你可以创建一个定形数组，知道它在任何维度上的宽度。使用  <code>;</code> 分开维度：</p>
<pre tabindex="0"><code>my @array[2;2];
say @array; # [[(Any) (Any)] [(Any) (Any)]]

@array[1;0] = &#39;Hamadryas&#39;;
say @array; # [[(Any) (Any)] [Hamadryas (Any)]]

my $n = 0;
my $m = 1;

@array[$n;$m] = &#39;Borbo&#39;;
say @array; # [[(Any) Borbo] [Hamadryas (Any)]]
</code></pre><p>You can extend this to higher dimensions:</p>
<p>你可以将此扩展到更高的维度：</p>
<pre tabindex="0"><code>my @array[2;2;3];
</code></pre><p>The <code>:shape</code> adverb can describe the size in each dimension:</p>
<p><code>:shape</code> 副词可以描述每个维度的大小：</p>
<pre tabindex="0"><code>my @array = Array.new: :shape(3,3);
</code></pre><p>Once you set the limits in each dimension the size is fixed. This means that you can create fixed-size one-dimensional arrays. You won’t be able to use operaters that increase or decrease the number of elements:</p>
<p>在每个维度中设置限制后，大小就固定了。这意味着你可以创建固定大小的一维数组。你将无法使用增加或减少元素数量的操作符：</p>
<pre tabindex="0"><code>my @array[5];
</code></pre><h1 id="typed-containers">Typed Containers</h1>
<p>The container types (<a href="https://docs.raku.org/type/List.html"><code>List</code></a>, <a href="https://docs.raku.org/type/Array.html"><code>Array</code></a>, <a href="https://docs.raku.org/type/Hash.html"><code>Hash</code></a>, and so on) can limit their elements to a particular type. There are a few ways that you can constrain these. Consider this example:</p>
<p>容器类型（<a href="https://docs.raku.org/type/List.html"><code>List</code></a>, <a href="https://docs.raku.org/type/Array.html"><code>Array</code></a>, <a href="https://docs.raku.org/type/Hash.html"><code>Hash</code></a>等）可以将其元素限制为特定类型。有几种方法可以约束这些。考虑这个例子：</p>
<pre tabindex="0"><code>my Int @array = 1, 2, 3;
@array.push: &#39;Hamadryas&#39;;
</code></pre><p>Since a <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> is not an <a href="https://docs.raku.org/type/Int.html"><code>Int</code></a> the <code>.push</code> fails:</p>
<p>由于<a href="https://docs.raku.org/type/Str.html"><code>字符串</code></a>不是<a href="https://docs.raku.org/type/Int.html"><code>Int</code></a>，因此 <code>.push</code> 失败：</p>
<pre tabindex="0"><code>Type check failed in assignment to @array
</code></pre><p>That form types the <code>@array</code> variable. The type is actually <code>Array[Int]</code>. You can also bind to the object you construct directly:</p>
<p>该形式键入 <code>@array</code> 变量。该类型实际上是 <code>Array [Int]</code>。你还可以绑定到直接构造的对象：</p>
<pre tabindex="0"><code>my @array := Array[Int].new: 1, 3, 7;
</code></pre><p>You can create <a href="https://docs.raku.org/type/Hash.html"><code>Hash</code></a>es with objects for keys and many other interesting constraints.</p>
<p>你可以使用对象创建<a href="https://docs.raku.org/type/Hash.html"><code>散列</code></a>以及许多其他有趣的约束。</p>
<h1 id="nativecall">NativeCall</h1>
<p>There’s a builtin foreign function interface named <code>NativeCall</code>. You use the <code>is native</code> trait to specify the external library. This one connects your program to the argumentless <code>flap</code> routine in <em>libbutterfly</em>:</p>
<p>有一个名为 <code>NativeCall</code> 的内置外部函数接口。你使用 <code>is native</code>  trait 指定外部库。这个程序将你的程序连接到 <code>libbutterfly</code> 中的无参数 <code>flap</code> 例程：</p>
<pre tabindex="0"><code>use NativeCall;
sub flap() is native(&#39;butterfly&#39;) { * }
</code></pre><p>There are ways to tell <code>NativeCall</code> how to translate data structures to “native” types and the other way around.</p>
<p>有办法告诉 <code>NativeCall</code> 如何将数据结构转换为“原生”类型，反之亦然。</p>
<h1 id="the-with-topicalizer">The with Topicalizer</h1>
<p>The <code>with</code> keyword sets the topic. In the postfix form you can use it so you don’t have to repeat a long variable name:</p>
<p><code>with</code> 关键字设置主题。你可以在后缀形式中使用它，以使你不必重复长变量名称：</p>
<pre tabindex="0"><code>put &#34;$_ has {.chars}&#34; with $some-very-long-name;
</code></pre><p>There’s a <a href="https://docs.raku.org/type/Block.html"><code>Block</code></a> form that’s similar to <code>if-elsif-else</code> but sets the topic to the result of the condition. Instead of looking for <code>True</code> or <code>False</code> it tests for definedness. In each of these the topic inside the <a href="https://docs.raku.org/type/Block.html"><code>Block</code></a> is the result of the respective <code>.index</code>:</p>
<p>有一个与 <code>if-elsif-else</code> 类似的 <a href="https://docs.raku.org/type/Block.html"><code>Block</code></a> 形式，但将主题设置为条件的结果。它不是寻找 <code>True</code> 或 <code>False</code>，而是测试定义。 <a href="https://docs.raku.org/type/Block.html"><code>Block</code></a> 里的每个这样的主题是相应的 <code>.index</code> 的结果：</p>
<pre tabindex="0"><code>my $s = &#39;Hamadryas&#39;;

  with $s.index: &#39;a&#39; { $s.substr( $_, 2 ).put }
orwith $s.index: &#39;m&#39; { put &#39;Found m&#39; }
orwith $s.index: &#39;H&#39; { fail &#34;Why is there an H at $_?&#34;  }
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[第十七章. Grammars]]></title>
            <link href="http://localhost:1313/raku/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2018-09-02-%E7%AC%AC%E4%BA%8C%E7%AB%A0.-%E7%8C%9C%E6%95%B0%E5%AD%97/?utm_source=atom_feed" rel="related" type="text/html" title="第二章. 猜数字" />
                <link href="http://localhost:1313/raku/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的容器" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/raku/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 连接 Kafka" />
                <link href="http://localhost:1313/raku/2018-07-14-cro-http-test/?utm_source=atom_feed" rel="related" type="text/html" title="Cro Http Test" />
            
                <id>http://localhost:1313/raku/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-09-17T00:10:09+08:00</published>
            <updated>2018-09-17T00:10:09+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="声明">声明</h1>
<p>本章翻译仅用于 Raku 学习和研究, 请支持电子版或<a href="https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8&amp;qid=1536753267&amp;sr=8-1&amp;keywords=Learning+Perl+6">纸质版</a>。</p>
<h1 id="第十七章-grammars">第十七章. Grammars</h1>
<p>Grammars are patterns on a higher plane of existence. They integrate and reuse pattern fragments to parse and react to complicated formats. This feature is at the core of Raku in a very literal sense; the language itself is implemented as a grammar. Once you start using it you’ll probably prefer it to regexes for all but the most simple problems.</p>
<p>Grammars 是存在于更高层面上的模式。它们集成并重用模式片段来解析复杂的格式并做出反应。从字面意义上讲，这个功能是Raku的核心;语言本身是作为语法实现的。一旦你开始使用它，你可能更喜欢它除了最简单的问题之外的所有正则表达式。</p>
<h1 id="a-simple-grammar">A Simple Grammar</h1>
<p>A grammar is a special sort of package. It can have methods and subroutines but mostly comprises special pattern methods called <code>regex</code>, <code>token</code>, and <code>rule</code>. Each of these define a pattern and apply different modifiers.</p>
<h6 id="note">NOTE</h6>
<p>Raku tends to refer to <code>regex</code>, <code>token</code>, and <code>rule</code> declarations as “rules,” which can be a bit imprecise at times. In this book, you can tell the difference between the language keyword and the general term by the typesetting. I’ll try to not present an ambiguous situation.</p>
<p>Start with something simple (too simple for grammars). Define a <code>TOP</code> pattern that matches digits as the starting point. That name is special because <code>.parse</code> uses it by default. In this example, you declare that with <code>regex</code>:</p>
<p>Grammar 是一种特殊的包。它可以有方法和子程序，但主要包括称为 <code>regex</code>，<code>token</code> 和 <code>rule</code> 的特殊模式方法。其中每个都定义了一个模式并应用了不同的修饰符。</p>
<h6 id="注意">注意</h6>
<p>Raku 倾向于将 <code>regex</code>，<code>token</code> 和 <code>rule</code> 声明称为“规则”，有时可能有点不精确。在本书中，您可以通过排版来区分语言关键字和一般术语。我会尽量不提出模棱两可的情况。</p>
<p>从简单的东西开始（对于 grammar 来说太简单了）。定义匹配数字作为起点的 <code>TOP</code> 模式。该名称很特殊，因为 <code>.parse</code> 默认使用它。在此示例中，您使用 <code>regex</code> 声明一个 <code>TOP</code>：</p>
<pre tabindex="0"><code>grammar Number {
    regex TOP { \d }
    }

my $result = Number.parse( &#39;7&#39; );  # works

put $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;;  # Parsed!
</code></pre><p>This succeeds. <code>.parse</code> applies the grammar to the entire value of <code>7</code>. It starts with the parts that <code>TOP</code> describes. It can match a digit, and the value you pass to <code>.parse</code> is a digit.</p>
<p>When <code>.parse</code> succeeds, it returns a <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> object (it returns <code>Nil</code> when it fails). Try it with a different value. Instead of a single digit, try several digits:</p>
<p>这成功了。 <code>.parse</code> 将 grammar 应用于整个值 <code>7</code>. 它从 <code>TOP</code> 描述的部分开始。它可以匹配一个数字，你传递给 <code>.parse</code> 的值是一个数字。</p>
<p>当 <code>.parse</code> 成功时，它返回一个 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 对象（当它失败时返回 <code>Nil</code>）。尝试使用不同的值。尝试几个数字而不是单个数字：</p>
<pre tabindex="0"><code>my $result = Number.parse( &#39;137&#39; );  # fails (extra digits)

put $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;;  # Failed!
</code></pre><p>This time <code>.parse</code> doesn’t succeed. It starts matching with the first character and ends matching on the last character. It asserts that the text starts, there is a single digit, and the text ends. If <code>.parse</code> sees that there are some characters before or after its match, it fails. It matches everything or not at all. It’s almost the same thing as explicitly using anchors:</p>
<p>这次 <code>.parse</code> 没有成功。它开始与第一个字符匹配，并在最后一个字符上结束匹配。它断言文本开始，有一个数字，文本结束。如果 <code>.parse</code> 看到匹配之前或之后有一些字符，则会失败。它匹配全部或根本不匹配。它与显式地使用锚点几乎相同：</p>
<pre tabindex="0"><code>grammar Number {
    regex TOP { ^ \d+ $ }  # explicitly anchored
    }
</code></pre><p>But <code>TOP</code> is only the default starting point for a grammar. You can tell <code>.parse</code> where you’d like to start. This version defines the same pattern but calls it <code>digits</code> instead of <code>TOP</code>:</p>
<p>但 <code>TOP</code> 是仅有的 grammar 的默认起点。你可以告诉 <code>.parse</code> 你想要开始的地方。此版本定义相同的模式但称为 <code>digits</code> 而不是 <code>TOP</code>：</p>
<pre tabindex="0"><code>grammar Number {
    regex digits { \d+ }
    }
</code></pre><p>Tell <code>.parse</code> where to start with the <code>:rule</code> named argument:</p>
<p>使用 <code>:rule</code> 命名参数告诉 <code>.parse</code> 从哪里开始：</p>
<pre tabindex="0"><code>my @strings = &#39;137&#39;, &#39;137 &#39;, &#39; 137 &#39;;

for @strings -&gt; $string {
    my $result = Number.parse( $string, :rule&lt;digits&gt; );
    put &#34;｢$string｣ &#34;, $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;;
    }
</code></pre><p>The first element of <code>@strings</code> parses because it is only digits. The other ones fail because they have extra characters:</p>
<p><code>@strings</code> 的第一个元素解析成功了因为它只是数字。其他的失败了因为他们有额外的字符：</p>
<pre tabindex="0"><code>｢137｣ parsed!
｢137 ｣ failed!
｢ 137 ｣ failed!
</code></pre><p>Declare <code>digits</code> with <code>rule</code> instead of <code>regex</code>. This implicitly allows whitespace after any part of your pattern:</p>
<p>使用 <code>rule</code> 而不是 <code>regex</code> 声明 <code>digits</code>。这隐式地允许在模式的任何部分之后有空格：</p>
<pre tabindex="0"><code>grammar Number {
    rule digits { \d+ }  #  not anchored, and works
    }
</code></pre><p>Now the second <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> matches too because the implicit whitespace can match the space at the end (but not the beginning):</p>
<p>现在第二个 <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> 也匹配，因为隐式空格可以匹配末尾的空格（但不是开头）：</p>
<pre tabindex="0"><code>｢137｣ parsed!
｢137 ｣ parsed!
｢ 137 ｣ failed!
</code></pre><p>The <code>rule</code> applies <code>:sigspace</code> to its pattern. It’s the same thing as adding that adverb to the pattern:</p>
<p>该 <code>rule</code> 将 <code>:sigspace</code> 应用到其模式。将该副词添加到模式中是一回事：</p>
<pre tabindex="0"><code>grammar Number {
    regex digits { :sigspace \d+ }
    }
</code></pre><p><code>:sigspace</code> inserts the predefined <code>&lt;.ws&gt;</code> <em>after</em> pattern tokens. Since there’s a dot before the name <code>ws</code>, the <code>&lt;.ws&gt;</code> does not create a capture. It’s the same as adding optional whitespace explicitly:</p>
<p><code>:sigspace</code>在模式标记之后插入预定义的 <code>&lt;.ws&gt;</code>。由于名称 <code>ws</code> 之前有一个点号，<code>&lt;.ws&gt;</code> 不会创建捕获。它与显式添加可选空格相同：</p>
<pre tabindex="0"><code>grammar Number {
    regex digits { \d+ &lt;.ws&gt; }
    }
</code></pre><p>Instead of showing <code>Parsed!</code>, you can on success output the <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> object you stored in <code>$result</code>:</p>
<p>您可以在成功输出存储在 <code>$result</code> 中的  <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 对象，而不是显示 <code>Parsed!</code></p>
<pre tabindex="0"><code>grammar Number {
    regex digits { \d+ &lt;.ws&gt; }
    }

my @strings = &#39;137&#39;, &#39;137 &#39;, &#39; 137 &#39;;

for @strings -&gt; $string {
    my $result = Number.parse( $string, :rule&lt;digits&gt; );
    put $result ?? $result !! &#39;Failed!&#39;;
    }
</code></pre><p>The output isn’t that different, but instead of its success status you see the text that matched:</p>
<p>输出没有那么不同，但您可以看到匹配到的文本，而不是其成功状态：</p>
<pre tabindex="0"><code>｢137｣
｢137 ｣
Failed!
</code></pre><p>Modify the grammar to remove that dot from <code>&lt;.ws&gt;</code> so it captures whitespace and try again:</p>
<p>修改 grammar 以从 <code>&lt;.ws&gt;</code> 中删除该点号，以便捕获空格并再次尝试：</p>
<pre tabindex="0"><code>grammar Number {
    regex digits { \d+ &lt;ws&gt; }
    }
</code></pre><p>Now the output shows the nested levels of named captures:</p>
<p>现在输出显示了命名捕获的嵌套级别：</p>
<pre tabindex="0"><code>｢137｣
 ws =&gt; ｢｣
｢137 ｣
 ws =&gt; ｢ ｣
Failed!
</code></pre><p>This still doesn’t match the <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> with leading whitespace. The parser couldn’t match that since <code>rule</code> only inserts <code>&lt;.ws&gt;</code> after explicit parts of the pattern. To match leading whitespace you need to add something to the front of the pattern. The beginning-of-string anchor does that, and now there’s something that <code>&lt;.ws&gt;</code> can come after:</p>
<p>这仍然与带有前导空格的 <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> 不匹配。解析器无法匹配，因为 <code>rule</code> 仅在模式的显式部分之后插入 <code>&lt;.ws&gt;</code>。要匹配前导空格，您需要在模式的前面添加一些内容。字符串开头的锚点就是这样，现在有一些 <code>&lt;.ws&gt;</code> 后面可以出现的东西：</p>
<pre tabindex="0"><code>grammar Number {
    rule digits { ^ \d+ }    # ^ &lt;.ws&gt; \d+ &lt;.ws&gt;
    }
</code></pre><p>There’s also the zero-width always-matches token, <code>&lt;?&gt;</code>:</p>
<p>还有零宽度始终匹配的 token 标记，<code>&lt;?&gt;</code>：</p>
<pre tabindex="0"><code>grammar Number {
    rule digits { &lt;?&gt; \d+ }  #  &lt;?&gt; &lt;.ws&gt; \d+ &lt;.ws&gt;
    }
</code></pre><p>Most of the time you don’t want to play these games. If you want leading whitespace, you can note that explicitly (and you probably don’t want to capture it):</p>
<p>大多数时候你不想玩这些游戏。如果你想要前导空格，你可以显式地注意到（并且你可能不想捕获它）：</p>
<pre tabindex="0"><code>grammar Number {
    rule digits { &lt;.ws&gt; \d+ }  # &lt;.ws&gt; \d+ &lt;.ws&gt;
    }
</code></pre><p>Use <code>token</code> instead of <code>rule</code> if you don’t want any implicit whitespace:</p>
<p>如果您不想要任何隐式空格，请使用 <code>token</code> 而不是 <code>rule</code>：</p>
<pre tabindex="0"><code>grammar Number {
    token digits { \d+ }  # just the digits
    }
</code></pre><p>You’ll see another feature of <code>rule</code> and <code>token</code> later in this chapter.</p>
<p>您将在本章后面看到 <code>rule</code> 和 <code>token</code> 的另一个功能。</p>
<p>EXERCISE 17.1Write a grammer to match octal digits, with or without a leading <code>0</code> or <code>0o</code>. Your grammar should parse numbers such as <code>123</code>, <code>0123</code>, and <code>0o456</code>, but not <code>8</code>, <code>129</code>, or <code>o345</code>.</p>
<p>练习17.1写一个 grammar 来匹配八进制数字，带或不带前导 <code>0</code> 或 <code>0o</code>。您的 grammar 应该解析诸如 <code>123</code>, <code>0123</code> 和 <code>0o456</code> 之类的数字，但不能解析 <code>8</code> ,<code>129</code> 或 <code>o345</code>。</p>
<h1 id="multiple-rules">Multiple Rules</h1>
<p>Grammars wouldn’t be useful if you were limited to one rule. You can define additional rules and use them inside other rules. In the first exercise you had only the <code>TOP</code> rule but you could separate the pattern into parts. Break up the pattern in <code>TOP</code> into rules for <code>prefix</code> and <code>digits</code>. It’s this decomposability that makes it so easy to solve hard parsing problems:</p>
<p>如果你只限于一条规则，那么 grammar 就没用了。您可以定义其他规则并在其他规则中使用它们。在第一个练习中，您只有 <code>TOP</code> 规则，但您可以将模式分成几部分。将 <code>TOP</code> 中的模式分解为 <code>prefix</code>和<code>digits</code>的规则。正是这种可分解性使得解决困难的解析问题变得如此简单：</p>
<pre tabindex="0"><code>grammar OctalNumber {
    regex TOP          { &lt;prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse( $number );
say $result // &#34;failed&#34;;
</code></pre><p>The stringified <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> object shows the overall match and the named subcaptures:</p>
<p>字符串化的 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 对象显示整体匹配和命名的子捕获：</p>
<pre tabindex="0"><code>｢0o177｣
 prefix =&gt; ｢0o｣
 digits =&gt; ｢177｣
</code></pre><p>You can access the pieces:</p>
<p>你可以访问这些部分：</p>
<pre tabindex="0"><code>put &#34;Prefix: $result&lt;prefix&gt;&#34;;
put &#34;Digits: $result&lt;digits&gt;&#34;;
</code></pre><p>EXERCISE 17.2Create a grammar to match a Raku variable name with a sigil (ignore sigilless variables, because that’s too easy). Use separate rules to match the sigil and the identifier. Here is a list of candidates to check if you don’t come up with your own:<code>my @candidates = qw/     sigilless   $scalar  @array   %hash     $123abc    $abc'123 $ab'c123     $two-words $two-    $-dash     /;</code></p>
<p>You can suppress some of those named captures by prefixing the rule with a dot. You probably don’t care about the prefix, so don’t save it:</p>
<p>练习17.2 创建一个 grammar，匹配带有 sigil 的 Raku 变量名（忽略无符号变量，因为这太简单了）。使用单独的规则来匹配 sigil 和标识符。这是一个候选人列表，检查你是否没有自己的：<code>my @candidates = qw/     sigilless   $scalar  @array   %hash     $123abc    $abc'123 $ab'c123     $two-words $two-    $-dash     /;</code></p>
<p>您可以通过在规则前加一个点号来抑制某些命名捕获。您可能不关心前缀，所以不要保存它：</p>
<pre tabindex="0"><code>grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt; }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse( $number );
say $result // &#34;failed&#34;;
</code></pre><p>The output doesn’t include the prefix information:</p>
<p>输出不包含前缀信息：</p>
<pre tabindex="0"><code>｢0o177｣
 digits =&gt; ｢177｣
</code></pre><p>This doesn’t make much of a difference in this small example, but imagine a complicated grammar with many, many rules. That brings you to the next big feature of grammars. Besides the grammar itself, you can specify an <em>action class</em> that processes the rules as the grammar successfully parses them.</p>
<p>这在这个小例子中并没有太大的区别，但想象一下复杂的 grammar 有很多很多规则。这将带您进入 grammar 的下一个重要特征。除 grammar 本身外，您还可以指定一个 action 类来处理规则，因为 grammar 会成功解析它们。</p>
<h1 id="debugging-grammars">Debugging Grammars</h1>
<p>There are two modules that can help you figure out what’s going on in your grammar. Both are much more impressive in your terminal.</p>
<p>有两个模块可以帮助您弄清楚 grammar 中发生了什么。两者在你的终端中都更令人印象深刻。</p>
<h2 id="grammartracer">Grammar::Tracer</h2>
<p>The <code>Grammar::Tracer</code> module shows you the path through a grammar (and applies to any grammar in its scope). Merely loading the module is enough to activate it:</p>
<p><code>Grammar::Tracer</code> 模块向您显示 grammar 的路径（并适用于其作用域内的任何 grammar）。仅加载模块就足以激活它：</p>
<pre tabindex="0"><code>use Grammar::Tracer;

grammar OctalNumber {
    regex TOP          { &lt;prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
$/ = OctalNumber.parse( $number );
say $/ // &#34;failed&#34;;
</code></pre><p>The first part of the output is the trace. It shows which rule it’s in and the result. In this example each one matches:</p>
<p>输出的第一部分是跟踪。它显示了它所在的规则和结果。在这个例子中，每个规则都匹配：</p>
<pre tabindex="0"><code>TOP
|  prefix
|  * MATCH &#34;0o&#34;
|  digits
|  * MATCH &#34;177&#34;
* MATCH &#34;0o177&#34;
｢0o177｣
 prefix =&gt; ｢0o｣
 digits =&gt; ｢177｣
</code></pre><p>Changing the data to include invalid digits, such as <code>0o178</code>, means the grammar will fail. In the trace you can see it matches up to <code>0o17</code> but can’t continue, so you know where in your <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> things went wrong. It could be that the grammar should not match the text or the grammar is not as accommodating as it should be:</p>
<p>更改数据以包含无效数字（例如 <code>0o178</code>）意味着 grammar 将失败。在跟踪中，您可以看到它最多匹配到 <code>0o17</code> 但无法继续，因此你就知道  <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a>  中的哪些地方出错了。可能是 grammar 不应该与文本匹配，或者 grammar 不应该像它应该的那样适应：</p>
<pre tabindex="0"><code>TOP
|  prefix
|  * MATCH &#34;0o&#34;
|  digits
|  * MATCH &#34;17&#34;
* MATCH &#34;0o17&#34;
digits
* FAIL
digits
* MATCH &#34;0&#34;
failed
</code></pre><p>Instead of adding <code>Grammar::Tracer</code> to your program you can load it from the command line with the <code>-M</code>switch. You probably don’t mean to leave it in anyway:</p>
<p>您可以使用 <code>-M</code> 开关从命令行加载 <code>Grammar::Tracer</code>，而不是将 <code>Grammar::Tracer</code> 添加到程序中。你可能并不是故意把它留下来：</p>
<pre tabindex="0"><code>% raku -MGrammar::Tracer program.p6
</code></pre><h2 id="grammardebugger">Grammar::Debugger</h2>
<p>The <code>Grammar::Debugger</code> module does the same thing as <code>Grammar::Tracer</code> (they come together in the same distribution) but allows you to proceed one step at a time. When you start it you get a prompt; type <code>h</code> to get a list of commands:</p>
<p><code>Grammar::Debugger</code> 模块与 <code>Grammar::Tracer</code> （它们在同一个发行版中）执行相同的操作，但允许您一次执行一个步骤。当你启动它时，你得到一个提示; 键入 <code>h</code> 以获取命令列表：</p>
<pre tabindex="0"><code>% raku -MGrammar::Debugger test.p6
TOP
&gt; h
    r              run (until breakpoint, if any)
    &lt;enter&gt;        single step
    rf             run until a match fails
    r &lt;name&gt;       run until rule &lt;name&gt; is reached
    bp add &lt;name&gt;  add a rule name breakpoint
    bp list        list all active rule name breakpoints
    bp rm &lt;name&gt;   remove a rule name breakpoint
    bp rm          removes all breakpoints
    q              quit
</code></pre><p>Typing Enter with no command single-steps through the parse process and gives you a chance to inspect the text and the state of the parser. The <code>rf</code> command will get you to the next failing rule:</p>
<p>在没有命令的情况下键入回车键单步执行解析过程，并让你有机会检查文本和解析器的状态。<code> rf</code> 命令会使你进入下一个失败的规则：</p>
<pre tabindex="0"><code>&gt; rf
|  prefix
|  * MATCH &#34;0o&#34;
|  digits
|  * MATCH &#34;17&#34;
* MATCH &#34;0o17&#34;
digits
* FAIL
&gt;
</code></pre><h1 id="a-simple-action-class">A Simple Action Class</h1>
<p>A grammar does its work by descending into its rules to take apart text. You can go the opposite way by processing each part of the parsed text to build a new <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> (or data structure, or whatever you like). You can tell <code>.parse</code> to use an action class to do this.</p>
<p>grammar 通过下降到它的规则中分解文本来完成其工作。你可以通过处理已解析文本的每个部分来构建新的 <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a>（或数据结构，或任何您喜欢的任何内容）。您可以告诉 <code>.parse</code> 使用 action 类来执行此操作。</p>
<p>Here’s a simple action class, <code>OctalActions</code>. It doesn’t need to have the same name as the grammar, but the method names are the same as the rule names. Each method takes a <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> object argument. In this example, the signature uses <code>$/</code>, which is a variable with a few advantages that you’ll see in a moment:</p>
<p>这是一个简单的 action 类 <code>OctalActions</code>。它不需要与 grammar 具有相同的名称，但方法名称与规则名称相同。每个方法都接收 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 对象参数。在此示例中，签名使用 <code>$/</code>，这是一个具有一些优势的变量，稍后你将看到：</p>
<pre tabindex="0"><code>class OctalActions {
    method digits ($/) { put &#34;Action class got $/&#34; }
    }

grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }
</code></pre><p>Tell <code>.parse</code> which class to use with the <code>:actions</code> named parameter. The name does not need to correspond to the grammar:</p>
<p>使用 <code>:actions</code> 命名参数告诉 <code>.parse</code> 使用哪个类。该名称不需要与 grammar 对应：</p>
<pre tabindex="0"><code>my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse(
    $number, :actions(OctalActions)
    );
say $result // &#34;failed&#34;;
</code></pre><p>This action class doesn’t do much. When the <code>digits</code> rule successfully matches it triggers the rule of the same name in the action class. That method merely outputs the argument:</p>
<p>这个 action 类做的不多。当 <code>digits</code> 规则成功匹配时，它会触发 action 类中相同名称的规则。该方法仅输出参数：</p>
<pre tabindex="0"><code>Action class got 177
｢0o177｣
 digits =&gt; ｢177｣
</code></pre><p>EXERCISE 17.3Implement your own action class for the <code>OctalNumber</code> grammar. When the <code>digits</code> method matches, output the decimal version of the number. The <code>parse-base</code> routine from <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> may be useful. For extra credit, take one number per line from standard input and turn them into decimal numbers.</p>
<p>练习17.3 为 <code>OctalNumber</code> grammar 实现自己的 action 类。当 <code>digits</code> 方法匹配时，输出数字的十进制版本。 <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> 的 <code>parse-base</code> 例程可能很有用。如需额外学分，请从标准输入中每行获取一个数字并将其转换为十进制数字。</p>
<h2 id="creating-an-abstract-syntax-tree">Creating an Abstract Syntax Tree</h2>
<p>Actions shouldn’t output information directly. Instead, they can add values to the <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> object. Calling <code>make</code>in the action method sets a value in the abstract syntax tree (or <code>.ast</code>) slot of the <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a>. You can access that with <code>.made</code>:</p>
<p>Action 不应直接输出信息。相反，他们可以向 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 对象添加值。在 action 方法中调用 <code>make</code> 会在 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 的抽象语法树（或 <code>.ast</code> ）槽中设置一个值。您可以使用 <code>.made</code> 访问它：</p>
<pre tabindex="0"><code>class OctalActions {
    method digits ($/) {
        make parse-base( ~$/, 8 ) # must stringify $/
        }
    }

grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse(
    $number, :actions(OctalActions)
    );
put $result ??
    &#34;Turned ｢{$result&lt;digits&gt;}｣ into ｢{$result&lt;digits&gt;.made}｣&#34;
    !! &#39;Failed!&#39;;
</code></pre><p>The <code>make</code> puts something into the <code>.ast</code> slot of the <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> and <code>.made</code> gets it back out. You can <code>make</code> any value that you like, including containers, objects, and most other things you can imagine. You still get the original, literal match.</p>
<p>In the previous example, the <code>digits</code> action method handled the value. A <code>TOP</code> action method could do it, but it has to reach one level below the <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> object:</p>
<p><code>make</code> 将一些内容放入<a href="https://docs.raku.org/type/Match.html"><code>Match</code></a>的 <code>.ast</code> 插槽中，然后 <code>.made</code> 将其恢复原状。您可以<code>make</code> 任何您喜欢的值，包括容器，对象和您可以想象的大多数其他内容。你仍然得到原始的，字面上的匹配。</p>
<p>在前面的示例中，<code>digits</code> action 方法处理了该值。 <code>TOP</code> action 方法可以做到，但它必须到达  <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 对象下面的一个级别：</p>
<pre tabindex="0"><code>class OctalActions {
    method digits ($/) {
        make parse-base( ~$/, 8 ) # must stringify $/
        }
    }

grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse(
    $number, :actions(OctalActions)
    );
put $result.so ??
    &#34;Turned ｢{$number}｣ into ｢{$result.made}｣&#34;
    !! &#39;Failed!&#39;;
</code></pre><p>You don’t have to use <code>$/</code> in the signature; it’s a convenience. There’s nothing particularly magical about it. You could use some other variable if you are paid by the character:</p>
<p>您不必在签名中使用 <code>$/</code>; 这是一个方便写法。它没什么特别神奇的。如果你有其它字符，您可以使用其他变量：</p>
<pre tabindex="0"><code>class OctalActions {
    method TOP ($match) { make parse-base( ~$match&lt;digits&gt;, 8 ) }
    }
</code></pre><p>EXERCISE 17.4Create a grammar to parse a four-part, dotted-decimal IP address, such as <code>192.168.1.137</code>. Create an action class that turns the parse results into a 32-bit number. Output that 32-bit number in hexadecimal.</p>
<p>练习17.4 创建一个 grammar 来解析一个由四部分组成的点分十进制 IP 地址，例如 <code>192.168.1.137</code>。创建一个 action 类，将解析结果转换为32位数。以十六进制输出那个32位数。</p>
<h1 id="ratcheting">Ratcheting</h1>
<p>The <code>rule</code> and <code>token</code> declarators have a feature that <code>regex</code> doesn’t; they both prevent backtracking by implicitly setting the <code>:ratchet</code> adverb. Once one of those rules matches they don’t backtrack to try again if there’s a failure later in the grammar.</p>
<p>Here’s a nonsense grammar that includes a rule <code>&lt;some-stuff&gt;</code> that matches one or more of any character. The <code>TOP</code> token wants to match digits surrounded by unspecified stuff:</p>
<p><code>rule</code> 和 <code>token</code> 声明符具有 <code>regex</code> 不具有的功能;他们都通过隐式设置 <code>:ratchet</code> 副词来阻止回溯。一旦这些规则中的一个匹配，如果在 grammar 中稍后出现失败，则它们不会回溯以再次尝试。</p>
<p>这是一个无意义的 grammar，其中包含能匹配一个或多个字符的 <code>&lt;some-stuff&gt;</code> 规则。 <code>TOP</code> token 想要匹配由未指定的东西包围的数字：</p>
<pre tabindex="0"><code>grammar Stuff {
    token TOP { &lt;some-stuff&gt; &lt;digits&gt; &lt;some-stuff&gt; }
    token digits       { \d+ }
    token some-stuff   { .+  }
    }
</code></pre><p>This <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a> could satisfy that pattern. It has stuff, some digits, and more stuff:</p>
<p>这个<a href="https://docs.raku.org/type/Str.html"><code>字符串</code></a>可以满足这种模式。它有东西，一些数字和更多的东西：</p>
<pre tabindex="0"><code>my $string = &#39;abcdef123xyx456&#39;;
</code></pre><p>But, <code>Stuff</code> fails to parse it:</p>
<p>但是，<code>Stuff</code> 无法解析它：</p>
<pre tabindex="0"><code>my $result = Stuff.parse( $string );
put &#34;｢$string｣ &#34;, $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;; # Failed!
</code></pre><p>It’s the <code>:ratchet</code> that makes it fail. Work out its path to see why. <code>TOP</code> has to first match <code>&lt;some-stuff&gt;</code>. That matches any character one or more times, greedily—it matches the entire text. <code>TOP</code> next needs to match<code>&lt;digits&gt;</code>, but there is nothing left to match because of that greediness. Without <code>:ratchet</code> the pattern might roll back some of the characters it already consumed. With <code>:ratchet</code> it doesn’t do that. The grammar can’t match the rest of <code>TOP</code> and it fails.</p>
<p>Without <code>:ratchet</code> the situation is different. If you use <code>regex</code> instead of <code>token</code>, you allow the grammar to give back characters it has already matched:</p>
<p>是 <code>:ratchet</code> 使它失败的。找出原因，看看为什么。 <code>TOP</code> 必须首先匹配 <code>&lt;some-stuff&gt;</code>。这匹配任何一个字符一次或多次，贪婪地 - 它匹配整个文本。 <code>TOP</code>  接着需要匹配 <code>&lt;digits&gt;</code>，但由于这种贪婪，没有什么可以匹配的了。如果没有 <code>:ratchet</code> 模式可能会回滚它已经消耗的一些字符。使用 <code>:ratchet</code> 它不会那样做。Grammar 不能匹配 <code>TOP</code> 的其余部分，所以失败了。</p>
<p>没有 <code>:ratchet</code> 的情况是不同的。如果使用 <code>regex</code> 而不是 <code>token</code>，则允许 grammar 归还已匹配的字符：</p>
<pre tabindex="0"><code>grammar Stuff {
    # regex does not turn on ratcheting
    regex TOP { &lt;some-stuff&gt; &lt;digits&gt; &lt;some-stuff&gt; }
    token digits       { \d+ }
    regex some-stuff   { .+  }
    }
</code></pre><p>That could match. The <code>TOP</code> matches <code>&lt;some-stuff&gt;</code> but realizes it’s run out of text and starts backtracking. All parts of the grammar that want to allow backtracking have to use <code>regex</code>. It’s not good enough for <code>TOP</code> to backtrack but not <code>&lt;some-stuff&gt;</code>.</p>
<p>那可能会匹配。 <code>TOP</code> 匹配 <code>&lt;some-stuff&gt;</code>，但意识到它已用完文本并开始回溯。想要允许回溯的 grammar 的所有部分都必须使用 <code>regex</code>。对于 <code>TOP</code> 来说，回溯并不是足够好，除了 <code>&lt;some-stuff&gt;</code> 。</p>
<h1 id="parsing-json">Parsing JSON</h1>
<p>In <em>Mastering Perl</em> I presented a JSON parser that Randal Schwartz created using some advanced features of Perl 5 regular expressions. In many ways his implementation was a grammar, but he was forced to inseparably combine the parsing and the actions. That made the regular expression almost impenetrable. It’s much cleaner and more accessible to write it as a Raku grammar.</p>
<p>JSON is actually quite simple with only a few weird things to handle, but it gives you the opportunity to see how <code>proto</code> rules can simplify actions:</p>
<p>在 Mastering Perl 中，我提到了一个 Randal Schwartz 使用 Perl 5 正则表达式的一些高级功能创建的 JSON 解析器。在许多方面，他的实现是一种 grammar，但他被迫不可分割地将解析和 action 组合在一块。这使得正则表达式几乎无法穿透。用 Raku grammar 编写它会更清晰，更容易访问。</p>
<p>JSON 实际上非常简单，只需处理几个奇怪的事情，但它让您有机会了解 <code>proto</code> 规则如何简化 action：</p>
<pre tabindex="0"><code>grammar Grammar::JSON {
    rule TOP                { &lt;.ws&gt; &lt;value&gt; &lt;.ws&gt; }

    rule object             { &#39;{&#39; ~ &#39;}&#39; &lt;string-value-list&gt; }
    rule string-value-list  { &lt;string-value&gt; * % &#39;,&#39; }
    token string-value      { &lt;string&gt; &lt;.ws&gt; &#39;:&#39; &lt;.ws&gt; &lt;value&gt; }

    rule array              { &#39;[&#39; ~ &#39;]&#39; &lt;list&gt; }
    rule list               { &lt;value&gt; * % &#39;,&#39; }

    token value             {
        &lt;string&gt; | &lt;number&gt; | &lt;object&gt; | &lt;array&gt; |
        &lt;true&gt; | &lt;false&gt; | &lt;null&gt;
        }

    token true  { &#39;true&#39;  }
    token false { &#39;false&#39; }
    token null  { &#39;null&#39;  }

    token string {
        (:ignoremark \&#34; ) ~ \&#34;
        [
            &lt;u_char&gt;              |
            [ &#39;\\&#39; &lt;[\\/bfnrt&#34;]&gt; ] |
            &lt;-[\\\&#34;\n\t]&gt;+
        ]*
        }

    token u_char {
        &#39;\\u&#39; &lt;code_point&gt;
        }

    token code_point { &lt;[0..9a..fA..F]&gt;**4 }

    token number {
        &#39;-&#39; ?
        [ 0 | &lt;[1..9]&gt;&lt;[0..9]&gt;* ]
        [ &#39;.&#39; &lt;[0..9]&gt;+ ]?
        [ &lt;[eE]&gt; &lt;[+-]&gt;? &lt;[0..9]&gt;+ ]?
        }
    }
</code></pre><p>You may be surprised at how easy and short that grammar is. It’s almost a straight translation of the grammar from <a href="https://trac.tools.ietf.org/html/rfc8259">RFC 8259</a>. Now, create an action class for that:</p>
<p>您可能会对这个 grammar 的简单和简短感到惊讶。它几乎是  <a href="https://trac.tools.ietf.org/html/rfc8259">RFC 8259</a> grammar 的直接翻译。现在，为此创建一个 action 类：</p>
<pre tabindex="0"><code>class JSON::Actions {
    method TOP ($/) { make $&lt;value&gt;.made }
    method object ($/) {
        make $&lt;string-value-list&gt;.made.hash.item;
        }
    method array ($/) {
        make $&lt;list&gt;.made.item;
        }

    method true       ($/) { make True }
    method False      ($/) { make False }
    method null       ($/) { make Nil }

    method value      ($/) { make (
        $&lt;true&gt; || $&lt;false&gt; || $&lt;null&gt; || $&lt;object&gt; ||
        $&lt;array&gt; || $&lt;string&gt; || $&lt;number&gt; ).made
        }

    method string-value-list ($/) {
        make $&lt;string-value&gt;&gt;&gt;.made.flat;
        }

    method string-value ($/) {
        make $&lt;string&gt; =&gt; $&lt;value&gt;
        }

    method list       ($/) { make ~$/ }
    method string     ($/) { make $&lt;uchar&gt;.made || ~$/ }

    method u_char     ($/) { make $&lt;code_point&gt;.made }
    method code_point ($/) { make chr( (~$/).parse-base(16) ) }
    method number     ($/) { make +$/ }
    }
</code></pre><p>Look at the clunky handling of <code>value</code>. Almost anything can be a value, so the action method does some ham-handed work to figure out which thing just matched. It looks into the possible submatches to find one with a defined value. Well, that’s pretty stupid even if it’s a quick way to get started (although there is some value in the immediate stupid versus the far-off smart).</p>
<p>A <code>proto</code> rule gets around this by making it easy for you to give different subrules the same name but different patterns. Instead of an alternation you have one token for each:</p>
<p>看看笨重的 <code>value</code> 处理。几乎任何东西都可以是一个值，所以 action 方法会做一些简单的工作来弄清楚哪个东西匹配。它查找可能的子匹配以找到具有定义值的子匹配。好吧，即使这是一个快速入门的方式，这也是非常愚蠢的（虽然在愚蠢的直接智能中存在一些价值）。</p>
<p><code>proto</code> 规则可以让您轻松地为不同的子规则赋予相同的名称但不同的模式。不是备选分支，而是每个都有一个 <code>token</code>：</p>
<pre tabindex="0"><code>proto token value { * }
token value:sym&lt;string&gt; { &lt;string&gt; }
token value:sym&lt;number&gt; { &lt;number&gt; }
token value:sym&lt;object&gt; { &lt;object&gt; }
token value:sym&lt;array&gt;  { &lt;array&gt;  }
token value:sym&lt;true&gt;   { &lt;sym&gt;    }
token value:sym&lt;false&gt;  { &lt;sym&gt;    }
token value:sym&lt;null&gt;   { &lt;sym&gt;    }
</code></pre><p>The first <code>proto</code> rule matches <code>*</code>, which really means it dispatches to another rule in that group. It can dispatch to all of them and find the one that works.</p>
<p>Some of these use the special <code>&lt;sym&gt;</code> subrule in their pattern. This means that the name of the rule is the literal text to match. The <code>proto</code> rule <code>&lt;true&gt;</code> matches the literal text <code>true</code>. You don’t have to type that out in the name and the pattern.</p>
<p>It doesn’t matter which of those matches; the grammar calls each of them <code>$&lt;value&gt;</code>. The superrule only knows that something that is a value matched and that the subrule handled it appropriately. The action class <code>make</code>s the right value and stores it in the <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a>:</p>
<p>第一个 <code>proto</code> 规则匹配 <code>*</code>，这实际上意味着它将分派给该组中的另一个规则。它可以发送给所有人并找到有效的。</p>
<p>其中一些在其模式中使用特殊的 <code>&lt;sym&gt;</code> 子规则。这意味着规则的名称是要匹配的文字文本。 <code>proto</code> 规则 <code>&lt;true&gt;</code> 匹配文字文本 <code>true</code>。您不必在名称和模式中输入该内容。</p>
<p>哪些匹配无关紧要; grammar 调用每个 <code>$&lt;value&gt;</code>。超级规则只知道值匹配的东西，并且子规则适当地处理它。 action 类生成正确的值并将其存储在 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 中：</p>
<pre tabindex="0"><code>class JSON::Actions {
    method TOP    ($/) { make $&lt;value&gt;.made }
    method object ($/) { make $&lt;string-value-list&gt;.made.hash.item }

    method string-value-list ($/) { make $&lt;string-value&gt;&gt;&gt;.made.flat }
    method string-value      ($/) {
        make $&lt;string&gt;.made =&gt; $&lt;value&gt;.made
        }

    method array  ($/) { make $&lt;list&gt;.made.item }
    method list   ($/) { make [ $&lt;value&gt;.map: *.made ] }

    method string     ($/) { make $&lt;uchar&gt;.made || ~$/ }

    method value:sym&lt;number&gt; ($/) { make +$/.Str }
    method value:sym&lt;string&gt; ($/) { make $&lt;string&gt;.made }
    method value:sym&lt;true&gt;   ($/) { make Bool::True  }
    method value:sym&lt;false&gt;  ($/) { make Bool::False }
    method value:sym&lt;null&gt;   ($/) { make Any }
    method value:sym&lt;object&gt; ($/) { make $&lt;object&gt;.made }
    method value:sym&lt;array&gt;  ($/) { make $&lt;array&gt;.made }

    method u_char     ($/) { make $&lt;code_point&gt;.made }
    method code_point ($/) { make chr( (~$/).parse-base(16) ) }
    }
</code></pre><p>EXERCISE 17.5Implement your own JSON parser (steal all the code you like). Test it against some JSON files to see how well it works. You might like to try the JSON files at [<em>https://github.com/briandfoy/json-acceptance-tests</em></p>
<p>练习17.5实现自己的 JSON 解析器（窃取你喜欢的所有代码）。针对某些 JSON 文件进行测试，看看它的工作情况。您可能想在 <a href="https//github.com/briandfoy/json-acceptance-tests">https//github.com/briandfoy/json-acceptance-tests</a> 上尝试 JSON文件。</p>
<h1 id="parsing-csv">Parsing CSV</h1>
<p>Let’s parse some comma-separated values (CSV) files. These are tricky because there’s no actual standard (despite <a href="https://tools.ietf.org/html/rfc4180">RFC 4180</a>). Microsoft Excel does it one way but some other producers do it slightly differently.</p>
<p>People often initially go wrong thinking they can merely split the data on a comma character—but that might be part of the literal data in a quoted field. The quote character may also be part of the literal data, but one producer might escape internal quote marks by doubling them, <code>&quot;&quot;</code>, while another might use the backslash, <code>\&quot;</code>. People often assume they are line-oriented, but some producers allow unescaped (but quoted!) vertical whitespace. If all of that wasn’t bad enough, what do you do if one line has fewer (or more) fields than the other lines?</p>
<p>让我们解析一些逗号分隔值（CSV）文件。这些都很棘手，因为没有实际的标准（尽管有despite <a href="https://tools.ietf.org/html/rfc4180">RFC 4180</a> ）。 Microsoft Excel 以一种方式实现，但其他一些生产商则略有不同。</p>
<p>最初人们通常认为他们只能按照逗号字符拆分数据 - 但逗号可能是引用字段中字面量数据的一部分。引号字符也可能是字面量数据的一部分，但是有些制作人可能会通过两个双引号 <code>&quot;&quot;</code> 来避免内部引号，而另一个可能会使用反斜杠，<code>\&quot;</code>。人们通常认为它们是面向行的，但是一些制作人允许未转义的（但引起来！）垂直空白。如果所有这些都不够糟糕，如果一行的字段少于（或多于）其他行，你会怎么做？</p>
<h6 id="warning-警告">WARNING 警告</h6>
<p>Don’t parse CSV files like this. The <code>Text::CSV</code> module not only parses the format but also tries to correct problems as it goes.</p>
<p>不要像这样解析 CSV 文件。 <code>Text::CSV</code> 模块不仅可以解析格式，还可以尝试纠正问题。</p>
<p>Still willing to give it a try? You should find that grammars make most of these concerns tractable:</p>
<p>仍然愿意尝试一下？您应该发现 grammar 使大多数这样的问题易于处理：</p>
<ul>
<li>The ratcheting behavior keeps things simple.</li>
<li>You can easily handle balanced openers and closers (i.e., the quoting stuff).</li>
<li>A grammar can inherit other grammars, so you can adjust a grammar based on the data instead of writing one grammar that handles all the data.</li>
<li>You’ve seen action classes, but you can also have action instances that remember extra non-<a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> data.</li>
<li>There’s a <code>.subparse</code> method that lets you parse chunks so you can handle one record at a time.</li>
<li>棘轮行为使事情变得简单。</li>
<li>您可以轻松地处理平衡的开口和闭合（即引用的东西）。</li>
<li>grammar 可以继承其他 grammar，因此您可以根据数据调整 grammar，而不是编写一个处理所有数据的 grammar。</li>
<li>您已经看过 action 类，但你也可以拥有记住额外非<a href="https://docs.raku.org/type/Match.html"><code>匹配</code></a>数据的 action 实例。</li>
<li>有一个 <code>.subparse</code> 方法，可以让你解析块，这样你就可以一次处理一条记录。</li>
</ul>
<p>Here’s a simple CSV grammar based off the rules in <a href="https://tools.ietf.org/html/rfc4180">RFC 4180</a>. It allows for quoted fields and uses <code>&quot;&quot;</code> to escape a literal quote. If a comma, quote, or vertical whitespace appears in the literal data, it must be quoted:</p>
<p>这是一个简单的 CSV grammar，基于 <a href="https://tools.ietf.org/html/rfc4180">RFC 4180</a> 中的规则。它允许引用的字段并使用 <code>&quot;&quot;</code> 来避免字面量引号。如果字面量数据中出现逗号，引号或垂直空格，则必须引起它：</p>
<pre tabindex="0"><code>grammar Grammar::CSV {
    token TOP       { &lt;record&gt;+ }
    token record    { &lt;value&gt;+ % &lt;.separator&gt; \R }
    token separator { &lt;.ws&gt; &#39;,&#39; &lt;.ws&gt; }
    token value     {
        &#39;&#34;&#39;             # quoted
            &lt;( [ &lt;-[&#34;]&gt; | &lt;.escaped-quote&gt; ]* )&gt;
        &#39;&#34;&#39;
            |
        &lt;-[&#34;,\n\f\r]&gt;+  # non-quoted (no vertical ws)
            |
            &#39;&#39;          # empty
        }

    token escaped-quote { &#39;&#34;&#34;&#39; }
    }

class CSV::Actions {
    method record ($/) { make $&lt;value&gt;».made.flat }
    method value ($/)  {
        # undo the double double quote
        make $/.subst( rx/ &#39;&#34;&#34;&#39; /, &#39;&#34;&#39;, :g )
        }
    }
</code></pre><p>Try this on entire files. The entire file either satisfies this grammar or doesn’t:</p>
<p>在整个文件上试试这个。整个文件要么满足这个 grammar，要么不满足：</p>
<pre tabindex="0"><code>my $data = $filename.IO.slurp;
my $result = Grammar::CSV.parse( $data );
</code></pre><p>You typically don’t want to parse entire files, though. Let’s fix the first part of that problem. You want to process records as you run into them. Instead of using <code>.parse</code>, which anchors to the end of the text, you can use <code>.subparse</code>, which doesn’t. This means you can parse part of the text then stop.</p>
<p>You can deal with one record at a time. Using <code>.subparse</code> with the <code>record</code> rule gets you the first record and only the first record. The <code>.subparse</code> method always returns a <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a>, unlike <code>.parse</code>, which only returns a <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> when it succeeds. You can’t rely on the type of the object as an indication of success:</p>
<p>但是，您通常不希望解析整个文件。让我们解决这个问题的第一部分。您希望在遇到记录时处理记录。你可以使用 <code>.subparse</code>，而不是使用锚定到文本末尾的 <code>.parse</code>，  <code>.subparse</code> 不会锚定到文本末尾。这意味着您可以解析部分文本然后停止。</p>
<p>您可以一次处理一条记录。将 <code>.subparse</code> 与 <code>record</code> 规则一起使用可以获得第一条记录，并且只获得第一条记录。与 <code>.parse</code> 不同，<code>.subparse</code> 方法总是返回一个 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a>，<code>.parse</code> 方法只在成功时返回一个 <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a>。你不能依赖对象的类型作为成功的指示：</p>
<pre tabindex="0"><code>my $data = $filename.IO.slurp;
my $first_result = Grammar::CSV.subparse(
    $data, :rule(&#39;record&#39;), :action(CSV::Actions)
    );
if $first-result { ... }
</code></pre><p>That works for the first line. Use <code>:c(N)</code> to tell these methods where to start in the <a href="https://docs.raku.org/type/Str.html"><code>Str</code></a>. You have to know where you want to start. The <a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> knows how far it got; look in the <code>.from</code> slot:</p>
<p>这适用于第一行。使用 <code>:c(N)</code> 告诉这些方法在 <a href="https://docs.raku.org/type/Str.html"><code>字符串</code></a>中从哪里开始。你必须知道你想要从哪里开始。<a href="https://docs.raku.org/type/Match.html"><code>Match</code></a> 知道它进行了多远;看看 <code>.from</code> 插槽：</p>
<pre tabindex="0"><code>my $data  = $filename.IO.slurp;

loop {
    state $from = 0;
    my $match = Grammar::CSV.subparse(
        $data,
        :rule(&#39;record&#39;),
        :actions(CSV::Actions),
        :c($from)
        );
    last unless $match;

    put &#34;Matched from {$match.from} to {$match.to}&#34;;
    $from = $match.to;
    say $match;
    }
</code></pre><p>This is most of the way to a solution—it fails to go through the entire file if <code>.subparse</code> fails on one record. With some boring monkey work you could fix this to find the start of the next record and restart the parsing, but that’s more than I want to fit in this book.</p>
<p>这是解决方案的大部分方法 - 如果 <code>.subparse</code> 在一条记录上失败，则无法遍历整个文件。使用一些无聊的猴子工作，你可以修复这个问题，找到下一条记录的开始并重新开始解析，但这比我想要适应本书更多。</p>
<h2 id="adjusting-the-grammar">Adjusting the Grammar</h2>
<p>You thought the problem was solved. Then, someone sent you a file with a slightly different format. Instead of escaping a <code>&quot;</code> by doubling it, the new format uses the backslash.</p>
<p>Now your existing grammar fails to parse. You don’t have a rule that satisfies that type of escape because you didn’t need it for your grammar. As a matter of practice in both patterns and grammars, only match what you should match. Be liberal in what you accept in other ways, such as making a subgrammar to handle the new case:</p>
<p>你以为问题已经解决了。然后，有人给你发送了一个格式略有不同的文件。新格式使用反斜杠，而不是使用两个引号转义 <code>&quot;</code>。</p>
<p>现在你现有的 grammar 解析失败。您没有满足该类型的转义的规则，因为您的 grammar 不需要它。作为模式和 grammar 的练习，只匹配你应该匹配的内容。在其他方面随心所欲，例如制作一个子 grammar 来处理新案例：</p>
<pre tabindex="0"><code>grammar Grammar::CSV::Backslashed is Grammar::CSV {
    token escaped-quote { &#39;\\&#34;&#39; }
    }

class CSV::Actions::Backslashed is CSV::Actions {
    method value ($/)  { make $/.subst( rx/ &#39;\\&#34;&#39; /, &#39;&#34;&#39;, :g ) }
    }
</code></pre><p>With two grammars, how do you get the one that you need to use? The name interpolation <code>::($</code><em>name</em><code>)</code> comes in handy here:</p>
<p>有两个 grammar，你如何得到你需要使用的那个？<code>::($</code><em>name</em><code>)</code> 在这里派上用场：</p>
<pre tabindex="0"><code>my %formats;
%formats&lt;doubled&gt; = {
    &#39;file&#39;    =&gt; $*SPEC.catfile( &lt;corpus test.csv&gt; ),
    &#39;grammar&#39; =&gt; &#39;Grammar::CSV&#39;,
    };
%formats&lt;backslashed&gt; = {
    &#39;file&#39; =&gt; $*SPEC.catfile( &lt;corpus test-backslash.csv&gt; ),
    &#39;grammar&#39; =&gt; &#39;Grammar::CSV::Backslashed&#39;,
    };

for %formats.values -&gt; $hash {
    $hash&lt;data&gt; = $hash&lt;file&gt;.IO.slurp;
    my $class = (require ::( $hash&lt;grammar&gt; ) );
    my $match = $class.parse( $hash&lt;data&gt; );
    say &#34;{$hash&lt;file&gt;} with {$hash&lt;grammar&gt;} &#34;,
        $match ?? &#39;parsed&#39; !! &#39;failed&#39;;
    }
</code></pre><p>The <code>%formats</code> <a href="https://docs.raku.org/type/Hash.html"><code>Hash</code></a> of <a href="https://docs.raku.org/type/Hash.html"><code>Hash</code></a>es stores the filenames and the grammars for them. You can load a grammar and use it to parse the data without the explicit grammar name:</p>
<p><code>%formats</code> <a href="https://docs.raku.org/type/Hash.html"><code>散列</code></a>的<a href="https://docs.raku.org/type/Hash.html"><code>散列</code></a>存储文件名和 grammar。您可以加载 grammar 并使用它来解析数据而不使用显式的 grammar 名称：</p>
<pre tabindex="0"><code>corpus/test.csv with Grammar::CSV parsed
corpus/test-backslash.csv with Grammar::CSV::Backslashed parsed
</code></pre><p>That mostly solves the problem, although there are plenty of special cases that this doesn’t cover.</p>
<p>这主要解决了这个问题，尽管有很多特殊情况并没有涵盖。</p>
<h2 id="using-roles-in-grammars">Using Roles in Grammars</h2>
<p>Roles can supply rules and methods that grammars can use. In the previous section you handled different sorts of double-quote escaping through inheritance, where you overrode the rule. You can do the same thing with roles.</p>
<p>A grammar can have methods and subroutines. The way you declare a name with <code>sub</code>, <code>method</code>, or <code>rule</code> tells the language parser (not your grammar!) how to parse the stuff in the <a href="https://docs.raku.org/type/Block.html"><code>Block</code></a>.</p>
<p>First, adjust the main grammar to have a stub method for <code>&lt;escaped-quote&gt;</code>. This forces something else to define it:</p>
<p>角色可以提供 grammar 可以使用的规则和方法。在上一节中，您通过继承处理了不同类型的双引号转义，其中您重写了规则。你可以用角色做同样的事情。</p>
<p>Grammar 可以有方法和子程序。使用 <code>sub</code>，<code>method</code>或 <code>rule</code> 声明名称的方式告诉语言解析器（而不是 grammar！）如何解析<a href="https://docs.raku.org/type/Block.html"><code>块</code></a>中的东西。</p>
<p>首先，调整主 grammar，使其具有 <code>&lt;escaped-quote&gt;</code> 的存根方法。这迫使别人定义它：</p>
<pre tabindex="0"><code>grammar Grammar::CSV {
     token TOP       { &lt;record&gt;+ }
     token record    { &lt;value&gt;+ % &lt;.separator&gt; \R }
     token separator { &lt;.ws&gt; &#39;,&#39; &lt;.ws&gt; }
     token value     {
         &#39;&#34;&#39;             # quoted
             &lt;( [ &lt;-[&#34;]&gt; | &lt;.escaped-quote&gt; ]* )&gt;
         &#39;&#34;&#39;
             |
         &lt;-[&#34;,\n\f\r]&gt;+  # non-quoted (no vertical ws)
             |
             &#39;&#39;          # empty
         }

     # stub that you must define in a role
     method escaped-quote { !!! }
     }
</code></pre><p>A role will fill in that stub method. There’s one role for each way to escape the double quote:</p>
<p>角色将填充该存根方法。每种方式都有一个角色来转义双引号：</p>
<pre tabindex="0"><code>role DoubledQuote     { token escaped-quote { &#39;&#34;&#34;&#39;  } }
role BackslashedQuote { token escaped-quote { &#39;\\&#34;&#39; } }
</code></pre><p>When it’s time to parse a file you can choose which role you want to use. You can create a new object for <code>Grammar::CSV</code> and apply the appropriate role to it:</p>
<p>在解析文件时，您可以选择要使用的角色。您可以为 <code>Grammar::CSV</code> 创建一个新对象并将适当的角色应用于它：</p>
<pre tabindex="0"><code>my $filename   = ...;
my $csv-data   = $filename.IO.slurp;
my $csv-parser = Grammar::CSV.new but DoubledQuote;
</code></pre><p>Use that object to parse your data:</p>
<p>使用该对象解析数据：</p>
<pre tabindex="0"><code>my $match = $csv-parser.parse: $csv-data;
say $match // &#39;Failed!&#39;;
</code></pre><p>Doing this doesn’t fix the double quotes in the data—a <code>&quot;&quot;</code> stays as a <code>&quot;&quot;</code>—but you can fix that in an action class.</p>
<p>EXERCISE 17.6Adjust the CSV example to use roles instead of inheritance. Create an action class to adjust the escaped double quotes as you run into them. You can start with <em>Grammars/test.csv</em> from the downloads section of <a href="https://www.learningraku.com/">the book’s website</a> if you like.</p>
<p>这样做不会修复数据中的双引号 -  <code>&quot;&quot;</code> 保留为 <code>&quot;&quot;</code> - 但您可以在 action 类中修复它。</p>
<p>练习17.6 调整 CSV 示例以使用角色而不是继承。创建一个 action 类，以便在遇到它们时调整转义的双引号。如果您愿意，可以从本书网站的下载部分 Grammars/ test.csv 开始。</p>
<h1 id="summary">Summary</h1>
<p>Grammars are one of the killer features of the language. You can define complex relationships between patterns and use action classes to run arbitrarily complex code when something matches. You might find that your entire program ends up being one big grammar.</p>
<p>Grammars 是 Raku 语言的杀手级特性之一。您可以定义模式之间的复杂关系，并在匹配时使用 action 类来运行任意复杂的代码。您可能会发现整个程序最终变成一个大的 grammar。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[第二章. 猜数字]]></title>
            <link href="http://localhost:1313/raku/2018-09-02-%E7%AC%AC%E4%BA%8C%E7%AB%A0.-%E7%8C%9C%E6%95%B0%E5%AD%97/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的容器" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/raku/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 连接 Kafka" />
                <link href="http://localhost:1313/raku/2018-07-14-cro-http-test/?utm_source=atom_feed" rel="related" type="text/html" title="Cro Http Test" />
                <link href="http://localhost:1313/raku/2018-05-10-deconstructing-simple-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Deconstructing Simple Grammars" />
            
                <id>http://localhost:1313/raku/2018-09-02-%E7%AC%AC%E4%BA%8C%E7%AB%A0.-%E7%8C%9C%E6%95%B0%E5%AD%97/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-09-02T00:10:09+08:00</published>
            <updated>2018-09-02T00:10:09+08:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="声明">声明</h1>
<p>本章翻译仅用于 Raku 学习和研究, 请支持电子版或<a href="https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8&amp;qid=1536753267&amp;sr=8-1&amp;keywords=Learning+Perl+6">纸质版</a>。</p>
<h1 id="第二章-猜数字">第二章. 猜数字</h1>
<p>You’re about to be thrown in the deep end. There are some basic things you need to know to write useful programs, and you’ll meet a lot of them in this chapter so you can write a number-guessing program by the end. It’s quite a bit to take in all at once but it should make the rest of the chapters more interesting.</p>
<p>你将要陷入深渊。编写有用的程序需要了解一些基本的东西，本章中你会遇到很多基本的东西，所以你可以在最后编写一个数字猜测程序。一下子就可以完全接受它，但它应该让其他章节更有趣。</p>
<h1 id="binding-and-assignment">Binding and Assignment</h1>
<p>You read a little about variables in <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch01.html#camelia-introduction">Chapter 1</a>. To store a value in a variable you assign to it. The item assignment operator, <code>=</code>, stores a single thingy for you. <code>$number</code> is a scalar variable; it can store exactly one thingy. This is item assignment because there’s one thingy. This “sets” the value:</p>
<p>您将在第1章中阅读一些关于变量的内容。将值存储在您为其分配的变量中。项目赋值运算符=为您存储单个东西。 $ number是一个标量变量;它可以存储一个东西。这是项目分配，因为有一个东西。这“设置”了价值：</p>
<pre tabindex="0"><code>my $number = 2;
</code></pre><p>If you decide that you don’t want that value you can replace it:</p>
<p>如果您认为不需要该值，则可以替换它：</p>
<pre tabindex="0"><code>$number = 3;
</code></pre><p>Sometimes you want a value that you can’t change (more likely a value you don’t want another part of your program to change). Instead of the assignment operator you can use the binding operator, <code>:=</code>, to set the value:</p>
<p>有时你想要一个你无法改变的值（更可能是你不希望程序的另一部分改变的值）。您可以使用绑定运算符：=来设置值，而不是赋值运算符：</p>
<pre tabindex="0"><code>my $sides-of-a-square := 4;
$sides-of-a-square = 5
</code></pre><p>When you try to change the value you get an error:</p>
<p>当您尝试更改该值时，您会收到错误：</p>
<pre tabindex="0"><code>Cannot assign to an immutable value
</code></pre><p>It’s not the binding operator that makes the variable immutable. It merely makes the thingy on the left the same as the one on the right. In this case, <code>$sides-of-square</code> is actually <code>4</code> and not just a variable that happens to store <code>4</code>. You can’t assign to <code>4</code>, so you can’t assign to <code>$sides-of-a-square</code>.</p>
<p>If you first assign to a scalar variable then <em>bind</em> to that variable you end up with two names for the same variable:</p>
<p>它不是使变量成为不可变的绑定运算符。它只是让左边的东西和右边的东西相同。在这种情况下，$ sides-of-square实际上是4而不仅仅是恰好存储4的变量。你不能分配给4，所以你不能分配到$ side-of-a-square。</p>
<p>如果您首先分配给标量变量然后绑定到该变量，则最终会为同一个变量使用两个名称：</p>
<pre tabindex="0"><code>my $number = 3;
my $sides := $number;
</code></pre><p>You can change <code>$sides</code> or <code>$number</code>, and the “other” will change. But there is no “other” to change because they are the same thing! You might think of these as aliases, but it’s a bit more complicated.</p>
<p>There’s an important concept here that you should learn early. A variable assignment with <code>=</code> creates a container, then puts a value in that container. A container is just a box that can store a value. You can add, remove, and replace the value in that box. This is mostly invisible to you because the language handles it for you.</p>
<p>The binding operator skips this containerization. It aliases the thingy on the right side directly. If it’s already a container that’s what you bind to. You can break down the action of assignment into two steps. First you bind to an anonymous container. That’s right: a container can exist without a name. An anonymous container is just the <code>$</code> sigil:</p>
<p>您可以更改$ sides或$ number，“other”将更改。但是没有“其他”可以改变，因为它们是同一个东西！您可能会将这些视为别名，但它有点复杂。</p>
<p>这里有一个重要的概念，你应该尽早学习。带=的变量赋值创建一个容器，然后在该容器中放入一个值。容器只是一个可以存储值的盒子。您可以添加，删除和替换该框中的值。这对你来说几乎是不可见的，因为语言会为你处理它。</p>
<p>绑定操作员跳过此容器化。它直接在右侧别名。如果它已经是一个与你绑定的容器。您可以将分配操作分解为两个步骤。首先绑定到匿名容器。没错：容器可以没有名字而存在。一个匿名的容器只是$ sigil：</p>
<pre tabindex="0"><code>my $number := $;
</code></pre><p>After that you can change the value in the container using <code>=</code>:</p>
<p>之后，您可以使用=更改容器中的值：</p>
<pre tabindex="0"><code>$number = 3;
</code></pre><p>Sometimes you’ll need to know if the thingy you have is a container, and there will be times you’ll want to skip the container. Start thinking about this early, before you develop bad habits, and your programming life will be easier.</p>
<p>有时你需要知道你拥有的东西是否是一个容器，有时候你会想要跳过容器。在你养成坏习惯之前就开始考虑这个问题，你的编程生活会更容易。</p>
<h1 id="a-main-program">A MAIN Program</h1>
<p>In <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch01.html#camelia-introduction">Chapter 1</a> you saw some examples of statements. This is a complete program:</p>
<p>在第1章中，您看到了一些语句示例。这是一个完整的程序：</p>
<pre tabindex="0"><code>put &#39;Hello Raku!&#39;;
</code></pre><p>If you’ve programmed in some other languages you may have encountered a subroutine called <code>main</code> or something similar. Those languages probably required you to put your program inside that routine; when you ran your program it automatically ran that subroutine for you. Raku is a little different because it assumes that your entire file is already that <code>main</code>.</p>
<p>You can still have such a subroutine though. If you define a <code>MAIN</code> subroutine (all caps!) your program will call that automatically if you run the program:</p>
<p>如果您使用其他语言进行编程，则可能遇到了一个名为main或类似的子程序。那些语言可能要求你把你的程序放在那个例程中;当你运行程序时，它会自动为你运行该子程序。 Raku有点不同，因为它假设您的整个文件已经是主要文件。</p>
<p>你仍然可以拥有这样的子程序。如果你定义一个MAIN子程序（所有大写！），你的程序将在你运行程序时自动调用它：</p>
<pre tabindex="0"><code>sub MAIN {
    put &#39;Hello Raku!&#39;
    }
</code></pre><p>You won’t read about subroutines until <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines">Chapter 11</a>, so trust me for a bit on this one. You’ll read more of an explanation of <code>MAIN</code> as you go through the book.</p>
<p>EXERCISE 2.1Create both versions of the “Hello Raku” program. The one-line version and <code>MAIN</code> version should give you the same output.</p>
<p>在第11章之前，你不会阅读关于子程序的内容，所以请相信我一点。在阅读本书时，您将阅读更多关于MAIN的解释。</p>
<p>EXERCISE 2.1创建“Hello Raku”程序的两个版本。单行版本和MAIN版本应该为您提供相同的输出。</p>
<h2 id="program-arguments">Program Arguments</h2>
<p>You probably have seen other command-line programs that take arguments. The filenames you give to <em>more</em> or <em>type</em> are arguments that tell those programs which file’s contents you want to see:</p>
<p>您可能已经看过其他带参数的命令行程序。您提供给更多或类型的文件名是告诉这些程序您想要查看哪些文件内容的参数：</p>
<pre tabindex="0"><code>% more hello-world.p6

C:\ type hello-world.p6 
</code></pre><p>Your Raku program can take arguments too. When you try it with your existing program you get a help message instead of the output that you expected:</p>
<p>你的Raku程序也可以参数。当您使用现有程序尝试它时，您会得到一条帮助消息，而不是您期望的输出：</p>
<pre tabindex="0"><code>% raku hello-world-main.p6 1 2 3
Usage:
  hello-world-main.p6
</code></pre><p>To accept arguments you have to tell <code>MAIN</code> to expect them. Your program had an implicit set of empty parentheses in it. Those parentheses define the parameters, which are the templates for the arguments. Arguments are what you get; parameters are what you wanted. In this case you didn’t specify any parameters, so your program expects no arguments and complains if you try to give it some:</p>
<p>要接受参数，你必须告诉MAIN期望它们。你的程序中有一组隐含的空括号。这些括号定义参数，这些参数是参数的模板。争论就是你得到的;参数是你想要的。在这种情况下，您没有指定任何参数，因此如果您尝试给它一些，您的程序不需要参数和抱怨：</p>
<pre tabindex="0"><code>sub MAIN () {
    put &#39;Hello Raku!&#39;
    }
</code></pre><p>You can change this. You can specify a variable in the parameter list. One parameter allows your <code>MAIN</code> subroutine to take exactly one argument. Change your <code>put</code> statement to output the value in <code>$thingy</code> by defining a signature after the subroutine name:</p>
<p>你可以改变这个。您可以在参数列表中指定变量。一个参数允许MAIN子例程只取一个参数。通过在子例程名称后定义签名，更改put语句以输出$ thingy中的值：</p>
<pre tabindex="0"><code>sub MAIN ( $thingy ) {
    put $thingy;
    }
</code></pre><p>When you run this program with no command-line arguments you get a different help message. You needed one argument and gave it none. Curiously, the help message tells you the name of the variable you used in the parameter:</p>
<p>如果在没有命令行参数的情况下运行此程序，则会收到不同的帮助消息。你需要一个论点并且没有给它。奇怪的是，帮助消息告诉您在参数中使用的变量的名称：</p>
<pre tabindex="0"><code>% raku main-one-thingy.p6
Usage:
  main-one-thingy.p6 &lt;thingy&gt;

% raku main-one-thingy.p6 Hello
Hello
</code></pre><p>Quote the entire value or escape the whitespace (Unix shells only) to preserve whitespace inside a value you want to give to the thingy:</p>
<p>引用整个值或转义空格（仅限Unix shell）以保留要为thingy赋值的内部空格：</p>
<pre tabindex="0"><code>% raku main-one-thingy.p6 &#34;Hello Raku&#34;
Hello Raku

% raku main-one-thingy.p6 Hello\ Perl\ 6
Hello Raku
</code></pre><p>You can specify more than one parameter by separating them with commas. You can also output multiple things in a single <code>put</code> by separating them with commas:</p>
<p>您可以通过用逗号分隔多个参数来指定它们。您也可以通过用逗号分隔它们来输出单个put中的多个内容：</p>
<pre tabindex="0"><code>sub MAIN ( $thingy1, $thingy2 ) {
    put &#39;1: &#39;, $thingy1;
    put &#39;2: &#39;, $thingy1;
    }
</code></pre><p>Now you have to give your program two arguments. If you don’t give it exactly two arguments it doesn’t work:</p>
<p>现在你必须给你的程序两个参数。如果你不准确地给它两个参数它不起作用：</p>
<pre tabindex="0"><code>% raku main-two-thingys.p6 Hamadryas
Usage:
  main-two-thingys.p6 &lt;thingy1&gt; &lt;thingy2&gt;

% raku main-two-thingys.p6 Hamadryas perlicus
1: Hamadryas
2: perlicus
</code></pre><h6 id="note">NOTE</h6>
<p><em>Hamadryas perlicus</em> is the (un)scientific name I’ve given to the butterfly on the cover. Sometimes I call him “Hama” for short because it rhymes with “llama.”</p>
<p>Sometimes you don’t want to specify two arguments even though you need two values. You can specify a default value for some parameters. Use the <code>=</code> to specify the default:</p>
<p>Hamadryas perlicus *是我在封面上给蝴蝶的（非）学名。有时我称他为“哈马”，因为它与“美洲驼”押韵。</p>
<p>有时您不希望指定两个参数，即使您需要两个值。您可以为某些参数指定默认值。使用=指定默认值：</p>
<pre tabindex="0"><code>sub MAIN ( $thingy1, $thingy2 = &#39;perlicus&#39; ) {
    put &#39;1: &#39;, $thingy1;
    put &#39;2: &#39;, $thingy2;
    }
</code></pre><p>When you call it with two arguments it works as before, but when you specify exactly one argument it uses the default for the second:</p>
<p>当你用两个参数调用它时，它像以前一样工作，但是当你指定一个参数时，它使用第二个参数的默认值：</p>
<pre tabindex="0"><code>% raku main-two-thingys-default.p6 Hamadryas februa
1: Hamadryas
2: februa

% raku main-two-thingys-default.p6 Hamadryas
1: Hamadryas
2: perlicus
</code></pre><p>Any parameters with defaults have to show up after those without them. You’ll see much more about parameters in <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines">Chapter 11</a>.</p>
<p>EXERCISE 2.2Create a program that takes three command-line arguments and outputs them on separate, numbered lines. Give two of the parameters default values.</p>
<p>任何带有默认值的参数都必须显示在没有它们的参数之后。您将在第11章中看到有关参数的更多信息。</p>
<p>练习2.2创建一个带有三个命令行参数的程序，并将它们输出到不同的编号行上。给出两个参数默认值。</p>
<h2 id="prompting-for-values">Prompting for Values</h2>
<p>The <code>prompt</code> routine outputs a message asking for input. When you type some text followed by Return <code>prompt</code>reads that text and returns it. You can assign that value to a variable:</p>
<p>提示例程输出要求输入的消息。当您键入一些文本，然后返回提示时，将读取该文本并将其返回。您可以将该值分配给变量：</p>
<pre tabindex="0"><code>my $answer = prompt &#39;What is your favorite number? &#39;;
put &#39;Your answer was [&#39;, $answer, &#39;]&#39;;
</code></pre><p>When you run the program you see the prompt and start typing right after it on the same line:</p>
<p>运行程序时，您会看到提示并在同一行后面开始输入：</p>
<pre tabindex="0"><code>% raku prompt.p6
What is your favorite number? 137
Your answer was [137]
</code></pre><p>The value you get back from <code>prompt</code> does not include the line ending from Return.</p>
<p>EXERCISE 2.3Write a program that asks for your name and then outputs a greeting to that name. If your name is Gilligan it should output “Hello Gilligan.” Can you use a <code>MAIN</code> subroutine and only prompt if there’s no command-line argument?</p>
<p>从提示中返回的值不包括以Return结尾的行。</p>
<p>练习2.3写一个程序，询问你的名字，然后输出一个问候语到该名称。如果你的名字是Gilligan，它应该输出“Hello Gilligan。”你能使用MAIN子程序，只有在没有命令行参数的情况下才会提示吗？</p>
<h1 id="literal-numbers">Literal Numbers</h1>
<p>Literal values are those that you type directly into the program. They are fixed and are sometimes called “hardcoded” values because they exist directly in the program instead of coming from input or configuration. These are terms, and you can write them in several ways.</p>
<p>An integer is a whole number. These are the numbers of everyday life expressed with the digits from 0 to 9:</p>
<p>文字值是您直接在程序中键入的值。它们是固定的，有时称为“硬编码”值，因为它们直接存在于程序中，而不是来自输入或配置。这些是术语，您可以通过多种方式编写它们。</p>
<p>整数是整数。这些是用0到9的数字表示的日常生活数量：</p>
<pre tabindex="0"><code>137
4
-19
0
</code></pre><p>Digital computers are more comfortable with powers of two. Prefix a literal number with <code>0x</code> to specify a hexadecimal number. That’s base 16 and uses the digits 0 to 9 and the letters <em>A</em> to <em>F</em> (in either case) to represent 0 to 15:</p>
<p>数字计算机更适合两种能力。使用0x前缀一个文字数字以指定十六进制数字。这是基数16并使用数字0到9和字母A到F（在任何一种情况下）代表0到15：</p>
<pre tabindex="0"><code>0x89
0xBEEF
-0x20
</code></pre><p>Octal numbers are base 8 and use the digits 0 to 7. Prefix a literal octal number with <code>0o</code>:</p>
<p>八进制数是基数8并使用数字0到7.用0o前缀一个文字八进制数：</p>
<pre tabindex="0"><code>0o211
-0o177
</code></pre><p>Binary numbers are base 2 and use the digits 0 and 1. These are handy when you deal with binary formats. Prefix them with <code>0b</code>:</p>
<p>二进制数字是基数2并使用数字0和1.当您处理二进制格式时，这些都很方便。用0b作为前缀：</p>
<pre tabindex="0"><code>0b10001001
</code></pre><p>Choose a representation that’s easy for you to understand or that’s natural for the task. The compiler converts those representations into values that the physical computer can use. It doesn’t care which one you use; they are just numbers. These are all the same value:</p>
<p>选择一个易于理解或对任务而言很自然的表示。编译器将这些表示转换为物理计算机可以使用的值。它并不关心你使用哪一个;他们只是数字。这些都是相同的价值：</p>
<pre tabindex="0"><code>137           # decimal,     base 10
0b10001001    # binary,      base  2
0o211         # octal,       base  8
0x89          # hexadecimal, base 16
</code></pre><p>EXERCISE 2.4In the REPL try the different base examples. What decimal value does the REPL echo?</p>
<p>Perhaps you don’t like the ASCII digits 0 to 9. You can use any digits that Unicode supports; Raku knows about anything that’s a number character. Eastern Arabic numerals work. Notice that the radix prefixes are the same:</p>
<p>EXERCISE 2.4在REPL中尝试不同的基础示例。 REPL回显的十进制值是多少？</p>
<p>也许您不喜欢ASCII数字0到9.您可以使用Unicode支持的任何数字; Raku知道任何数字角色。东部阿拉伯数字工作。请注意，基数前缀是相同的：</p>
<pre tabindex="0"><code>١٣٧
0b١٠٠٠١٠٠١
0o٢١١
0x٨٩
</code></pre><p>So do Bengali digits:</p>
<p>孟加拉语数字也是如此：</p>
<pre tabindex="0"><code>১৩৭
0b১০০০১০০১
0o২১১
0x৮৯
</code></pre><p>I don’t encourage you to represent numbers like this in your program, but Raku understands them. This is useful when you are processing text that contains them. Your program will be able to convert these to a number type.</p>
<p>You can choose other bases up to base 36. You’ve already seen base 16, which uses 0 to 9 and <em>A</em> to <em>F</em>. Base 17 would add <em>G</em>, and so on up to base 36, which includes <em>Z</em>. Use a colon before the base (in decimal), then put the digits inside angle brackets:</p>
<p>我不鼓励你在你的程序中代表这样的数字，但Raku理解它们。当您处理包含它们的文本时，这非常有用。您的程序将能够将这些转换为数字类型。</p>
<p>您可以选择基数为36的其他基数。您已经看过基数为16，使用0到9和A到F.基数17将添加G，依此类推到基数36，其中包括Z.使用冒号之前基数（十进制），然后将数字放在尖括号内：</p>
<pre tabindex="0"><code>:7&lt;254&gt;
:19&lt;IG88&gt;
:26&lt;HAL9000&gt;
:36&lt;THX1138&gt;
</code></pre><p>EXERCISE 2.5Try the unusual base examples in the REPL. What decimal numbers are they?</p>
<p>练习2.5尝试REPL中不寻常的基础示例。它们的十进制数是多少？</p>
<h2 id="formatting-numbers">Formatting Numbers</h2>
<p>Literal numbers are objects. You can call methods on objects. The <code>.base</code> method allows you to specify the base that you want to represent:</p>
<p>文字数字是对象。您可以在对象上调用方法。 .base方法允许您指定要表示的基数：</p>
<pre tabindex="0"><code>put 0x89.base: 10;     #  137
</code></pre><p>You can choose some other base, up to 36:</p>
<p>您可以选择其他一些基地，最多36个：</p>
<pre tabindex="0"><code>put 0x89.base:  2;     # 10001001
put 0x89.base:  8;     # 211
put 0x89.base: 16;     # 89
</code></pre><p>EXERCISE 2.6Write a program that takes a decimal number as its single command-line argument. Output its binary, octal, decimal, and hexadecimal values. What happens if you give it a hexadecimal number on the command line? What if you specify the decimal number in Eastern Arabic digits?</p>
<p>In the previous exercise you couldn’t specify a hexadecimal number as an argument. That’s because you weren’t actually specifying a number as an argument. It was text made up of digit characters. If you want to use a hexadecimal number you have to tell your program how to convert the number. You can use <code>.parse-base</code> for that. You tell it which base you expect and it does the rest:</p>
<p>练习2.6编写一个以十进制数作为单个命令行参数的程序。输出二进制，八进制，十进制和十六进制值。如果在命令行上给它一个十六进制数，会发生什么？如果您在东部阿拉伯数字中指定十进制数怎么办？</p>
<p>在上一个练习中，您无法将十六进制数指定为参数。那是因为你实际上没有指定一个数字作为参数。它是由数字字符组成的文本。如果要使用十六进制数，则必须告诉程序如何转换数字。你可以使用.parse-base。你告诉它你期望的基础，剩下的就是：</p>
<pre tabindex="0"><code>my $number = $thingy.parse-base: 16;
</code></pre><p>EXERCISE 2.7Modify your answer from the previous exercise to accept a hexadecimal number command-line argument. Your program will now only handle hexadecimal numbers if you’re using only what you’ve seen so far.</p>
<p>练习2.7修改上一练习中的答案以接受十六进制数字命令行参数。如果你只使用到目前为止看到的内容，你的程序现在只能处理十六进制数字。</p>
<h1 id="numeric-operations">Numeric Operations</h1>
<p>Numeric operators transform numbers into new values. The simplest demonstration is to immediately output the result. The <code>+</code> is the addition operator:</p>
<p>数字运算符将数字转换为新值。最简单的演示是立即输出结果。 +是加法运算符：</p>
<pre tabindex="0"><code>put 2 + 2;
</code></pre><p>You can also store the result in a variable and then output it. The item assignment is an operation and so is the addition. The <code>+</code> happens first because it has higher precedence:</p>
<p>您还可以将结果存储在变量中，然后将其输出。项目分配是一项操作，添加也是如此。 +首先发生，因为它具有更高的优先级：</p>
<pre tabindex="0"><code>my $sum = 2 + 2;
put $sum;
</code></pre><p>There are operators for subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), and exponentiation (<code>**</code>). You’ll see more in the next chapter.</p>
<p>Outputting a single number is easy. If you want to output a series of numbers, you could have multiple lines:</p>
<p>有减法（ - ），乘法（*），除法（/）和取幂（**）的运算符。您将在下一章中看到更多内容。</p>
<p>输出单个数字很容易。如果要输出一系列数字，可以有多行：</p>
<pre tabindex="0"><code>my $sum = 0;
put $sum + 1;
put $sum + 1 + 1;
put $sum + 1 + 1 + 1;
</code></pre><p>Each time you add one more to it. That repeats a lot of structure. You can back up a little to make an improvement where the <code>put</code> statement is the same in each case:</p>
<p>每次再添加一个。这重复了很多结构。在每种情况下，put语句相同时，您可以稍微备份以进行改进：</p>
<pre tabindex="0"><code>my $sum = 0;

$sum = $sum + 1;
put $sum;

$sum = $sum + 1;
put $sum;

$sum = $sum + 1;
put $sum;
</code></pre><p>The <code>$sum</code> variable shows up on the left and right of the assignment. That’s okay; the compiler’s not going to get confused. It evaluates everything on the right side using the current value of <code>$sum</code>. When it’s reduced the right side to its value it assigns that to <code>$sum</code>, replacing the value that’s already there. You’re still doing the same thing over and over again, but now that same thing looks exactly like the other things.</p>
<p>Now it’s time to introduce <code>loop</code>. It repeatedly executes the code inside its braces. This code will run until you interrupt the program (probably with Control-C):</p>
<p>$ sum变量显示在赋值的左侧和右侧。没关系;编译器不会混淆。它使用$ sum的当前值评估右侧的所有内容。当它将右侧减少到它的值时，它会将其分配给$ sum，替换已存在的值。你仍然一遍又一遍地做同样的事情，但现在同样的事情看起来和其他事情完全一样。</p>
<p>现在是时候介绍循环了。它重复执行括号内的代码。此代码将一直运行，直到您中断程序（可能使用Control-C）：</p>
<pre tabindex="0"><code>my $sum = 0;
loop {
    $sum = $sum + 1;
    put $sum;
    }
</code></pre><p>You can combine the two statements inside <code>loop</code>. The result of an assignment is the value that you assigned. Here, you add to <code>$sum</code> then assign that result back to <code>$sum</code>, and use that expression as the value you give to <code>put</code>:</p>
<p>您可以在循环内组合这两个语句。赋值的结果是您指定的值。在这里，您添加$ sum然后将该结果分配回$ sum，并将该表达式用作您放置的值：</p>
<pre tabindex="0"><code>my $sum = 0;
loop {
    put $sum = $sum + 1;
    }
</code></pre><p>This sort of structure is so common that it has its own operator: the <code>++</code> unary prefix autoincrement operator. It adds one before you use the value:</p>
<p>这种结构很常见，它有自己的运算符：++一元前缀自动增量运算符。它在您使用该值之前添加一个：</p>
<pre tabindex="0"><code>my $sum = 0;
loop {
    put ++$sum;
    }
</code></pre><p>There’s also a unary postfix version. It adds one to the value, but after you use it:</p>
<p>还有一个一元的后缀版本。它会在值中添加一个，但在您使用它之后：</p>
<pre tabindex="0"><code>my $sum = 0;
loop {
    put $sum++;
    }
</code></pre><p>EXERCISE 2.8What’s the difference in output in the two programs that use the prefix and postfix autoincrement operators? Can you figure it out without running the programs?</p>
<p>So far you’ve declared variables with <code>my</code>. That limits their definition to the current scope. That’s a problem for variables you want in a <code>loop</code> if they should keep their values. This wouldn’t work because each time through the <code>loop</code> would get a new variable even though you used the same name:</p>
<p>练习2.8使用前缀和后缀自动增量运算符的两个程序的输出差异是什么？如果不运行程序，你能搞清楚吗？</p>
<p>到目前为止，你已经用我的声明了变量。这将他们的定义限制在当前范围内。如果它们应该保留它们的值，那么在循环中你想要的变量就是一个问题。这不起作用，因为即使您使用相同的名称，每次循环都会获得一个新变量：</p>
<pre tabindex="0"><code>loop {
    my $sum = 0;
    put $sum++;
    }
</code></pre><p>Declare the variable with <code>state</code> instead: this makes the variable private to the block but doesn’t reset it each time through it. A <code>state</code> declaration only executes the first time through the block and is ignored after that. The assignment to <code>$sum</code> happens once:</p>
<p>用状态声明变量：这使得变量对块是私有的，但每次都不会重置它。状态声明仅在块中第一次执行，之后将被忽略。 $ sum的赋值发生一次：</p>
<pre tabindex="0"><code>loop {
    state $sum = 0;
    put $sum++;
    }
</code></pre><p>This is a bit nicer because everything about <code>$sum</code> is contained inside the block. Always try to give variables the smallest scope they need. If they don’t need to be outside the block define them inside it.</p>
<p>Those operators add or subtract one. If you want to increment by a different number you’re back to using <code>+</code>:</p>
<p>这有点好，因为$ sum的所有内容都包含在块中。始终尝试为变量提供所需的最小范围。如果他们不需要在块之外定义它们。</p>
<p>那些运营商增加或减少一个。如果你想增加一个不同的数字，你就回到了使用+：</p>
<pre tabindex="0"><code>loop {
    state $sum = 0;
    put $sum = $sum + 2;
    }
</code></pre><p>That’s still one too many <code>$sum</code>s in that code. There’s a special form of the assignment operator that lets you shorten this. You can put the infix operator before the <code>=</code>, like this:</p>
<p>那段代码中仍然有太多$ sum。有一种特殊形式的赋值运算符可以让你缩短它。您可以在=之前放置中缀运算符，如下所示：</p>
<pre tabindex="0"><code>$sum += 2;
</code></pre><p>This convenient shorthand is binary assignment. It’s the same as using the variable on both sides of the <code>=</code> but it’s easier to type:</p>
<p>这种方便的简写是二进制赋值。它与在=的两侧使用变量相同，但更容易输入：</p>
<pre tabindex="0"><code>$sum = $sum + 2;
</code></pre><p>Most binary operators can do this, even if they are multiple characters:</p>
<p>大多数二元运算符都可以执行此操作，即使它们是多个字符：</p>
<pre tabindex="0"><code>$product *= 5;
$quotient /= 2;
$is-divisible %%= 3;
</code></pre><p>EXERCISE 2.9Rewrite the looping program to output only multiples of three by adding the appropriate interval to the previous value. Further modify the program to accept the multiple as a command-line argument.</p>
<p>练习2.9通过将适当的间隔添加到上一个值，重写循环程序以仅输出三的倍数。进一步修改程序以接受多个作为命令行参数。</p>
<h1 id="conditional-execution">Conditional Execution</h1>
<p>This chapter has been working its way to a number-guessing program. You know a little bit about numbers, command-line arguments, prompting, and looping. Next you need to know how to decide between two or more paths in your code. That comes in two parts: comparing things to get an answer and using that answer to select the next thing to do.</p>
<p>本章一直致力于数字猜测程序。您对数字，命令行参数，提示和循环有一点了解。接下来，您需要知道如何在代码中的两个或多个路径之间做出决定。这分为两部分：比较事情以获得答案并使用该答案选择下一步要做的事情。</p>
<h2 id="boolean-values">Boolean Values</h2>
<p>Boolean values are logical values that can be one thing or the other: yes or no, on or off, or <code>True</code> or <code>False</code>. These are of type <a href="https://docs.raku.org/type/Bool.html"><code>Bool</code></a>. You’ll use these values to decide between different paths in your program. First, a little Boolean math.</p>
<p>You can combine Boolean values with logical operators. The <code>&amp;&amp;</code> logical AND operator evaluates to <code>True</code> if both operands are <code>True</code>. The <code>||</code> logical OR operator evaluates to <code>True</code> if one or more operators are <code>True</code>:</p>
<p>布尔值是逻辑值，可以是一个或另一个：是或否，打开或关闭，或者是True或False。这些是Bool类型。您将使用这些值来决定程序中的不同路径。首先，一点布尔数学。</p>
<p>您可以将布尔值与逻辑运算符组合使用。如果两个操作数均为True，则&amp;&amp; logical AND运算符的计算结果为True。 ||如果一个或多个运算符为True，则逻辑OR运算符的计算结果为True：</p>
<pre tabindex="0"><code>% raku
&gt; True &amp;&amp; True
True
&gt; True &amp;&amp; False
False
&gt; True || True
True
&gt; True || False
True
</code></pre><p>All of these operators have spelled out “word” versions. These are the lowest-precedence operators (aside from the sequence operators). These operations always happen last:</p>
<p>所有这些运营商都拼写出“单词”版本。这些是优先级最低的运算符（除了序列运算符）。这些操作总是最后发生：</p>
<pre tabindex="0"><code>% raku
&gt; True and True
True
&gt; True and False
False
&gt; True or False
True
</code></pre><p>The <code>!</code> unary prefix operator changes one <a href="https://docs.raku.org/type/Bool.html"><code>Bool</code></a> value to the other one: <code>True</code> becomes <code>False</code>, and the other way around. This is called negating the condition. <code>not</code> is the low-precedence version of that:</p>
<p>的！一元前缀运算符将一个Bool值更改为另一个：True变为False，反之亦然。这被称为否定条件。不是那个低优先级的版本：</p>
<pre tabindex="0"><code>% raku
&gt; ! True
False
&gt; ! False
True
&gt; not True
False
&gt; not False
True
</code></pre><p>Many objects can collapse themselves to a <a href="https://docs.raku.org/type/Bool.html">Bool</a> value when needed, but it’s up to each object how it does that. For numbers, <code>0</code> is <code>False</code> and everything else is <code>True</code>.</p>
<p>For most objects (not just numbers) you can use a prefix <code>?</code> to coerce into either <code>True</code> or <code>False</code>. It calls the <code>.Bool</code> method on the object. The builtin types know how to convert their values to Booleans using whatever rule they decide. For numbers, <code>0</code> is <code>False</code> and everything else is <code>True</code>:</p>
<p>许多对象可以在需要时将自身折叠为Bool值，但是由每个对象决定它是如何做到的。对于数字，0为False，其他所有为True。</p>
<p>对于大多数对象（不仅仅是数字），您可以使用前缀？强迫无论是真还是假。它在对象上调用.Bool方法。内置类型知道如何使用他们决定的任何规则将其值转换为布尔值。对于数字，0为False，其他一切为True：</p>
<pre tabindex="0"><code>% raku
&gt; ?1
True
&gt; ?0
False
&gt; ?-1
True
&gt; 1.Bool
True
&gt; 0.Bool
False
&gt; (-1).Bool
True
</code></pre><p>The <code>.so</code> method and <code>so</code> routine do the same thing:</p>
<p>.so方法和例程也做同样的事情：</p>
<pre tabindex="0"><code>&gt; 1.so
True
&gt; 0.so
False
&gt; (-1).so
True
&gt; so 0
False
&gt; so 1
True
</code></pre><p>Type objects know what they are but they have no concrete value. They are always <code>False</code>:</p>
<p>类型对象知道它们是什么，但它们没有具体的价值。他们总是错的：</p>
<pre tabindex="0"><code>% raku
&gt; Int.so
False
</code></pre><p>Some things that want Boolean values will implicitly do these coercions for you.</p>
<p>一些需要布尔值的东西会隐式地为你做这些强制。</p>
<h3 id="short-circuit-operators">SHORT-CIRCUIT OPERATORS</h3>
<p>The logical operators don’t really evaluate to Boolean values. <code>&amp;&amp;</code> and <code>||</code> test their expressions for <code>True</code> or <code>False</code>, but the entire structure evaluates to the last expression it evaluated.</p>
<p><code>||</code> needs only one expression to be <code>True</code> for the entire thing to be <code>True</code>. If it gets back anything that’s <code>True</code>, then the entire thing is <code>True</code>. All of these are <code>False</code>, but you can see the last expression <code>||</code> evaluated:</p>
<p>逻辑运算符并不真正评估为布尔值。 &amp;&amp;和||测试他们的表达式是True还是False，但整个结构的计算结果是它评估的最后一个表达式。</p>
<p>||只需要一个表达式为True，整个事物就是True。如果它返回任何真实的东西，那么整个事情就是真的。所有这些都是假的，但你可以看到最后一个表达式||评价：</p>
<pre tabindex="0"><code>% raku
&gt; 0 || Nil
Nil
&gt; 0 || False
False
&gt; 0 || Failure
(Failure)
</code></pre><p>These are <code>True</code>. When <code>||</code> finds any value that would evaluate to <code>True</code> as a Boolean it stops right away. These are sometimes called short-circuit operators:</p>
<p>这些是真的。当||找到任何值将被评估为True的值作为它立即停止的布尔值。这些有时被称为短路运营商：</p>
<pre tabindex="0"><code>% raku
&gt; True || 0
True
&gt; 137 || True
137
</code></pre><p>It’s the same with <code>&amp;&amp;</code>. It returns the last expression it evaluated. If that value is <code>False</code> then one of those expressions was <code>False</code>:</p>
<p>与&amp;&amp;相同。它返回它评估的最后一个表达式。如果该值为False，则其中一个表达式为False：</p>
<pre tabindex="0"><code>% raku
&gt; 0 &amp;&amp; 137
0
&gt; 42 &amp;&amp; 8
8
</code></pre><p>There’s a third operator that’s similar. The defined-or operator, <code>//</code>, tests its left side for definedness. If the left value is defined that’s the result, even if that value is <code>False</code>:</p>
<p>还有第三个类似的运营商。定义的或运算符//测试其左侧的定义。如果定义左值是结果，即使该值为False：</p>
<pre tabindex="0"><code>% raku
&gt; 0 // 137
0
&gt; Nil // 19
19
</code></pre><p>A type object is never defined:</p>
<p>永远不会定义类型对象：</p>
<pre tabindex="0"><code>% raku
&gt; Int // 7
7
</code></pre><p>The defined-or is part of a common technique to set a value if a variable doesn’t already have one (or has one that is not defined). You’ll see it as a binary assignment:</p>
<p>如果变量还没有（或者没有定义一个变量），则定义或者是设置值的常用技术的一部分。您会将其视为二进制赋值：</p>
<pre tabindex="0"><code>$value //= 137;
</code></pre><h2 id="comparing-things">Comparing Things</h2>
<p>A comparator evaluates to <code>True</code> or <code>False</code> based on some relative measure. The numeric equality operator, <code>==</code>, compares two numbers to test if they are exactly the same. If they are the same it evaluates to <code>True</code>; otherwise it evaluates to <code>False</code>:</p>
<p>比较器根据某些相对度量计算为True或False。数字相等运算符==，比较两个数字以测试它们是否完全相同。如果它们相同则评估为True;否则评估为False：</p>
<pre tabindex="0"><code>% raku
&gt; 1 == 1
True
&gt; 1 == 3
False
</code></pre><p>The numeric inequality operator <code>!=</code> tests that two numbers are <em>not</em> the same:</p>
<p>数值不等式运算符！=测试两个数字不相同：</p>
<pre tabindex="0"><code>% raku
&gt; 1 != 1
False
&gt; 1 != 3
True
</code></pre><p>Some operators have two versions. You just saw the “ASCII” version, but there’s also a “fancy” Unicode version with <code>≠</code>:</p>
<p>一些运营商有两个版本。您刚看到“ASCII”版本，但也有一个“奇特”的Unicode版本，≠：</p>
<pre tabindex="0"><code>% raku
&gt; 1 ≠ 3
True
</code></pre><p>Instead of a literal value you can compare a variable. It doesn’t matter which side you put the values on:</p>
<p>您可以比较变量而不是文字值。将值放在哪一方并不重要：</p>
<pre tabindex="0"><code>% raku
&gt; my $number = 37
37
&gt; $number == 38
False
&gt; 39 == $number
False
&gt; $number == 37
True
</code></pre><p>You can have an expression on either side of the comparator or variables on both sides:</p>
<p>您可以在比较器的任一侧或两侧的变量上都有一个表达式：</p>
<pre tabindex="0"><code>% raku
&gt; 2 + 2 == 4
True
&gt; 5 == 2
False
&gt; my $thing1 = 17
17
&gt; my $thing2 = 13
13
&gt; $thing1 == $thing2
False
&gt; $thing1 != $thing2
True
</code></pre><p>The <code>&gt;</code> tests that the first operand is numerically greater than the second number and the <code>&lt;</code> tests that the first is less than the second:</p>
<p><code>&gt;</code> 测试第一个操作数在数值上大于第二个数字，并且&lt;测试第一个操作数小于第二个数字：</p>
<pre tabindex="0"><code>% raku
&gt; 1 &gt; 3
False
&gt; 1 &lt; 3
True
&gt; 3 &lt; 3
False
</code></pre><p>With an equals sign the test can include the number. <code>&gt;=</code> tests that the first number is numerically equal to or greater than the second, and <code>&lt;=</code> tests that it is less than or equal:</p>
<p>使用等号，测试可以包括数字。 &gt; =测试第一个数字在数值上等于或大于第二个数字，并且&lt;=测试它是否小于或等于：</p>
<pre tabindex="0"><code>% raku
&gt; 3 &lt; 3
False
&gt; 3 &lt;= 3
True
&gt; 7 &gt; 7
False
&gt; 7 &gt;= 7
True
</code></pre><p>You can also write these with fancier symbols: <code>&gt;=</code> as <code>≥</code> and <code>&lt;=</code> as <code>≤</code>.</p>
<p>Although not a comparator, the <code>%%</code> operator also returns a Boolean. It tests if the number on the left side is evenly divisible by the number on the right side. This is quite handy:</p>
<p>您也可以使用更高的符号来编写这些符号：&gt; =as≥且&lt;=as≤。</p>
<p>虽然不是比较器，但%%运算符也返回一个布尔值。它测试左侧的数字是否可以被右侧的数字整除。这非常方便：</p>
<pre tabindex="0"><code>% raku
&gt; 10 %% 2
True
&gt; 10 %% 3
False
</code></pre><h3 id="chained-comparisons">CHAINED COMPARISONS</h3>
<p>You can chain comparison operators. You can test that a number is inside or outside of a window (remember the <code>&gt;</code> at the start of the input lines is the REPL prompt) like this:</p>
<p>您可以链接比较运算符。您可以测试一个数字是在窗口内部还是外部（请记住输入行开头的&gt;是REPL提示符），如下所示：</p>
<pre tabindex="0"><code>% raku
&gt; $n  = 10
10
&gt; 7 &lt; $n &lt; 15
True
&gt; 7 &lt;= $n &lt; 15
True
&gt; 7 &lt; $n &gt; 15
False
&gt; 7 &gt; $n &lt; 15
False
</code></pre><p>Without this you’d have to perform additional and separate comparisons:</p>
<p>如果没有这个，你必须进行额外的和单独的比较：</p>
<pre tabindex="0"><code>&gt; 7 &lt; $n and $n &lt; 15
True
</code></pre><h3 id="conditionally-running-a-statement">CONDITIONALLY RUNNING A STATEMENT</h3>
<p>The <code>if</code> keyword allows you to evaluate a statement only when some condition is satisfied. The postfix form is the easiest. The part after the <code>if</code> is the condition; it evaluates to <code>True</code> or <code>False</code>:</p>
<p>if关键字允许您仅在满足某些条件时评估语句。后缀形式是最简单的。 if之后的部分是条件;它评估为真或假：</p>
<pre tabindex="0"><code>my $number = 10;
put &#39;The number is even&#39; if $number %% 2;
</code></pre><p>The condition is satisfied when it evaluates to <code>True</code>. “Satisfaction” is getting what you want; the <code>if</code> wants (roughly) its condition to be <code>True</code> before it allows the statement to run. If the condition is <code>False</code> the program skips that statement.</p>
<p>The <code>if</code> condition is a Boolean context; it calls <code>.Bool</code> for you when you don’t do it explicitly. All of these are the same, but you’ll probably do the last one:</p>
<p>在评估为True时满足条件。 “满意”正在得到你想要的东西;在允许语句运行之前，if（大致）将其条件设置为True。如果条件为False，程序将跳过该语句。</p>
<p>if条件是布尔上下文;当你不明确地做它时，它会调用.Bool。所有这些都是一样的，但你可能会做最后一个：</p>
<pre tabindex="0"><code>put &#39;Always outputs&#39; if 1.Bool;
put &#39;Always outputs&#39; if 1.so;
put &#39;Always outputs&#39; if ?1;
put &#39;Always outputs&#39; if 1;
</code></pre><p>With this you can improve your looping program. Previously you had no way to stop it. The <code>last</code> keyword immediately leaves the loop:</p>
<p>有了这个，你可以改善你的循环程序。以前你无法阻止它。最后一个关键字立即离开循环：</p>
<pre tabindex="0"><code>loop {
    state $sum = 0;
    put $sum++;
    last;
    }
</code></pre><p>This outputs one line then finishes the loop. That’s what <code>last</code> said to do, but that’s not very useful. This version evaluates <code>last</code> only when <code>$sum</code> is <code>5</code>:</p>
<p>这输出一行然后完成循环。这就是上次说的，但这并不是很有用。仅当$ sum为5时，此版本才会评估最后一次：</p>
<pre tabindex="0"><code>loop {
    state $sum = 0;
    put $sum++;
    last if $sum == 5;
    }
</code></pre><p>EXERCISE 2.10What is the output of this program? Can you work it out without running the program?</p>
<p>The <code>next</code> command is similar to <code>last</code>, but it goes on to the next iteration of the loop. You can use a postfix <code>if</code>to skip numbers that are divisible by two (when more than one thingy is using a variable in a condition it’s probably better to change it in a separate step):</p>
<p>练习2.10这个程序的输出是什么？你可以在不运行程序的情况下解决问题吗？</p>
<p>下一个命令与last类似，但它继续循环的下一次迭代。您可以使用后缀if跳过可被2整除的数字（当一个条件中有多个东西使用变量时，最好在单独的步骤中更改它）：</p>
<pre tabindex="0"><code>loop {
    state $sum = 0;
    $sum += 1;
    next if $sum %% 2;
    put $sum;
    last if $sum &gt; 5;
    }
</code></pre><p>Now you get the odd numbers:</p>
<p>现在你得到奇数：</p>
<pre tabindex="0"><code>1
3
5
7
</code></pre><h2 id="conditional-branching">Conditional Branching</h2>
<p>You can also write <code>if</code> in a block form. The code inside the block runs only when the <code>if</code> is satisfied:</p>
<p>你也可以用块形式写。块中的代码仅在满足if时运行：</p>
<pre tabindex="0"><code>if $number %% 2 {
    put &#39;The number is even&#39;;
    }
</code></pre><p>You can use parentheses for <em>grouping</em> if you like but they can’t be immediately next to the <code>if</code>; there must be some whitespace:</p>
<p>如果您愿意，可以使用括号进行分组，但不能紧跟if;必须有一些空白：</p>
<pre tabindex="0"><code>if ($number %% 2) {
    put &#39;The number is even&#39;;
    }
</code></pre><p>With no space between the <code>if</code> and the <code>(</code> it looks like a subroutine call, which it isn’t. This is a syntax error:</p>
<p>if和the之间没有空格（它看起来像子程序调用，它不是。这是语法错误：</p>
<pre tabindex="0"><code>if($number %% 2) {  # ERROR!
    put &#39;The number is even&#39;;
    }
</code></pre><p>An <code>unless</code> is the opposite sense of <code>if</code>. It executes its block when the condition is <code>False</code>. Another way to think about that is that it skips the block when the condition is <code>True</code>:</p>
<p>除非是相反的if。它在条件为False时执行其块。另一种思考方式是在条件为True时跳过块：</p>
<pre tabindex="0"><code>unless $number %% 2 {
    put &#39;The number is odd&#39;;
    }
</code></pre><p>Some people prefer an <code>if</code> with a negated condition:</p>
<p>有些人更喜欢具有否定条件的if：</p>
<pre tabindex="0"><code>if ! $number %% 2 {
    put &#39;The number is odd&#39;;
    }
</code></pre><p>An <code>else</code> allows you to provide a default block to run when the <code>if</code> is not satisfied:</p>
<p>如果不满足if，则允许您提供默认块以运行：</p>
<pre tabindex="0"><code>if $number %% 2 {
    put &#39;The number is even&#39;;
    }
else {
    put &#39;The number is odd&#39;;
    }
</code></pre><p>These different possibilities are branches of your code. You go down one or the other branch but not both. This is one example of a control structure that decides which code runs.</p>
<p>The entire <code>if</code> structure evaluates to a value when you put a <code>do</code> in front of it. The <code>do</code> allows you to treat a control structure as an expression. The result is the last evaluated expression from inside the structure. This way you can isolate only the parts that are different, then use one statement for output:</p>
<p>这些不同的可能性是代码的分支。你去一个或另一个分支，但不是两个。这是决定运行哪些代码的控制结构的一个示例。</p>
<p>当你在它前面放置一个do时，整个if结构的计算结果为一个值。 do允许您将控制结构视为表达式。结果是结构内部的最后一个计算表达式。这样，您只能隔离不同的部分，然后使用一个语句进行输出：</p>
<pre tabindex="0"><code>my $type = do if $number %% 2 { &#39;even&#39; }
              else            { &#39;odd&#39;  }

put &#39;The number is &#39;, $type;
</code></pre><p>You can skip the intermediate variable (although if that’s confusing it’s okay to do it the longer way):</p>
<p>你可以跳过中间变量（虽然如果这让人感到困惑，可以用更长的方式去做）：</p>
<pre tabindex="0"><code>put &#39;The number is &#39;,
    do if $number %% 2 { &#39;even&#39; }
       else            { &#39;odd&#39;  }
</code></pre><p>There’s a shortcut for this. The conditional operator has three parts: the condition, the <code>True</code> branch, and the <code>False</code> branch. Between those parts are <code>??</code> and <code>!!</code>:</p>
<p>这有一个捷径。条件运算符有三个部分：条件，True分支和False分支。那些部分之间是??和!!：</p>
<pre tabindex="0"><code>CONDITION ?? TRUE BRANCH !! FALSE BRANCH
</code></pre><p>Using this operator you can rewrite the preceding example. The particular formatting isn’t important, but this fits nicely on the page and lines up the different parts. You don’t use a block, which makes this useful for short bits of code:</p>
<p>使用此运算符可以重写前面的示例。特定的格式并不重要，但这非常适合页面并排列不同的部分。你不使用一个块，这使得这对短代码有用：</p>
<pre tabindex="0"><code>put &#39;The number is &#39;,
    $number %% 2 ?? &#39;even&#39; !! &#39;odd&#39;;
</code></pre><p>An <code>elsif</code> specifies another branch with its own condition, so you have three ways this code might run. Some people think zero is neither odd nor even, and they can add another branch for that:</p>
<p>elsif指定另一个具有自己条件的分支，因此您可以通过三种方式运行此代码。有些人认为零既不是奇数也不是偶数，他们可以为此添加另一个分支：</p>
<pre tabindex="0"><code>if $number == 0 {
    put &#39;The number is zero&#39;;
    }
elsif $number %% 2 {
    put &#39;The number is even&#39;;
    }
else {
    put &#39;The number is odd&#39;;
    }
</code></pre><p>This code works, but it has some repeated structure because each branch has a <code>put</code>. A <code>do</code> cleans that up nicely. Here’s another way to write that:</p>
<p>这段代码有效，但它有一些重复的结构，因为每个分支都有一个put。 A做得很好清理。这是写另一种方式：</p>
<pre tabindex="0"><code>put &#39;The number is &#39;, do
       if $number == 0 { &#39;zero&#39; }
    elsif $number %% 2 { &#39;even&#39; }
    else               { &#39;odd&#39;  }
</code></pre><p>EXERCISE 2.11Create a program that outputs the numbers from 1 to 100. However, if the number is a multiple of three, output “Fizz” instead of the number. If it’s a multiple of five, output “Buzz”. If it’s a multiple of both three and five, output “FizzBuzz”.</p>
<p>练习2.11创建一个从1到100输出数字的程序。但是，如果数字是3的倍数，则输出“Fizz”而不是数字。如果它是五的倍数，则输出“Buzz”。如果它是三个和五个的倍数，则输出“FizzBuzz”。</p>
<h1 id="putting-it-all-together">Putting It All Together</h1>
<p>With a few more things you can now write the number-guessing program. The <code>.rand</code> method returns a fractional number between 0 and the integer (exclusively):</p>
<p>通过更多的东西，你现在可以编写数字猜测程序。 .rand方法返回0和整数（仅限）之间的小数：</p>
<pre tabindex="0"><code>% raku
&gt; 100.rand
62.549491627582
</code></pre><p>The <code>.Int</code> method coerces that to a whole number. It discards the fractional portion; it does not round the number. Put that together with <code>.rand</code> and you get a whole number between 0 and the starting number:</p>
<p>.Int方法强制转换为整数。它丢弃了小数部分;它没有数字。将它与.rand一起放在0和起始编号之间的整数：</p>
<pre tabindex="0"><code>% raku
&gt; 100.rand.Int
23
</code></pre><p>Put that together in a complete program. Choose the number, then test what side of another number (sometimes called the “pivot”) it’s on:</p>
<p>把它放在一个完整的程序中。选择数字，然后测试它所在的另一个数字（有时称为“数据透视”）的哪一侧：</p>
<pre tabindex="0"><code>my $number = 100.rand.Int;

if $number &gt; 50 {
    put &#39;The number is greater than 50&#39;;
    }
elsif $number &lt; 50 {
    put &#39;The number is less than 50&#39;;
    }
else {
    put &#39;The number is 50&#39;;
    }
</code></pre><p>Run that several times and you should get different output eventually:</p>
<p>运行几次，你最终会得到不同的输出：</p>
<pre tabindex="0"><code>% raku random.p6
The number is less than 50
% raku random.p6
The number is less than 50
% raku random.p6
The number is greater than 50
</code></pre><p>EXERCISE 2.12Wrap the pivot program in a <code>MAIN</code> subroutine so you can specify the highest possible number as a command-line argument. Default to <code>100</code> if you don’t supply an argument. Adjust that so the program can take another command-line argument to specify the pivot number.</p>
<p>In the previous exercise you set the default for the second argument using a hard-coded literal integer:</p>
<p>练习2.12在MAIN子例程中包含pivot程序，以便您可以将最高可能的数字指定为命令行参数。如果您不提供参数，则默认为100。调整它，以便程序可以使用另一个命令行参数来指定数据透视表编号。</p>
<p>在上一个练习中，您使用硬编码的文字整数设置第二个参数的默认值：</p>
<pre tabindex="0"><code>sub MAIN ( $highest = 100, $pivot = 50 ) { ... }
</code></pre><p>If you run the program with one command-line argument that is less than <code>50</code> (or whatever you chose as your default) the output will always be the same:</p>
<p>如果使用一个小于50的命令行参数（或者您选择作为默认值的任何内容）运行程序，则输出将始终相同：</p>
<pre tabindex="0"><code>% raku number-program.p6 37
The number is less than 50
</code></pre><p>You can use parameters you’ve already specified to compute defaults for other parameters. Use <code>$highest</code> to compute <code>$pivot</code>:</p>
<p>您可以使用已指定的参数来计算其他参数的默认值。使用$ highest来计算$ pivot：</p>
<pre tabindex="0"><code>sub MAIN ( $highest = 100, $pivot = $highest / 2 ) {
</code></pre><p>EXERCISE 2.13Modify your answer to the previous exercise so you can set the pivot to half the highest value. Default to <code>50</code> if you don’t specify two arguments.</p>
<p>Now you have everything you need to write your number-guessing program. Your program chooses a secret number that you then have to figure out. This early in the book that seems like a complicated program, but you’ve seen just enough to make it:</p>
<p>练习2.13修改上一练习的答案，以便将枢轴设置为最高值的一半。如果未指定两个参数，则默认为50。</p>
<p>现在，您拥有编写数字猜测程序所需的一切。您的程序会选择一个您必须弄清楚的密码。在本书的早期，这看起来像一个复杂的程序，但你已经看到了足够的成就：</p>
<ul>
<li>Choose a secret number (<code>.rand</code>).</li>
<li>Loop repeatedly until the person guesses the number (<code>next</code> and <code>last</code>).</li>
<li>Get the person’s guess (<code>prompt</code>).</li>
<li>Give the person a hint about their guess. Tell them if they are too high or low (comparators, <code>if</code>).</li>
</ul>
<p>•选择一个密码（•。和•）。</p>
<p>反复循环，直到该人猜到该号码（下一个和最后一个）。</p>
<p>得到这个人的猜测（提示）。</p>
<p>给这个人一个关于他们猜测的暗示。告诉他们是否太高或太低（比较，如果）。</p>
<p>EXERCISE 2.14Implement the number-guessing program. If you supply a command-line argument use that as the maximum number; otherwise use 100. It may help to immediately output the secret number as you get your program working.</p>
<p>练习2.14实施数字猜测程序。如果提供命令行参数，请将其用作最大数字;否则使用100.当您的程序正常工作时，可能有助于立即输出密码。</p>
<h1 id="summary">Summary</h1>
<p>You made it! First chapters are typically the toughest because you’re getting your bearings. You’ve made at least one meaty program that incorporates several things that you haven’t seen in depth yet. You can take input from the command line or from a prompt. You can compare values and follow different code branches. Not bad for a first chapter.</p>
<p>你做到了！第一章通常是最难的，因为你得到了你的支持。你已经制作了至少一个丰富的程序，其中包含了一些你还没有深入见过的东西。您可以从命令行或提示中获取输入。您可以比较值并遵循不同的代码分支。对于第一章来说还不错。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的容器]]></title>
            <link href="http://localhost:1313/raku/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8-spark-%E8%AF%BB%E5%86%99-hbase-%E6%95%B0%E6%8D%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Use Spark to read and write HBase data" />
                <link href="http://localhost:1313/raku/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 连接 Kafka" />
                <link href="http://localhost:1313/raku/2018-07-14-cro-http-test/?utm_source=atom_feed" rel="related" type="text/html" title="Cro Http Test" />
                <link href="http://localhost:1313/raku/2018-05-10-deconstructing-simple-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Deconstructing Simple Grammars" />
                <link href="http://localhost:1313/raku/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的列表解析" />
            
                <id>http://localhost:1313/raku/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-08-29T19:55:09+08:00</published>
            <updated>2018-08-29T19:55:09+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>在本系列的<a href="https://opensource.com/article/18/7/migrating-perl-5-perl-6">第一篇</a>文章中，将 Perl 5 与 Raku 进行了比较，我们研究了将代码迁移到 Raku 时可能遇到的一些问题。在<a href="https://opensource.com/article/18/7/garbage-collection-perl-6">第二篇</a>文章中，我们研究了垃圾收集在 Raku 中的工作原理。第三篇文章，我们将重点介绍 Perl 5 的引用以及如何在 Raku 中处理它们，并介绍绑定和容器的概念。</p>
<h2 id="引用">引用</h2>
<p>Raku 中没有引用，这对许多习惯于 Perl 5 语义的人来说都是令人惊讶的。但不要担心：因为没有引用，所以您不必担心是否应该解引用某些内容。</p>
<pre tabindex="0"><code class="language-perl5" data-lang="perl5"># Perl 5
my $foo = \@bar;   # must add reference \ to make $foo a reference to @bar
say @bar[1];       # no dereference needed
say $foo-&gt;[1];     # must add dereference -&gt;
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># Raku</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="nv">@bar</span><span class="p">;</span>    <span class="c1"># $foo now contains @bar</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@bar</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>       <span class="c1"># no dereference needed, note: sigil does not change</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>       <span class="c1"># no dereference needed either</span>
</span></span></code></pre></div><p>有人可能会说 Raku 中的所有东西都是引用。来自 Perl 5（其中一个对象是一个受祝福的引用），这将是关于 Raku 的逻辑结论，其中所有的东西都是对象（或者可以被认为是一个对象）。但这并不能完全符合 Raku 中的情况，并且会妨碍你理解 Raku 的工作原理。谨防<a href="https://en.wikipedia.org/wiki/False_friend">虚假的朋友</a>！</p>
<h2 id="绑定">绑定</h2>
<p>在我们完成赋值之前，了解 Raku 中绑定的概念很重要。您可以使用 <code>:=</code> 运算符将某些东西显式绑定到其他东西上。定义词法变量时，可以将值绑定到它：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1"># note: := instead of =</span>
</span></span></code></pre></div><p>简单地说，这会在词法填充（lexpad）中创建一个名为 &ldquo;<strong>$foo</strong>&rdquo; 的键（您可以将其视为编译时哈希，其中包含有关该词法范围内可见事物的信息）并使其 42 为字面值。因为这是一个文字常量，所以你无法改变它。试图这样做会导致异常。所以不要那样做！</p>
<p>在许多情况下，这种绑定操作在引擎盖下使用，例如在迭代时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">;</span>    <span class="c1"># can also be written as ^10</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="p">;</span>          <span class="c1"># [0 1 2 3 4 5 6 7 8 9]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">++</span> <span class="p">}</span>  <span class="c1"># $_ is bound to each array element and incremented</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="p">;</span>          <span class="c1"># [1 2 3 4 5 6 7 8 9 10]</span>
</span></span></code></pre></div><p>如果您尝试迭代常量列表，则 <code>**$_**</code> 绑定到字面值，您无法递增：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">9</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">++</span> <span class="p">}</span>  <span class="c1"># error: requires mutable arguments</span>
</span></span></code></pre></div><h2 id="赋值">赋值</h2>
<p>如果你在 Perl 5 和 Raku 中比较“创建一个词法变量并赋值给它”，它在外面看起来是一样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$bar</span> <span class="o">=</span> <span class="mi">56</span><span class="p">;</span>  <span class="c1"># both Perl 5 and Raku</span>
</span></span></code></pre></div><p>在 Raku 中，这也会在 lexpad 中创建一个名为 “<strong>$bar</strong>” 的键。但是不是直接将值绑定到该 lexpad 条目，而是为您创建一个容器（<strong>Scalar</strong>对象），并将其绑定到“<strong>$bar</strong>”的 lexpad 条目。然后，56 被存储为该容器中的值。在伪代码中，您可以将其视为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$bar</span> <span class="o">:=</span> <span class="kt">Scalar</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">value</span> <span class="o">=&gt;</span> <span class="mi">56</span> <span class="p">);</span>
</span></span></code></pre></div><p>请注意，<strong>Scalar</strong> 对象已绑定，未分配。 Perl 5 中最接近它的是绑定标量。但当然“= <strong>56</strong>”的类型要少得多！</p>
<p>诸如 <strong>Array</strong> 和 <strong>Hash</strong> 之类的数据结构也会自动将值放在绑定到结构的容器中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="p">;</span>       <span class="c1"># empty Array</span>
</span></span><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1"># bind a Scalar container to 6th element and put 42 in it</span>
</span></span></code></pre></div><h2 id="容器">容器</h2>
<p>对于 Raku 中的大多数操作，<strong>Scalar</strong> 容器对象是不可见的，因此大多数情况下您不必考虑它。例如，每当您使用变量作为参数调用子例程（或方法）时，它将绑定到容器中的值。而且因为您无法分配值，您会得到：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">frobnicate</span><span class="p">(</span><span class="nv">$this</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$this</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">frobnicate</span><span class="p">(</span><span class="nv">$foo</span><span class="p">);</span> <span class="c1"># Cannot assign to a readonly variable or a value</span>
</span></span></code></pre></div><p>如果要允许分配外部值，可以将 <strong>is rw</strong> trait 添加到签名中的变量。这会将签名中的变量绑定到指定变量的容器，从而允许赋值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">oknicate</span><span class="p">(</span><span class="nv">$this</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$this</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">oknicate</span><span class="p">(</span><span class="nv">$foo</span><span class="p">);</span> <span class="c1"># no problem</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>       <span class="c1"># 42</span>
</span></span></code></pre></div><h2 id="proxy">Proxy</h2>
<p>从概念上讲，Raku 中的 <strong>Scalar</strong> 对象有一个 <strong>FETCH</strong> 方法（用于生成对象中的值）和一个 <strong>STORE</strong> 方法（用于更改对象中的值），就像 Perl 5 中的绑定标量一样。</p>
<p>假设您稍后将值 <strong>768</strong> 分配给 <strong>$bar</strong> 变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$bar</span> <span class="o">=</span> <span class="mi">768</span><span class="p">;</span>
</span></span></code></pre></div><p>发生的事情在概念上相当于：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$bar</span><span class="o">.</span><span class="nb">STORE</span><span class="p">(</span><span class="mi">768</span><span class="p">);</span>
</span></span></code></pre></div><p>假设您要在 <strong>$bar</strong> 中的值中添加 <strong>20</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$bar</span> <span class="o">=</span> <span class="nv">$bar</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>
</span></span></code></pre></div><p>概念上发生的是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$bar</span><span class="o">.</span><span class="nb">STORE</span><span class="p">(</span> <span class="nv">$bar</span><span class="o">.</span><span class="nf">FETCH</span> <span class="o">+</span> <span class="mi">20</span> <span class="p">);</span>
</span></span></code></pre></div><p>如果要在容器上指定自己的 <strong>FETCH</strong> 和 <strong>STORE</strong> 方法，可以通过绑定到 <a href="https://docs.raku.org/type/Proxy">Proxy</a> 对象来实现。例如，要创建一个始终报告分配给它的值的两倍的变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$double</span> <span class="o">:=</span> <span class="nb">do</span> <span class="p">{</span>  <span class="c1"># $double now a Proxy, rather than a Scalar container</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">()</span>     <span class="p">{</span> <span class="nv">$value</span> <span class="o">+</span> <span class="nv">$value</span> <span class="p">}</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">      <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">(</span><span class="nv">$new</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nv">$new</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>请注意，您需要一个额外的变量来保存存储在这样一个容器中的值。</p>
<h2 id="约束和默认值">约束和默认值</h2>
<p>除了值之外，<a href="https://docs.raku.org/type/Scalar">Scalar</a> 还包含额外信息，例如类型约束和默认值。采用这个定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="kt">Int</span> <span class="nv">$baz</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>
</span></span></code></pre></div><p>它创建一个名为 “<strong>$baz</strong>” 的标量绑定到 lexpad，将该容器中的值约束为使用 <strong>Int</strong> 成功智能匹配的类型，将容器的默认值设置为 <strong>42</strong>，并将值 <strong>666</strong> 放入容器中。</p>
<p>由于类型约束，为该变量分配字符串将失败：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$baz</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Type check failed in assignment to $baz; expected Int but got Str (&#34;foo&#34;)</span>
</span></span></code></pre></div><p>如果在定义变量时未给出类型约束，则将假定为 <strong>Any</strong> 类型。如果未指定默认值，则将假定类型约束。</p>
<p>将 <strong>Nil</strong>（相当于 Perl 5 的 <strong>undef</strong> 的 Raku）分配给该变量会将其重置为默认值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$baz</span><span class="p">;</span>   <span class="c1"># 666</span>
</span></span><span class="line"><span class="cl"><span class="nv">$baz</span> <span class="o">=</span> <span class="kt">Nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$baz</span><span class="p">;</span>   <span class="c1"># 42</span>
</span></span></code></pre></div><h2 id="总结">总结</h2>
<p>Perl 5 具有值和值的引用。 Raku 没有引用，但它有值和容器。 Raku 中有两种类型的容器：<a href="https://docs.raku.org/type/Proxy">Proxy</a>（很像 Perl 5 中的绑定标量）和 <a href="https://docs.raku.org/type/Scalar">Scalar</a>。简单地说，变量以及 <a href="https://docs.raku.org/type/List">List</a>，<a href="https://docs.raku.org/type/Array">Array</a> 或 <a href="https://docs.raku.org/type/Hash">Hash</a> 的元素是值（如果它已绑定）或容器（如果已分配）。无论何时调用子例程（或方法），给定的参数都被解除容器化并绑定到子例程的参数（除非另有说明）。容器还保留类型约束和默认值等信息。将Nil分配给变量会将其返回到其默认值，如果未指定类型约束，则为Any。</p>
<h2 id="原文连接">原文连接</h2>
<p><a href="https://opensource.com/article/18/8/containers-perl-6">https://opensource.com/article/18/8/containers-perl-6</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[使用 Raku 连接 Kafka]]></title>
            <link href="http://localhost:1313/raku/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2018-07-14-cro-http-test/?utm_source=atom_feed" rel="related" type="text/html" title="Cro Http Test" />
                <link href="http://localhost:1313/raku/2018-05-10-deconstructing-simple-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Deconstructing Simple Grammars" />
                <link href="http://localhost:1313/raku/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的列表解析" />
                <link href="http://localhost:1313/raku/2018-04-12-setting-timeouts-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中设置超时" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
            
                <id>http://localhost:1313/raku/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-07-20T20:14:28+08:00</published>
            <updated>2018-07-20T20:14:28+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>有这样一个场景, 数据发送方将压缩文件读成字节数组后发往 Kafka, 然后第三方的 Kafka Client 从中读取字节数组解压缩, 每条 message 对应一个压缩文件, 每个压缩文件中包含 <code>_log.txt</code> 和 <code>_result.txt</code>。</p>
<p>Raku 可以从 Kafka 中读取消息并完成解析。</p>
<p>首先安装相关模块: <a href="https://github.com/mempko/PKafka">Pkafka</a> 用于和 Kafka 交互； <a href="https://github.com/frithnanth/raku-Archive-Libarchive">Archive::Libarchive</a> 用于解压缩字节数组。 <a href="https://cro.services">Cro</a> 用于 HTTP 请求，<a href="https://github.com/raku/DBIish">DBiish</a> 用于数据库读写。</p>
<pre tabindex="0"><code>zef install Pkafka
zef install Archive::Libarchive
zef install Cro
zef install DBIish
</code></pre><p>代码片段如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">PKafka::Consumer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">PKafka::Message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">PKafka::Producer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Archive::Libarchive</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Archive::Libarchive::Constants</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Cro::HTTP::Client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">JSON::Fast</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">JSON::Path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">DBIish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$brokers</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">127.0.0.1</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$test</span> <span class="o">=</span> <span class="n">PKafka::Consumer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">topic</span><span class="o">=&gt;</span><span class="p">&#34;</span><span class="s2">dc-diagnostic-report</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">brokers</span><span class="o">=&gt;</span><span class="nv">$brokers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">$test</span><span class="o">.</span><span class="nf">messages</span><span class="o">.</span><span class="nb">tap</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$msg</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">given</span> <span class="nv">$msg</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="n">PKafka::Message</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">got offset: </span><span class="p">{</span><span class="nv">$msg</span><span class="o">.</span><span class="nb">offset</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">                <span class="k">my</span> <span class="nv">$log</span> <span class="o">=</span> <span class="nf">get-log</span><span class="p">(</span><span class="nv">$msg</span><span class="o">.</span><span class="nb">payload</span><span class="p">);</span>                  <span class="c1"># 获取 log</span>
</span></span><span class="line"><span class="cl">                <span class="k">my</span> <span class="p">(</span><span class="nv">$taskid</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get-result</span><span class="p">(</span><span class="nv">$msg</span><span class="o">.</span><span class="nb">payload</span><span class="p">);</span> <span class="c1"># 获取 taskid 和 result</span>
</span></span><span class="line"><span class="cl">                <span class="k">my</span> <span class="nv">$json</span> <span class="o">=</span> <span class="nf">request_ads</span><span class="p">(</span><span class="nv">$taskid</span><span class="o">,</span><span class="nv">$log</span><span class="o">,</span> <span class="nv">$result</span><span class="p">);</span>    <span class="c1"># 获取 json</span>
</span></span><span class="line"><span class="cl">                <span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span>  <span class="nf">parse-json</span><span class="p">(</span><span class="nv">$json</span><span class="p">);</span>                  <span class="c1"># 解析 json, 提取出 sql value</span>
</span></span><span class="line"><span class="cl">                <span class="nf">write2db</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>                                <span class="c1"># 写数据库</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="n">PKafka::EOF</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Messages Consumed </span><span class="p">{</span> <span class="nv">$msg</span><span class="o">.</span><span class="nf">total-consumed</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">when</span> <span class="n">PKafka::Error</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Error </span><span class="p">{</span><span class="nv">$msg</span><span class="o">.</span><span class="nb">what</span><span class="p">}&#34;;</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$test</span><span class="o">.</span><span class="nf">stop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$t1</span> <span class="o">=</span> <span class="nv">$test</span><span class="o">.</span><span class="nf">consume-from-beginning</span><span class="p">(</span><span class="s">partition</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">await</span> <span class="nv">$t1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">获取 log
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">get-log</span><span class="p">(</span><span class="nv">$payload</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">Archive::Libarchive</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="s">operation</span> <span class="o">=&gt;</span> <span class="n">LibarchiveRead</span><span class="o">,</span> <span class="s">file</span> <span class="o">=&gt;</span> <span class="nv">$payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$log-content</span> <span class="o">=</span> <span class="nv">$a</span><span class="o">.</span><span class="nf">read-file-content</span><span class="p">(</span><span class="k">sub</span> <span class="p">(</span><span class="n">Archive::Libarchive::Entry</span> <span class="nv">$e</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$e</span><span class="o">.</span><span class="nf">pathname</span><span class="o">.</span><span class="nb">ends-with</span><span class="p">(&#39;</span><span class="s1">_log.txt</span><span class="p">&#39;)</span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$log</span> <span class="o">=</span> <span class="nv">$log-content</span><span class="o">.</span><span class="nb">decode</span><span class="p">(&#39;</span><span class="s1">UTF8-C8</span><span class="p">&#39;);</span> <span class="c1"># encoding: https://stackoverflow.com/questions/50674498/raku-malformed-utf-8-causes-program-crash</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$a</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$log</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">获取 taskid 和 result
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">get-result</span><span class="p">(</span><span class="nv">$payload</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">Archive::Libarchive</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="s">operation</span> <span class="o">=&gt;</span> <span class="n">LibarchiveRead</span><span class="o">,</span> <span class="s">file</span> <span class="o">=&gt;</span> <span class="nv">$payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$res-content</span> <span class="o">=</span> <span class="nv">$a</span><span class="o">.</span><span class="nf">read-file-content</span><span class="p">(</span><span class="k">sub</span> <span class="p">(</span><span class="n">Archive::Libarchive::Entry</span> <span class="nv">$e</span> <span class="k">--&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$e</span><span class="o">.</span><span class="nf">pathname</span><span class="o">.</span><span class="nb">ends-with</span><span class="p">(&#39;</span><span class="s1">_result.txt</span><span class="p">&#39;)</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$log-result</span> <span class="o">=</span> <span class="nv">$res-content</span><span class="o">.</span><span class="nb">decode</span><span class="p">(&#39;</span><span class="s1">UTF8-C8</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$taskid</span> <span class="o">=</span> <span class="nv">$log-result</span><span class="o">.</span><span class="nb">lines</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">split</span><span class="p">(&#34;</span><span class="s2">:</span><span class="p">&#34;)</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 获取 taskid</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nv">$log-result</span><span class="o">.</span><span class="nb">lines</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="nb">split</span><span class="p">(&#34;</span><span class="s2">:</span><span class="p">&#34;)</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 获取 result 的内容</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$a</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="nv">$taskid</span><span class="o">,</span> <span class="nv">$result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">请求 ADS
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">request_ads</span><span class="p">(</span><span class="nv">$taskid</span><span class="o">,</span> <span class="nv">$log</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$client</span> <span class="o">=</span> <span class="n">Cro::HTTP::Client</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="s">content-type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">application/json</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">%rds</span> <span class="o">=</span> <span class="s">taskId</span> <span class="o">=&gt;</span> <span class="nv">$taskid</span><span class="o">,</span> <span class="o">:</span><span class="nv">$log</span><span class="o">,</span> <span class="o">:</span><span class="nv">$result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$resp</span> <span class="o">=</span> <span class="nb">await</span> <span class="nv">$client</span><span class="o">.</span><span class="nf">post</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">http://10.0.201.46/bls_ads/diagResultReq</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">body</span> <span class="o">=&gt;</span> <span class="nv">%rds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$json</span> <span class="o">=</span> <span class="n">to-json</span> <span class="nb">await</span> <span class="nv">$resp</span><span class="o">.</span><span class="nf">body-text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$json</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">解析 JSON
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">parse-json</span><span class="p">(</span><span class="nv">$json</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$oj</span>     <span class="o">=</span> <span class="nf">from-json</span><span class="p">(</span><span class="nv">$json</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$path</span>   <span class="o">=</span> <span class="n">JSON::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">$.data.dtcs.ecu[0]</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$ecuid</span>  <span class="o">=</span> <span class="nv">$path</span><span class="o">.</span><span class="nb">values</span><span class="p">(</span><span class="nv">$oj</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="p">{&#39;</span><span class="s1">ecuid</span><span class="p">&#39;};</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dtcnum</span> <span class="o">=</span> <span class="nv">$path</span><span class="o">.</span><span class="nb">values</span><span class="p">(</span><span class="nv">$oj</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="p">{&#39;</span><span class="s1">dtcnum</span><span class="p">&#39;};</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dtc</span>    <span class="o">=</span> <span class="nv">$path</span><span class="o">.</span><span class="nb">values</span><span class="p">(</span><span class="nv">$oj</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="p">{&#39;</span><span class="s1">dtc</span><span class="p">&#39;};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$taskid</span>  <span class="o">=</span> <span class="n">JSON::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">$.taskId</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">values</span><span class="p">(</span><span class="nv">$oj</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$vtype</span>   <span class="o">=</span> <span class="n">JSON::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">$.vtype</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">values</span><span class="p">(</span><span class="nv">$oj</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$ecunum</span>  <span class="o">=</span> <span class="n">JSON::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">$.ecunum</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">values</span><span class="p">(</span><span class="nv">$oj</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$funid</span>   <span class="o">=</span> <span class="n">JSON::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">$.funid</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">values</span><span class="p">(</span><span class="nv">$oj</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="nv">$taskid</span><span class="o">,</span> <span class="nv">$vtype</span><span class="o">,</span> <span class="nv">$funid</span><span class="o">,</span> <span class="nv">$ecuid</span><span class="o">,</span> <span class="nv">$dtcnum</span><span class="o">,</span> <span class="nv">$dtc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">写数据库
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">sub</span> <span class="nf">write2db</span><span class="p">(</span><span class="nv">@values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dbh</span> <span class="o">=</span> <span class="n">DBIish</span><span class="o">.</span><span class="nb">connect</span><span class="p">(&#34;</span><span class="s2">mysql</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">database</span><span class="p">&lt;</span><span class="s">wmdtc</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">host</span><span class="p">&lt;</span><span class="s">127.0.0.1</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">user</span><span class="p">&lt;</span><span class="s">root</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">password</span><span class="p">&lt;</span><span class="s">000608</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">port</span><span class="p">&lt;</span><span class="s">6606</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">RaiseError</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="p">(</span><span class="nv">$taskid</span><span class="o">,</span> <span class="nv">$vtype</span><span class="o">,</span> <span class="nv">$funid</span><span class="o">,</span> <span class="nv">$ecuid</span><span class="o">,</span> <span class="nv">$dtcnum</span><span class="o">,</span> <span class="nv">$dtc</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$sth</span> <span class="o">=</span> <span class="nv">$dbh</span><span class="o">.</span><span class="nf">prepare</span><span class="p">(</span><span class="k">q</span><span class="sa">:to</span><span class="p">/STATEMENT/)</span><span class="s">;
</span></span></span><span class="line"><span class="cl"><span class="s">        insert into wm_ads_result (taskid, vtype, funid, ecuid, dtcnum, dtc)
</span></span></span><span class="line"><span class="cl"><span class="s">        values (?,?,?,?,?,?) 
</span></span></span><span class="line"><span class="cl"><span class="s">        ON DUPLICATE KEY 
</span></span></span><span class="line"><span class="cl"><span class="s">        UPDATE vtype=?, funid=?, ecuid=?, dtcnum=?, dtc=?
</span></span></span><span class="line"><span class="cl"><span class="s">    </span><span class="p">STATEMENT</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">$sth</span><span class="o">.</span><span class="nf">execute</span><span class="p">(</span><span class="nv">$taskid</span><span class="o">,</span> <span class="nv">$vtype</span><span class="o">,</span> <span class="nv">$funid</span><span class="o">,</span> <span class="nv">$ecuid</span><span class="o">,</span> <span class="nv">$dtcnum</span><span class="o">,</span> <span class="nv">$dtc</span><span class="o">,</span><span class="nv">$vtype</span><span class="o">,</span> <span class="nv">$funid</span><span class="o">,</span> <span class="nv">$ecuid</span><span class="o">,</span> <span class="nv">$dtcnum</span><span class="o">,</span> <span class="nv">$dtc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">$sth</span><span class="o">.</span><span class="nb">finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$dbh</span><span class="o">.</span><span class="nf">dispose</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中遇到的困难是如何在不将字节数组保存到本地磁盘的情况下，在内存中完成压缩包中各文件内容的读取。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Cro Http Test]]></title>
            <link href="http://localhost:1313/raku/2018-07-14-cro-http-test/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2018-05-10-deconstructing-simple-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Deconstructing Simple Grammars" />
                <link href="http://localhost:1313/raku/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的列表解析" />
                <link href="http://localhost:1313/raku/2018-04-12-setting-timeouts-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中设置超时" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
                <link href="http://localhost:1313/raku/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的数据类型 Bag" />
            
                <id>http://localhost:1313/raku/2018-07-14-cro-http-test/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-07-14T17:14:59+08:00</published>
            <updated>2018-07-14T17:14:59+08:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="crohttptest">Cro::HTTP::Test</h2>
<p>原则上可以通过使用 <a href="https://cro.services/docs/reference/cro-http-server">Cro::HTTP::Server</a>托管应用程序, 使用 <a href="https://cro.services/docs/reference/cro-http-client">Cro::HTTP::Client</a>向其发出请求, 并使用标准 <code>Test</code> 库检查结果来编写 Cro HTTP 服务的测试。该库使编写此类测试更容易, 并通过以下方式更快地执行它们：</p>
<ul>
<li>为发出测试请求和检查结果提供更方便的 API</li>
<li>跳过网络并将 <code>Cro::TCP</code> 对象从客户端管道传递到服务器管道, 反之亦然</li>
</ul>
<h2 id="基本示例">基本示例</h2>
<p>给定模块 <code>MyService::Routes</code>, 如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">routes</span><span class="p">()</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">route</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">get</span> <span class="k">-&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">content</span> <span class="p">&#39;</span><span class="s1">text/plain</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Nothing to see here</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">post</span> <span class="k">-&gt;</span> <span class="p">&#39;</span><span class="s1">add</span><span class="p">&#39;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">request-body</span> <span class="p">&#39;</span><span class="s1">application-json</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">:</span><span class="nv">$x</span><span class="o">!,</span> <span class="o">:</span><span class="nv">$y</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nb">content</span> <span class="p">&#39;</span><span class="s1">application/json</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">{</span> <span class="p">:</span><span class="s">result</span><span class="p">(</span><span class="nv">$x</span> <span class="o">+</span> <span class="nv">$y</span><span class="p">)</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们可以像这样编写测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Cro::HTTP::Test</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">MyService::Routes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">test-service</span> <span class="nf">routes</span><span class="p">()</span><span class="o">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span> <span class="nb">get</span><span class="p">(&#39;</span><span class="s1">/</span><span class="p">&#39;)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">status</span> <span class="o">=&gt;</span> <span class="mi">200</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">content-type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">text/plain</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">body</span> <span class="o">=&gt;</span> <span class="p">/</span><span class="sr">nothing</span><span class="p">/;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">test-given</span> <span class="p">&#39;</span><span class="s1">/add</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">test</span> <span class="nf">post</span><span class="p">(</span><span class="s">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">:</span><span class="s">x</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">y</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">status</span> <span class="o">=&gt;</span> <span class="mi">200</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">:</span><span class="s">result</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">test</span> <span class="nf">post</span><span class="p">(</span><span class="s">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">:</span><span class="s">x</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">status</span> <span class="o">=&gt;</span> <span class="mi">400</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">test</span> <span class="nb">get</span><span class="p">(</span><span class="s">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">:</span><span class="s">x</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">status</span> <span class="o">=&gt;</span> <span class="mi">405</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">done-testing</span><span class="p">;</span>
</span></span></code></pre></div><h2 id="设置要测试的服务">设置要测试的服务</h2>
<p><code>test-service</code> 函数有两个候选者。</p>
<p><code>test-service</code>(<code>Cro::Transform, &amp;tests, :$fake-auth, :$http)</code> 候选者针对提供的 HTTP 应用程序运行测试, 该应用程序可以是任何使用 <a href="https://cro.services/docs/reference/cro-http-request">Cro::HTTP::Request</a> 的 <code>Cro::Transform</code> 并生成 <a href="https://cro.services/docs/reference/cro-http-response">Cro::HTTP::Response</a>。使用 <a href="https://cro.services/docs/reference/cro-http-router">Cro::HTTP::Router</a> 编写的应用程序执行此操作。也可以使用 <code>Cro.compose</code> 将（可能模拟的）中间件放在适当的位置。可选的 <code>:$fake-auth</code> 参数, 如果传递, 将添加一个中间件, 将请求的 <code>auth</code> 设置为指定的对象。这对于模拟用户或会话以及测试授权非常有用。 http 参数指定运行测试的 HTTP 版本。由于我们在测试中控制客户端和服务器端, 因此不允许设置 <code>:http&lt;1.1 2&gt;</code>。默认值为 <code>:http&lt;2&gt;</code>。</p>
<p><code>test-service($uri, &amp;tests)</code> 候选者针对指定的基 URI 运行测试, 通过 <a href="https://cro.services/docs/reference/cro-http-client">Cro::HTTP::Client</a> 连接到它。这使得可以使用 <a href="https://cro.services/docs/reference/cro-http-test">Cro::HTTP::Test</a> 为使用除 Cro 之外的其他东西构建的服务编写测试。</p>
<p>所有其他命名参数都作为 <a href="https://cro.services/docs/reference/cro-http-client">Cro::HTTP::Client</a> 构造函数参数传递。</p>
<h2 id="写测试">写测试</h2>
<p><code>test</code> 函数用于传递给 <code>test-service</code> 的块内部。它期望传递一个表示测试请求的位置参数，并命名参数，指示响应的预期属性。</p>
<p>通过调用 <code>get</code>，<code>put</code>，<code>post</code>，<code>delete</code>，<code>head</code> 或 <code>patch</code> 之一来指定请求。还有其他 HTTP 的 <code>request($method, ...)</code>（事实上，<code>get</code> 只会调用 <code>request('GET', ...)</code>）。这些函数接受提供相对 URI 的可选位置参数，如果提供该 URI 将附加到当前有效基 URI。 <code>:$json</code> 命名参数被特殊处理，扩展为 <code>{content-type =&gt;'application/json', body =&gt; $json}</code>。所有其他命名参数将传递给 Cro::HTTP::Client 的 request 方法，从而使所有 HTTP 客户端的功能都可用。</p>
<p><code>test</code> 函数的命名参数构成检查。它们主要遵循 <a href="https://cro.services/docs/reference/cro-http-response">Cro::HTTP::Response</a> 对象上的方法名称。可用的检查如下。</p>
<h3 id="status">status</h3>
<p>Smartmatches 响应检查的响应的 <code>status</code> 属性。虽然整数（例如 <code>status =&gt; 200</code>）将是最常见的，但也可能是诸如 <code>status =&gt; * &lt;400</code> 之类的事情（例如，不是错误）。</p>
<h3 id="content-type">content-type</h3>
<p>检查内容类型是否相同。如果传递了一个字符串，它会将其解析为媒体类型，并检查类型和子类型是否与响应的类型匹配。如果字符串中有任何额外参数（例如字符集），则还将在接收的媒体类型中检查这些参数。如果接收的媒体类型具有未提及的额外参数，则将忽略这些参数。因此，检查content-type =&gt;&lsquo;text / plain&rsquo;匹配text / plain;响应中的charset = utf8。</p>
<p>对于更细粒度的控制，传递一个块，它将传递一个Cro :: MediaType的实例，并期望返回一些测试通过的truthy。</p>
<h3 id="header-或-headers">header 或 headers</h3>
<p>将哈希映射头名称转换为头值，或者执行相同的Pair列表。如果标题存在且标题的值与值相匹配，则测试通过。仅在关注标题存在时使用*，但不希望检查其值。响应中的所有其他标头都将被忽略（即，额外的标头被认为是正常的）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="s">headers</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s">Strict-Transport-Security</span> <span class="o">=&gt;</span> <span class="o">*,</span>
</span></span><span class="line"><span class="cl">        <span class="s">Cache-Control</span> <span class="o">=&gt;</span> <span class="p">/</span><span class="sr">public</span><span class="p">/</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>为了进一步控制，传递一个块，它将接收一个Pair列表，每个块代表一个头。它的返回值应该是测试通过的真相。</p>
<h3 id="body-text">body-text</h3>
<p>获得响应的正文 - 并将其与提供的值进行智能匹配。字符串，正则表达式或代码对象都可能有用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="s">body-text</span> <span class="o">=&gt;</span> <span class="p">/:</span><span class="na">i</span><span class="sr"> success</span><span class="p">/</span>
</span></span></code></pre></div><p>如果测试的内容类型且测试失败，则将跳过正文测试。</p>
<h3 id="body-blob">body-blob</h3>
<p>获得响应的body-blob并将其与提供的值进行智能匹配</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="s">body-blob</span> <span class="o">=&gt;</span> <span class="o">*.</span><span class="nb">bytes</span> <span class="o">&gt;</span> <span class="mi">128</span>
</span></span></code></pre></div><p>如果测试的内容类型且测试失败，则将跳过正文测试。</p>
<h3 id="body">body</h3>
<p>获得响应的主体并将其与提供的值进行智能匹配。请注意，body属性根据响应的内容类型决定要生成的内容，从而选择适当的主体解析器。因此，建议将其与内容类型一起使用（将始终在正文之前进行测试，如果失败则跳过正文测试）。</p>
<h3 id="json">json</h3>
<p>对于JSON响应的常见情况，这是一个方便的捷径。它实现了content-type =&gt; {。type eq&rsquo;application&rsquo;&amp;&amp; .subtype-name eq&rsquo;json&rsquo;|| .suffix eq&rsquo;json&rsquo;}（也就是说，它接受application / json或类似application / vnd.foobar + json的东西）。</p>
<p>如果传递了代码值，那么将使用反序列化的JSON主体调用代码，并且应该返回一个truthy值以供测试通过。否则，将使用is-deep测试例程来检查收到的JSON的结构是否符合预期。</p>
<h3 id="many-tests-with-one-uri-set-of-headers-etc">Many tests with one URI, set of headers, etc.</h3>
<p>重复测试的相同细节可能会很繁琐。例如，通常希望针对相同的URI编写许多测试，每次都将其传递给不同的主体或使用不同的请求方法。测试给定的功能有多种形式。它可以与URI和块一起使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">test-given</span> <span class="p">&#39;</span><span class="s1">/add</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span> <span class="nf">post</span><span class="p">(</span><span class="s">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">:</span><span class="s">x</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">y</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">status</span> <span class="o">=&gt;</span> <span class="mi">200</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">:</span><span class="s">result</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">test</span> <span class="nf">post</span><span class="p">(</span><span class="s">json</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">:</span><span class="s">x</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span> <span class="p">})</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">status</span> <span class="o">=&gt;</span> <span class="mi">400</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这种情况下，测试将全部针对附加到当前有效URI的URI执行，该URI在测试服务块中是被测试服务的基URI。如果各个测试用例也具有URI，则也会附加它。可以嵌套测试给定的块，并且每个块都附加其URI段，从而建立新的当前有效URI。</p>
<p>也可以将命名参数传递给test-given，这些参数将用作请求参数，传递给Cro :: HTTP :: Client。请注意，为get或request指定的任何命名参数都将覆盖在给定测试中指定的参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">test-given</span> <span class="p">&#39;</span><span class="s1">/add</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">header</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ow">X</span><span class="o">-</span><span class="err">Precision</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">15</span><span class="p">&#39;</span> <span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第二种形式不需要相对URI，而只需要选项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">test-given</span> <span class="s">header</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ow">X</span><span class="o">-</span><span class="err">Precision</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">15</span><span class="p">&#39;</span> <span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Deconstructing Simple Grammars]]></title>
            <link href="http://localhost:1313/raku/2018-05-10-deconstructing-simple-grammars/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的列表解析" />
                <link href="http://localhost:1313/raku/2018-04-12-setting-timeouts-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中设置超时" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
                <link href="http://localhost:1313/raku/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的数据类型 Bag" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E6%96%B9-python-%E5%BA%93/?utm_source=atom_feed" rel="related" type="text/html" title="Python 第三方库" />
            
                <id>http://localhost:1313/raku/2018-05-10-deconstructing-simple-grammars/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-05-10T11:27:22+08:00</published>
            <updated>2018-05-10T11:27:22+08:00</updated>
            
            
            <content type="html"><![CDATA[<p>去年我写了一个<a href="https://gfldex.wordpress.com/2017/12/31/expensive-egg-timers/">鸡蛋定时器</a>，它的解析命令行参数类似于 GNU sleep。我对这个解析器的严格形式很满意，如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">Seconds</span> <span class="nv">$to-wait</span> <span class="o">=</span> <span class="nv">@timicles</span><span class="o">»</span>\
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">split</span><span class="p">(/&lt;</span><span class="nf">number</span><span class="p">&gt;/</span><span class="o">,</span> <span class="p">:</span><span class="s">v</span><span class="p">)</span>\
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="k">-&gt;</span> <span class="o">[</span><span class="nv">$</span><span class="o">,</span><span class="kt">Rat</span><span class="p">(</span><span class="kt">Any</span><span class="p">)</span> <span class="nv">$count</span><span class="o">,</span> <span class="kt">Str</span><span class="p">(</span><span class="kt">Any</span><span class="p">)</span> <span class="nv">$unit</span><span class="o">]</span> <span class="k">--&gt;</span> <span class="n">Seconds</span> <span class="p">{</span> <span class="nv">%unit-multipliers</span><span class="p">{</span><span class="nv">$unit</span><span class="p">}</span> <span class="o">*</span> <span class="nv">$count</span> <span class="p">})</span>\
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">sum</span><span class="p">;</span>
</span></span></code></pre></div><p>它只做了几件简单的事情，而且是一件接着一件做。带有动作类的 grammar 就显得矫枉过正了。我不满意用 <code>split</code> 的能力来返回带有零件的针。它肯定不会提高可读性。</p>
<p>经过相当多的迭代（并踩到了一个 <a href="https://github.com/rakudo/rakudo/issues/1800">bug</a>），我想出了一个使用 <code>Str.match</code> 代替的方法。如果我把每个 <code>Match</code> 对象转换成 <code>Hash</code>，我就可以在一个尖号块的签名中使用<a href="https://docs.raku.org/type/Signature#Destructuring_Parameters">解构</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="n">Seconds</span> <span class="nv">$to-wait</span> <span class="o">=</span> <span class="nv">@timicles</span><span class="o">»</span>\
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">match</span><span class="p">(/&lt;</span><span class="nf">number</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">suffix</span><span class="p">&gt;</span><span class="o">+</span><span class="p">/)</span><span class="o">».</span><span class="nb">hash</span>\ <span class="c1"># the +-quatifier is a workaround</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">%</span> <span class="p">(</span> <span class="kt">Rat</span><span class="p">(</span><span class="kt">Any</span><span class="p">)</span> <span class="o">:</span><span class="nv">$number</span><span class="o">,</span> <span class="kt">Str</span><span class="p">(</span><span class="kt">Any</span><span class="p">)</span> <span class="o">:</span><span class="nv">$suffix</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">%unit-multipliers</span><span class="p">{</span><span class="nv">$suffix</span><span class="p">}</span> <span class="o">*</span> <span class="nv">$number</span> <span class="p">})</span>\
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">sum</span><span class="p">;</span>
</span></span></code></pre></div><p>我可以不使用位置参数，而是使用命名的参数，这些参数对应于匹配参数中命名正则表达式。</p>
<p>即使是在这样一小段代码中，事情也会变得有条不紊。超方法调用摆脱了简单的循环。精心设计的内置类型允许在没有临时变量负载的情况下进行签名解构。这几乎就像某些语言设计者的目标是制造一种最优雅的语言一样。</p>
<p>by <a href="https://gfldex.wordpress.com/2018/05/10/deconstructing-simple-grammars/">gfldex</a>.</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的列表解析]]></title>
            <link href="http://localhost:1313/raku/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2018-04-12-setting-timeouts-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中设置超时" />
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
                <link href="http://localhost:1313/raku/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的数据类型 Bag" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E6%96%B9-python-%E5%BA%93/?utm_source=atom_feed" rel="related" type="text/html" title="Python 第三方库" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E9%A5%AD%E5%90%A6%E4%B8%8A%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="一步一步学习小爬虫" />
            
                <id>http://localhost:1313/raku/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-04-13T00:00:00+00:00</published>
            <updated>2018-04-13T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="raku-中的列表解析">Raku 中的列表解析</h1>
<p>看一看 Python 中关于列表推导的页面。</p>
<pre tabindex="0"><code>S = {x² : x in {0 ... 9}}
V = (1, 2, 4, 8, ..., 2¹²)
M = {x | x in S and x even}
</code></pre><p>Python 列表解析:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="n">M</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</span></span></code></pre></div><p>在原始定义中我没有看到 10 或 13 , Raku 与原始语言最接近的语法是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\S</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$_</span>² <span class="k">for</span> <span class="mi">0</span> <span class="o">...</span> <span class="mi">9</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\V</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span> <span class="o">...</span> <span class="mi">2</span>¹²<span class="p">);</span> <span class="c1"># almost identical</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\M</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$_</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="k">for</span> <span class="k">S</span><span class="p">)</span><span class="sr">;
</span></span></span></code></pre></div><p>Raku 与 Python 最接近的语法是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\S</span> <span class="o">=</span> <span class="o">[</span><span class="k">-&gt;</span> \<span class="nb">x</span> <span class="p">{</span> <span class="nb">x</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span> <span class="k">for</span> <span class="o">^</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\V</span> <span class="o">=</span> <span class="o">[</span><span class="k">-&gt;</span> \<span class="no">i</span> <span class="p">{</span> <span class="mi">2</span><span class="o">**</span><span class="no">i</span> <span class="p">}</span> <span class="k">for</span> <span class="o">^</span><span class="mi">13</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\M</span> <span class="o">=</span> <span class="o">[</span><span class="k">-&gt;</span> \<span class="nb">x</span> <span class="p">{</span> <span class="nb">x</span> <span class="k">if</span> <span class="nb">x</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span> <span class="k">for</span> <span class="k">S</span><span class="p">]</span><span class="sr">;
</span></span></span></code></pre></div><p>Raku 更惯用的语法是:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">)</span><span class="o">»</span>²<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\V</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">2</span>¹²<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\M</span> <span class="o">=</span> <span class="k">S</span><span class="p">.</span><span class="sr">grep</span><span class="o">:</span><span class="sr"> </span><span class="o">*</span><span class="sr"> </span><span class="nv">%%</span><span class="sr"> </span><span class="mi">2</span><span class="sr">;
</span></span></span></code></pre></div><p>具有无限序列的 Raku:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\S</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="o">*</span>²<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\V</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\M</span> <span class="o">=</span> <span class="k">S</span><span class="p">.</span><span class="sr">grep</span><span class="o">:</span><span class="sr"> </span><span class="o">*</span><span class="sr"> </span><span class="nv">%%</span><span class="sr"> </span><span class="mi">2</span><span class="sr">;
</span></span></span></code></pre></div><hr>
<ul>
<li>Python</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;The quick brown fox jumps over the lazy dog&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">words</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">stuff</span> <span class="o">=</span> <span class="p">[[</span><span class="n">w</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">w</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">]</span>
</span></span></code></pre></div><ul>
<li>Raku</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\string</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">The quick brown fox jumps over the lazy dog</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\words</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\stuff</span> <span class="o">=</span> <span class="o">[[.</span><span class="nb">uc</span><span class="o">,</span> <span class="o">.</span><span class="nb">lc</span><span class="o">,</span> <span class="o">.</span><span class="nb">chars</span><span class="o">]</span> <span class="k">for</span> <span class="nb">words</span><span class="o">]</span>
</span></span></code></pre></div><p>这里有一些使用 Set 运算符的其他翻译</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">primes</span> <span class="o">=</span> <span class="o">[</span><span class="nb">x</span> <span class="k">for</span> <span class="nb">x</span> <span class="nb">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">50</span><span class="p">)</span> <span class="k">if</span> <span class="nb">x</span> <span class="nb">not</span> <span class="nb">in</span> <span class="n">noprimes</span><span class="o">]</span> <span class="c1"># python</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\primes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">..^</span><span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*</span> <span class="o">∉</span> <span class="n">noprimes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\prime-set</span> <span class="o">=</span> <span class="mi">2</span><span class="o">..^</span><span class="mi">50</span> <span class="ow">(-)</span> <span class="n">noprimes</span><span class="p">;</span> <span class="c1"># a Set object</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">\primes</span> <span class="o">=</span> <span class="n">prime-set</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>
</span></span></code></pre></div><p>另外我相当确定 Python 没有在 Supply 上并发地使用它们的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># create a prime supply and act on it in the background</span>
</span></span><span class="line"><span class="cl"><span class="kt">Supply</span><span class="o">.</span><span class="nb">interval</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">is-prime</span><span class="p">)</span><span class="o">.</span><span class="nb">act</span><span class="o">:</span> <span class="nv">&amp;say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">main thread still running</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># says &#39;main thread still running&#39; immediately</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># deadlock main thread,</span>
</span></span><span class="line"><span class="cl"><span class="c1"># otherwise the program would terminate</span>
</span></span><span class="line"><span class="cl"><span class="nb">await</span> <span class="kt">Promise</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># waits 2 seconds from the .act call, says 2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># waits 1 second , says 3</span>
</span></span><span class="line"><span class="cl"><span class="c1"># waits 2 seconds, says 5</span>
</span></span><span class="line"><span class="cl"><span class="c1"># waits 2 seconds, says 7</span>
</span></span><span class="line"><span class="cl"><span class="c1"># waits 4 seconds, says 11</span>
</span></span><span class="line"><span class="cl"><span class="c1"># and so on until it is terminated</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[在 Raku 中设置超时]]></title>
            <link href="http://localhost:1313/raku/2018-04-12-setting-timeouts-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E5%83%8F%E6%88%91%E8%BF%99%E6%A0%B7%E7%9A%84-jar-%E5%8C%85/?utm_source=atom_feed" rel="related" type="text/html" title="添加第三方 pom 仓库" />
                <link href="http://localhost:1313/raku/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的数据类型 Bag" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E6%96%B9-python-%E5%BA%93/?utm_source=atom_feed" rel="related" type="text/html" title="Python 第三方库" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E9%A5%AD%E5%90%A6%E4%B8%8A%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="一步一步学习小爬虫" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="爬取百度贴吧尝试" />
            
                <id>http://localhost:1313/raku/2018-04-12-setting-timeouts-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-04-12T00:00:00+00:00</published>
            <updated>2018-04-12T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="在-raku-中设置超时httpsrakuonline2018030369-setting-timeouts-in-perl-6"><a href="https://raku.online/2018/03/03/69-setting-timeouts-in-perl-6/">在 Raku 中设置超时</a></h1>
<p>在 Perl 5 中，我曾经使用信号设置超时（至少，这是一种简单且可预测的方式）。在 Raku 中，您可以使用 promise。让我们看看如何做到这一点。</p>
<p>要模仿长时间运行的任务，请创建一个无限循环，然后打印其状态。开始吧:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="o">*</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">100_000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>只要循环得到控制，它将永远不会退出。我们的任务是在几秒钟内停止程序，因此计时器应在循环之前设置:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="nb">exit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="o">*</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">100_000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这里，<code>Promise.in</code> 方法创建一个 promise，在给定秒数后自动 kept。在 promise 的基础上，使用 <code>then</code>，我们添加了另一个 promise，其代码将在超时后运行。这里唯一的语句就是退出，停止主程序。</p>
<p>运行该程序以查看它的工作原理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nb">time</span> <span class="nb">raku</span> <span class="n">timeout</span><span class="o">.</span><span class="nf">pl</span>
</span></span><span class="line"><span class="cl"><span class="mi">100000</span>
</span></span><span class="line"><span class="cl"><span class="mi">200000</span>
</span></span><span class="line"><span class="cl"><span class="mi">300000</span>
</span></span><span class="line"><span class="cl"><span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="mi">3700000</span>
</span></span><span class="line"><span class="cl"><span class="mi">3800000</span>
</span></span><span class="line"><span class="cl"><span class="mi">3900000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">real</span> <span class="mi">0</span><span class="n">m2</span><span class="mf">.196</span><span class="n">s</span>
</span></span><span class="line"><span class="cl"><span class="n">user</span> <span class="mi">0</span><span class="n">m2</span><span class="mf">.120</span><span class="n">s</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span> <span class="mi">0</span><span class="n">m0</span><span class="mf">.068</span><span class="n">s</span>
</span></span></code></pre></div><p>该程序在我的计算机上计数达四百万，并在两秒内退出。这正是我们需要的行为。</p>
<p>为了比较，下面是实现同样功能的 Perl 5 程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">v5</span><span class="mf">.10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">alarm</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$SIG</span><span class="p">{</span><span class="n">ALRM</span><span class="p">}</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">exit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="nv">$c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">say</span> <span class="nv">$c</span> <span class="k">unless</span> <span class="nv">$c</span> <span class="nv">%</span> <span class="nv">1_000_000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>（它设法计数高达 4000 万，但这是另一回事了。）</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的数据类型 Bag]]></title>
            <link href="http://localhost:1313/raku/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E6%96%B9-python-%E5%BA%93/?utm_source=atom_feed" rel="related" type="text/html" title="Python 第三方库" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E9%A5%AD%E5%90%A6%E4%B8%8A%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="一步一步学习小爬虫" />
                <link href="http://localhost:1313/notes/%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E7%9A%84%E5%B8%96%E5%AD%90/?utm_source=atom_feed" rel="related" type="text/html" title="爬取百度贴吧尝试" />
                <link href="http://localhost:1313/notes/%E6%89%80%E4%BB%A5%E4%BD%BF%E7%94%A8-jupyter-notebook-%E6%89%93%E5%BC%80spark/?utm_source=atom_feed" rel="related" type="text/html" title="在 Python Jupyter NoteBook 中使用 Spark" />
                <link href="http://localhost:1313/notes/%E5%9C%A8-python-%E4%B8%AD%E4%BD%BF%E7%94%A8-xpath-/?utm_source=atom_feed" rel="related" type="text/html" title="在 Python 中使用 XPath" />
            
                <id>http://localhost:1313/raku/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2018-02-07T00:00:00+00:00</published>
            <updated>2018-02-07T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>数据类型 Bag 是一种 Perl 5 中没有的新的数据类型。</p>
<p>它可以被认为是一个容器，它一方面知道它里面有多少个单独的元素，另一方面可以说有多少种不同类型的商品。您可以用不同的方式描述此类型：Bag 是一个哈希，默认情况下，您添加的键的值为1。我们来看看例子。</p>
<p>把一个 1 放进 bag 里，看看 <code>perl</code> 的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b1</span> <span class="o">=</span> <span class="nb">bag</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$b1</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span></code></pre></div><p>该程序打印以下输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Bag</span>
</span></span></code></pre></div><p>也就是说，我们有一个 1。</p>
<p>如果你把另一个数字也放进 bag 里面：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b2</span> <span class="o">=</span> <span class="nb">bag</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$b2</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span></code></pre></div><p>现在有一个 1 和一个 2：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">=&gt;</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Bag</span>
</span></span></code></pre></div><p>好的，如果你添加另一个 1 呢?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b3</span> <span class="o">=</span> <span class="nb">bag</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$b3</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</span></span></code></pre></div><p>现在有两个 1：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">(</span><span class="mi">1</span><span class="o">=&gt;</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="kt">Bag</span>
</span></span></code></pre></div><p>让我们稍微离题一下：所有显示的例子都可以把括号去掉：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b1</span> <span class="o">=</span> <span class="nb">bag</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b2</span> <span class="o">=</span> <span class="nb">bag</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b3</span> <span class="o">=</span> <span class="nb">bag</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></div><p>比较典型的是，bag 不止能存储数字，还可以存储字符串，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$cars</span> <span class="o">=</span> <span class="nb">bag</span> <span class="p">&lt;</span><span class="s">green black blue black white</span><span class="p">&gt;;</span>
</span></span></code></pre></div><p>我可以了解变量 <code>$cars</code> 的内容？</p>
<p>首先，有什么颜色:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cars</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span> <span class="c1"># (white blue black green)</span>
</span></span></code></pre></div><p>其次，实际上有多少种不同的颜色：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cars</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span> <span class="c1"># 4</span>
</span></span></code></pre></div><p>或者有多少个不同的对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$cars</span><span class="o">.</span><span class="nb">total</span><span class="p">;</span> <span class="c1"># 5</span>
</span></span></code></pre></div><p>最后，在创建 Bag 类型的对象时，可以使用类似于如何创建哈希的语法（但是，您不能省略括号和引号）:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$cars2</span> <span class="o">=</span> <span class="nb">bag</span><span class="p">(&#39;</span><span class="s1">green</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">black</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">blue</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">white</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Playing with the code of Rakudo Raku]]></title>
            <link href="http://localhost:1313/raku/2017-12-23-playing-with-the-code-of-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/a-restful-api-with-openapi/?utm_source=atom_feed" rel="related" type="text/html" title="第二十二天 - 使用 OpenAPI 的 RESTful API" />
                <link href="http://localhost:1313/notes/virtual-ly-a-lumberjack/?utm_source=atom_feed" rel="related" type="text/html" title="第二十一天 - 虚拟的伐木工人" />
                <link href="http://localhost:1313/notes/python-%E4%B8%AD-mongodb-%E7%9A%84%E4%BD%BF%E7%94%A8/?utm_source=atom_feed" rel="related" type="text/html" title="MongoDB 的使用" />
                <link href="http://localhost:1313/notes/redis-%E4%B9%8B%E5%AD%98%E5%82%A8%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0%E6%AD%A3%E6%96%87/?utm_source=atom_feed" rel="related" type="text/html" title="redis 的使用" />
                <link href="http://localhost:1313/notes/practical-testing/?utm_source=atom_feed" rel="related" type="text/html" title="第二十天 - 实用测试" />
            
                <id>http://localhost:1313/raku/2017-12-23-playing-with-the-code-of-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2017-12-23T00:00:00+00:00</published>
            <updated>2017-12-23T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>昨天，我们查看了返回字符串的 Bool 类的两个方法。函数产生的字符串表示在源代码中被硬编码。</p>
<p>让我们使用这个观察并尝试改变文本。</p>
<p>所以，这里是我们要修改的片段：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Bool</span><span class="o">.^</span><span class="nf">add_multi_method</span><span class="p">(&#39;</span><span class="s1">gist</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nb">gist</span><span class="p">(</span><span class="nb">Bool</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">self</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">True</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">False</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>该 <code>gist</code> 方法用于对已定义的变量进行字符串化。</p>
<p>要做到这一点，你需要在计算机上安装 Rakudo 的源代码，以便编译它们。首先从 GitHub 克隆项目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ git clone https://github.com/rakudo/rakudo.git
</span></span></code></pre></div><p>编译 MoarVM：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nb">cd</span> rakudo
</span></span><span class="line"><span class="cl">$ perl Configure.pl --gen-moar --gen-nqp --backends<span class="o">=</span>moar
</span></span><span class="line"><span class="cl">$ make
</span></span></code></pre></div><p>完成之后，你会在 <code>rakudo</code> 目录下获得 <code>raku</code> 可执行文件。</p>
<p>现在，打开 <code>src/core/Bool.pm</code> 文件，并将 <code>gist</code> 方法的字符串更改为使用 Unicode 大拇指代替纯文本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Bool</span><span class="o">.^</span><span class="nf">add_multi_method</span><span class="p">(&#39;</span><span class="s1">gist</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nb">gist</span><span class="p">(</span><span class="nb">Bool</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">self</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">👍</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">👎</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>保存文件后，您需要重新编译 Rakudo。 Bool.pm 位于要在 Makefile 中编译的文件列表中：</p>
<pre tabindex="0"><code>M_CORE_SOURCES = \
    src/core/core_prologue.pm\
    src/core/traits.pm\
    src/core/Positional.pm\
    . . .
    src/core/Bool.pm\
    . . .
</code></pre><p>运行 <code>make</code> 并获取更新的 <code>raku</code>。运行它并享受结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">:~/</span><span class="n">rakudo</span><span class="nv">$</span> <span class="o">./</span><span class="nb">raku</span>
</span></span><span class="line"><span class="cl"><span class="n">To</span> <span class="nb">exit</span> <span class="nb">type</span> <span class="p">&#39;</span><span class="s1">exit</span><span class="p">&#39;</span> <span class="ow">or</span> <span class="p">&#39;</span><span class="s1">^D</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">my</span> <span class="kt">Bool</span> <span class="nv">$b</span> <span class="o">=</span> <span class="kt">True</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">👍
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nv">$b</span> <span class="o">=</span> <span class="o">!</span><span class="nv">$b</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">👎
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span>
</span></span></code></pre></div><p>作为练习，让我们通过添加未定义值的 <code>gist</code> 方法来改进本地 Raku。默认情况下，它不存在，我们昨天看到了。这意味着尝试在字符串中插入未定义的变量将被拒绝。让我们做得更好。</p>
<p>插值使用 <code>Str</code> 方法。它与 <code>gist</code> 和 <code>perl</code> 类似，所以在创建新版本时不会遇到任何困难。</p>
<p>这是目前在 Raku 中的内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Bool</span><span class="o">.^</span><span class="nf">add_multi_method</span><span class="p">(&#39;</span><span class="s1">Str</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="kt">Str</span><span class="p">(</span><span class="nb">Bool</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">self</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">True</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">False</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>这是你需要添加的内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">Bool</span><span class="o">.^</span><span class="nf">add_multi_method</span><span class="p">(&#39;</span><span class="s1">Str</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="kt">Str</span><span class="p">(</span><span class="nb">Bool</span><span class="p">:</span><span class="s">U</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">&#39;</span><span class="s1">¯\_(ツ)_/¯</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>请注意，第二个变体中不需要 <code>self</code>（不能使用）。</p>
<p>编译并运行 <code>raku</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="nb">raku</span>
</span></span><span class="line"><span class="cl"><span class="n">To</span> <span class="nb">exit</span> <span class="nb">type</span> <span class="p">&#39;</span><span class="s1">exit</span><span class="p">&#39;</span> <span class="ow">or</span> <span class="p">&#39;</span><span class="s1">^D</span><span class="p">&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">my</span> <span class="kt">Bool</span> <span class="nv">$b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="kt">Bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="p">&#34;</span><span class="s2">Here is my variable: </span><span class="nv">$b</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">Here</span> <span class="k">is</span> <span class="k">my</span> <span class="nb">variable</span><span class="o">:</span> <span class="o">¯</span>\<span class="nf">_</span><span class="p">(</span><span class="n">ツ</span><span class="p">)</span><span class="n">_</span><span class="o">/¯</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span>
</span></span></code></pre></div><p>它按预期工作。恭喜，你刚刚改变了 Raku 的行为！</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku from Haskell - Nutshell]]></title>
            <link href="http://localhost:1313/raku/2017-04-29-raku-from-haskell-nutshell/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E7%94%A8-parquet-%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E6%B5%81/?utm_source=atom_feed" rel="related" type="text/html" title="用 parquet 数据模拟实时数据流" />
                <link href="http://localhost:1313/notes/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BE%E7%BD%AE/?utm_source=atom_feed" rel="related" type="text/html" title="Spark 环境变量的设置" />
                <link href="http://localhost:1313/notes/%E6%9C%AC%E5%9C%B0%E8%AF%BB%E5%8F%96-hbase-%E7%9A%84-pom-%E6%96%87%E4%BB%B6/?utm_source=atom_feed" rel="related" type="text/html" title="本地读取 HBase 的 pom 文件" />
                <link href="http://localhost:1313/notes/%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0-kafka-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/?utm_source=atom_feed" rel="related" type="text/html" title="搭建本地 Kafka 测试环境" />
                <link href="http://localhost:1313/notes/%E5%B9%B2%E8%B4%A7%E6%BB%A1%E6%BB%A1%E7%9A%84-pyspark-%E7%AC%94%E8%AE%B0/?utm_source=atom_feed" rel="related" type="text/html" title="Pyspark 笔记" />
            
                <id>http://localhost:1313/raku/2017-04-29-raku-from-haskell-nutshell/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2017-04-29T00:00:00+00:00</published>
            <updated>2017-04-29T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>Haskell 和 Raku 是非常不同的语言。这很明显。 但是，这并不意味着没有相似之处或共同的想法！ 此页面尝试让一个 Haskell 用户启动并运行 Raku。Haskell 用户可能会发现，在用 Raku 编写脚本时，他们不需要放弃所有 Haskelly 的想法。</p>
<p>请注意，这不应该被误认为是初学者教程或 Raku 概述; 它旨在作为具有强大 Haskell 背景的 Raku 学习者的技术参考。</p>
<h2 id="类型">类型</h2>
<h3 id="类型-vs-值">类型 vs 值</h3>
<p>在 Haskell 中, 您有类型级编程, 然后进行值级编程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">plusTwo</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>   <span class="c1">-- Types</span>
</span></span><span class="line"><span class="cl"><span class="nf">plusTwo</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>               <span class="c1">-- Values</span>
</span></span></code></pre></div><p>您不要像下面那样在 Haskell 中混合类型和值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">plusTwo</span> <span class="mi">2</span>          <span class="o">--</span> <span class="n">This</span> <span class="k">is</span> <span class="nc">valid</span>
</span></span><span class="line"><span class="cl"><span class="n">plusTwo</span> <span class="n">Integer</span>    <span class="o">--</span> <span class="n">This</span> <span class="k">is</span> <span class="nb">not</span> <span class="n">valid</span>
</span></span></code></pre></div><p>在 Raku 中, 类型(亦称为类型对象)和值处于同样的级别</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">plus-two</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$x</span> <span class="k">--&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">plus-two</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>   <span class="c1"># This is valid</span>
</span></span><span class="line"><span class="cl"><span class="nf">plus-two</span><span class="p">(</span><span class="kt">Int</span><span class="p">);</span> <span class="c1"># This is valid</span>
</span></span></code></pre></div><p>我将再用一个例子来说明 Raku 这个独特之处:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">is-string</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$</span> <span class="k">--&gt;</span> <span class="kt">True</span><span class="p">)</span>  <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">is-string</span><span class="p">(</span><span class="kt">Any</span> <span class="nv">$</span> <span class="k">--&gt;</span> <span class="kt">False</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nf">is-string</span><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;);</span>    <span class="c1">#True </span>
</span></span><span class="line"><span class="cl"><span class="nf">is-string</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>          <span class="c1">#False </span>
</span></span></code></pre></div><h3 id="maybe">Maybe</h3>
<p>在 Haskell 中，您有一个 Maybe 类型, 可以让您放弃空类型的烦恼。 假设您有一个将 String 解析为 Integer 的假设函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nf">parseInt</span> <span class="o">::</span> <span class="n">String</span> <span class="k">-&gt;</span> <span class="n">Maybe</span> <span class="n">Integer</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">case</span> <span class="n">parseInt</span> <span class="n">myString</span> <span class="k">of</span>
</span></span><span class="line"><span class="cl">  <span class="nc">Just</span> <span class="nb">x</span>  <span class="k">-&gt;</span> <span class="nb">x</span>
</span></span><span class="line"><span class="cl">  <span class="n">Nothing</span> <span class="k">-&gt;</span> <span class="mi">0</span>
</span></span></code></pre></div><p>在 Raku 中, 由于类型对象与常规对象共存，因此我们拥有 <code>Defined</code> 和 <code>Undefined</code> 对象的概念。 平常的类型对象是 undefined 的, 而实例化后的对象是 defined 的。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的笑脸]]></title>
            <link href="http://localhost:1313/raku/2017-03-11-raku%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/maven-%E5%88%9B%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/?utm_source=atom_feed" rel="related" type="text/html" title="使用 IDEA 创建 maven 父子工程" />
                <link href="http://localhost:1313/notes/introducing-pandas-udf-for-pyspark/?utm_source=atom_feed" rel="related" type="text/html" title="Introducing Pandas UDF for PySpark" />
                <link href="http://localhost:1313/notes/idea%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4%E6%8A%A5%E7%BA%A2/?utm_source=atom_feed" rel="related" type="text/html" title="IDEA 报红" />
                <link href="http://localhost:1313/notes/exitcodeexception-exitcode1/?utm_source=atom_feed" rel="related" type="text/html" title="dr.who" />
                <link href="http://localhost:1313/notes/dependencies-unknown/?utm_source=atom_feed" rel="related" type="text/html" title="依赖未知" />
            
                <id>http://localhost:1313/raku/2017-03-11-raku%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2017-03-11T00:00:00+00:00</published>
            <updated>2017-03-11T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>+++</p>
<p>在 Raku 中在调用者的类型身上使用 <code>:D</code> 或 <code>:U</code> 类型笑脸来制造 <code>type/instance</code> 方法:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">(</span><span class="n">Foo:D:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">instance</span><span class="p">&#34;</span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">multi</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">(</span><span class="n">Foo:U:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">type object</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Foo</span>    <span class="o">.</span><span class="nf">foo</span><span class="p">;</span> <span class="c1"># 输出 type object</span>
</span></span><span class="line"><span class="cl"><span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">foo</span><span class="p">;</span> <span class="c1"># 输出 instance</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Can use compile time vars to aovid re-typing the actual name everywhere:</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">multi</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">instance</span><span class="p">&#34;</span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">multi</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">(</span><span class="vg">::?CLASS:U</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">type object</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Bar</span>    <span class="o">.</span><span class="nf">foo</span><span class="p">;</span> <span class="c1"># &#34;type object&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">Bar</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">foo</span><span class="p">;</span> <span class="c1"># &#34;instance&#34;</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[2017 StackOverFlow-sort,deepmap,flat]]></title>
            <link href="http://localhost:1313/raku/2017-01-02-stackoverflow/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E4%B8%BA-openresty-%E7%9A%84-luajit-%E5%AE%89%E8%A3%85-luarocks-/?utm_source=atom_feed" rel="related" type="text/html" title="给 openresty 的 luajit 安装 luarocks" />
                <link href="http://localhost:1313/notes/termux/?utm_source=atom_feed" rel="related" type="text/html" title="使用 termux 运行 Linux 系统" />
                <link href="http://localhost:1313/raku/2016-12-31-raku%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 时间戳转换器命令行版" />
                <link href="http://localhost:1313/notes/%E9%81%8D%E5%8E%86%E6%97%A5%E6%9C%9F/?utm_source=atom_feed" rel="related" type="text/html" title="使用 shell 遍历日期" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0---animation/?utm_source=atom_feed" rel="related" type="text/html" title="iOS 动画" />
            
                <id>http://localhost:1313/raku/2017-01-02-stackoverflow/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2017-01-02T22:56:16+00:00</published>
            <updated>2017-01-02T22:56:16+00:00</updated>
            
            
            <content type="html"><![CDATA[<ul>
<li><a href="http://stackoverflow.com/questions/41406004/raku-what-is-the-best-way-to-match-any-of-a-group-of-words">raku What is the best way to match any of a group of words?</a></li>
</ul>
<p>我想匹配任意一组单词，但是失败了，请问怎样才能正确地匹配到？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span><span class="o">=</span><span class="p">&lt;</span><span class="s">a b c d e f</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="p">&#34;</span><span class="s2">a1234567</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="nv">@a</span><span class="ni">.</span><span class="sr">any </span><span class="p">/;</span>
</span></span></code></pre></div><p><strong>Answer</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">a1234567</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$x</span> <span class="o">~~</span> <span class="p">/</span><span class="nv">@a</span><span class="p">/</span>
</span></span></code></pre></div><p><code>/@a/</code> 和  <code>/| @a/</code> 相同，它是最长的备选分支。对于备选分支，你可以使用 <code>/|| @a/</code>。</p>
<ul>
<li><a href="http://stackoverflow.com/questions/41194693/how-to-build-lazy-lists-with-defined-generators-and-is-there-a-takewhile-alter">How to build lazy lists with defined generators and is there a “takeWhile” alternative?</a></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nv">$x</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$alist</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span> <span class="nv">&amp;foo</span> <span class="o">...</span> <span class="o">^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">);</span>
</span></span></code></pre></div><p>我想得到　<code>(1 4 9 16 25 .. )</code> 而程序得到的是 <code>(1 2 4 16 256)</code>。</p>
<p><strong>Answer</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*</span> <span class="o">**</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1"># using a Whatever-expression</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">&amp;foo</span><span class="p">);</span>    <span class="c1"># using your `foo` function</span>
</span></span></code></pre></div><p>或者使用 Haskell/Python 那样的列表解析式:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..*</span><span class="p">);</span>  <span class="c1"># using an in-line expression</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="n">foo</span> <span class="nv">$_</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..*</span><span class="p">);</span>   <span class="c1"># using your `foo` function</span>
</span></span></code></pre></div><p>另外还有一种方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@alist</span> <span class="o">=</span> <span class="p">{(</span><span class="o">++</span><span class="nv">$</span><span class="p">)</span>²<span class="p">}</span> <span class="o">...</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">;</span> <span class="c1"># stop immediately after past 70</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alist</span><span class="p">;</span> <span class="c1"># [1 4 9 16 25 36 49 64 81]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@alist</span> <span class="o">=</span> <span class="p">{(</span><span class="o">++</span><span class="nv">$</span><span class="p">)</span>²<span class="p">}</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">;</span> <span class="c1"># stop immediately before past 70</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@alist</span><span class="p">;</span> <span class="c1"># [1 4 9 16 25 36 49 64]</span>
</span></span></code></pre></div><p>个人不推荐使用　<code>$</code> 匿名变量的这种写法, 对于 new comer 不太友好。</p>
<ul>
<li><a href="http://stackoverflow.com/questions/41457242/raku-is-using-junctions-in-matching-possible">在匹配中使用 junctions 可以吗？</a></li>
</ul>
<blockquote>
<p>Is it possible to use junction to match any of the values in a junction? I want to match any of the values in an array. What is the proper way to do it?</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">my</span> <span class="nv">@a</span><span class="o">=&lt;</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="nb">any</span><span class="p">(</span><span class="nv">@a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">my</span> <span class="nv">$y</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">a 1</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="nv">$y</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="nv">$x</span><span class="sr"> </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="kt">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="nv">$y</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="p">&#34;</span><span class="nv">$x</span><span class="p">&#34;</span><span class="sr"> </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="kt">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@a</span><span class="p">)</span><span class="o">.</span><span class="kt">Str</span>
</span></span><span class="line"><span class="cl"><span class="nb">any</span><span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="nv">$y</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="nv">$x</span><span class="sr"> </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="kt">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="nv">$y</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="nv">$x</span><span class="sr"> </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="kt">False</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="nb">say</span> <span class="nv">$y</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="nv">@a</span><span class="sr"> </span><span class="p">/</span>
</span></span><span class="line"><span class="cl"><span class="p">｢</span><span class="s">a</span><span class="p">｣</span>
</span></span></code></pre></div><p><strong>Answer</strong></p>
<p><code>junctions</code>  不该被插值到正则表达式中。它们应该被用在普通的 Raku 表达式中，特别是带有比较操作符的表达式（例如  <code>eq</code>）:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">x y z</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span>    <span class="p">&#34;</span><span class="s2">y</span><span class="p">&#34;</span> <span class="ow">eq</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>  <span class="c1"># any(False, True, False)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">y</span><span class="p">&#34;</span> <span class="ow">eq</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>  <span class="c1"># True</span>
</span></span></code></pre></div><p>要在正则表达式中匹配一个数组的任意值，就在正则表达式中写上那个数组名好了（以<code>@</code>开头）。默认地，这被插值为 <code>|</code> 备选分支（“longest match”），但是你也可以把他指定为 <code>||</code> 备选分支（“first match”）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">foo bar barkeep</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">barkeeper</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="nv">@a</span><span class="sr"> </span><span class="p">/;</span>     <span class="c1"># ｢barkeep｣</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">barkeeper</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="nv">@a</span><span class="sr"> </span><span class="p">/;</span>  <span class="c1"># ｢bar｣</span>
</span></span></code></pre></div><p>我需要排序数组的数组， <code>.sort</code> 方法能不能按照内层数组的不同索引来排序呢？</p>
<p>要排序的数组在一个更大的数组的外面：（birthday 是 &lsquo;mmddyy&rsquo; 格式的：）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@allRecords</span> <span class="o">=</span> <span class="o">[</span> <span class="o">[</span><span class="n">birthday1</span> <span class="n">firstName1</span> <span class="n">lastName1</span> <span class="o">[</span><span class="n">data1</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">                   <span class="o">[</span><span class="n">birthday2</span> <span class="n">firstName2</span> <span class="n">lastName2</span> <span class="o">[</span><span class="n">data2</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">                   <span class="o">...</span>
</span></span><span class="line"><span class="cl">                   <span class="o">[</span><span class="n">birthdayN</span> <span class="n">firstNameN</span> <span class="n">lastNameN</span> <span class="o">[</span><span class="n">dataN</span><span class="o">]</span> <span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">@allRecords</span><span class="o">.</span><span class="nb">sort</span> <span class="n">by</span> <span class="n">itself</span> <span class="n">sorts</span> <span class="n">by</span> <span class="n">birthdays</span><span class="o">.</span>
</span></span></code></pre></div><p>有什么好方法能按照 firstName 或 lastName 或 按照内层数组里面的数据来排序？</p>
<p><strong>Answer</strong></p>
<p><code>sort</code> 方法接受一个<a href="https://docs.raku.org/routine/sort#(List)_routine_sort">可选的 sub 参数</a>。如果元数是 1， 那么它使用返回值作为比较操作数；如果元数为 2， 那么你可以在两个元素之间手动作比较，两个元素的比较会返回 <code>Less</code>, <code>Same</code>, <code>More</code>。</p>
<p>拿你上面的例子来说，我们可以像这样按照 first name 进行排序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@allRecords</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
</span></span></code></pre></div><p>我们可以先按照 last name 再按照 first name 进行排序，然后按照 birthday 来做单独的比较，就像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@allRecords</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span><span class="nv">$b</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nv">$a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="ow">cmp</span> <span class="nv">$b</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">||</span> <span class="nv">$a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="ow">cmp</span> <span class="nv">$b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">||</span> <span class="nv">$a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="ow">cmp</span> <span class="nv">$b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><p>或者再次通过转换操作数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@allRecords</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.[</span><span class="mi">2</span><span class="o">...</span><span class="mi">0</span><span class="o">]</span><span class="p">);</span>
</span></span></code></pre></div><p>变换 birthday 条目以至于我们能先按照 year 排序作为练习留给读者完成，但是其中一种方法是在合适的地方添加像这样的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.</span><span class="nb">comb</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span>
</span></span></code></pre></div><p>你可以按照 lastname，firstname， birthday 这样的顺序排序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="o">*[</span><span class="mi">2</span><span class="o">...</span><span class="mi">0</span><span class="o">]</span>
</span></span></code></pre></div><p>还有两个问题：</p>
<ul>
<li><code>*.[1]</code> 和 <code>*[1]</code> 有什么区别？</li>
</ul>
<p>两者没有任何区别，但是前者可读性更好！</p>
<ul>
<li>range 操作符和 &hellip; 序列操作符有什么区别</li>
</ul>
<p>range 不能倒数， <code>...</code> 可以倒数。</p>
<ul>
<li><a href="http://stackoverflow.com/questions/41554702/how-do-i-find-the-index-of-the-maximum-value-in-a-list-in-perl-6">How do I find the index of the maximum value in a list in Raku?</a></li>
</ul>
<p>在 Perl  6 中怎样找出列表中最大值的索引?</p>
<p><strong>Answer</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">maxpairs</span><span class="p">;</span> <span class="c1"># [2 =&gt; 9 4 =&gt; 9]</span>
</span></span></code></pre></div><p><code>@list.maxpairs</code> 用于获取索引和对应最大值的所有对儿。
<code>@list.pairs.max(*.value).key</code> 用于仅获取单个索引。</p>
<pre tabindex="0"><code>&gt; @list.pairs.max(*.value).key
2
</code></pre><ul>
<li><a href="http://stackoverflow.com/questions/41648119/how-can-i-completely-flatten-a-perl-6-list-of-lists-of-lists">How can I completely flatten a Raku list (of lists (of lists) … )</a></li>
</ul>
<p>如何彻底地展平 Raku 的列表？这个问题不同于  <a href="http://stackoverflow.com/q/37173023/2766176">How do I “flatten” a list of lists in perl 6?</a>, 后者不是彻底的 flat。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span>  <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@b</span>  <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">,</span><span class="p">)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">f</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@c</span>  <span class="o">=</span> <span class="p">&#39;</span><span class="s1">x</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">y</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span> <span class="p">)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">w</span><span class="p">&#39;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@ab</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@b</span><span class="o">,</span> <span class="nv">@c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">ab: </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">@ab</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@f</span> <span class="o">=</span> <span class="nv">@ab</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">@f</span> <span class="o">=</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="nv">@f</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">@f</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">elems</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">??</span>
</span></span><span class="line"><span class="cl">            <span class="nb">take</span> <span class="nv">@f</span><span class="o">.</span><span class="nb">shift</span><span class="o">.</span><span class="kt">Slip</span>
</span></span><span class="line"><span class="cl">                <span class="o">!!</span>
</span></span><span class="line"><span class="cl">            <span class="nv">@f</span><span class="o">.</span><span class="nb">unshift</span><span class="p">(</span> <span class="nv">@f</span><span class="o">.</span><span class="nb">shift</span><span class="o">.</span><span class="kt">Slip</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">f: </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">@f</span><span class="p">;</span>
</span></span></code></pre></div><p>这打印出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">ab:</span> <span class="o">[[</span><span class="n">a</span> <span class="p">(</span><span class="n">b</span> <span class="n">c</span><span class="p">)</span><span class="o">]</span> <span class="o">[</span><span class="p">(</span><span class="nb">d</span><span class="p">)</span> <span class="nb">e</span> <span class="nb">f</span> <span class="o">[</span><span class="n">a</span> <span class="p">(</span><span class="n">b</span> <span class="n">c</span><span class="p">)</span><span class="o">]]</span> <span class="o">[</span><span class="nb">x</span> <span class="p">(</span><span class="n">y</span> <span class="nb">z</span><span class="p">)</span> <span class="nb">w</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl"><span class="nb">f</span><span class="o">:</span> <span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="nb">d</span> <span class="nb">e</span> <span class="nb">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="nb">x</span> <span class="n">y</span> <span class="nb">z</span> <span class="nb">w</span><span class="o">]</span>
</span></span></code></pre></div><p>但这不够简洁。一种可行的办法是使用：<code>gather/take/deepmap</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="k">gather</span> <span class="nv">@ab</span><span class="o">.</span><span class="nb">deepmap</span><span class="p">(</span><span class="o">*.</span><span class="nb">take</span><span class="p">)</span>
</span></span></code></pre></div><p><code>postcircumfix []</code> 操作符可用于多维下标来获取一组展平的叶子节点，直到特定的深度，尽管　“无限深度”　版本还没有实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@ab</span><span class="o">[*</span><span class="p">;</span><span class="o">*]</span><span class="p">;</span>     <span class="c1"># (a (b c) (d) e f [a (b c)] x (y z) w)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@ab</span><span class="o">[*</span><span class="p">;</span><span class="o">*</span><span class="p">;</span><span class="o">*]</span><span class="p">;</span>   <span class="c1"># (a b c d e f a (b c) x y z w)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@ab</span><span class="o">[*</span><span class="p">;</span><span class="o">*</span><span class="p">;</span><span class="o">*</span><span class="p">;</span><span class="o">*]</span><span class="p">;</span> <span class="c1"># (a b c d e f a b c x y z w)</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@ab</span><span class="o">[**]</span><span class="p">;</span>      <span class="c1"># HyperWhatever in array index not yet implemented. Sorry.</span>
</span></span></code></pre></div><ul>
<li>避免容器化 (containerization)</li>
</ul>
<p>内置的 <code>flat</code> 函数能很好地展平深度嵌套的列表。问题是它不能落进 item 容器（Scalar）中。嵌套列表中非故意的 item 容器的常见来源有：</p>
<ul>
<li><code>数组</code>（但不是<code>列表</code>）将其每个元素包装在一个新的 item 容器中，无论它之前有没有。</li>
<li>如何避免：如果不需要 Array 提供的可变性，请使用列表的列表而不是数组的数组。使用绑定 <code>:=</code> 可以用来代替赋值，将列表存储在@变量中，而不将其转换为<code>数组</code>：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span>  <span class="o">:=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">(&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@b</span>  <span class="o">:=</span> <span class="p">(&#39;</span><span class="s1">d</span><span class="p">&#39;</span><span class="o">,</span><span class="p">)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">f</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">flat</span> <span class="nv">@b</span><span class="p">;</span>  <span class="c1"># (d e f a b c)</span>
</span></span></code></pre></div><ul>
<li>$variables 是 item 容器。</li>
<li>如何避免：当将列表存储在 <code>$</code> 变量中，然后将其作为元素插入到另一个列表中时，使用 <code>&lt;&gt;</code> 来对它进行 decontainerize(解容器化)。当把 <code>$</code> 变量传递给 flat 时, 父列表的容器也可以使用 <code>|</code> 绕过：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">$a</span><span class="o">&lt;&gt;,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">flat</span> <span class="o">|</span><span class="nv">$b</span><span class="p">;</span>  <span class="c1"># (1 2 3 4 5 6)</span>
</span></span></code></pre></div><p>未完待续。。。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 时间戳转换器命令行版]]></title>
            <link href="http://localhost:1313/raku/2016-12-31-raku%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E9%81%8D%E5%8E%86%E6%97%A5%E6%9C%9F/?utm_source=atom_feed" rel="related" type="text/html" title="使用 shell 遍历日期" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E5%9B%9B%E7%AB%A0---animation/?utm_source=atom_feed" rel="related" type="text/html" title="iOS 动画" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-views/?utm_source=atom_feed" rel="related" type="text/html" title="iOS 视图" />
                <link href="http://localhost:1313/raku/2016-11-01-raku-grammar%E4%B9%8B%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E6%9C%AC/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammar 之分割结构化文本" />
                <link href="http://localhost:1313/raku/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/?utm_source=atom_feed" rel="related" type="text/html" title="第 10000 个素数" />
            
                <id>http://localhost:1313/raku/2016-12-31-raku%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2016-12-31T23:14:12+00:00</published>
            <updated>2016-12-31T23:14:12+00:00</updated>
            
            
            <content type="html"><![CDATA[<h1 id="raku-by-example-datetime-conversion-for-the-command-line">Raku By Example: Datetime Conversion for the Command Line</h1>
<p>我偶尔会在数据库中存储 UNIX 时间戳, 即从 1970-01-01 开始的秒数。我在按照日期查询数据库中的数据时, 需要将 UNIX 时间戳转换为人类可读的时间, 所以我写了个很小的工具来帮助我在 UNIX  时间戳和日期/时间之间来回转换:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="n">autotime</span> <span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span>
</span></span><span class="line"><span class="cl"><span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="n">autotime</span> <span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span> <span class="mi">11</span><span class="p">:</span><span class="mi">2</span><span class="s">3</span><span class="p">:</span><span class="mi">0</span><span class="s">0</span>
</span></span><span class="line"><span class="cl"><span class="mi">1450956180</span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="n">autotime</span> <span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="n">autotime</span> <span class="mi">1450956180</span>
</span></span><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span> <span class="mi">11</span><span class="p">:</span><span class="mi">2</span><span class="s">3</span><span class="p">:</span><span class="mi">0</span><span class="s">0</span>
</span></span></code></pre></div><h2 id="使用库">使用库</h2>
<p>Raku 的 <a href="https://docs.raku.org/type/DateTime">DateTime</a> 和 <a href="https://docs.raku.org/type/Date">Date</a> 模块会做实际的转换。
<code>DateTime.new</code> 构造函数有一个接收单个整数作为 UNIX 时间戳的变体:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#34;</span><span class="s2">say DateTime.new(1480915200)</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="mi">2016</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mo">05</span><span class="n">T05:20:00Z</span>
</span></span></code></pre></div><p>看起来我们已经完成了一个方向的转换,对吗?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$timestamp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们来运行它:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="n">autotime</span> <span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="n">Invalid</span> <span class="kt">DateTime</span> <span class="n">string</span> <span class="p">&#39;</span><span class="s1">1450915200</span><span class="p">&#39;;</span> <span class="k">use</span> <span class="nn">an</span> <span class="n">ISO</span> <span class="mi">8601</span> <span class="n">timestamp</span> <span class="p">(</span><span class="n">yyyy-mm-ddThh:mm:ssZ</span> <span class="ow">or</span> <span class="n">yyyy-mm-ddThh:mm:ss</span><span class="o">+</span><span class="mo">01</span><span class="p">:</span><span class="mi">0</span><span class="s">0</span><span class="p">)</span> <span class="nb">instead</span>
</span></span><span class="line"><span class="cl">  <span class="nb">in</span> <span class="k">sub</span> <span class="nb">MAIN</span> <span class="nb">at</span> <span class="n">autotime</span> <span class="nb">line</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="nb">in</span> <span class="nb">block</span> <span class="o">&lt;</span><span class="k">unit</span><span class="o">&gt;</span> <span class="nb">at</span> <span class="n">autotime</span> <span class="nb">line</span> <span class="mi">2</span>
</span></span></code></pre></div><p>发生了什么？看起来 <code>DateTime</code> 构造函数把参数当作了字符串, 尽管 <code>sub MAIN</code> 的参数被声明为 <code>Int</code>。怎么会变成那样呢? 我们添加一些调试输出:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$timestamp</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$timestamp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>打印出:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">IntStr</span>
</span></span></code></pre></div><p><code>$thing.^name</code> 是 $thing 所属类的名字。 <a href="https://docs.raku.org/type/IntStr">IntStr</a> 是 <code>Int</code> 和 <code>Str</code> 类的子类, 这就是为什么 <code>DateTime</code> 构造函数正常地认为 $timestamp 是一个 <code>Str</code> 的原因。</p>
<p>长话短说, 我们可以在参数前添加一个 <code>+</code> 前缀使参数强制为 &ldquo;真&rdquo; 整数, 这也是将字符串转为数值的通用机制:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="nv">$timestamp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这一次它真的工作了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="n">autotime-01</span><span class="o">.</span><span class="nf">p6</span> <span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span><span class="n">T00:00:00Z</span>
</span></span></code></pre></div><p>输出是 ISO 8601 样式的时间戳格式, 对眼睛不太友好。对于小时,分钟和秒数都为 0 的日期, 我们真正想要的只有日期:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="nv">$timestamp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">hour</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">minute</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">second</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样看起来更好一点:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="n">autotime</span> <span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span>
</span></span></code></pre></div><p>但是上面那种三个比较都为 0 的写法实在太丑了, 如果是 4 个, 5 个, 6 个&hellip; 那就是又丑又长。Raku 有一个 <code>all</code> Junction:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nv">$dt</span><span class="o">.</span><span class="nb">hour</span><span class="o">,</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">minute</span><span class="o">,</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">second</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>all(...)</code> 创建了一个 <a href="https://docs.raku.org/type/Junction">Junction</a>, 它是几个其他值的组合值, 它也存储了一个逻辑模式。当你比较一个 junction 和其他值的时候, 那个比较会自动地应用到该 junction 中的所有值上。<code>if</code> 语句在布尔上下文中对该 junction 进行求值, 在这个例子中, 当所有的比较为 <code>True</code> 时, if 也返回 <code>True</code>。</p>
<p>其他类型的 junction 还有 <code>any</code>, <code>all</code>, <code>none</code>。考虑到在布尔上下文中, 0 是唯一一个求值为 false 的整数, 我们甚至可以把上面的例子写为:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nb">none</span><span class="p">(</span><span class="nv">$dt</span><span class="o">.</span><span class="nb">hour</span><span class="o">,</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">minute</span><span class="o">,</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但是也可能没有必要搞得那么复杂,  如果 <code>$dt</code> 这个 Datetime 对象转换为 <code>Date</code>  然后再转换为 DateTime 而不丢失信息, 那么它肯定是一个 Date:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="kt">DateTime</span> <span class="o">==</span> <span class="nv">$dt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="nv">$dt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="datetime-格式化">DateTime 格式化</h2>
<p>如果时间戳没有被解析为整天, 那么当前我们的脚本的输出就会像这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span><span class="n">T00:00:01Z</span>
</span></span></code></pre></div><p>其中的 &ldquo;Z&rdquo; 表示 UTC 或 &ldquo;Zulu&rdquo; 时区。</p>
<p><code>DateTime</code> 类支持自定义格式化, 所以我们来写一个:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="nv">$timestamp</span><span class="o">,</span> <span class="s">formatter</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$o</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nb">sprintf</span> <span class="p">&#39;</span><span class="s1">%04d-%02d-%02d %02d:%02d:%02d</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="nv">$o</span><span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">month</span><span class="o">,</span>  <span class="nv">$o</span><span class="o">.</span><span class="nb">day</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                    <span class="nv">$o</span><span class="o">.</span><span class="nb">hour</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">minute</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">second</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="kt">DateTime</span> <span class="o">==</span> <span class="nv">$dt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在输出看起来更好看了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">./</span><span class="n">autotime</span> <span class="mi">1450915201</span>
</span></span><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span> <span class="mo">00</span><span class="p">:</span><span class="mi">0</span><span class="s">0</span><span class="p">:</span><span class="mi">0</span><span class="s">1</span>
</span></span></code></pre></div><p>语法 <code>formatter =&gt; ...</code> 在参数上下文中表示具名参数。
这样的代码我不喜欢, 因为在 <code>DateTime.new</code> 调用中它是内联的, 这并不清晰。</p>
<p>我们来单独写一个例程:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nb">formatter</span><span class="p">(</span><span class="nv">$o</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sprintf</span> <span class="p">&#39;</span><span class="s1">%04d-%02d-%02d %02d:%02d:%02d</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$o</span><span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">month</span><span class="o">,</span>  <span class="nv">$o</span><span class="o">.</span><span class="nb">day</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$o</span><span class="o">.</span><span class="nb">hour</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">minute</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">second</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="nv">$timestamp</span><span class="o">,</span> <span class="s">formatter</span> <span class="o">=&gt;</span> <span class="nv">&amp;formatter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="kt">DateTime</span> <span class="o">==</span> <span class="nv">$dt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>是的, 你可以把一个子例程声明放在另一个子例程声明的正文中; 子例程只是一个普通的词法符号,就像一个用 <code>my</code> 声明的变量。</p>
<p>在行 <code>my $dt = DateTime.new(+$timestamp,formatter =&gt; &amp;formatter);</code> 中, 语法 <code>&amp;formatter</code> 引用子例程作为一个对象,而不调用它。</p>
<p>这是 Raku, <code>formatter =&gt; &amp;formatter</code> 有一个简写: <code>&amp;formatter</code>。
作为一般规则,如果要填充一个名称为变量名称并且其值为变量值的命名参数, 可以通过写入 <code>:$variable</code> 创建它。 作为扩展, <code>:thing</code> 是 <code>thing =&gt; True</code> 的缩写。</p>
<h2 id="寻找其他途径">寻找其他途径</h2>
<p>现在, 从时间戳到日期和时间的转换工作的很好, 让我们看另一种途径。
我们的小工具需要解析输入, 并决定输入的是时间戳还是日期和可选的时间。</p>
<p>一种无聊的方式是使用条件:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$input</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$input</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># convert from timestamp to date/datetime</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># convert from date to timestamp</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但我讨厌无聊, 所以我想看看一个更令人兴奋的（端可扩展）方法。</p>
<p>Raku 支持多重分派。这意味着您可以有多个具有相同名称但不同签名的子例程。
Raku 自动决定要调用哪一个。 您必须通过编写 <code>multi sub</code> 而不是 <code>sub</code> 来显式地启用此功能, 以便 Raku 可以捕获意外的重新声明。</p>
<p>让我们看看它在实际中的运用:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nb">formatter</span><span class="p">(</span><span class="nv">$o</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sprintf</span> <span class="p">&#39;</span><span class="s1">%04d-%02d-%02d %02d:%02d:%02d</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$o</span><span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">month</span><span class="o">,</span>  <span class="nv">$o</span><span class="o">.</span><span class="nb">day</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="nv">$o</span><span class="o">.</span><span class="nb">hour</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">minute</span><span class="o">,</span> <span class="nv">$o</span><span class="o">.</span><span class="nb">second</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="nv">$timestamp</span><span class="o">,</span> <span class="o">:</span><span class="nv">&amp;formatter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="kt">DateTime</span> <span class="o">==</span> <span class="nv">$dt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$dt</span><span class="o">.</span><span class="kt">Str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$date</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$date</span><span class="p">)</span><span class="o">.</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">posix</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们看一下效果:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="n">autotime</span> <span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span>
</span></span><span class="line"><span class="cl"><span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="n">autotime</span> <span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="n">Ambiguous</span> <span class="n">call</span> <span class="nb">to</span> <span class="p">&#39;</span><span class="s1">MAIN</span><span class="p">&#39;;</span> <span class="n">these</span> <span class="n">signatures</span> <span class="nb">all</span> <span class="nb">match</span><span class="o">:</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="p">(</span><span class="kt">Int</span> <span class="nv">$timestamp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">:</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$date</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">in</span> <span class="nb">block</span> <span class="o">&lt;</span><span class="k">unit</span><span class="o">&gt;</span> <span class="nb">at</span> <span class="o">./</span><span class="n">autotime</span> <span class="nb">line</span> <span class="mi">17</span>
</span></span></code></pre></div><p>不是我所想象的。问题又是整数参数自动被转换为了 <code>IntStr</code>, Int 和 Str <code>multi</code>（或候选）都接受它作为参数。</p>
<p>避免这种错误的最简单的方法是缩小 Str 候选者接受的字符串的种类。
经典的方法是用一个正则表达式粗略验证传入的参数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$date</span> <span class="k">where</span> <span class="o">/^</span> \<span class="nb">d</span><span class="o">+</span> \<span class="o">-</span> \<span class="nb">d</span><span class="o">+</span> \<span class="o">-</span> \<span class="nb">d</span><span class="o">+</span> <span class="nv">$</span> <span class="o">/</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$date</span><span class="p">)</span><span class="o">.</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">posix</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>它确实能工作, 但为什么重复 Date.new 已经有用于验证日期字符串的逻辑？
如果你传递一个看起来不像日期的字符串参数,你会得到这样的错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="n">Invalid</span> <span class="kt">Date</span> <span class="n">string</span> <span class="p">&#39;</span><span class="s1">foobar</span><span class="p">&#39;;</span> <span class="k">use</span> <span class="nb">yyyy-mm-dd</span> <span class="nb">instead</span>
</span></span></code></pre></div><p>我们可以使用这种行为约束 <code>MAIN multi</code> 候选者的字符串参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$date</span> <span class="k">where</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">say</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$date</span><span class="p">)</span><span class="o">.</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">posix</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这里额外的 <code>try</code> 是因为子类型约束后面的 <code>where</code> 不应该抛出异常, 而只是返回一个假值。</p>
<p>现在它的工作得像预期的一样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="n">autotime</span> <span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="n">autotime</span> <span class="mi">1450915200</span>
</span></span><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span>
</span></span></code></pre></div><h2 id="处理时间">处理时间</h2>
<p>剩下要实现的功能是把日期和时间转换为时间戳。换句话说, 我们想这样调用 <code>autotime 2015-12-24 11:23:00</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$date</span> <span class="k">where</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">}</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$time</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$date</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$time</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span> <span class="nv">$hour</span><span class="o">,</span> <span class="nv">$minute</span><span class="o">,</span> <span class="nv">$second</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">$time</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">date</span> <span class="o">=&gt;</span> <span class="nv">$d</span><span class="o">,</span> <span class="o">:</span><span class="nv">$hour</span><span class="o">,</span> <span class="o">:</span><span class="nv">$minute</span><span class="o">,</span> <span class="o">:</span><span class="nv">$second</span><span class="p">)</span><span class="o">.</span><span class="nb">posix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$d</span><span class="o">.</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">posix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>凭借尾部的?, 新的第二个参数是可选的 。 如果存在第二个参数, 我们用冒号将时间字符串分割成小时,分钟和秒。 我写的第一个本能是使用较短的变量名称, <code>my($h, $m, $s) = $time.split(':')</code>, 但然后调用 <code>DateTime</code> 构造函数看起来像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">date</span> <span class="o">=&gt;</span> <span class="nv">$d</span><span class="o">,</span> <span class="s">hour</span> <span class="o">=&gt;</span> <span class="nv">$h</span><span class="o">,</span> <span class="s">minute</span> <span class="o">=&gt;</span> <span class="nv">$m</span><span class="o">,</span> <span class="s">second</span> <span class="o">=&gt;</span> <span class="nv">$s</span><span class="p">);</span>
</span></span></code></pre></div><p>所以构造函数的命名参数使我选择更多的自解释变量名。</p>
<p>所以, 这个可以工作:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">./</span><span class="n">autotime</span> <span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span> <span class="mi">11</span><span class="p">:</span><span class="mi">2</span><span class="s">3</span><span class="p">:</span><span class="mi">0</span><span class="s">0</span>
</span></span><span class="line"><span class="cl"><span class="mi">1450956180</span>
</span></span></code></pre></div><p>而且我们还可以检测它的原形:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="n">autotime</span> <span class="mi">1450956180</span>
</span></span><span class="line"><span class="cl"><span class="mi">2015</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">24</span> <span class="mi">11</span><span class="p">:</span><span class="mi">2</span><span class="s">3</span><span class="p">:</span><span class="mi">0</span><span class="s">0</span>
</span></span></code></pre></div><h2 id="系好你的安全带">系好你的安全带</h2>
<p>Raku 的隐式变量或主题变量:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="nb">say</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>产生如下输出:</p>
<p>[source]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span></code></pre></div><p>这个例子中没有显式的迭代变量, 所以 Perl 隐式地把当前循环的值绑定给叫做 <code>$_</code> 的变量。方法调用 <code>.say</code> 是 <code>$_.say</code> 的缩写。由于我们有一个子例程在同一个变量上调用了 6 个方法, 所以使用 <code>$_</code> 会有很好的可视效果:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nb">formatter</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">sprintf</span> <span class="p">&#39;</span><span class="s1">%04d-%02d-%02d %02d:%02d:%02d</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="o">.</span><span class="nb">month</span><span class="o">,</span>  <span class="o">.</span><span class="nb">day</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="nb">hour</span><span class="o">,</span> <span class="o">.</span><span class="nb">minute</span><span class="o">,</span> <span class="o">.</span><span class="nb">second</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果你不想求助于函数定义在词法作用域中设置 <code>$_</code>, 那么你可以使用 <code>given VALUE BLOCK</code> 结构:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="nv">$timestamp</span><span class="o">,</span> <span class="o">:</span><span class="nv">&amp;formatter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="kt">DateTime</span> <span class="o">==</span> <span class="nv">$_</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="o">.</span><span class="kt">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Raku 还提供了对 <code>$_</code> 变量的条件语句的快捷方式,可以用作一个通用的switch语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">given</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="nv">$timestamp</span><span class="o">,</span> <span class="o">:</span><span class="nv">&amp;formatter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">when</span> <span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="kt">DateTime</span> <span class="o">==</span> <span class="nv">$_</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.</span><span class="kt">Date</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果你有一个只读的变量或参数, 那么你可以不使用 <code>$</code> 符号, 虽然你可以在声明时使用反斜线:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> \<span class="n">timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">given</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="n">timestamp</span><span class="o">,</span> <span class="o">:</span><span class="nv">&amp;formatter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>所以现在完整的代码看起来像这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> \<span class="n">timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">sub</span> <span class="nb">formatter</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">sprintf</span> <span class="p">&#39;</span><span class="s1">%04d-%02d-%02d %02d:%02d:%02d</span><span class="p">&#39;</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="o">.</span><span class="nb">month</span><span class="o">,</span>  <span class="o">.</span><span class="nb">day</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="nb">hour</span><span class="o">,</span> <span class="o">.</span><span class="nb">minute</span><span class="o">,</span> <span class="o">.</span><span class="nb">second</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">given</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">+</span><span class="n">timestamp</span><span class="o">,</span> <span class="o">:</span><span class="nv">&amp;formatter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">when</span> <span class="o">.</span><span class="kt">Date</span><span class="o">.</span><span class="kt">DateTime</span> <span class="o">==</span> <span class="nv">$_</span> <span class="p">{</span> <span class="nb">say</span> <span class="o">.</span><span class="kt">Date</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$date</span> <span class="k">where</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">}</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$time</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$d</span> <span class="o">=</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$date</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nv">$time</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="p">(</span> <span class="nv">$hour</span><span class="o">,</span> <span class="nv">$minute</span><span class="o">,</span> <span class="nv">$second</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">$time</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="kt">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">date</span> <span class="o">=&gt;</span> <span class="nv">$d</span><span class="o">,</span> <span class="o">:</span><span class="nv">$hour</span><span class="o">,</span> <span class="o">:</span><span class="nv">$minute</span><span class="o">,</span> <span class="o">:</span><span class="nv">$second</span><span class="p">)</span><span class="o">.</span><span class="nb">posix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="nv">$d</span><span class="o">.</span><span class="kt">DateTime</span><span class="o">.</span><span class="nb">posix</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="main-魔法">MAIN 魔法</h2>
<p>为我们调用 <code>sub MAIN</code> 的魔法还为我们提供了一个自动化的用法消息, 如果我们用不匹配任何 <code>multi</code> 的参数调用 MAIN, 例如调用时不提供参数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="nf">autotime</span>
</span></span><span class="line"><span class="cl"><span class="n">Usage:</span>
</span></span><span class="line"><span class="cl">  <span class="o">./</span><span class="n">autotime</span> <span class="p">&lt;</span><span class="s">timestamp</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="o">./</span><span class="n">autotime</span> <span class="o">&lt;</span><span class="n">date</span><span class="o">&gt;</span> <span class="o">[</span><span class="p">&lt;</span><span class="s">time</span><span class="p">&gt;</span><span class="o">]</span>
</span></span></code></pre></div><p>我们可以通过在 MAIN subs 之前添加语义注释来为这些用法行添加简短描述:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env raku</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Convert timestamp to ISO date
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Int</span> \<span class="n">timestamp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">#| </span><span class="sd">Convert ISO date to timestamp
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">multi</span> <span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="kt">Str</span> <span class="nv">$date</span> <span class="k">where</span> <span class="p">{</span> <span class="k">try</span> <span class="kt">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">}</span><span class="o">,</span> <span class="kt">Str</span> <span class="nv">$time</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在用法信息变为了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$</span> <span class="o">./</span><span class="nf">autotime</span>
</span></span><span class="line"><span class="cl"><span class="n">Usage:</span>
</span></span><span class="line"><span class="cl">  <span class="o">./</span><span class="n">autotime</span> <span class="p">&lt;</span><span class="s">timestamp</span><span class="p">&gt;</span> <span class="o">--</span> <span class="n">Convert</span> <span class="n">timestamp</span> <span class="nb">to</span> <span class="n">ISO</span> <span class="n">date</span>
</span></span><span class="line"><span class="cl">  <span class="o">./</span><span class="n">autotime</span> <span class="o">&lt;</span><span class="n">date</span><span class="o">&gt;</span> <span class="o">[</span><span class="p">&lt;</span><span class="s">time</span><span class="p">&gt;</span><span class="o">]</span> <span class="o">--</span> <span class="n">Convert</span> <span class="n">ISO</span> <span class="n">date</span> <span class="nb">to</span> <span class="n">timestamp</span>
</span></span></code></pre></div><h2 id="总结">总结</h2>
<p>我们已经看到了一些 Date 和 DateTime 算法, 但令人兴奋的部分是 multi dispatch, 命名参数,带有 where 从句的子类型约束, given/ when 和 隐式 $_ 变量, 以及一些魔法, 当涉及到 MAIN subs 时。</p>
<p>原文请参见 <a href="https://perlgeek.de/blog-en/perl-6/2016-book-timestamp-converter.html">Raku By Example: Datetime Conversion for the Command Line</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Grammar 之分割结构化文本]]></title>
            <link href="http://localhost:1313/raku/2016-11-01-raku-grammar%E4%B9%8B%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E6%9C%AC/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/?utm_source=atom_feed" rel="related" type="text/html" title="第 10000 个素数" />
                <link href="http://localhost:1313/raku/2016-10-19-raku%E4%B8%AD%E7%9A%84with/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 with" />
                <link href="http://localhost:1313/raku/2016-09-26-these-keys-are-lta/?utm_source=atom_feed" rel="related" type="text/html" title="These keys are LTA" />
                <link href="http://localhost:1313/raku/2016-09-25-whatever-star/?utm_source=atom_feed" rel="related" type="text/html" title="Whatever Star" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/?utm_source=atom_feed" rel="related" type="text/html" title="我们的类型选择" />
            
                <id>http://localhost:1313/raku/2016-11-01-raku-grammar%E4%B9%8B%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E6%9C%AC/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2016-11-01T02:05:48+00:00</published>
            <updated>2016-11-01T02:05:48+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>如何使用 Grammar 分割一个有规律的文本文件? 首先这个文本有规律, 但是却是多行的。
我想将这样的文档分为独立的. 比如下面这个例子, 我想将他们分成3个独立的文本, 每个文本包含: [时间] Title 以及下面的 content lines. 实际的文件会有上千个, 最终输出的文本的名字是按照括号里面的时间来。</p>
<p><strong>sample.txt</strong></p>
<pre tabindex="0"><code>[28/04/2015 12:32] Title1

content line 1
content line 2
content line 3
content line 4
content line 5

balabala
balabala

[28/04/2015 12:16] Title2

content line 6
balabala
content line 7

[27/04/2015 17:30] ​Title3

content line 8
content line 9
content line 10
</code></pre><p>下面是解析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">use</span> <span class="nn">Grammar::Tracer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 开启 Grammar 调试有助于排错</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">StructedText</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">entry</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">head</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">   </span><span class="c1"># 每一项有一个标题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="c1"># 每个标题下面有很多行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">    }
</span></span></span><span class="line"><span class="cl"><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token head     </span><span class="p">{</span> <span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">datetime</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span> \<span class="k">s</span><span class="p">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">title</span><span class="p">&gt;</span><span class="sr"> }
</span></span></span><span class="line"><span class="cl"><span class="sr">    token datetime </span><span class="p">{</span>  <span class="p">&lt;</span><span class="s">filedate</span><span class="p">&gt;</span> \<span class="k">s</span><span class="p">+</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">filetime</span><span class="p">&gt;</span><span class="sr">    }
</span></span></span><span class="line"><span class="cl"><span class="sr">    token filedate </span><span class="p">{</span> <span class="o">[</span>\<span class="nb">d</span><span class="o">+]+</span>   <span class="nv">%</span>   <span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span>               <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token filetime </span><span class="p">{</span> <span class="o">[</span>\<span class="nb">d</span><span class="o">+]+</span>   <span class="nv">%</span>   <span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span>               <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token title    </span><span class="p">{</span>          \<span class="n">N</span><span class="o">+</span>                   <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token line  </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">[</span>
</span></span><span class="line"><span class="cl">		    <span class="p">&lt;</span><span class="s">!head</span><span class="p">&gt;</span>       <span class="c1"># 前面不是 head 标题</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span>             <span class="c1"># 点号匹配换行符</span>
</span></span><span class="line"><span class="cl">        <span class="o">]+</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">}
</span></span></span><span class="line"><span class="cl"><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr"></span><span class="c1"># Method &#39;ast&#39; not found for invocant of class &#39;Str&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"># make ~$&lt;filetime&gt;.subst(&#39;:&#39;, &#39;-&#39;, :g).ast;
</span></span></span><span class="line"><span class="cl"><span class="c1"># 字符串是没有 ast 方法的, Match 对象才有。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">class StructedText</span><span class="o">:</span><span class="p">:</span><span class="na">Actions</span><span class="sr"> </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">line</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span>                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">title</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">datetime</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span><span class="o">.</span><span class="nb">subst</span><span class="p">(</span><span class="k">rx</span><span class="p">/&lt;[</span><span class="sr">:/</span><span class="p">]&gt;/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># 在datime 中处理文件名, 替换掉特殊符号</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">head</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$&lt;datetime&gt;</span><span class="o">.</span><span class="nb">ast</span> <span class="p">}</span> <span class="c1"># head 使用了 datetime 这个 submatch 来构建 ast</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">entry</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;head&gt;</span><span class="o">.</span><span class="s">ast</span> <span class="o">=&gt;</span> <span class="nv">$&lt;line&gt;</span><span class="o">».</span><span class="k">made</span><span class="p">;</span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span>   <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;entry&gt;</span><span class="o">».</span><span class="nb">ast</span><span class="p">;</span>                 <span class="p">}</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">my </span><span class="nv">$actions</span><span class="sr"> </span><span class="o">=</span><span class="sr"> StructedText</span><span class="o">:</span><span class="p">:</span><span class="na">Actions</span><span class="ni">.</span><span class="sr">new;
</span></span></span><span class="line"><span class="cl"><span class="sr">my </span><span class="nv">$parsed</span><span class="sr"> </span><span class="o">=</span><span class="sr"> StructedText</span><span class="ni">.</span><span class="sr">parsefile</span><span class="p">(&#39;</span><span class="s1">sample.txt</span><span class="p">&#39;</span><span class="sr">, </span><span class="o">:</span><span class="nv">$actions</span><span class="p">)</span><span class="ni">.</span><span class="sr">made;
</span></span></span><span class="line"><span class="cl"><span class="sr">if </span><span class="nv">$parsed</span><span class="sr"> </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">@$parsed</span> <span class="k">-&gt;</span> <span class="nv">$e</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="o">~</span><span class="nv">$e</span><span class="o">.</span><span class="nb">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="sr">
</span></span></span></code></pre></div><p><code>ast</code> 和 <code>made</code> 一样, 都是使用孩子节点上已经制造好的(<code>make</code>)的 ast, 处理后再附件到(<code>$/.make</code>)父节点的 <code>$/</code> 上。
例如, 我们的 <code>TOP</code> 在使用 <code>entry</code> 时, 需要从 entry 中取回 ast (<code>$&lt;entry&gt;».ast</code>) 供它附加.而 method entry 中用到了 <code>&lt;head&gt;</code>, 这时 <!-- raw HTML omitted --> 一定是制造好了的(<code>make</code>), 我们现在要用它, 就使用 <code>.ast</code> 语法来取回这个 ast 片段, 同理, method entry 中用到了 <code>$line</code>, 则子节点 <code>$line</code> 已经为我们制造好了(<code>method line($/)  { $/.make: ~$/ }</code>), 使用时用 <code>.made</code> 方法取回就行了。</p>
<p>总而言之, TOP 是树根的话, 那么这一级会取回所有的 AST 块,  而它的孩子节点会依次取回下一节点的 AST 块, 逐级逐级的准备好(<code>make</code>)数据块, 然后再逐级往上附加数据块。</p>
<pre tabindex="0"><code>28-04-2015 12-32
28-04-2015 12-16
27-04-2015 17-30
</code></pre><p>完整的代码如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">grammar</span> <span class="nc">StructedText</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">entry</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="sr"> </span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">token</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">        </span><span class="p">&lt;</span><span class="nf">head</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">   </span><span class="c1"># 每一项有一个标题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="c1"># 每个标题下面有很多行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="sr">    }
</span></span></span><span class="line"><span class="cl"><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token head     </span><span class="p">{</span> <span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">datetime</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span> \<span class="k">s</span><span class="p">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">title</span><span class="p">&gt;</span><span class="sr"> }
</span></span></span><span class="line"><span class="cl"><span class="sr">    token datetime </span><span class="p">{</span>  <span class="p">&lt;</span><span class="s">filedate</span><span class="p">&gt;</span> \<span class="k">s</span><span class="p">+</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">filetime</span><span class="p">&gt;</span><span class="sr">    }
</span></span></span><span class="line"><span class="cl"><span class="sr">    token filedate </span><span class="p">{</span> <span class="o">[</span>\<span class="nb">d</span><span class="o">+]+</span> <span class="nv">%</span> <span class="p">&#39;</span><span class="s1">/</span><span class="p">&#39;</span> <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token filetime </span><span class="p">{</span> <span class="o">[</span>\<span class="nb">d</span><span class="o">+]+</span> <span class="nv">%</span> <span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span> <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token title    </span><span class="p">{</span> \<span class="n">N</span><span class="o">+</span>          <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">    token line  </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">[</span>
</span></span><span class="line"><span class="cl">            <span class="p">&lt;</span><span class="s">!head</span><span class="p">&gt;</span>       <span class="c1"># 前面不是 head 标题</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span>             <span class="c1"># 点号匹配换行符</span>
</span></span><span class="line"><span class="cl">        <span class="o">]+</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">}
</span></span></span><span class="line"><span class="cl"><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">class StructedText</span><span class="o">:</span><span class="p">:</span><span class="na">Actions</span><span class="sr"> </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">line</span>    <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span>                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">filedate</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span><span class="o">.</span><span class="nb">subst</span><span class="p">(</span><span class="k">rx</span><span class="p">/&lt;[</span><span class="sr">:/</span><span class="p">]&gt;/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">head</span>    <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span><span class="o">.</span><span class="nb">subst</span><span class="p">(</span><span class="k">rx</span><span class="p">/&lt;[</span><span class="sr">:/</span><span class="p">]&gt;/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">entry</span>   <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;head&gt;</span><span class="o">.</span><span class="s">ast</span> <span class="o">=&gt;</span> <span class="nv">$&lt;line&gt;</span><span class="o">».</span><span class="k">made</span><span class="p">;</span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nf">TOP</span>     <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;entry&gt;</span><span class="o">».</span><span class="nb">ast</span><span class="p">;</span>                 <span class="p">}</span>    
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">my </span><span class="nv">$actions</span><span class="sr"> </span><span class="o">=</span><span class="sr"> StructedText</span><span class="o">:</span><span class="p">:</span><span class="na">Actions</span><span class="ni">.</span><span class="sr">new;
</span></span></span><span class="line"><span class="cl"><span class="sr">my </span><span class="nv">$parsed</span><span class="sr"> </span><span class="o">=</span><span class="sr"> StructedText</span><span class="ni">.</span><span class="sr">parsefile</span><span class="p">(&#39;</span><span class="s1">sample.txt</span><span class="p">&#39;</span><span class="sr">, </span><span class="o">:</span><span class="nv">$actions</span><span class="p">)</span><span class="ni">.</span><span class="sr">made;
</span></span></span><span class="line"><span class="cl"><span class="sr">
</span></span></span><span class="line"><span class="cl"><span class="sr">if </span><span class="nv">$parsed</span><span class="sr"> </span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nv">@$parsed</span> <span class="k">-&gt;</span> <span class="nv">$e</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$filename</span> <span class="o">=</span> <span class="o">~</span><span class="nv">$e</span><span class="o">.</span><span class="nb">key</span><span class="o">.</span><span class="nb">match</span><span class="p">(/&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">&lt;(</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="se">\</span><span class="sr">[</span><span class="se">\</span><span class="sr">]</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="o">)&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;/)</span>  <span class="o">~</span> <span class="p">&#34;</span><span class="s2">.txt</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl">        <span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="nv">$filename</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$fh</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="o">~</span><span class="nv">$e</span><span class="o">.</span><span class="nb">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nv">$e</span><span class="o">.</span><span class="nb">value</span> <span class="k">-&gt;</span> <span class="nv">$v</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$fh</span><span class="o">.</span><span class="nb">say</span><span class="o">:</span> <span class="nv">$v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">生成文件 </span><span class="nv">$filename</span><span class="s2"> </span><span class="p">&#34;;</span>       
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="sr">
</span></span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[第 10000 个素数]]></title>
            <link href="http://localhost:1313/raku/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2016-10-19-raku%E4%B8%AD%E7%9A%84with/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 with" />
                <link href="http://localhost:1313/raku/2016-09-26-these-keys-are-lta/?utm_source=atom_feed" rel="related" type="text/html" title="These keys are LTA" />
                <link href="http://localhost:1313/raku/2016-09-25-whatever-star/?utm_source=atom_feed" rel="related" type="text/html" title="Whatever Star" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/?utm_source=atom_feed" rel="related" type="text/html" title="我们的类型选择" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-the-swift-language/?utm_source=atom_feed" rel="related" type="text/html" title="Swift 语言" />
            
                <id>http://localhost:1313/raku/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2016-10-26T16:41:13+00:00</published>
            <updated>2016-10-26T16:41:13+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>到目前为止(2016.10.26), Raku 的速度相比 Perl 5/Python 的差距还是很大的。以打印从 1 开始计数的第 10000 个素数为例, 使用如下版本的 Rakudo:</p>
<blockquote>
<p>This is Rakudo version 2016.07.1 built on MoarVM version 2016.07 implementing Raku.c.</p>
</blockquote>
<p>从程序执行耗费的时间来看, Raku 实在慢的如蜗牛。</p>
<h2 id="并发打印第10000个素数">并发打印第10000个素数</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">sub</span> <span class="nf">find-prime</span><span class="p">(</span><span class="nv">$count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$channel</span> <span class="o">=</span> <span class="kt">Channel</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="k">start</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">^</span><span class="nv">$count</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nv">$channel</span><span class="o">.</span><span class="nb">send</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">if</span> <span class="o">.</span><span class="nb">is-prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>  
</span></span><span class="line"><span class="cl">        <span class="k">LEAVE</span> <span class="nv">$channel</span><span class="o">.</span><span class="nb">close</span> <span class="k">unless</span> <span class="nv">$channel</span><span class="o">.</span><span class="nb">closed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nv">$channel</span><span class="o">.</span><span class="nb">list</span> <span class="k">but</span> <span class="k">role</span> <span class="nc">::</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">channel</span> <span class="p">{</span> <span class="nv">$channel</span> <span class="p">}</span> <span class="p">};;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@primes</span> <span class="o">=</span> <span class="nf">find-prime</span><span class="p">(</span><span class="mi">110000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#for @primes {</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    @primes.channel.close if $++ &gt; 110000; # hard-close the channel after 110000 found primes</span>
</span></span><span class="line"><span class="cl"><span class="c1">#    .say if $++ %% 100 # print every 100th prime</span>
</span></span><span class="line"><span class="cl"><span class="c1">#}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@primes</span><span class="o">[</span><span class="mi">10000</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</span></span></code></pre></div><p>上面的并发查找素数, 用时 <strong>35</strong> 秒多! <a href="https://raw.githubusercontent.com/raku/specs/master/S14-roles-and-parametric-types.pod">but</a> 的作用类似于 <code>does</code>。</p>
<h2 id="gathertake-版">gather/take 版</h2>
<p><code>gather/take</code> 类似于 Python 中的 <code>yield</code> , 用于惰性求值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@vals</span> <span class="o">=</span> <span class="nb">lazy</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">^</span><span class="no">Inf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">take</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">.</span><span class="nb">is-prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@vals</span><span class="o">[</span><span class="mi">10000</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</span></span></code></pre></div><p>用时 25 秒多, 比并发版本的要快一点。</p>
<h2 id="普通版本">普通版本</h2>
<p>如果不使用 <code>is-prime</code> 函数, 查找第 10000 个素数就巨慢:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">lazy</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="nl">CANDIDATE</span><span class="o">:</span> <span class="k">for</span>  <span class="mi">2</span> <span class="o">..</span> <span class="mi">110000</span> <span class="k">-&gt;</span> <span class="nv">$candidate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    	 <span class="k">for</span>  <span class="mi">2</span> <span class="o">..</span> <span class="nb">sqrt</span> <span class="nv">$candidate</span>  <span class="k">-&gt;</span> <span class="nv">$divisor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    		<span class="nb">next</span> <span class="n">CANDIDATE</span> <span class="k">if</span> <span class="nv">$candidate</span> <span class="nv">%</span> <span class="nv">$divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    	 <span class="p">}</span>
</span></span><span class="line"><span class="cl">    	<span class="nb">take</span> <span class="nv">$candidate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span> <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@vals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@vals</span><span class="o">[</span><span class="mi">10000</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</span></span></code></pre></div><p>下面这个 <code>lazy gather</code> 根本没有起作用, 原因是 feed 运算符还没实现 lazy 求值? - 巨慢。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">lazy</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">^</span><span class="no">Inf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">take</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">.</span><span class="nb">is-prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@vals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@vals</span><span class="o">[</span><span class="mi">10000</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</span></span></code></pre></div><p>没有使用 <code>is-prime</code> 函数的普通指数运算也会巨慢:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"> <span class="k">my</span> <span class="nv">@vals</span> <span class="o">=</span> <span class="nb">lazy</span> <span class="k">gather</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">110000</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nb">take</span> <span class="nv">$_</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nv">$_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">%</span> <span class="nv">$_</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nv">$_</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nb">say</span> <span class="nv">@vals</span><span class="o">[</span><span class="mi">10000</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 with]]></title>
            <link href="http://localhost:1313/raku/2016-10-19-raku%E4%B8%AD%E7%9A%84with/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2016-09-26-these-keys-are-lta/?utm_source=atom_feed" rel="related" type="text/html" title="These keys are LTA" />
                <link href="http://localhost:1313/raku/2016-09-25-whatever-star/?utm_source=atom_feed" rel="related" type="text/html" title="Whatever Star" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/?utm_source=atom_feed" rel="related" type="text/html" title="我们的类型选择" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-the-swift-language/?utm_source=atom_feed" rel="related" type="text/html" title="Swift 语言" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF/?utm_source=atom_feed" rel="related" type="text/html" title="捕获错误" />
            
                <id>http://localhost:1313/raku/2016-10-19-raku%E4%B8%AD%E7%9A%84with/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2016-10-19T19:17:03+00:00</published>
            <updated>2016-10-19T19:17:03+00:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="with-orwith-without">with orwith without</h2>
<p><code>with</code> 语句就像 <code>if</code> 但是是为了测试是否定义而非真假。此外, 它主题化了条件, 这很像 <code>given</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">with</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="c1"># print 0</span>
</span></span></code></pre></div><p>代替 <code>elsif</code>, <code>orwith</code> 用于把是否定义的测试链接起来:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># The below code says &#34;Found a at 0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;;</span>
</span></span><span class="line"><span class="cl"><span class="k">with</span>   <span class="nv">$s</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found a at </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">orwith</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">b</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found b at </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">orwith</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">index</span><span class="p">(&#34;</span><span class="s2">c</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Found c at </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>                 <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Didn&#39;t find a, b or c</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>你可以混合基于 <code>if</code> 的从句和基于 <code>with</code> 的从句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="c1"># This says &#34;Yes&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">orwith</span> <span class="kt">Nil</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No</span><span class="p">&#34;</span> <span class="p">}</span> <span class="k">orwith</span> <span class="mi">0</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Yes</span><span class="p">&#34;</span> <span class="p">};</span>
</span></span></code></pre></div><p>至于 <code>unless</code>, 你可以使用 <code>without</code> 来检测未定义(undefinedness), 但是你不可以添加 <code>else</code> 从句:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="kt">Any</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">without</span> <span class="nv">$answer</span> <span class="p">{</span> <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">Got: </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">}</span>
</span></span></code></pre></div><p>我们还有 <code>with</code> 和 <code>without</code> 语句修饰符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Any</span><span class="o">,</span> <span class="kt">True</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="mi">42</span> <span class="k">with</span> <span class="nv">$answer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">undefined answer</span><span class="p">&#34;</span> <span class="k">without</span> <span class="nv">$answer</span><span class="p">;</span>
</span></span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[These keys are LTA]]></title>
            <link href="http://localhost:1313/raku/2016-09-26-these-keys-are-lta/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/raku/2016-09-25-whatever-star/?utm_source=atom_feed" rel="related" type="text/html" title="Whatever Star" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/?utm_source=atom_feed" rel="related" type="text/html" title="我们的类型选择" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-the-swift-language/?utm_source=atom_feed" rel="related" type="text/html" title="Swift 语言" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF/?utm_source=atom_feed" rel="related" type="text/html" title="捕获错误" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/?utm_source=atom_feed" rel="related" type="text/html" title="面向对象编程和面向协议编程" />
            
                <id>http://localhost:1313/raku/2016-09-26-these-keys-are-lta/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2016-09-26T12:15:14+00:00</published>
            <updated>2016-09-26T12:15:14+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>在折腾枚举作为子例程布尔选项的时候, 我发现默认的错误信息不够酷。</p>
<ul>
<li><code>Constraint type check failed for parameter '@options'</code></li>
</ul>
<p>让错误信息变得更具体有点困难。我们来创建几个 exceptions 来告诉我们当东西出错时究竟发生了什么。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">X::Paramenter::Exclusive</span> <span class="k">is</span> <span class="kt">Exception</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">has</span> <span class="nv">$.type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">Parameters of </span><span class="p">{</span><span class="nv">$.type</span><span class="o">.</span><span class="nb">perl</span><span class="p">}</span><span class="s2"> are mutual exclusive</span><span class="p">&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在我们能检查 <em>Find::Type</em> 的选项是否是独占的从而抛出异常。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="nf">exclusive-argument</span><span class="p">(</span><span class="nv">@options</span><span class="o">,</span> <span class="n">Find::Type</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">fail</span> <span class="ne">X::Paramenter::Exclusive</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">type</span> <span class="o">=&gt;</span> <span class="n">Find::Type</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">X::Parameter::UnrecognisedOption</span> <span class="k">is</span> <span class="kt">Exception</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.unrecognised</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">Option </span><span class="p">{</span> <span class="nv">$.unrecognised</span> <span class="p">}</span><span class="s2"> not any of </span><span class="p">{</span> <span class="nv">$.type</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="p">(</span><span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span> <span class="ow">Z</span><span class="o">~</span> <span class="o">.</span><span class="nb">enums</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">flat</span> <span class="p">})</span><span class="o">.</span><span class="nb">flat</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;)</span> <span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>因为枚举对类型而言是容器, 我们能使用集合操作符来检查并挑选出不匹配的选项(基本上, +options 吞噬的任何东西我们都不知道)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="ow">or</span> <span class="nb">fail</span> <span class="ne">X::Parameter::UnrecognisedOption</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">type</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">Find::Type</span><span class="o">,</span> <span class="n">Find::Options</span><span class="p">)</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">unrecognised</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="nb">item</span> <span class="o">∖</span> <span class="p">(</span><span class="o">|</span><span class="n">Find::Type::</span><span class="o">.</span><span class="nb">values</span><span class="o">,</span> <span class="o">|</span><span class="n">Find::Options::</span><span class="o">.</span><span class="nb">values</span><span class="p">)</span> <span class="p">)</span>
</span></span></code></pre></div><p>把错误信息拼接在一块儿有点复杂因为我们可以在一个给定的枚举中得到所有枚举键的一个列表, 除了那些不知道它们的限定名的。 我们不得不在枚举名的前面手动前置一个 <code>::</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">class</span> <span class="ne">X::Parameter::UnrecognisedOption</span> <span class="k">is</span> <span class="kt">Exception</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">has</span> <span class="nv">$.unrecognised</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">method</span> <span class="nb">message</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">&#34;</span><span class="s2">Option </span><span class="p">{</span> <span class="nv">$.unrecognised</span> <span class="p">}</span><span class="s2"> not any of </span><span class="p">{</span> <span class="nv">$.type</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="p">(</span><span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span> <span class="ow">Z</span><span class="o">~</span> <span class="o">.</span><span class="nb">enums</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">flat</span> <span class="p">}</span> <span class="p">}&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这导致了一个更令人惊叹的错误信息:</p>
<pre tabindex="0"><code>Option 42 not any of Type::File, Type::Dir, Type::Symlink, Options::Recursive, Options::Keep-going
</code></pre><p>这看起来都很普通。我们拥有一个参数化的吞噬参数, 它带有一个或多个枚举而那些枚举可能拥有一个 flag 告诉它们是否用作单选按钮。听起来这个 idiom 会很适合这个模块。</p>
<blockquote>
<p>翻译的不好, 最好看原文。</p>
</blockquote>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Whatever Star]]></title>
            <link href="http://localhost:1313/raku/2016-09-25-whatever-star/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%88%91%E4%BB%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/?utm_source=atom_feed" rel="related" type="text/html" title="我们的类型选择" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%BA%8C%E7%AB%A0-the-swift-language/?utm_source=atom_feed" rel="related" type="text/html" title="Swift 语言" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF/?utm_source=atom_feed" rel="related" type="text/html" title="捕获错误" />
                <link href="http://localhost:1313/notes/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/?utm_source=atom_feed" rel="related" type="text/html" title="面向对象编程和面向协议编程" />
                <link href="http://localhost:1313/notes/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E9%97%B4%E4%BC%A0%E5%80%BC/?utm_source=atom_feed" rel="related" type="text/html" title="使用代理进行页面传值" />
            
                <id>http://localhost:1313/raku/2016-09-25-whatever-star/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2016-09-25T16:14:05+00:00</published>
            <updated>2016-09-25T16:14:05+00:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="whatever-是什么">Whatever 是什么?</h2>
<blockquote>
<p>Placeholder for unspecified value/parameter - 未指定的值/参数的占位符。</p>
</blockquote>
<p><code>*</code> 字面量在 「term」 位置上创建 「Whatever」 对象。
<code>*</code> 的大部分魔法来自于 「Whatever 柯里化」. 当 <code>*</code> 作为 item 与很多操作符组合使用时, 编译器会把表达式转换为 「WhateverCode」 类型的闭包.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="o">*</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1"># same as   -&gt; $x { $x + 2 };</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">$c</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>              <span class="c1"># 6</span>
</span></span></code></pre></div><p>如果一个表达式中有 N 个 <code>*</code>, 则会产生一个含有 <code>N</code> 个参数的闭包:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span><span class="p">;</span>          <span class="c1"># same as   -&gt; $x, $y { $x + $y }</span>
</span></span></code></pre></div><p>在复杂的表达式中使用 <code>*</code> 也会产生闭包:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="o">*</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>      <span class="c1"># same as   -&gt; $x { 4 * $x + 5 }</span>
</span></span></code></pre></div><p>在 <code>*</code> 号身上调用方法也会产生闭包:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="o">*.</span><span class="nb">uc</span><span class="p">;</span>      <span class="c1"># same as &lt;a b c&gt;.map: -&gt; $char { $char.uc }</span>
</span></span></code></pre></div><p>前面提到, 不是所有的操作符和语法都会把 <code>*</code> 柯里化为 「WhateverCode」。
下面这几种情况, <code>*</code> 仍旧是 「Whatever 对象」。</p>
<pre tabindex="0"><code>例外               Example    What it does

逗号               1,*,2      用一个 * 元素生成一个 Parcel
范围操作符         1..*       Range.new(:from(1), :to(*));
序列操作符         1 ... *    无限列表
智能匹配           1 ~~ *     返回 True
赋值               $x = *     把 * 赋值给 $x
绑定               $x := *    把 * 绑定给 $x
列表重复           1 xx *     生成无限列表
</code></pre><p>范围操作符被特殊处理. 它们不使用 Whatever-Stars 柯里化, 但是它们使用 「WhateverCode」 进行柯里化.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>        <span class="c1"># Range</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">..*-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>      <span class="c1"># WhateverCode</span>
</span></span></code></pre></div><p>上面的 <code>*-1</code> 是作为参数传递了。</p>
<p>下面这些也能使用:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..*</span><span class="p">;</span>          <span class="c1"># infinite loop</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">..*]</span><span class="p">;</span>           <span class="c1"># 1 2 3 4</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">..*-</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>         <span class="c1"># 1 2 3</span>
</span></span></code></pre></div><p>因为 Whatever-currying 是纯粹的语法编译器转换, 这不会在运行时把存储的 Whatever-stars 柯里化为 WhateverCodes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>                 <span class="c1"># not a closure, dies because</span>
</span></span><span class="line"><span class="cl">                        <span class="c1"># it can&#39;t coerce $x to Numeric</span>
</span></span></code></pre></div><p>存储 Whatever-stars 的使用案例像上面提到的那样, 但要把柯里化异常的情况也包含进去. 例如, 如果你想要一个默认的无限序列:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$max</span>    <span class="o">=</span> <span class="nf">potential-upper-limit</span><span class="p">()</span> <span class="o">//</span> <span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$series</span> <span class="o">=</span> <span class="nf">known-lower-limit</span><span class="p">()</span> <span class="o">...</span> <span class="nv">$max</span><span class="p">;</span>
</span></span></code></pre></div><p>一个存储后的 <code>*</code> 会在智能匹配的特殊情况下生成 WhateverCode. 注意, 正被柯里化的并非真正储存的 <code>*</code>, 而是在 LHS 上的 <code>*</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$constraint</span> <span class="o">=</span> <span class="nf">find-constraint</span><span class="p">()</span> <span class="o">//</span> <span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$maybe-always-matcher</span> <span class="o">=</span> <span class="o">*</span> <span class="o">~~</span> <span class="nv">$constraint</span><span class="p">;</span>
</span></span></code></pre></div><p>如果这个假定的 find-constraint 没有找到约束, 则 maybe-always-matcher 会对任何东西都返回 True.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">$maybe-always-matcher</span><span class="p">(</span><span class="mi">555</span><span class="p">);</span>      <span class="c1"># True</span>
</span></span><span class="line"><span class="cl"><span class="nv">$maybe-always-matcher</span><span class="p">(</span><span class="kt">Any</span><span class="p">);</span>      <span class="c1"># True</span>
</span></span></code></pre></div><h2 id="whatever-star">Whatever Star</h2>
<p>当作为一个「项」使用时， 我们把 <code>*</code> 叫做 &ldquo;Whatever&rdquo;。当不是实际值时，它用作占位符。例如, <code>1, 2, 3 ... *</code>，意思是没有终结点的自然数序列。</p>
<h2 id="whatever-闭包">Whatever 闭包</h2>
<p>Whatever 最强大的用处是 「Whatever」 闭包。</p>
<p>对于 Whatever 没有特殊意义的普通操作符：把 Whatever 当作参数传递时就创建了一个闭包！ 所以，举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">*</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># 等价于 -&gt; $a { $a + 1 }</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="c1"># 等价于 -&gt; $a, $b { $a + $b }</span>
</span></span></code></pre></div><p>一个星号占一个坑儿。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>                  <span class="c1"># 返回 @list 数组中所有大于 10 的元素</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$ele</span> <span class="p">{</span> <span class="nv">$ele</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="p">}</span> <span class="p">)</span> <span class="c1"># 同上, 使用显式的闭包</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$ele</span> <span class="p">{</span> <span class="nv">$ele</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="p">}</span>   <span class="c1"># 同上, 使用冒号调用方式</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10</span>                  <span class="c1"># 同上</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="p">}</span>             <span class="c1"># 同上</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*</span> <span class="o">+</span> <span class="o">*</span><span class="p">)</span>                    <span class="c1"># 返回 @list 数组中每两个元素的和</span>
</span></span><span class="line"><span class="cl"><span class="nv">@list</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">+</span><span class="nv">$b</span> <span class="p">}</span> <span class="p">)</span>    <span class="c1"># 同上, 使用显式的闭包</span>
</span></span></code></pre></div><p>如果给 <code>@a[ ]</code> 的方括号里面传递一个闭包， 它会把 <code>@a</code> 数组的元素个数作为参数传递并计算！</p>
<p>数组的最后一个元素</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span>  <span class="mi">1</span><span class="o">,</span><span class="mi">22</span><span class="o">,</span><span class="mi">33</span><span class="o">,</span><span class="mi">11</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="k">-&gt;</span><span class="nv">$a</span> <span class="p">{</span><span class="nv">$a-1</span><span class="p">}</span><span class="o">]</span><span class="p">;</span> <span class="c1"># $a  即为数组@a 的元素个数</span>
</span></span></code></pre></div><p>数组的倒数第二个元素</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[*-</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="k">-&gt;</span><span class="nv">$a</span> <span class="p">{</span><span class="nv">$a-2</span><span class="p">}</span><span class="o">]</span><span class="p">;</span>
</span></span></code></pre></div><p>所以 <code>@a[*/2]</code> 是 <code>@a</code> 数组的中间元素, <code>@a[1..*-2]</code>  是 <code>@a</code> 中不包含首尾元素的其它元素。
<code>1, 1, * + * ... *</code>  是一个无限列表, <code>* + *</code> 是后来值的生成规则， 最后一个 <code>*</code> 表示没有终结测试。</p>
<p>把闭包存储在标量中</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$b</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nv">$a</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># 4</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@add_by_one</span> <span class="o">=</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span> <span class="c1"># 对 @list 中的每个元素加 1</span>
</span></span></code></pre></div><p>Raku 的列表求值是惰性的,只要你不要求最后一个元素, 无限列表是没问题的。使用绑定 <code>(:=)</code> 操作符把列表赋值给变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@fib</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span>
</span></span></code></pre></div><p>如果我稍后要 <code>@fib[40]</code> 的值, 会生成足够多的元素以获取数组的第 41 个元素,那些生成的元素会被记忆。尽管未来, 如果列表未绑定给变量, 之前的值会被忘记, 大部分 Raku 列表函数能作用并生成惰性列表。</p>
<p><code>@a.map</code> 和 <code>@a.grep</code> 都生成「惰性列表」， 即使 <code>@a</code> 不是惰性的。
<code>@fib.grep(* %% 2)</code> 是一个偶数惰性列表，例如 <code>@fib Z @a</code> 生成一个惰性列表： <code>@fib[0], @a[0], @fib[1], @a[1] ...</code>。
给 for 循环传递一个无限列表是没问题的， 它会循环直到停止。</p>
<p>但是要注意不能使用嵌套的闭包:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="o">*</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">===</span><span class="n">SORRY</span><span class="o">!===</span> <span class="n">Error</span> <span class="k">while</span> <span class="n">compiling:</span>
</span></span><span class="line"><span class="cl"><span class="n">Malformed</span> <span class="n">double</span> <span class="n">closure</span><span class="p">;</span> <span class="kt">WhateverCode</span> <span class="k">is</span> <span class="nc">already</span> <span class="n">a</span> <span class="n">closure</span> <span class="k">without</span> <span class="n">curlies</span><span class="o">,</span>
</span></span><span class="line"><span class="cl"><span class="nb">so</span> <span class="n">either</span> <span class="nb">remove</span> <span class="n">the</span> <span class="n">curlies</span> <span class="ow">or</span> <span class="k">use</span> <span class="nn">valid</span> <span class="nb">parameter</span> <span class="n">syntax</span> <span class="nb">instead</span> <span class="k">of</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="nb">at</span> <span class="nb">line</span> <span class="mi">2</span> <span class="o">------&gt;</span> <span class="p">&lt;</span><span class="s">BOL</span><span class="p">&gt;&lt;</span><span class="s">HERE</span><span class="p">&gt;&lt;</span><span class="s">EOL</span><span class="p">&gt;</span>
</span></span></code></pre></div><p>注意上面的错误信息, 说的已经很明显了, WhateverCode 已经是一个不带花括号的闭包了, 所以要么移除花括号, 要么使用合法的参数语法代替 <code>*</code> 号, 提示信息足够清楚了。所以, 按照提示:</p>
<p>方法一：使用 <code>$_</code> 代替 <code>*</code> 号</p>
<pre tabindex="0"><code>&gt; my @b = @a.map: { $_ ** 2 }
[1 4 9 16 25 36 49 64 81 100]
</code></pre><p>方法二：</p>
<pre tabindex="0"><code>&gt; my @b = @a.map:  * ** 2
[1 4 9 16 25 36 49 64 81 100]
</code></pre><p>方法三, 显式的使用 cloure：</p>
<pre tabindex="0"><code>&gt; my @b = @a.map: -&gt; $item { $item ** 2 }
[1 4 9 16 25 36 49 64 81 100]
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[When and Where]]></title>
            <link href="http://localhost:1313/raku/2015-03-15-when%E5%92%8Cwhere/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="http://localhost:1313/notes/%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 自动发送邮件" />
                <link href="http://localhost:1313/notes/%E7%BB%83%E4%B9%A0%E9%A2%98/?utm_source=atom_feed" rel="related" type="text/html" title="Perl 练习" />
                <link href="http://localhost:1313/notes/%E4%BA%A7%E5%93%81%E5%8C%B9%E9%85%8D/?utm_source=atom_feed" rel="related" type="text/html" title="产品匹配" />
                <link href="http://localhost:1313/notes/%E7%94%A8%E5%AD%97%E7%AC%A6%E7%94%BB%E7%BE%8E%E5%8C%96%E4%B8%80%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E7%AA%97%E5%8F%A3/?utm_source=atom_feed" rel="related" type="text/html" title="用字符画美化一下命令提示符窗口" />
                <link href="http://localhost:1313/notes/win32--ieautomation-%E4%BD%BF%E7%94%A8ie%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E8%A1%8Cweb%E5%BA%94%E7%94%A8%E8%87%AA%E5%8A%A8%E5%8C%96/?utm_source=atom_feed" rel="related" type="text/html" title="使用IE浏览器进行Web应用自动化" />
            
                <id>http://localhost:1313/raku/2015-03-15-when%E5%92%8Cwhere/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2015-03-15T13:15:00+03:00</published>
            <updated>2015-03-15T13:15:00+03:00</updated>
            
            
            <content type="html"><![CDATA[<h2 id="when-可以用在主题化_的语句中">When 可以用在主题化($_)的语句中</h2>
<p>Perl 里面有个特殊的变量叫 <code>$_</code>, 即主题化变量, the variable in question.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">for</span> <span class="p">(&#39;</span><span class="s1">Swift</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">PHP</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;)</span> <span class="k">-&gt;</span> <span class="nv">$item</span>  <span class="p">{</span> <span class="nb">say</span> <span class="nv">$item</span> <span class="k">when</span> <span class="nv">$item</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr">P</span><span class="p">/</span> <span class="p">}</span>    
</span></span><span class="line"><span class="cl"><span class="n">PHP</span>                                                                                  
</span></span><span class="line"><span class="cl"><span class="n">Python</span>                                                                               
</span></span><span class="line"><span class="cl"><span class="kt">Perl</span>  
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">for</span> <span class="p">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">56</span><span class="o">,</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="o">*&gt;</span><span class="mi">40</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">56</span>
</span></span><span class="line"><span class="cl"><span class="mi">42</span>
</span></span></code></pre></div><p>而 <em>where</em> 用于对类型进行约束.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-raku" data-lang="raku"><span class="line"><span class="cl"><span class="o">&gt;</span> <span class="k">for</span> <span class="p">(&#39;</span><span class="s1">Swift</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">PHP</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">42</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$item</span>  <span class="k">where</span> <span class="nv">$item</span> <span class="o">~~</span> <span class="kt">Str</span>  <span class="p">{</span><span class="nb">say</span> <span class="nv">$item</span><span class="p">}</span>   
</span></span><span class="line"><span class="cl"><span class="n">Swift</span>                                                                                    
</span></span><span class="line"><span class="cl"><span class="n">PHP</span>                                                                                      
</span></span><span class="line"><span class="cl"><span class="n">Python</span>                                                                                   
</span></span><span class="line"><span class="cl"><span class="kt">Perl</span>                                                                                     
</span></span><span class="line"><span class="cl"><span class="n">Constraint</span> <span class="nb">type</span> <span class="n">check</span> <span class="n">failed</span> <span class="k">for</span> <span class="nb">parameter</span> <span class="p">&#39;</span><span class="s1">$item</span><span class="p">&#39;</span>       
</span></span></code></pre></div><p>未完待续.</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="http://localhost:1313/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
</feed>
