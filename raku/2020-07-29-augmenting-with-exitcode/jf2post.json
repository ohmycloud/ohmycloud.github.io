{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003ch2 id=\"categories-raku\"\u003ecategories: [\u0026ldquo;Raku\u0026rdquo;]\u003c/h2\u003e\n\u003cp\u003e在我的上一篇文章中，我找到了一个很好的方法来匹配 exitcode。我想把它扩展到与 STDERR 匹配，如果 exitcode 是非零。我已经有了一种方法来捕获一个管道的所有错误流。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003epx\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nb\"\u003efind\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003etmp\u003c/span\u003e\u003cspan class=\"o\"\u003e»\u003c/span\u003e \u003cspan class=\"o\"\u003e|»\u003c/span\u003e \u003cspan class=\"n\"\u003epx\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003eyour-script-here\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e|»\u003c/span\u003e \u003cspan class=\"nv\"\u003e@a\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003estderr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eCapture\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我使用 \u003ccode\u003eCapture\u003c/code\u003e（类型对象）的方式和我们使用 \u003ccode\u003e*\u003c/code\u003e 或 Whatever 一样。它只是表示，神奇的东西应该发生。这个神奇的东西归结为把所有 \u003ccode\u003eSTDERR\u003c/code\u003e 流粘到一个二维数组中。如果我想处理错误，我可能想对 exitcode、shell 命令的名称和它输出到 \u003ccode\u003eSTDERR\u003c/code\u003e 的部分进行匹配。像下面这样的语法会很好。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eExitcode\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eSTDERR\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003eabc def ghi\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;)\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eexitint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003ecommand\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003egiven\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhen\u003c/span\u003e ‚\u003cspan class=\"nb\"\u003efind\u003c/span\u003e‘ \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003edef\u003c/span\u003e\\\u003cspan class=\"k\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"se\"\u003e\\S\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nb\"\u003enote\u003c/span\u003e „\u003cspan class=\"nb\"\u003efind\u003c/span\u003e \u003cspan class=\"n\"\u003eterminated\u003c/span\u003e \u003cspan class=\"k\"\u003ewith\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e \u003cspan class=\"ow\"\u003eand\u003c/span\u003e \u003cspan class=\"nv\"\u003e$0\u003c/span\u003e“\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e事实证明，在 Junction 中得到对 \u003ccode\u003eStr\u003c/code\u003e、\u003ccode\u003eNumeric\u003c/code\u003e 和 \u003ccode\u003eRegex\u003c/code\u003e 的匹配是很容易做到的。我们需要做的就是增强 \u003ccode\u003eRegex\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eaugment\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eRegex\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emulti\u003c/span\u003e \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nb\"\u003eACCEPTS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003eRegex:D:\u003c/span\u003e \u003cspan class=\"n\"\u003eShell::Piping::Exitcode:D\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e?\u003c/span\u003e\u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSTDERR\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e„\\\u003cspan class=\"n\"\u003en\u003c/span\u003e“\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ematch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eaugment\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eInt\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emulti\u003c/span\u003e \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nb\"\u003eACCEPTS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eInt\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eD\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eShell::Piping::Exitcode:D\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eACCEPTS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eexitint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eaugment\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eStr\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emulti\u003c/span\u003e \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nb\"\u003eACCEPTS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eStr\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003eD\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eShell::Piping::Exitcode:D\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eACCEPTS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ecommand\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这只对匹配有效。我无法用这种方式将 \u003ccode\u003e(\\S+)\u003c/code\u003e 捕获到 \u003ccode\u003e$0\u003c/code\u003e。我们知道并喜欢 \u003ccode\u003eStr.match\u003c/code\u003e 能做到这一点-看起来很容易。让我们从它那里\u003cdel\u003e偷\u003c/del\u003e学代码吧!\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eproto\u003c/span\u003e \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nb\"\u003ematch\u003c/span\u003e\u003cspan class=\"ow\"\u003e(|)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nv\"\u003e$/\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nf\"\u003enqp::getlexcaller\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u0026#39;\u003c/span\u003e\u003cspan class=\"s1\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026#39;);\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e所以 \u003ccode\u003e.match\u003c/code\u003e 要做的第一件事就是将本地的 \u003ccode\u003e$/\u003c/code\u003e 与调用者的 \u003ccode\u003e$/\u003c/code\u003e 绑定。因此，任何对本地版本的改变都会实际改变调用者的版本。我试着模仿了一下，但没有成功。无论是 nqp 方式还是稍微干净的 Raku 方式都不行。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eaugment\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eRegex\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emulti\u003c/span\u003e \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nb\"\u003eACCEPTS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003eRegex:D:\u003c/span\u003e \u003cspan class=\"n\"\u003eShell::Piping::Exitcode:D\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         \u003cspan class=\"n\"\u003eCALLER::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e?\u003c/span\u003e\u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSTDERR\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e„\\\u003cspan class=\"n\"\u003en\u003c/span\u003e“\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ematch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e至少在 \u003ccode\u003egiven/when\u003c/code\u003e 块中不行。简单的说 \u003ccode\u003e$ex ~~ defs(\\S+);\u003c/code\u003e 在全局作用域内就能正常工作。我甚至得到了一个错误信息：\u003ccode\u003eOUTER\u003c/code\u003e 中不存在 \u003ccode\u003e\\$\u003c/code\u003e。考虑到根据定义，它应该存在于每一个块中，这很奇怪。\u003c/p\u003e\n\u003cp\u003e我们可以用下面的构造来检查调用者的词法作用域。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"n\"\u003eCALLER::\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ekeys\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003esay\u003c/span\u003e \u003cspan class=\"kt\"\u003eBacktrace\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003enew\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003egist\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这将输出词法和有多少堆栈帧。而事实上，\u003ccode\u003egiven/when\u003c/code\u003e 确实引入了一个额外的栈帧，它包含 \u003ccode\u003e$_\u003c/code\u003e 但不包含 \u003ccode\u003e$/\u003c/code\u003e（以及其他一些零碎的东西）。由于 caller 是一个 Stash，什么是转半的 Hash，我们可以像往常一样使用 \u003ccode\u003e:existence\u003c/code\u003e，再增加一个 caller。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eaugment\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"kt\"\u003eRegex\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003emulti\u003c/span\u003e \u003cspan class=\"k\"\u003emethod\u003c/span\u003e \u003cspan class=\"nb\"\u003eACCEPTS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003eRegex:D:\u003c/span\u003e \u003cspan class=\"n\"\u003eShell::Piping::Exitcode:D\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eCALLER::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;:\u003c/span\u003e\u003cspan class=\"s\"\u003eexists\u003c/span\u003e \u003cspan class=\"o\"\u003e??\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCALLER::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e!!\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCALLER::CALLER::\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"s\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$/\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e?\u003c/span\u003e\u003cspan class=\"nv\"\u003e$ex\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSTDERR\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e„\\\u003cspan class=\"n\"\u003en\u003c/span\u003e“\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ematch\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e现在，它的工作原理与设想的一样。\u003c/p\u003e\n\u003cp\u003e然而-实际上 HOWEVER-我正在增强一个内置类。这是有风险的。我不是一个人。我们得到了一个 ircbot，可以在生态系统的源代码中 grep。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e20:01 \u0026lt; gfldex\u0026gt; greppable6: augment class\n20:01 \u0026lt; greppable6\u0026gt; gfldex, 49 lines, 26 modules: https://gist.github.com/4088b5b8e7b51d94276b15500c240a5f\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我们编写模块时，我们会引入自定义名称所在的作用域。一个模块的用户可以决定将这些名字导入到用户控制的作用域中。当我们增强模块时，我们将一个新的名字引入到一个全局的作用域中。如果两个模块有相同的想法会怎样？如果注入的方法实际上是一个多，那么它很可能会工作。但它不一定要这样。当两个或更多的 \u003ccode\u003emulti\u003c/code\u003e 候选者具有相同的优先权时，第一个被发现的将获胜。通过在一个非 \u003ccode\u003emulti\u003c/code\u003e 上使用 \u003ccode\u003eaugment\u003c/code\u003e，我们有机会得到一个错误信息。如果我们通过 \u003ccode\u003eMOP\u003c/code\u003e 添加一个方法，我们就不会。如果我想在 \u003ccode\u003ewhen\u003c/code\u003e 语句或代码块中允许智能匹配，我需要提供在 \u003ccode\u003e~~\u003c/code\u003e 的 LHS 上有我的自定义类的能力。所以没有办法绕过 \u003ccode\u003eaugment\u003c/code\u003e。我甚至可以说，这就是在语言设计中加入 \u003ccode\u003eaugment\u003c/code\u003e 的原因。当我们考虑到 Raku 越来越不年轻，语言版本不断增加时，情况就会变得更糟。一个测试马虎的模块可能会与语言版本增加的新方法发生碰撞。我们是否应该在 \u003ccode\u003ecompunit\u003c/code\u003e 中强制执行一个带有语言版本的使用语句，并带有一个增强语句？\u003c/p\u003e\n\u003cp\u003e这真的困扰着我。我们可以使用 \u003ccode\u003eMETA6\u003c/code\u003e 并添加字段 \u003ccode\u003eaugments: \u0026quot;Cool,Int,Regex\u0026quot;\u003c/code\u003e。这样 zef 就有机会发现碰撞并提供一个警告。遗憾的是，我们没有办法强制执行这个功能（因为 \u003ccode\u003eEVAL\u003c/code\u003e）。我会花更多的时间来思考这个问题，可能会开始一个\u003ca href=\"https://github.com/Raku/problem-solving\"\u003e解决问题\u003c/a\u003e的问题。\u003c/p\u003e\n","text":"categories: [\u0026ldquo;Raku\u0026rdquo;] 在我的上一篇文章中，我找到了一个很好的方法来匹配 exitcode。我想把它扩展到与 STDERR 匹配，如果 exitcode 是非零。我已经有了一种方法来捕获一个管道的所有错误流。\npx\u0026lt;find /tmp» |» px\u0026lt;your-script-here\u0026gt; |» @a :stderr(Capture); 我使用 Capture（类型对象）的方式和我们使用 * 或 Whatever 一样。它只是表示，神奇的东西应该发生。这个神奇的东西归结为把所有 STDERR 流粘到一个二维数组中。如果我想处理错误，我可能想对 exitcode、shell 命令的名称和它输出到 STDERR 的部分进行匹配。像下面这样的语法会很好。\nmy $ex = Exitcode.new: :STDERR(\u0026lt;abc def ghi\u0026gt;), :exitint(42), :command\u0026lt;find\u0026gt;; given $ex { when ‚find‘ \u0026amp; 42 \u0026amp; /def\\s(\\S+)/ { note „find terminated with 42 and $0“; } } 事实证明，在 Junction 中得到对 Str、Numeric 和 Regex 的匹配是很容易做到的。我们需要做的就是增强 Regex。\naugment class Regex { multi method ACCEPTS(Regex:D: Shell::Piping::Exitcode:D $ex) { ?$ex.STDERR.join(„\\n“).match(self) } } augment class Int { multi method ACCEPTS(Int:D: Shell::Piping::Exitcode:D $ex) { self.ACCEPTS($ex.exitint) } } augment class Str { multi method ACCEPTS(Str:D: Shell::Piping::Exitcode:D $ex) { self.ACCEPTS($ex.command) } } 这只对匹配有效。我无法用这种方式将 (\\S+) 捕获到 $0。我们知道并喜欢 Str.match 能做到这一点-看起来很容易。让我们从它那里偷学代码吧!\nproto method match(|) { $/ := nqp::getlexcaller(\u0026#39;$/\u0026#39;); {*} } 所以 .match 要做的第一件事就是将本地的 $/ 与调用者的 $/ 绑定。因此，任何对本地版本的改变都会实际改变调用者的版本。我试着模仿了一下，但没有成功。无论是 nqp 方式还是稍微干净的 Raku 方式都不行。\naugment class Regex { multi method ACCEPTS(Regex:D: Shell::Piping::Exitcode:D $ex) { CALLER::\u0026lt;$/\u0026gt; := $/; ?$ex.STDERR.join(„\\n“).match(self) } } 至少在 given/when 块中不行。简单的说 $ex ~~ defs(\\S+); 在全局作用域内就能正常工作。我甚至得到了一个错误信息：OUTER 中不存在 \\$。考虑到根据定义，它应该存在于每一个块中，这很奇怪。\n我们可以用下面的构造来检查调用者的词法作用域。\nsay CALLER::.keys; say Backtrace.new.gist; 这将输出词法和有多少堆栈帧。而事实上，given/when 确实引入了一个额外的栈帧，它包含 $_ 但不包含 $/（以及其他一些零碎的东西）。由于 caller 是一个 Stash，什么是转半的 Hash，我们可以像往常一样使用 :existence，再增加一个 caller。\naugment class Regex { multi method ACCEPTS(Regex:D: Shell::Piping::Exitcode:D $ex) { CALLER::\u0026lt;$/\u0026gt;:exists ?? (CALLER::\u0026lt;$/\u0026gt; := $/) !! (CALLER::CALLER::\u0026lt;$/\u0026gt; := $/); ?$ex.STDERR.join(„\\n“).match(self) } } 现在，它的工作原理与设想的一样。\n然而-实际上 HOWEVER-我正在增强一个内置类。这是有风险的。我不是一个人。我们得到了一个 ircbot，可以在生态系统的源代码中 grep。\n20:01 \u0026lt; gfldex\u0026gt; greppable6: augment class 20:01 \u0026lt; greppable6\u0026gt; gfldex, 49 lines, 26 modules: https://gist.github.com/4088b5b8e7b51d94276b15500c240a5f 当我们编写模块时，我们会引入自定义名称所在的作用域。一个模块的用户可以决定将这些名字导入到用户控制的作用域中。当我们增强模块时，我们将一个新的名字引入到一个全局的作用域中。如果两个模块有相同的想法会怎样？如果注入的方法实际上是一个多，那么它很可能会工作。但它不一定要这样。当两个或更多的 multi 候选者具有相同的优先权时，第一个被发现的将获胜。通过在一个非 multi 上使用 augment，我们有机会得到一个错误信息。如果我们通过 MOP 添加一个方法，我们就不会。如果我想在 when 语句或代码块中允许智能匹配，我需要提供在 ~~ 的 LHS 上有我的自定义类的能力。所以没有办法绕过 augment。我甚至可以说，这就是在语言设计中加入 augment 的原因。当我们考虑到 Raku 越来越不年轻，语言版本不断增加时，情况就会变得更糟。一个测试马虎的模块可能会与语言版本增加的新方法发生碰撞。我们是否应该在 compunit 中强制执行一个带有语言版本的使用语句，并带有一个增强语句？\n这真的困扰着我。我们可以使用 META6 并添加字段 augments: \u0026quot;Cool,Int,Regex\u0026quot;。这样 zef 就有机会发现碰撞并提供一个警告。遗憾的是，我们没有办法强制执行这个功能（因为 EVAL）。我会花更多的时间来思考这个问题，可能会开始一个解决问题的问题。\n"},"name":"带退出码的增强","published":"2020-08-02T19:23:37+08:00","summary":"categories: [\u0026ldquo;Raku\u0026rdquo;] 在我的上一篇文章中，我找到了一个很好的方法来匹配 exitcode。我想把它扩展到与 STDERR 匹配，如果 exitcode 是非零。我已经有了一种方法来捕获一个管道的所有错误流。\npx\u0026lt;find /tmp» |» px\u0026lt;your-script-here\u0026gt; |» @a :stderr(Capture); 我使用 Capture（类型对象）的方式和我们使用 * 或 Whatever 一样。它只是表示，神奇的东西应该发生。这个神奇的东西归结为把所有 STDERR 流粘到一个二维数组中。如果我想处理错误，我可能想对 exitcode、shell 命令的名称和它输出到 STDERR 的部分进行匹配。像下面这样的语法会很好。\nmy $ex = Exitcode.new: :STDERR(\u0026lt;abc def ghi\u0026gt;), :exitint(42), :command\u0026lt;find\u0026gt;; given $ex { when ‚find‘ \u0026amp; 42 \u0026amp; /def\\s(\\S+)/ { note „find terminated with 42 and $0“; } } 事实证明，在 Junction 中得到对 Str、Numeric 和 Regex 的匹配是很容易做到的。我们需要做的就是增强 Regex。\naugment class Regex { multi method ACCEPTS(Regex:D: Shell::Piping::Exitcode:D $ex) { ?","type":"entry","url":"http://localhost:1313/raku/2020-07-29-augmenting-with-exitcode/"}