{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003ch1 id=\"声明\"\u003e声明\u003c/h1\u003e\n\u003cp\u003e本章翻译仅用于 Raku 学习和研究, 请支持电子版或\u003ca href=\"https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8\u0026amp;qid=1536753267\u0026amp;sr=8-1\u0026amp;keywords=Learning+Perl+6\"\u003e纸质版\u003c/a\u003e。\u003c/p\u003e\n\u003ch1 id=\"第二十章-高级话题\"\u003e第二十章. 高级话题\u003c/h1\u003e\n\u003cp\u003eIn such a short book I don’t have enough pages to show you everything that you can do. This chapter is a brief survey of some of the features I would have liked to explain in more detail. You now know these exist and you can investigate them further on your own.\u003c/p\u003e\n\u003cp\u003e在这么短的书中，我没有足够的页面向你展示你可以做的一切。本章简要介绍了一些我希望更详细解释的功能。你现在知道这些存在，你可以自己进一步研究它们。\u003c/p\u003e\n\u003ch1 id=\"单行\"\u003e单行\u003c/h1\u003e\n\u003cp\u003eYou can run \u003cem\u003eraku\u003c/em\u003e one-liners. These are programs that you compose completely on the command line. The \u003ccode\u003e-e\u003c/code\u003eswitch takes an argument that is the program:\u003c/p\u003e\n\u003cp\u003e你可以运行 raku 单行。这些完全是你在命令行上编写的程序。 \u003ccode\u003e-e\u003c/code\u003e 开关接受一个参数，即程序：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e% raku -e \u0026#39;put \u0026#34;Hello Raku\u0026#34;\u0026#39;\nHello Raku\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003e-n\u003c/code\u003e switch runs the program once for each line of input. The current line is in \u003ccode\u003e$_\u003c/code\u003e. This one uppercases and outputs the line:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e-n\u003c/code\u003e 开关为每行输入运行一次程序。当前行是 \u003ccode\u003e$_\u003c/code\u003e。这个单行大写一行并输出该行：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e% raku -n -e \u0026#39;.uc.put\u0026#39; *.pod\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can load a module with \u003ccode\u003e-M\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e你可以使用 \u003ccode\u003e-M\u003c/code\u003e 加载模块：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e% raku -MMath::Constants -e \u0026#39;put α\u0026#39;\n0.0072973525664\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"declarator-block-comments\"\u003eDeclarator Block Comments\u003c/h1\u003e\n\u003cp\u003eThe parser doesn’t discard all comments. It remembers special comments and attaches them to the subroutine. \u003ccode\u003e#|\u003c/code\u003e comments attach themselves to the subroutine after them and \u003ccode\u003e#=\u003c/code\u003e comments attach themselves to the subroutine before them. These comments are available through the \u003ccode\u003e.WHY\u003c/code\u003e meta-method:\u003c/p\u003e\n\u003cp\u003e解析器不会丢弃所有的注释。它会记住特殊注释并将它们附加到子例程中。 \u003ccode\u003e#|\u003c/code\u003e 注释将它们附加到它们之后的子例程中，并且 \u003ccode\u003e#=\u003c/code\u003e 注释将它们自身附加到它们之前的子例程中。这些注释可通过 \u003ccode\u003e.WHY\u003c/code\u003e 元方法获得：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#| Hamadryas is a sort of butterfly\nclass Hamadryas {\n\n    #| Flap makes the butterfly go\n    method flap () {\n\n        }\n    }\n\nHamadryas.WHY.put;\nHamadryas.^find_method(\u0026#39;flap\u0026#39;).WHY.put;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe output is the combination of all the comments attached to that subroutine:\u003c/p\u003e\n\u003cp\u003e输出是附加到该子例程的所有注释的组合：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eHamadryas is a sort of butterfly\nFlap makes the butterfly go\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is the sort of thing that’s handy in an integrated development environment to grab a description of the thing you are trying to use. It’s also useful when you are debugging something—that is, it’s useful if the developer documented their code.\u003c/p\u003e\n\u003cp\u003e在集成开发环境中，这种方法很方便，可以获取你尝试使用的内容的描述。当你调试某些内容时，它也很有用 - 也就是说，如果开发人员记录了他们的代码，那么它很有用。\u003c/p\u003e\n\u003ch1 id=\"feed-operators\"\u003eFeed Operators\u003c/h1\u003e\n\u003cp\u003eThe feed operators decide which way information flows. Here’s a list-processing pipeline that has a \u003ccode\u003e.grep\u003c/code\u003e, a \u003ccode\u003e.sort\u003c/code\u003e, and finally a \u003ccode\u003e.map\u003c/code\u003e. What they do doesn’t matter as much as their order:\u003c/p\u003e\n\u003cp\u003efeed 操作符决定信息的流向。这是一个列表处理管道，它有一个 \u003ccode\u003e.grep\u003c/code\u003e，一个 \u003ccode\u003e.sort\u003c/code\u003e，最后一个 \u003ccode\u003e.map\u003c/code\u003e。他们所做的事与顺序无关紧要：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @array = @some-array\n    .grep( *.chars \u0026gt; 5 )\n    .sort( *.fc )\n    .map( *.uc )\n    ;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe final step is farthest away from the assignment. You might not like that. The leftward feed operator allows you to write this in a way where the data flows in one direction. This flows bottom to top into the new variable:\u003c/p\u003e\n\u003cp\u003e最后一步是离赋值最远的。你可能不喜欢那样。向左的 feed 操作符允许你以数据在一个方向上流动的方式编写代码。下面这个从底部到顶部流入新到变量：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @array \u0026lt;==\n    map(  *.uc         ) \u0026lt;==\n    sort( *.fc         ) \u0026lt;==\n    grep( *.chars \u0026gt; 5  ) \u0026lt;==\n    @some-array\n    ;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that the assignment operator disappeared because the feed operator took care of that.\u003c/p\u003e\n\u003cp\u003e请注意，赋值运算符已消失，因为 feed 运算符负责处理了。\u003c/p\u003e\n\u003cp\u003eThe rightward feed operator goes the other way. The new variable is at the end this time. This is the same thing in the other direction:\u003c/p\u003e\n\u003cp\u003e向右的 feed 操作符走另一条路。这次这个新变量在最后。在另一方向上也是如此：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e@some-array\n    ==\u0026gt; grep( *.chars \u0026gt; 5  )\n    ==\u0026gt; sort( *.fc         )\n    ==\u0026gt; map(  *.uc         )\n    ==\u0026gt; my @array;\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"destructuring-signatures\"\u003eDestructuring Signatures\u003c/h1\u003e\n\u003cp\u003eYou can group parameters with square brackets to create a subsignature. Inside the \u003ccode\u003e[]\u003c/code\u003e you can break down the aggregate into a smaller signature:\u003c/p\u003e\n\u003cp\u003e你可以使用方括号对参数进行分组以创建子签名。在 \u003ccode\u003e[]\u003c/code\u003e内部，你可以将总体分解为较小的签名：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esub show-the-arguments ( $i, [$j, *@args] ) {  # slurpy\n    put \u0026#34;The arguments are i: $i j: $j and @args[]\u0026#34;;\n    }\n\nmy @a = ( 3, 7, 5 );\nshow-the-arguments( 1, @a );\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith that, \u003ccode\u003e$i\u003c/code\u003e gets the first parameter and the \u003ccode\u003e[]\u003c/code\u003e gets the rest. The \u003ccode\u003e[]\u003c/code\u003e destructures the remaining arguments into \u003ccode\u003e$j\u003c/code\u003e and \u003ccode\u003e@args\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e有了它，\u003ccode\u003e$i\u003c/code\u003e 获得第一个参数，\u003ccode\u003e[]\u003c/code\u003e 获得其余参数。 \u003ccode\u003e[]\u003c/code\u003e 将剩余的参数解构为 \u003ccode\u003e$j\u003c/code\u003e 和 \u003ccode\u003e@args\u003c/code\u003e。\u003c/p\u003e\n\u003ch1 id=\"defining-your-own-operators\"\u003eDefining Your Own Operators\u003c/h1\u003e\n\u003cp\u003eYou can create new operators. Almost all of the things that we call “operators” are methods.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e↑\u003c/code\u003e and \u003ccode\u003e↑↑\u003c/code\u003e represent Knuth arrows. These are higher levels of exponentiation:\u003c/p\u003e\n\u003cp\u003e你可以创建新的运算符。几乎所有我们称之为“运算符”的东西都是方法。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e↑\u003c/code\u003e 和 \u003ccode\u003e↑↑\u003c/code\u003e 代表高德纳箭头。这些是更高的取幂水平：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emulti infix:\u0026lt;↑\u0026gt; ( Int:D \\n, Int:D \\m  --\u0026gt; Int:D )\n    is equiv(\u0026amp;infix:\u0026lt;**\u0026gt;)\n    is assoc\u0026lt;right\u0026gt;\n    { n ** m }\n\nproto infix:\u0026lt;↑↑\u0026gt; ( Int:D \\n, Int:D \\m --\u0026gt; Int:D )\n    is tighter(\u0026amp;infix:\u0026lt;↑\u0026gt;)\n    is assoc\u0026lt;right\u0026gt;\n    { * }\nmulti infix:\u0026lt;↑↑\u0026gt; ( \\n,  0 ) { 1 }\nmulti infix:\u0026lt;↑↑\u0026gt; ( \\n,  1 ) { n }\nmulti infix:\u0026lt;↑↑\u0026gt; ( \\n, \\m ) { [↑] n xx m }\n\nput 2↑3;  # 2 ** 3 = 8\nput 2↑↑3; # 2 ** 2 ** 2 = 2 ** 4 = 16\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNotice that the definitions allow you to set traits for precedence and associativity. As with other subroutines these are lexically scoped, so they won’t affect other parts of your program.\u003c/p\u003e\n\u003cp\u003e请注意，这些定义允许你设置优先级和关联性的特征。与其他子例程一样，它们是词法作用域的，因此它们不会影响程序的其他部分。\u003c/p\u003e\n\u003ch1 id=\"perl-5-patterns\"\u003ePerl 5 Patterns\u003c/h1\u003e\n\u003cp\u003eIf you like Perl 5 patterns better, or already have some good ones that you’d like to reuse, you can do that. The \u003ccode\u003e:Perl5\u003c/code\u003e adverb tells the match operator to interpret the pattern as a Perl 5 regular expression:\u003c/p\u003e\n\u003cp\u003e如果你更喜欢 Perl 5 模式，或者已经有一些你想要重用的好模式，你可以这样做。 \u003ccode\u003e:Perl5\u003c/code\u003e 副词告诉匹配操作符将模式解释为 Perl 5 正则表达式：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $file = ...;\nfor $file.IO.lines {\n    next unless m:Perl5/\\A\\s+#/;  # no quoting the # in Perl 5\n    .put;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"shaped-arrays\"\u003eShaped Arrays\u003c/h1\u003e\n\u003cp\u003eWant a multidimensional matrix? You can create a shaped array that knows how wide it is in any dimension. Use the \u003ccode\u003e;\u003c/code\u003e to separate the dimensions:\u003c/p\u003e\n\u003cp\u003e想要一个多维矩阵？你可以创建一个定形数组，知道它在任何维度上的宽度。使用  \u003ccode\u003e;\u003c/code\u003e 分开维度：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @array[2;2];\nsay @array; # [[(Any) (Any)] [(Any) (Any)]]\n\n@array[1;0] = \u0026#39;Hamadryas\u0026#39;;\nsay @array; # [[(Any) (Any)] [Hamadryas (Any)]]\n\nmy $n = 0;\nmy $m = 1;\n\n@array[$n;$m] = \u0026#39;Borbo\u0026#39;;\nsay @array; # [[(Any) Borbo] [Hamadryas (Any)]]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can extend this to higher dimensions:\u003c/p\u003e\n\u003cp\u003e你可以将此扩展到更高的维度：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @array[2;2;3];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003e:shape\u003c/code\u003e adverb can describe the size in each dimension:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e:shape\u003c/code\u003e 副词可以描述每个维度的大小：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @array = Array.new: :shape(3,3);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOnce you set the limits in each dimension the size is fixed. This means that you can create fixed-size one-dimensional arrays. You won’t be able to use operaters that increase or decrease the number of elements:\u003c/p\u003e\n\u003cp\u003e在每个维度中设置限制后，大小就固定了。这意味着你可以创建固定大小的一维数组。你将无法使用增加或减少元素数量的操作符：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @array[5];\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"typed-containers\"\u003eTyped Containers\u003c/h1\u003e\n\u003cp\u003eThe container types (\u003ca href=\"https://docs.raku.org/type/List.html\"\u003e\u003ccode\u003eList\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/type/Array.html\"\u003e\u003ccode\u003eArray\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003eHash\u003c/code\u003e\u003c/a\u003e, and so on) can limit their elements to a particular type. There are a few ways that you can constrain these. Consider this example:\u003c/p\u003e\n\u003cp\u003e容器类型（\u003ca href=\"https://docs.raku.org/type/List.html\"\u003e\u003ccode\u003eList\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/type/Array.html\"\u003e\u003ccode\u003eArray\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003eHash\u003c/code\u003e\u003c/a\u003e等）可以将其元素限制为特定类型。有几种方法可以约束这些。考虑这个例子：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy Int @array = 1, 2, 3;\n@array.push: \u0026#39;Hamadryas\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSince a \u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003eStr\u003c/code\u003e\u003c/a\u003e is not an \u003ca href=\"https://docs.raku.org/type/Int.html\"\u003e\u003ccode\u003eInt\u003c/code\u003e\u003c/a\u003e the \u003ccode\u003e.push\u003c/code\u003e fails:\u003c/p\u003e\n\u003cp\u003e由于\u003ca href=\"https://docs.raku.org/type/Str.html\"\u003e\u003ccode\u003e字符串\u003c/code\u003e\u003c/a\u003e不是\u003ca href=\"https://docs.raku.org/type/Int.html\"\u003e\u003ccode\u003eInt\u003c/code\u003e\u003c/a\u003e，因此 \u003ccode\u003e.push\u003c/code\u003e 失败：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eType check failed in assignment to @array\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat form types the \u003ccode\u003e@array\u003c/code\u003e variable. The type is actually \u003ccode\u003eArray[Int]\u003c/code\u003e. You can also bind to the object you construct directly:\u003c/p\u003e\n\u003cp\u003e该形式键入 \u003ccode\u003e@array\u003c/code\u003e 变量。该类型实际上是 \u003ccode\u003eArray [Int]\u003c/code\u003e。你还可以绑定到直接构造的对象：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy @array := Array[Int].new: 1, 3, 7;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can create \u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003eHash\u003c/code\u003e\u003c/a\u003ees with objects for keys and many other interesting constraints.\u003c/p\u003e\n\u003cp\u003e你可以使用对象创建\u003ca href=\"https://docs.raku.org/type/Hash.html\"\u003e\u003ccode\u003e散列\u003c/code\u003e\u003c/a\u003e以及许多其他有趣的约束。\u003c/p\u003e\n\u003ch1 id=\"nativecall\"\u003eNativeCall\u003c/h1\u003e\n\u003cp\u003eThere’s a builtin foreign function interface named \u003ccode\u003eNativeCall\u003c/code\u003e. You use the \u003ccode\u003eis native\u003c/code\u003e trait to specify the external library. This one connects your program to the argumentless \u003ccode\u003eflap\u003c/code\u003e routine in \u003cem\u003elibbutterfly\u003c/em\u003e:\u003c/p\u003e\n\u003cp\u003e有一个名为 \u003ccode\u003eNativeCall\u003c/code\u003e 的内置外部函数接口。你使用 \u003ccode\u003eis native\u003c/code\u003e  trait 指定外部库。这个程序将你的程序连接到 \u003ccode\u003elibbutterfly\u003c/code\u003e 中的无参数 \u003ccode\u003eflap\u003c/code\u003e 例程：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003euse NativeCall;\nsub flap() is native(\u0026#39;butterfly\u0026#39;) { * }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere are ways to tell \u003ccode\u003eNativeCall\u003c/code\u003e how to translate data structures to “native” types and the other way around.\u003c/p\u003e\n\u003cp\u003e有办法告诉 \u003ccode\u003eNativeCall\u003c/code\u003e 如何将数据结构转换为“原生”类型，反之亦然。\u003c/p\u003e\n\u003ch1 id=\"the-with-topicalizer\"\u003eThe with Topicalizer\u003c/h1\u003e\n\u003cp\u003eThe \u003ccode\u003ewith\u003c/code\u003e keyword sets the topic. In the postfix form you can use it so you don’t have to repeat a long variable name:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewith\u003c/code\u003e 关键字设置主题。你可以在后缀形式中使用它，以使你不必重复长变量名称：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eput \u0026#34;$_ has {.chars}\u0026#34; with $some-very-long-name;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThere’s a \u003ca href=\"https://docs.raku.org/type/Block.html\"\u003e\u003ccode\u003eBlock\u003c/code\u003e\u003c/a\u003e form that’s similar to \u003ccode\u003eif-elsif-else\u003c/code\u003e but sets the topic to the result of the condition. Instead of looking for \u003ccode\u003eTrue\u003c/code\u003e or \u003ccode\u003eFalse\u003c/code\u003e it tests for definedness. In each of these the topic inside the \u003ca href=\"https://docs.raku.org/type/Block.html\"\u003e\u003ccode\u003eBlock\u003c/code\u003e\u003c/a\u003e is the result of the respective \u003ccode\u003e.index\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e有一个与 \u003ccode\u003eif-elsif-else\u003c/code\u003e 类似的 \u003ca href=\"https://docs.raku.org/type/Block.html\"\u003e\u003ccode\u003eBlock\u003c/code\u003e\u003c/a\u003e 形式，但将主题设置为条件的结果。它不是寻找 \u003ccode\u003eTrue\u003c/code\u003e 或 \u003ccode\u003eFalse\u003c/code\u003e，而是测试定义。 \u003ca href=\"https://docs.raku.org/type/Block.html\"\u003e\u003ccode\u003eBlock\u003c/code\u003e\u003c/a\u003e 里的每个这样的主题是相应的 \u003ccode\u003e.index\u003c/code\u003e 的结果：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003emy $s = \u0026#39;Hamadryas\u0026#39;;\n\n  with $s.index: \u0026#39;a\u0026#39; { $s.substr( $_, 2 ).put }\norwith $s.index: \u0026#39;m\u0026#39; { put \u0026#39;Found m\u0026#39; }\norwith $s.index: \u0026#39;H\u0026#39; { fail \u0026#34;Why is there an H at $_?\u0026#34;  }\n\u003c/code\u003e\u003c/pre\u003e","text":"声明 本章翻译仅用于 Raku 学习和研究, 请支持电子版或纸质版。\n第二十章. 高级话题 In such a short book I don’t have enough pages to show you everything that you can do. This chapter is a brief survey of some of the features I would have liked to explain in more detail. You now know these exist and you can investigate them further on your own.\n在这么短的书中，我没有足够的页面向你展示你可以做的一切。本章简要介绍了一些我希望更详细解释的功能。你现在知道这些存在，你可以自己进一步研究它们。\n单行 You can run raku one-liners. These are programs that you compose completely on the command line. The -eswitch takes an argument that is the program:\n你可以运行 raku 单行。这些完全是你在命令行上编写的程序。 -e 开关接受一个参数，即程序：\n% raku -e \u0026#39;put \u0026#34;Hello Raku\u0026#34;\u0026#39; Hello Raku The -n switch runs the program once for each line of input. The current line is in $_. This one uppercases and outputs the line:\n-n 开关为每行输入运行一次程序。当前行是 $_。这个单行大写一行并输出该行：\n% raku -n -e \u0026#39;.uc.put\u0026#39; *.pod You can load a module with -M:\n你可以使用 -M 加载模块：\n% raku -MMath::Constants -e \u0026#39;put α\u0026#39; 0.0072973525664 Declarator Block Comments The parser doesn’t discard all comments. It remembers special comments and attaches them to the subroutine. #| comments attach themselves to the subroutine after them and #= comments attach themselves to the subroutine before them. These comments are available through the .WHY meta-method:\n解析器不会丢弃所有的注释。它会记住特殊注释并将它们附加到子例程中。 #| 注释将它们附加到它们之后的子例程中，并且 #= 注释将它们自身附加到它们之前的子例程中。这些注释可通过 .WHY 元方法获得：\n#| Hamadryas is a sort of butterfly class Hamadryas { #| Flap makes the butterfly go method flap () { } } Hamadryas.WHY.put; Hamadryas.^find_method(\u0026#39;flap\u0026#39;).WHY.put; The output is the combination of all the comments attached to that subroutine:\n输出是附加到该子例程的所有注释的组合：\nHamadryas is a sort of butterfly Flap makes the butterfly go This is the sort of thing that’s handy in an integrated development environment to grab a description of the thing you are trying to use. It’s also useful when you are debugging something—that is, it’s useful if the developer documented their code.\n在集成开发环境中，这种方法很方便，可以获取你尝试使用的内容的描述。当你调试某些内容时，它也很有用 - 也就是说，如果开发人员记录了他们的代码，那么它很有用。\nFeed Operators The feed operators decide which way information flows. Here’s a list-processing pipeline that has a .grep, a .sort, and finally a .map. What they do doesn’t matter as much as their order:\nfeed 操作符决定信息的流向。这是一个列表处理管道，它有一个 .grep，一个 .sort，最后一个 .map。他们所做的事与顺序无关紧要：\nmy @array = @some-array .grep( *.chars \u0026gt; 5 ) .sort( *.fc ) .map( *.uc ) ; The final step is farthest away from the assignment. You might not like that. The leftward feed operator allows you to write this in a way where the data flows in one direction. This flows bottom to top into the new variable:\n最后一步是离赋值最远的。你可能不喜欢那样。向左的 feed 操作符允许你以数据在一个方向上流动的方式编写代码。下面这个从底部到顶部流入新到变量：\nmy @array \u0026lt;== map( *.uc ) \u0026lt;== sort( *.fc ) \u0026lt;== grep( *.chars \u0026gt; 5 ) \u0026lt;== @some-array ; Notice that the assignment operator disappeared because the feed operator took care of that.\n请注意，赋值运算符已消失，因为 feed 运算符负责处理了。\nThe rightward feed operator goes the other way. The new variable is at the end this time. This is the same thing in the other direction:\n向右的 feed 操作符走另一条路。这次这个新变量在最后。在另一方向上也是如此：\n@some-array ==\u0026gt; grep( *.chars \u0026gt; 5 ) ==\u0026gt; sort( *.fc ) ==\u0026gt; map( *.uc ) ==\u0026gt; my @array; Destructuring Signatures You can group parameters with square brackets to create a subsignature. Inside the [] you can break down the aggregate into a smaller signature:\n你可以使用方括号对参数进行分组以创建子签名。在 []内部，你可以将总体分解为较小的签名：\nsub show-the-arguments ( $i, [$j, *@args] ) { # slurpy put \u0026#34;The arguments are i: $i j: $j and @args[]\u0026#34;; } my @a = ( 3, 7, 5 ); show-the-arguments( 1, @a ); With that, $i gets the first parameter and the [] gets the rest. The [] destructures the remaining arguments into $j and @args.\n有了它，$i 获得第一个参数，[] 获得其余参数。 [] 将剩余的参数解构为 $j 和 @args。\nDefining Your Own Operators You can create new operators. Almost all of the things that we call “operators” are methods.\nThe ↑ and ↑↑ represent Knuth arrows. These are higher levels of exponentiation:\n你可以创建新的运算符。几乎所有我们称之为“运算符”的东西都是方法。\n↑ 和 ↑↑ 代表高德纳箭头。这些是更高的取幂水平：\nmulti infix:\u0026lt;↑\u0026gt; ( Int:D \\n, Int:D \\m --\u0026gt; Int:D ) is equiv(\u0026amp;infix:\u0026lt;**\u0026gt;) is assoc\u0026lt;right\u0026gt; { n ** m } proto infix:\u0026lt;↑↑\u0026gt; ( Int:D \\n, Int:D \\m --\u0026gt; Int:D ) is tighter(\u0026amp;infix:\u0026lt;↑\u0026gt;) is assoc\u0026lt;right\u0026gt; { * } multi infix:\u0026lt;↑↑\u0026gt; ( \\n, 0 ) { 1 } multi infix:\u0026lt;↑↑\u0026gt; ( \\n, 1 ) { n } multi infix:\u0026lt;↑↑\u0026gt; ( \\n, \\m ) { [↑] n xx m } put 2↑3; # 2 ** 3 = 8 put 2↑↑3; # 2 ** 2 ** 2 = 2 ** 4 = 16 Notice that the definitions allow you to set traits for precedence and associativity. As with other subroutines these are lexically scoped, so they won’t affect other parts of your program.\n请注意，这些定义允许你设置优先级和关联性的特征。与其他子例程一样，它们是词法作用域的，因此它们不会影响程序的其他部分。\nPerl 5 Patterns If you like Perl 5 patterns better, or already have some good ones that you’d like to reuse, you can do that. The :Perl5 adverb tells the match operator to interpret the pattern as a Perl 5 regular expression:\n如果你更喜欢 Perl 5 模式，或者已经有一些你想要重用的好模式，你可以这样做。 :Perl5 副词告诉匹配操作符将模式解释为 Perl 5 正则表达式：\nmy $file = ...; for $file.IO.lines { next unless m:Perl5/\\A\\s+#/; # no quoting the # in Perl 5 .put; } Shaped Arrays Want a multidimensional matrix? You can create a shaped array that knows how wide it is in any dimension. Use the ; to separate the dimensions:\n想要一个多维矩阵？你可以创建一个定形数组，知道它在任何维度上的宽度。使用 ; 分开维度：\nmy @array[2;2]; say @array; # [[(Any) (Any)] [(Any) (Any)]] @array[1;0] = \u0026#39;Hamadryas\u0026#39;; say @array; # [[(Any) (Any)] [Hamadryas (Any)]] my $n = 0; my $m = 1; @array[$n;$m] = \u0026#39;Borbo\u0026#39;; say @array; # [[(Any) Borbo] [Hamadryas (Any)]] You can extend this to higher dimensions:\n你可以将此扩展到更高的维度：\nmy @array[2;2;3]; The :shape adverb can describe the size in each dimension:\n:shape 副词可以描述每个维度的大小：\nmy @array = Array.new: :shape(3,3); Once you set the limits in each dimension the size is fixed. This means that you can create fixed-size one-dimensional arrays. You won’t be able to use operaters that increase or decrease the number of elements:\n在每个维度中设置限制后，大小就固定了。这意味着你可以创建固定大小的一维数组。你将无法使用增加或减少元素数量的操作符：\nmy @array[5]; Typed Containers The container types (List, Array, Hash, and so on) can limit their elements to a particular type. There are a few ways that you can constrain these. Consider this example:\n容器类型（List, Array, Hash等）可以将其元素限制为特定类型。有几种方法可以约束这些。考虑这个例子：\nmy Int @array = 1, 2, 3; @array.push: \u0026#39;Hamadryas\u0026#39;; Since a Str is not an Int the .push fails:\n由于字符串不是Int，因此 .push 失败：\nType check failed in assignment to @array That form types the @array variable. The type is actually Array[Int]. You can also bind to the object you construct directly:\n该形式键入 @array 变量。该类型实际上是 Array [Int]。你还可以绑定到直接构造的对象：\nmy @array := Array[Int].new: 1, 3, 7; You can create Hashes with objects for keys and many other interesting constraints.\n你可以使用对象创建散列以及许多其他有趣的约束。\nNativeCall There’s a builtin foreign function interface named NativeCall. You use the is native trait to specify the external library. This one connects your program to the argumentless flap routine in libbutterfly:\n有一个名为 NativeCall 的内置外部函数接口。你使用 is native trait 指定外部库。这个程序将你的程序连接到 libbutterfly 中的无参数 flap 例程：\nuse NativeCall; sub flap() is native(\u0026#39;butterfly\u0026#39;) { * } There are ways to tell NativeCall how to translate data structures to “native” types and the other way around.\n有办法告诉 NativeCall 如何将数据结构转换为“原生”类型，反之亦然。\nThe with Topicalizer The with keyword sets the topic. In the postfix form you can use it so you don’t have to repeat a long variable name:\nwith 关键字设置主题。你可以在后缀形式中使用它，以使你不必重复长变量名称：\nput \u0026#34;$_ has {.chars}\u0026#34; with $some-very-long-name; There’s a Block form that’s similar to if-elsif-else but sets the topic to the result of the condition. Instead of looking for True or False it tests for definedness. In each of these the topic inside the Block is the result of the respective .index:\n有一个与 if-elsif-else 类似的 Block 形式，但将主题设置为条件的结果。它不是寻找 True 或 False，而是测试定义。 Block 里的每个这样的主题是相应的 .index 的结果：\nmy $s = \u0026#39;Hamadryas\u0026#39;; with $s.index: \u0026#39;a\u0026#39; { $s.substr( $_, 2 ).put } orwith $s.index: \u0026#39;m\u0026#39; { put \u0026#39;Found m\u0026#39; } orwith $s.index: \u0026#39;H\u0026#39; { fail \u0026#34;Why is there an H at $_?\u0026#34; } "},"name":"第二十章. 高级话题","published":"2018-09-20T00:10:09+08:00","summary":"声明 本章翻译仅用于 Raku 学习和研究, 请支持电子版或纸质版。\n第二十章. 高级话题 In such a short book I don’t have enough pages to show you everything that you can do. This chapter is a brief survey of some of the features I would have liked to explain in more detail. You now know these exist and you can investigate them further on your own.\n在这么短的书中，我没有足够的页面向你展示你可以做的一切。本章简要介绍了一些我希望更详细解释的功能。你现在知道这些存在，你可以自己进一步研究它们。\n单行 You can run raku one-liners. These are programs that you compose completely on the command line.","type":"entry","url":"http://localhost:1313/raku/2018-09-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0.-%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"}