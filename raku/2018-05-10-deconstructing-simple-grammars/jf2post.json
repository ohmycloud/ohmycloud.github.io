{"author":{"name":null,"type":"card","url":"http://localhost:1313/"},"content":{"html":"\u003cp\u003e去年我写了一个\u003ca href=\"https://gfldex.wordpress.com/2017/12/31/expensive-egg-timers/\"\u003e鸡蛋定时器\u003c/a\u003e，它的解析命令行参数类似于 GNU sleep。我对这个解析器的严格形式很满意，如下。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"n\"\u003eSeconds\u003c/span\u003e \u003cspan class=\"nv\"\u003e$to-wait\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e@timicles\u003c/span\u003e\u003cspan class=\"o\"\u003e»\u003c/span\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esplit\u003c/span\u003e\u003cspan class=\"p\"\u003e(/\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003enumber\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;/\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"nv\"\u003e$\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e\u003cspan class=\"kt\"\u003eRat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eAny\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$count\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eStr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eAny\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$unit\u003c/span\u003e\u003cspan class=\"o\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003e--\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eSeconds\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nv\"\u003e%unit-multipliers\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"nv\"\u003e$unit\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nv\"\u003e$count\u003c/span\u003e \u003cspan class=\"p\"\u003e})\u003c/span\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esum\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e它只做了几件简单的事情，而且是一件接着一件做。带有动作类的 grammar 就显得矫枉过正了。我不满意用 \u003ccode\u003esplit\u003c/code\u003e 的能力来返回带有零件的针。它肯定不会提高可读性。\u003c/p\u003e\n\u003cp\u003e经过相当多的迭代（并踩到了一个 \u003ca href=\"https://github.com/rakudo/rakudo/issues/1800\"\u003ebug\u003c/a\u003e），我想出了一个使用 \u003ccode\u003eStr.match\u003c/code\u003e 代替的方法。如果我把每个 \u003ccode\u003eMatch\u003c/code\u003e 对象转换成 \u003ccode\u003eHash\u003c/code\u003e，我就可以在一个尖号块的签名中使用\u003ca href=\"https://docs.raku.org/type/Signature#Destructuring_Parameters\"\u003e解构\u003c/a\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"n\"\u003eSeconds\u003c/span\u003e \u003cspan class=\"nv\"\u003e$to-wait\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nv\"\u003e@timicles\u003c/span\u003e\u003cspan class=\"o\"\u003e»\u003c/span\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003ematch\u003c/span\u003e\u003cspan class=\"p\"\u003e(/\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003enumber\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"sr\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nf\"\u003esuffix\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"p\"\u003e/)\u003c/span\u003e\u003cspan class=\"o\"\u003e».\u003c/span\u003e\u003cspan class=\"nb\"\u003ehash\u003c/span\u003e\\ \u003cspan class=\"c1\"\u003e# the +-quatifier is a workaround\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nv\"\u003e%\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"kt\"\u003eRat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eAny\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"nv\"\u003e$number\u003c/span\u003e\u003cspan class=\"o\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eStr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eAny\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"nv\"\u003e$suffix\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nv\"\u003e%unit-multipliers\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"nv\"\u003e$suffix\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nv\"\u003e$number\u003c/span\u003e \u003cspan class=\"p\"\u003e})\u003c/span\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003esum\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我可以不使用位置参数，而是使用命名的参数，这些参数对应于匹配参数中命名正则表达式。\u003c/p\u003e\n\u003cp\u003e即使是在这样一小段代码中，事情也会变得有条不紊。超方法调用摆脱了简单的循环。精心设计的内置类型允许在没有临时变量负载的情况下进行签名解构。这几乎就像某些语言设计者的目标是制造一种最优雅的语言一样。\u003c/p\u003e\n\u003cp\u003eby \u003ca href=\"https://gfldex.wordpress.com/2018/05/10/deconstructing-simple-grammars/\"\u003egfldex\u003c/a\u003e.\u003c/p\u003e\n","text":"去年我写了一个鸡蛋定时器，它的解析命令行参数类似于 GNU sleep。我对这个解析器的严格形式很满意，如下。\nmy Seconds $to-wait = @timicles»\\ .split(/\u0026lt;number\u0026gt;/, :v)\\ .map(-\u0026gt; [$,Rat(Any) $count, Str(Any) $unit] --\u0026gt; Seconds { %unit-multipliers{$unit} * $count })\\ .sum; 它只做了几件简单的事情，而且是一件接着一件做。带有动作类的 grammar 就显得矫枉过正了。我不满意用 split 的能力来返回带有零件的针。它肯定不会提高可读性。\n经过相当多的迭代（并踩到了一个 bug），我想出了一个使用 Str.match 代替的方法。如果我把每个 Match 对象转换成 Hash，我就可以在一个尖号块的签名中使用解构。\nmy Seconds $to-wait = @timicles»\\ .match(/\u0026lt;number\u0026gt; \u0026lt;suffix\u0026gt;+/)».hash\\ # the +-quatifier is a workaround .map(-\u0026gt; % ( Rat(Any) :$number, Str(Any) :$suffix ) { %unit-multipliers{$suffix} * $number })\\ .sum; 我可以不使用位置参数，而是使用命名的参数，这些参数对应于匹配参数中命名正则表达式。\n即使是在这样一小段代码中，事情也会变得有条不紊。超方法调用摆脱了简单的循环。精心设计的内置类型允许在没有临时变量负载的情况下进行签名解构。这几乎就像某些语言设计者的目标是制造一种最优雅的语言一样。\nby gfldex.\n"},"name":"Deconstructing Simple Grammars","published":"2018-05-10T11:27:22+08:00","summary":"去年我写了一个鸡蛋定时器，它的解析命令行参数类似于 GNU sleep。我对这个解析器的严格形式很满意，如下。\nmy Seconds $to-wait = @timicles»\\ .split(/\u0026lt;number\u0026gt;/, :v)\\ .map(-\u0026gt; [$,Rat(Any) $count, Str(Any) $unit] --\u0026gt; Seconds { %unit-multipliers{$unit} * $count })\\ .sum; 它只做了几件简单的事情，而且是一件接着一件做。带有动作类的 grammar 就显得矫枉过正了。我不满意用 split 的能力来返回带有零件的针。它肯定不会提高可读性。\n经过相当多的迭代（并踩到了一个 bug），我想出了一个使用 Str.match 代替的方法。如果我把每个 Match 对象转换成 Hash，我就可以在一个尖号块的签名中使用解构。\nmy Seconds $to-wait = @timicles»\\ .match(/\u0026lt;number\u0026gt; \u0026lt;suffix\u0026gt;+/)».hash\\ # the +-quatifier is a workaround .map(-\u0026gt; % ( Rat(Any) :$number, Str(Any) :$suffix ) { %unit-multipliers{$suffix} * $number })\\ .sum; 我可以不使用位置参数，而是使用命名的参数，这些参数对应于匹配参数中命名正则表达式。\n即使是在这样一小段代码中，事情也会变得有条不紊。超方法调用摆脱了简单的循环。精心设计的内置类型允许在没有临时变量负载的情况下进行签名解构。这几乎就像某些语言设计者的目标是制造一种最优雅的语言一样。\nby gfldex.","type":"entry","url":"http://localhost:1313/raku/2018-05-10-deconstructing-simple-grammars/"}