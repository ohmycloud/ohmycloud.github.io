{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass Student {\n    has $.name;\n    has $.sex;\n    has $!age;\n\n    method BUILD(:$!name) {\n\n    }\n}\n\nmy $stu = Student.new(:name('赵今麦'), :sex('女'));\ndd $stu;\n# Student $stu = Student.new(name =\u0026gt; \u0026quot;赵今麦\u0026quot;, sex =\u0026gt; Any)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果你加上 \u003ccode\u003eBUILD\u003c/code\u003e 方法, 你必须自己全权负责设置所有的东西。也就是既包括公共属性, 也包括私有属性。\u003c/p\u003e\n\u003cp\u003e但你可以通过巧妙地命名参数来让你的生活更轻松。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emethod BUILD (:$!name, :$!sex, :$!age) { }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eBUILD\u003c/code\u003e 方法可以初始化私有属性:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass Student {\n    has $.name;\n    has $.sex;\n    has $!age;\n\n    method BUILD(:$name, :$sex, :$age) {\n        $!name = $name;\n        $!sex = $sex;\n        $!age = $age;\n    }\n\n    method heart() { return '♥ ' ~ $!age }\n}\n\nmy $stu = Student.new(:name('赵今麦'), :sex('女'), :age(18));\ndd $stu;\nsay $stu;\nsay $stu.heart(); \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也可以在 TWEAK 方法中初始化私有属性:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass Student {\n    has $.name;\n    has $.sex;\n    has $!age;\n\n    method TWEAK(:$name, :$sex, :$age) {\n        $!age = $age + 1;\n    }\n\n    method heart() { return '♥' ~ $!age }\n}\n\nmy $stu = Student.new(:name('赵今麦'), :sex('女'), :age(18));\ndd $stu;\nsay $stu;\nsay $stu.heart(); \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e使用 \u003ccode\u003eTWEAK\u003c/code\u003e，你会得到与 \u003ccode\u003eBUILD\u003c/code\u003e 相同的参数，但所有的初始设置都已经完成了（\u003ccode\u003eBUILD\u003c/code\u003e 或公共属性的自动绑定，以及所有的默认值，再加上保证所需值的存在）。你只是有机会做一些最后的调整。\u003c/p\u003e\n","text":"class Student { has $.name; has $.sex; has $!age; method BUILD(:$!name) { } } my $stu = Student.new(:name('赵今麦'), :sex('女')); dd $stu; # Student $stu = Student.new(name =\u0026gt; \u0026quot;赵今麦\u0026quot;, sex =\u0026gt; Any) 如果你加上 BUILD 方法, 你必须自己全权负责设置所有的东西。也就是既包括公共属性, 也包括私有属性。\n但你可以通过巧妙地命名参数来让你的生活更轻松。\nmethod BUILD (:$!name, :$!sex, :$!age) { } BUILD 方法可以初始化私有属性:\nclass Student { has $.name; has $.sex; has $!age; method BUILD(:$name, :$sex, :$age) { $!name = $name; $!sex = $sex; $!age = $age; } method heart() { return '♥ ' ~ $!age } } my $stu = Student.new(:name('赵今麦'), :sex('女'), :age(18)); dd $stu; say $stu; say $stu.heart(); 也可以在 TWEAK 方法中初始化私有属性:\nclass Student { has $.name; has $.sex; has $!age; method TWEAK(:$name, :$sex, :$age) { $!age = $age + 1; } method heart() { return '♥' ~ $!age } } my $stu = Student.new(:name('赵今麦'), :sex('女'), :age(18)); dd $stu; say $stu; say $stu.heart(); 使用 TWEAK，你会得到与 BUILD 相同的参数，但所有的初始设置都已经完成了（BUILD 或公共属性的自动绑定，以及所有的默认值，再加上保证所需值的存在）。你只是有机会做一些最后的调整。\n"},"name":"BUILD 和 TWEAK 的区别","published":"2021-03-07T00:00:00+08:00","summary":"Difference Between Build and Tweak in Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/"},{"content":{"html":"\u003cp\u003eRaku 有非常好的 Unicode 支持, 但是输入 Unicode 一直是一个很大的问题。在 REPL 中, 输入 Unicode 都不太方便。下面介绍几种方法来方便地输入 Unicode。\u003c/p\u003e\n\u003ch1 id=\"comma\"\u003eComma\u003c/h1\u003e\n\u003cp\u003e最方便的是使用 Raku 自己的 IDE, \u003ca href=\"http://commaide.com\"\u003eComma\u003c/a\u003e。但是需要做两个设置:\u003c/p\u003e\n\u003cp\u003e首先, 切换到 Comma IDE, 点击左上角菜单栏的 \u003cstrong\u003eComma\u003c/strong\u003e 选项, 在弹出的 \u003cstrong\u003ePreference\u003c/strong\u003e 窗口中, 找到左侧菜单栏中的 \u003cstrong\u003eEditor\u003c/strong\u003e 选项, 点击 \u003cstrong\u003eCode Style\u003c/strong\u003e 中的 \u003cstrong\u003eRaku\u003c/strong\u003e, 在右侧的窗口的最上面, 找到 \u003cstrong\u003eSchema\u003c/strong\u003e 一行, 点击倒三角图标, 在下拉菜单中选择 \u003cstrong\u003eProject\u003c/strong\u003e。然后在第二行文字中找到 \u003cstrong\u003eEditor Behavior\u003c/strong\u003e, 勾选 \u003cstrong\u003eConvert operators to Unicode\u003c/strong\u003e。完成后点击右下角的 \u003cstrong\u003eApply\u003c/strong\u003e, 然后点击 \u003cstrong\u003eOK\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e这样当你在 Comma 中键入 \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e 这样的运算符后, Comma 会自动把它转为 Unicode 形式的 \u003ccode\u003e»\u003c/code\u003e。目前已支持大部分 Unicode 运算符了。Comma 是跨平台的 Raku 编辑器, 支持 Windows、Linux 和 MacOS, 所以你想跨平台开发的话, Comma 值得一试。\u003c/p\u003e\n\u003ch1 id=\"kitty\"\u003eKitty\u003c/h1\u003e\n\u003cp\u003e如果你想在 Vim 中开发 Raku, 又不想失去输入 Unicode 的乐趣, 请使用 \u003ca href=\"https://github.com/kovidgoyal/kitty\"\u003eKitty\u003c/a\u003e 终端。点开 Kitty 终端, 使用快捷键 Ctrl + Shift + U 即可触发输入 Unnicode 的界面(也可以键入命令 kitty +kitten unicode_input 来触发)。再通过快捷键  F1、F2、F3 和 F4 (或通过 Ctrl+[ 和 Ctrl+] 切换标签)可以分别按代码搜索 Unicode、按名字搜索 Unicode、按表情搜索和收藏。\u003c/p\u003e\n\u003cp\u003e例如在 REPL 中键入 Unicode 字符:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e$ raku\nWelcome to 𝐑𝐚𝐤𝐮𝐝𝐨™ v2021.02.\nImplementing the 𝐑𝐚𝐤𝐮™ programming language v6.d.\nBuilt on MoarVM version 2021.02.\n\nTo \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e \u003cspan class=\"nb\"\u003etype\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;exit\u0026#39;\u003c/span\u003e or \u003cspan class=\"s1\"\u003e\u0026#39;^D\u0026#39;\u003c/span\u003e\n\u0026gt; my @a \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1..5\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u0026gt; @a».sin\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e借助 Kitty, 数组 \u003ccode\u003e@a\u003c/code\u003e 后面的 \u003ccode\u003e»\u003c/code\u003e 可以这样输入, 先输入 \u003ccode\u003e@a\u003c/code\u003e, 然后使用快捷键 Shift + Ctrl + U 调出 Kitty 的 \u003cstrong\u003eUnicode input\u003c/strong\u003e 界面, 一般有两种方法, 第一种是通过快捷键 F1, 然后输入对应的 Unicode 编码, 再回车。第二种是通过快捷键 F2, 通过名字搜索, 例如输入单词 quota, 会出现一堆引号符号供你选择, 按上下方向键选中 \u003ccode\u003e»\u003c/code\u003e, 再回车即可。Vim 中同理。\u003c/p\u003e\n\u003ch1 id=\"julia-repl\"\u003eJulia REPL\u003c/h1\u003e\n\u003cp\u003e在 REPL 中输入 \u003ccode\u003e\\′ + 单词 + Tab, 例如输入 \u003c/code\u003e\\heartsuit` 再按 Tab, 就会自动变成 ♡\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003ejulia\u0026gt; \u003cspan class=\"se\"\u003e\\h\u003c/span\u003eeartsuit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"ipython\"\u003eIPython\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003e\\^\u003c/code\u003e 输入上标, \u003ccode\u003e\\_p\u003c/code\u003e 输入下标。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e$ ipython\n\u003cspan class=\"se\"\u003e\\^\u003c/span\u003ea\n\u003cspan class=\"se\"\u003e\\_\u003c/span\u003ep\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"vscode\"\u003eVScode\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003e\\\\′ + 完整的单词 + Tab, VsCode 会自动转换为 Unicode。 例如 \u003c/code\u003e^a\u003ccode\u003e和\u003c/code\u003e_p`\u003c/p\u003e\n\u003ch1 id=\"dmenu\"\u003edmenu\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"ch\"\u003e#!/usr/bin/perl\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e#use strict;\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#use warnings;\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#use autodie;\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#use utf8;\u003c/span\u003e\n\n\n\u003cspan class=\"nb\"\u003eopen\u003c/span\u003e \u003cspan class=\"nv\"\u003e$FH\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34; | dmenu -i -l 30 -fn \u0026#39;-xos4-terminus-medium-r-*-*-10-*\u0026#39; | sed \u0026#39;s/^\\\\(.\\\\).*/\\\\1/\u0026#39; | tr -d \u0026#39;\\n\u0026#39; | { pbcopy; pbpaste; } \u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# if you do not have the xos4-terminus font that makes characters a little bigger :\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e# uncoment this line and use the second here document\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#open $FH, \u0026#34; | dmenu -i -l 30 | sed \u0026#39;s/^\\\\(.\\\\).*/\\\\1/\u0026#39; | tr -d \u0026#39;\\n\u0026#39; | { xsel -ib; xsel -ip; } \u0026#34;;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# also you can compile dmenu from source and change the font size directly in the C done\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e# in the file config.h / config.def.h\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# this heredoc is well aligned with the -xos4-terminus-medium-r-*-*-10-* font\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eprint\u003c/span\u003e \u003cspan class=\"nv\"\u003e$FH\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026lt;\u0026lt;\u0026#39;\u003c/span\u003e\u003cspan class=\"dl\"\u003eEOF\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#39;\n\u003c/span\u003e\u003cspan class=\"s\"\u003e«         hyper operator\n\u003c/span\u003e\u003cspan class=\"s\"\u003e»         hyper operator\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∈        membership\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∉        non-membership\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∪         set union\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∩         set intersection\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∖         set difference\n\u003c/span\u003e\u003cspan class=\"s\"\u003e≡         set equality\n\u003c/span\u003e\u003cspan class=\"s\"\u003e≢        set inequality\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊖        symmetric set difference\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊍         baggy multiplication\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊎         baggy addition\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∅        empty set\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊆        subset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊈         not a subset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊂        strict subset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊄        not a strict subset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∋        reverse membership\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∌          reverse non-membership\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊇        superset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊉         not a superset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊃        strict superset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⊅        not a strict superset\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∞         infinity\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⚛        atomic operator\n\u003c/span\u003e\u003cspan class=\"s\"\u003eπ        pi\n\u003c/span\u003e\u003cspan class=\"s\"\u003eτ         tau\n\u003c/span\u003e\u003cspan class=\"s\"\u003e𝑒         Euler\u0026#39;s number\n\u003c/span\u003e\u003cspan class=\"s\"\u003e∘         function composition\n\u003c/span\u003e\u003cspan class=\"s\"\u003e×        multiplication \n\u003c/span\u003e\u003cspan class=\"s\"\u003e÷        division\n\u003c/span\u003e\u003cspan class=\"s\"\u003e≤         inferior or equal\n\u003c/span\u003e\u003cspan class=\"s\"\u003e≥         greater or equal\n\u003c/span\u003e\u003cspan class=\"s\"\u003e≠   \t     inequality\n\u003c/span\u003e\u003cspan class=\"s\"\u003e−        substraction\n\u003c/span\u003e\u003cspan class=\"s\"\u003e≅       approximatively equal\n\u003c/span\u003e\u003cspan class=\"s\"\u003e…      sequence operator\n\u003c/span\u003e\u003cspan class=\"s\"\u003e‘         left single quotation mark\n\u003c/span\u003e\u003cspan class=\"s\"\u003e’         right single quotation mark\n\u003c/span\u003e\u003cspan class=\"s\"\u003e‚         single low-9 quotation mark \n\u003c/span\u003e\u003cspan class=\"s\"\u003e”         right double quotation mark\n\u003c/span\u003e\u003cspan class=\"s\"\u003e“         left double quotation mark\n\u003c/span\u003e\u003cspan class=\"s\"\u003e„         double low-9 quotation mark\n\u003c/span\u003e\u003cspan class=\"s\"\u003e｢         halfwidth left corner bracket\n\u003c/span\u003e\u003cspan class=\"s\"\u003e｣         halfwidth right corner bracket\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁺         plus superscript\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁻         minus superscript\n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁰         0 superscript\n\u003c/span\u003e\u003cspan class=\"s\"\u003e¹         1 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e²         2 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e³         3 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁴         4 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁵         5 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁶         6 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁷         7 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁸         8 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e⁹         9 superscript \n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u003c/span\u003e\u003cspan class=\"dl\"\u003eEOF\u003c/span\u003e\n\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# use this without -xos4-terminus-medium-r-*-*-10-* font\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e# the default font may change given which font packages are installed and given the font configurations\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e#print $FH \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39;\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#«         hyper operator\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#»         hyper operator\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∈         membership\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∉         non-membership\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∪         set union\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∩         set intersection\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∖         set difference\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#≡         set equality\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#≢         set inequality\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊖         symmetric set difference\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊍         baggy multiplication\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊎         baggy addition\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∅         empty set\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊆         subset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊈         not a subset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊂         strict subset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊄         not a strict subset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∋         reverse membership\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∌         reverse non-membership\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊇         superset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊉         not a superset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊃         strict superset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⊅         not a strict superset\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∞         infinity\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⚛         atomic operator\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#π         pi\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#τ         tau\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#𝑒         Euler\u0026#39;s number\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#∘         function composition\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#×         multiplication \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#÷         division\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#≤         inferior or equal\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#≥         greater or equal\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#≠         inequality\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#−         substraction\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#≅         approximatively equal\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#…         sequence operator\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#‘         left single quotation mark\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#’         right single quotation mark\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#‚         single low-9 quotation mark \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#”         right double quotation mark\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#“         left double quotation mark\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#„         double low-9 quotation mark\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#｢         halfwidth left corner bracket\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#｣         halfwidth right corner bracket\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁺         plus superscript\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁻         minus superscript\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁰         0 superscript\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#¹         1 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#²         2 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#³         3 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁴         4 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁵         5 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁶         6 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁷         7 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁸         8 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#⁹         9 superscript \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#EOF\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e#;\u003c/span\u003e\n\n\n\n\u003cspan class=\"nb\"\u003eclose\u003c/span\u003e \u003cspan class=\"nv\"\u003e$FH\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\n\n\u003cspan class=\"cp\"\u003e__END__\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=pod \n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head1 NAME\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003elazy_raku_unicode.pl\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head1 SYNOPSIS\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eThis script allows you to select a Unicode symbol from a drop-down menu that you can simply paste into your text editor, terminal or IDE.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eAll it does is send a heredoc through a pipe to dmenu, and copy to the clipboard the character that you selected.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eDmenu is a program that reads lines from stdin, display them in a menu, and write to stdout the lines selected.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eIt is not practical to execute this script from a terminal each time you want a character though. This is why it should be executed by sxhkd.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eSxhkd is the program that will call this script each time you press the right key combination.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eOnly the most useful Unicode characters are present to not make dmenu get too slow. (It is usually very fast when there is only ascii text.)\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eThis include most of the Raku operators that have a Unicode version, plus some quoting characters, superscripts, and mathematical constants.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head1 MANUAL INSTALLATION STEPS\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head2 INSTALLING DMENU\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eB\u0026lt;On Debian or Ubuntu :\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tsudo apt install suckless-tools\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eB\u0026lt;On Archlinux :\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tsudo pacman -Sy dmenu\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eB\u0026lt;Compile it from source :\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\thttps://tools.suckless.org/dmenu/\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head2 CHANGING DMENU FONT SIZE (OPTIIONAL)\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eYou have only two ways of changing the font size :\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eChange the default font with the B\u0026lt;-fn\u0026gt; flag (See dmenu(1) for the specifics).\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\t\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tdmenu -l 30 -fn \u0026#39;-xos4-terminus-medium-r-*-*-10-*\u0026#39;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eModify directly the C source code of dmenu. Only the files B\u0026lt;config.h / config.def.h\u0026gt;.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eSimply edit this line and change 10 by 14 for example.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tstatic const char *fonts[] = {\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\t\t\u0026#34;monospace:size=10\u0026#34;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\t};\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eThen execute sudo make install and you\u0026#39;re ready to go.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head2 INSTALLING SXHKD\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eB\u0026lt;On Debian or Ubuntu :\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tsudo apt install sxhkd\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eB\u0026lt;On Archlinux :\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tsudo pacman -Sy sxhkd\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head2 CONFIGURING SXHKD\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eB\u0026lt;Autostarting sxhkd at startup :\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003esimply put this line in B\u0026lt;~/.xprofile\u0026gt; :\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tsxhkd \u0026amp;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eB\u0026lt;Setting the keybinding :\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\t\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eAdd these two lines in B\u0026lt;~/.config/sxhkd/sxhkdrc\u0026gt;\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tctrl + apostrophe\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\t\t/path/to/lazy_raku_unicode.pl\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eThe keybinding have to start at the beginning of a line, and the command has to follow on the next line and be preceded by a tabulation.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eTo make sxhkd reload the config file, either kill it and relaunch it, or send a SIGUSR1 signal. This command can do it :\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\tpidof sxhkd | kill -SIGUSR1 $(cat /dev/stdin)\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eIf you want to use a different keybinding, please see sxhkd(1) and use xev(1) to find the name of keys.\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003eHere the name of some of the keys : ctrl, super, alt, Return .\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=head1 SEE ALSO\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003edmenu(1), sxhkd(1), xev(1)\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cp\"\u003e=cut\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e参考链接: \u003ca href=\"https://docs.raku.org/language/unicode_entry\"\u003ehttps://docs.raku.org/language/unicode_entry\u003c/a\u003e\u003c/p\u003e\n","text":"Raku 有非常好的 Unicode 支持, 但是输入 Unicode 一直是一个很大的问题。在 REPL 中, 输入 Unicode 都不太方便。下面介绍几种方法来方便地输入 Unicode。\nComma 最方便的是使用 Raku 自己的 IDE, Comma。但是需要做两个设置:\n首先, 切换到 Comma IDE, 点击左上角菜单栏的 Comma 选项, 在弹出的 Preference 窗口中, 找到左侧菜单栏中的 Editor 选项, 点击 Code Style 中的 Raku, 在右侧的窗口的最上面, 找到 Schema 一行, 点击倒三角图标, 在下拉菜单中选择 Project。然后在第二行文字中找到 Editor Behavior, 勾选 Convert operators to Unicode。完成后点击右下角的 Apply, 然后点击 OK。\n这样当你在 Comma 中键入 \u0026gt;\u0026gt; 这样的运算符后, Comma 会自动把它转为 Unicode 形式的 »。目前已支持大部分 Unicode 运算符了。Comma 是跨平台的 Raku 编辑器, 支持 Windows、Linux 和 MacOS, 所以你想跨平台开发的话, Comma 值得一试。\nKitty 如果你想在 Vim 中开发 Raku, 又不想失去输入 Unicode 的乐趣, 请使用 Kitty 终端。点开 Kitty 终端, 使用快捷键 Ctrl + Shift + U 即可触发输入 Unnicode 的界面(也可以键入命令 kitty +kitten unicode_input 来触发)。再通过快捷键 F1、F2、F3 和 F4 (或通过 Ctrl+[ 和 Ctrl+] 切换标签)可以分别按代码搜索 Unicode、按名字搜索 Unicode、按表情搜索和收藏。\n例如在 REPL 中键入 Unicode 字符:\n$ raku Welcome to 𝐑𝐚𝐤𝐮𝐝𝐨™ v2021.02. Implementing the 𝐑𝐚𝐤𝐮™ programming language v6.d. Built on MoarVM version 2021.02. To exit type \u0026#39;exit\u0026#39; or \u0026#39;^D\u0026#39; \u0026gt; my @a = 1..5; \u0026gt; @a».sin 借助 Kitty, 数组 @a 后面的 » 可以这样输入, 先输入 @a, 然后使用快捷键 Shift + Ctrl + U 调出 Kitty 的 Unicode input 界面, 一般有两种方法, 第一种是通过快捷键 F1, 然后输入对应的 Unicode 编码, 再回车。第二种是通过快捷键 F2, 通过名字搜索, 例如输入单词 quota, 会出现一堆引号符号供你选择, 按上下方向键选中 », 再回车即可。Vim 中同理。\nJulia REPL 在 REPL 中输入 \\′ + 单词 + Tab, 例如输入 \\heartsuit` 再按 Tab, 就会自动变成 ♡\njulia\u0026gt; \\heartsuit IPython \\^ 输入上标, \\_p 输入下标。\n$ ipython \\^a \\_p VScode \\\\′ + 完整的单词 + Tab, VsCode 会自动转换为 Unicode。 例如 ^a和_p`\ndmenu #!/usr/bin/perl #use strict; #use warnings; #use autodie; #use utf8; open $FH, \u0026#34; | dmenu -i -l 30 -fn \u0026#39;-xos4-terminus-medium-r-*-*-10-*\u0026#39; | sed \u0026#39;s/^\\\\(.\\\\).*/\\\\1/\u0026#39; | tr -d \u0026#39;\\n\u0026#39; | { pbcopy; pbpaste; } \u0026#34;; # if you do not have the xos4-terminus font that makes characters a little bigger : # uncoment this line and use the second here document #open $FH, \u0026#34; | dmenu -i -l 30 | sed \u0026#39;s/^\\\\(.\\\\).*/\\\\1/\u0026#39; | tr -d \u0026#39;\\n\u0026#39; | { xsel -ib; xsel -ip; } \u0026#34;; # also you can compile dmenu from source and change the font size directly in the C done # in the file config.h / config.def.h # this heredoc is well aligned with the -xos4-terminus-medium-r-*-*-10-* font print $FH \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; « hyper operator » hyper operator ∈ membership ∉ non-membership ∪ set union ∩ set intersection ∖ set difference ≡ set equality ≢ set inequality ⊖ symmetric set difference ⊍ baggy multiplication ⊎ baggy addition ∅ empty set ⊆ subset ⊈ not a subset ⊂ strict subset ⊄ not a strict subset ∋ reverse membership ∌ reverse non-membership ⊇ superset ⊉ not a superset ⊃ strict superset ⊅ not a strict superset ∞ infinity ⚛ atomic operator π pi τ tau 𝑒 Euler\u0026#39;s number ∘ function composition × multiplication ÷ division ≤ inferior or equal ≥ greater or equal ≠ inequality − substraction ≅ approximatively equal … sequence operator ‘ left single quotation mark ’ right single quotation mark ‚ single low-9 quotation mark ” right double quotation mark “ left double quotation mark „ double low-9 quotation mark ｢ halfwidth left corner bracket ｣ halfwidth right corner bracket ⁺ plus superscript ⁻ minus superscript ⁰ 0 superscript ¹ 1 superscript ² 2 superscript ³ 3 superscript ⁴ 4 superscript ⁵ 5 superscript ⁶ 6 superscript ⁷ 7 superscript ⁸ 8 superscript ⁹ 9 superscript EOF ; # use this without -xos4-terminus-medium-r-*-*-10-* font # the default font may change given which font packages are installed and given the font configurations #print $FH \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; #« hyper operator #» hyper operator #∈ membership #∉ non-membership #∪ set union #∩ set intersection #∖ set difference #≡ set equality #≢ set inequality #⊖ symmetric set difference #⊍ baggy multiplication #⊎ baggy addition #∅ empty set #⊆ subset #⊈ not a subset #⊂ strict subset #⊄ not a strict subset #∋ reverse membership #∌ reverse non-membership #⊇ superset #⊉ not a superset #⊃ strict superset #⊅ not a strict superset #∞ infinity #⚛ atomic operator #π pi #τ tau #𝑒 Euler\u0026#39;s number #∘ function composition #× multiplication  #÷ division #≤ inferior or equal #≥ greater or equal #≠ inequality #− substraction #≅ approximatively equal #… sequence operator #‘ left single quotation mark #’ right single quotation mark #‚ single low-9 quotation mark  #” right double quotation mark #“ left double quotation mark #„ double low-9 quotation mark #｢ halfwidth left corner bracket #｣ halfwidth right corner bracket #⁺ plus superscript #⁻ minus superscript #⁰ 0 superscript #¹ 1 superscript  #² 2 superscript  #³ 3 superscript  #⁴ 4 superscript  #⁵ 5 superscript  #⁶ 6 superscript  #⁷ 7 superscript  #⁸ 8 superscript  #⁹ 9 superscript  #EOF #; close $FH; __END__ =pod =head1 NAME lazy_raku_unicode.pl =head1 SYNOPSIS This script allows you to select a Unicode symbol from a drop-down menu that you can simply paste into your text editor, terminal or IDE. All it does is send a heredoc through a pipe to dmenu, and copy to the clipboard the character that you selected. Dmenu is a program that reads lines from stdin, display them in a menu, and write to stdout the lines selected. It is not practical to execute this script from a terminal each time you want a character though. This is why it should be executed by sxhkd. Sxhkd is the program that will call this script each time you press the right key combination. Only the most useful Unicode characters are present to not make dmenu get too slow. (It is usually very fast when there is only ascii text.) This include most of the Raku operators that have a Unicode version, plus some quoting characters, superscripts, and mathematical constants. =head1 MANUAL INSTALLATION STEPS =head2 INSTALLING DMENU B\u0026lt;On Debian or Ubuntu :\u0026gt; sudo apt install suckless-tools B\u0026lt;On Archlinux :\u0026gt; sudo pacman -Sy dmenu B\u0026lt;Compile it from source :\u0026gt; https://tools.suckless.org/dmenu/ =head2 CHANGING DMENU FONT SIZE (OPTIIONAL) You have only two ways of changing the font size : Change the default font with the B\u0026lt;-fn\u0026gt; flag (See dmenu(1) for the specifics). dmenu -l 30 -fn \u0026#39;-xos4-terminus-medium-r-*-*-10-*\u0026#39; Modify directly the C source code of dmenu. Only the files B\u0026lt;config.h / config.def.h\u0026gt;. Simply edit this line and change 10 by 14 for example. static const char *fonts[] = { \u0026#34;monospace:size=10\u0026#34; }; Then execute sudo make install and you\u0026#39;re ready to go. =head2 INSTALLING SXHKD B\u0026lt;On Debian or Ubuntu :\u0026gt; sudo apt install sxhkd B\u0026lt;On Archlinux :\u0026gt; sudo pacman -Sy sxhkd =head2 CONFIGURING SXHKD B\u0026lt;Autostarting sxhkd at startup :\u0026gt; simply put this line in B\u0026lt;~/.xprofile\u0026gt; : sxhkd \u0026amp; B\u0026lt;Setting the keybinding :\u0026gt; Add these two lines in B\u0026lt;~/.config/sxhkd/sxhkdrc\u0026gt; ctrl + apostrophe /path/to/lazy_raku_unicode.pl The keybinding have to start at the beginning of a line, and the command has to follow on the next line and be preceded by a tabulation. To make sxhkd reload the config file, either kill it and relaunch it, or send a SIGUSR1 signal. This command can do it : pidof sxhkd | kill -SIGUSR1 $(cat /dev/stdin) If you want to use a different keybinding, please see sxhkd(1) and use xev(1) to find the name of keys. Here the name of some of the keys : ctrl, super, alt, Return . =head1 SEE ALSO dmenu(1), sxhkd(1), xev(1) =cut 参考链接: https://docs.raku.org/language/unicode_entry\n"},"name":"如何在 Raku 中输入 Unicode","published":"2021-03-01T00:00:00+08:00","summary":"How to Type Unicode in Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/"},{"content":{"html":"\u003cp\u003e在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\j = 1 | 2 | 3;\ndd j;\nuse nqp;\n.say for nqp::getattr(j, Junction, '$!eigenstates');\n# OUTPUT: any(1, 2, 3)\n          1\n          2\n          3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub pry(Mu $the-object is raw) {\n    use InterceptAllMethods;\n\n    class Interceptor {\n        has Mu $!the-object;\n        method ^find_method(Mu \\type, Str $name) {\n            my method (Mu \\SELF:) is raw {\n                use nqp;\n                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');\n                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)\n            }\n        }\n    }\n\n    use nqp;\n    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);\n}\n\n.say for j.\u0026amp;pry.eigenstates;\n# OUTPUT: 1\n          2\n          3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 \u003ccode\u003e.\u0026amp;pry\u003c/code\u003e 被调用的对象做任何我们想做的事情。\u003c/p\u003e\n\u003cp\u003e由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 \u003ccode\u003e.new\u003c/code\u003e。由于 \u003ccode\u003e.^\u003c/code\u003e 不是 \u003ccode\u003e.\u003c/code\u003e 的特殊形式，我们可以用它来获得对类方法的访问。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub interceptor(Method $the-method){\n    use InterceptAllMethods;\n    use nqp;\n\n    sub (Mu $the-object is raw) {\n        my class Interceptor {\n            has Mu $!the-object;\n            has Code $!the-method;\n\n            method ^find_method(Mu \\type, Mu:D $name) {\n                my method (Mu \\SELF: |c) is raw {\n                    $!the-method.($!the-object, $name, |c)\n                }\n            }\n            method ^introspect(Mu \\type, Mu \\obj) {\n                my method call-it() is raw {\n                    $!the-object\n                }\n                obj.\u0026amp;call-it;\n            }\n            method ^new(Mu \\type, $the-object!, $the-method) {\n                nqp::p6bindattrinvres(\n                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                        Interceptor, '$!the-method', $the-method)\n            }\n        }\n\n            # nqp::p6bindattrinvres(\n                #     nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                #   Interceptor, '$!the-method', $the-method);\n        Interceptor.^new($the-object, $the-method)\n    }\n}\n\nmy \u0026amp;first-defined = interceptor(\n    my method (Positional \\SELF: $name) {\n        for SELF.flat -\u0026gt; $e {\n            with $e.\u0026quot;$name\u0026quot;(|%_) {\n                .return\n            }\n        }\n        Nil\n    }\n);\n\nmy $file = \u0026lt;file1.txt file2.txt file3.txt nohup.out\u0026gt;».IO.\u0026amp;first-defined.open(:r);\ndd $file;\n# OUTPUT: Handle $file = IO::Handle.new(path =\u0026gt; IO::Path.new(\u0026quot;nohup.out\u0026quot;, :SPEC(IO::Spec::Unix), :CWD(\u0026quot;/home/dex/projects/raku/tmp\u0026quot;)), chomp =\u0026gt; Bool::True, nl-in =\u0026gt; $[\u0026quot;\\n\u0026quot;, \u0026quot;\\r\\n\u0026quot;], nl-out =\u0026gt; \u0026quot;\\n\u0026quot;, encoding =\u0026gt; \u0026quot;utf8\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003esub \u003ccode\u003einterceptor\u003c/code\u003e 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 \u003ccode\u003e.\u0026amp;first-defined\u003c/code\u003e 被调用时，会返回一个特殊的对象。让我们来看看它是什么。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\uhhh-special = \u0026lt;a b c\u0026gt;.\u0026amp;first-defined;\ndd uhhh-special.^introspect(uhhh-special);\n# OUTPUT: ($(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), method \u0026lt;anon\u0026gt; (Positional \\SELF: $name, *%_) { #`(Method|93927752146784) ... })\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们必须给 \u003ccode\u003e.^introspect\u003c/code\u003e 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。\u003c/p\u003e\n\u003cp\u003e目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 \u003ccode\u003eclass\u003c/code\u003e，而不是用不同的名字导出特殊的 \u003ccode\u003eMetamodel::ClassHOW\u003c/code\u003e。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass InterceptHOW is Metamodel::ClassHOW {\n    method publish_method_cache(|) { }\n}\n\nsub ipry(Mu $the-object is raw) {\n    my \\Interceptor = InterceptHOW.new_type(:name\u0026lt;Interceptor\u0026gt;);\n    Interceptor.^add_attribute(Attribute.new(:name\u0026lt;$!the-object\u0026gt;, :type(Mu), :package(Interceptor)));\n    Interceptor.^add_meta_method('find_method',\n        my method find_method(Mu \\type, Str $name) {\n            # say „looking for $name“;\n            my method (Mu \\SELF:) is raw {\n                use nqp;\n                my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object');\n                nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name)\n            }\n    });\n    Interceptor.^compose;\n\n    use nqp;\n    nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我写这篇文章的时候，我发现 \u003ccode\u003e.^add_meta_method\u003c/code\u003e 只有在提供给它的方法的第一个参数的名字和 \u003ccode\u003eStr\u003c/code\u003e 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 \u003ccode\u003e.^meta_method_table\u003c/code\u003e 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 \u003ccode\u003eActions.nqp\u003c/code\u003e 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。\u003c/p\u003e\n\u003cp\u003e我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti sub methodify(%h, :$deeply!) {\n    sub interceptor(%h, $parent = Nil){\n        use InterceptAllMethods;\n        use nqp;\n\n        class Interceptor is Callable {\n            has Mu $!the-object;\n            has Mu @!stack;\n\n            method ^find_method(Mu \\type, Mu:D $name) {\n                my method (Mu \\SELF: |c) is raw {\n                    my @new-stack = @!stack;\n                    my $the-object = $!the-object;\n\n                    if $name eq 'STORE' {\n                        # workaround for rakudobug#4203\n                        $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists;\n\n                        $the-object{||@new-stack} = c;\n                        return-rw c\n                    } else {\n                        @new-stack.push: $name;\n                        my \\nextlevel = SELF.^new($!the-object, @new-stack, $name);\n                        nextlevel\n                    }\n                }\n            }\n            method ^introspect(Mu \\type, Mu \\obj) {\n                my method call-it() is raw {\n                    $!the-object, @!stack\n                }\n                obj.\u0026amp;call-it;\n            }\n            method ^new(Mu \\type, $the-object!, @new-stack?, $name?) {\n                $name\n                    ?? nqp::p6bindattrinvres(\n                        nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object),\n                        Interceptor, '@!stack', @new-stack)\n                    !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object)\n                }\n        }\n\n        Interceptor.^new(%h)\n    }\n\n    interceptor(%h)\n}\n\nmy %h2;\nmy $o2 = methodify(%h2, :deeply);\n$o2.a.b = 42;\ndd %h2;\n$o2.a.b.c = \u0026lt;answer\u0026gt;;\ndd %h2;\nsay $o2.a.b.c;\n# OUTPUT: Hash %h2 = {:a(${:b(\\(42))})}\n          Hash %h2 = {:a(${:b(${:c(\\(\u0026quot;answer\u0026quot;))})})}\n          This type cannot unbox to a native string: P6opaque, Interceptor\n            in block \u0026lt;unit\u0026gt; at /home/dex/projects/raku/any-chain.raku line 310\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 \u003ccode\u003ev6.e.preview\u003c/code\u003e，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 \u003ccode\u003e.e\u003c/code\u003e 发布到野外之前，把所有的野兽都杀掉。\u003c/p\u003e\n\u003cp\u003e能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。\u003c/p\u003e\n\u003cp\u003e有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 \u003ccode\u003etry\u003c/code\u003e 来化解它们，但那会破坏一个方法调用链。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003econstant no-argument-given = Mu.new;\nsub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) {\n    interceptor(my method (Mu \\SELF: $name, |c) {\n        my $o = SELF;\n        my \\m = $o.^lookup($name) orelse {\n            my $bt = Backtrace.new;\n            my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1);\n            (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1));\n        }\n\n        try {\n            $o = $o.\u0026quot;$name\u0026quot;(|c);\n        }\n \n        $! ~~ Exception\n            ?? $alternate-value.WHICH eqv no-argument-given.WHICH\n                ?? $o\n                !! $alternate-value\n            !! $o\n    }).($obj)\n}\n\nclass C {\n    has $.greeting;\n    method might-throw { die \u0026quot;Not today love!\u0026quot; }\n    method greet { say $.greeting }\n}\n\nC.new(greeting =\u0026gt; ‚Let's make love!‘).\u0026amp;try.might-throw.greet;\n# OUTPUT: Let's make love!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 \u003ccode\u003e$alternate-value\u003c/code\u003e，因为它实际上可能会把异常对象变成 \u003ccode\u003eNil\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的\u003ca href=\"https://ftp.fau.de/fosdem/2021/D.perl/programming_lang_for_free_software.webm\"\u003e编程语言\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/17/method-ish/\"\u003ehttps://gfldex.wordpress.com/2021/02/17/method-ish/\u003c/a\u003e\u003c/p\u003e\n","text":"在我的上一篇文章中，我又一次为从 CORE 中增强类的方法而苦恼。这种挣扎完全没有必要，因为我并没有用增加的方法改变对象的状态。对于做更高级的东西，我可能不得不这样做。把手伸进 Raku 的内部这么深，我可能会把自己烫伤。既然我想做的是把我的代码绑在编译器的变化上，反正我可能会全身心地投入到 nqp-land 中去。\nmy \\j = 1 | 2 | 3; dd j; use nqp; .say for nqp::getattr(j, Junction, '$!eigenstates'); # OUTPUT: any(1, 2, 3) 1 2 3 我们可以使用 nqp 来获取私有属性，而不需要添加任何方法。这就有点儿不伦不类了。所以，让我们用一个伪方法来做一些 deboilerplating。\nsub pry(Mu $the-object is raw) { use InterceptAllMethods; class Interceptor { has Mu $!the-object; method ^find_method(Mu \\type, Str $name) { my method (Mu \\SELF:) is raw { use nqp; my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object'); nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name) } } } use nqp; nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object); } .say for j.\u0026amp;pry.eigenstates; # OUTPUT: 1 2 3 通过 InterceptAllMethods，lizmat 改变了类关键字的行为，允许我们提供一个 FALLBACK-method 来捕获任何方法，包括从 Mu 继承的方法。这反过来又允许 pry 返回的对象将任何方法调用转移到一个自定义的方法。在这个方法中，我们可以对 .\u0026amp;pry 被调用的对象做任何我们想做的事情。\n由于我们的特殊对象会拦截任何调用，甚至是 Mu 的调用，我们需要找到另一种方法来调用 .new。由于 .^ 不是 . 的特殊形式，我们可以用它来获得对类方法的访问。\nsub interceptor(Method $the-method){ use InterceptAllMethods; use nqp; sub (Mu $the-object is raw) { my class Interceptor { has Mu $!the-object; has Code $!the-method; method ^find_method(Mu \\type, Mu:D $name) { my method (Mu \\SELF: |c) is raw { $!the-method.($!the-object, $name, |c) } } method ^introspect(Mu \\type, Mu \\obj) { my method call-it() is raw { $!the-object } obj.\u0026amp;call-it; } method ^new(Mu \\type, $the-object!, $the-method) { nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), Interceptor, '$!the-method', $the-method) } } # nqp::p6bindattrinvres( # nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), # Interceptor, '$!the-method', $the-method); Interceptor.^new($the-object, $the-method) } } my \u0026amp;first-defined = interceptor( my method (Positional \\SELF: $name) { for SELF.flat -\u0026gt; $e { with $e.\u0026quot;$name\u0026quot;(|%_) { .return } } Nil } ); my $file = \u0026lt;file1.txt file2.txt file3.txt nohup.out\u0026gt;».IO.\u0026amp;first-defined.open(:r); dd $file; # OUTPUT: Handle $file = IO::Handle.new(path =\u0026gt; IO::Path.new(\u0026quot;nohup.out\u0026quot;, :SPEC(IO::Spec::Unix), :CWD(\u0026quot;/home/dex/projects/raku/tmp\u0026quot;)), chomp =\u0026gt; Bool::True, nl-in =\u0026gt; $[\u0026quot;\\n\u0026quot;, \u0026quot;\\r\\n\u0026quot;], nl-out =\u0026gt; \u0026quot;\\n\u0026quot;, encoding =\u0026gt; \u0026quot;utf8\u0026quot;) sub interceptor 接受一个方法并返回一个 sub。如果这个 sub 像方法一样被调用，它将把要被调用的方法的名称和调用者转发给一个自定义方法。当 .\u0026amp;first-defined 被调用时，会返回一个特殊的对象。让我们来看看它是什么。\nmy \\uhhh-special = \u0026lt;a b c\u0026gt;.\u0026amp;first-defined; dd uhhh-special.^introspect(uhhh-special); # OUTPUT: ($(\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;), method \u0026lt;anon\u0026gt; (Positional \\SELF: $name, *%_) { #`(Method|93927752146784) ... }) 我们必须给 .^introspect 一个我们想看的对象，因为它的调用者是类 Interceptor 的类型对象。\n目前，我还不知道有什么办法（毕竟，我知道的只是足够多的东西，真的很危险。这是不幸的，因为 lizmat 决定重载关键字 class，而不是用不同的名字导出特殊的 Metamodel::ClassHOW。如果我们不想或不能有外部依赖，我们可以使用 MOP 来创建我们的类型对象。\nclass InterceptHOW is Metamodel::ClassHOW { method publish_method_cache(|) { } } sub ipry(Mu $the-object is raw) { my \\Interceptor = InterceptHOW.new_type(:name\u0026lt;Interceptor\u0026gt;); Interceptor.^add_attribute(Attribute.new(:name\u0026lt;$!the-object\u0026gt;, :type(Mu), :package(Interceptor))); Interceptor.^add_meta_method('find_method', my method find_method(Mu \\type, Str $name) { # say „looking for $name“; my method (Mu \\SELF:) is raw { use nqp; my $the-object := nqp::getattr(SELF, Interceptor, '$!the-object'); nqp::getattr($the-object, $the-object.WHAT, '$!' ~ $name) } }); Interceptor.^compose; use nqp; nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object); } 当我写这篇文章的时候，我发现 .^add_meta_method 只有在提供给它的方法的第一个参数的名字和 Str 相同的时候才会工作。起初，我尝试了一个匿名方法，它最终出现在 .^meta_method_table 中，但从未被调用。我想这个 bug 其实并不重要，因为这个元方法根本没有被记录下来。如果我玩火，我没有权利抱怨烧伤。你会在野外的 Actions.nqp 中发现这个方法。Class 关键字并没有什么神奇的作用。Rakudo 只是使用 MOP 来构造类型对象。\n我们不能在 Raku 中重载赋值操作符。这其实并不需要，因为赋值是通过调用一个名为 STORE 的方法来实现的。由于我们得到了对 dispatch 的完全控制，我们可以拦截任何方法调用，包括一连串的方法调用。\nmulti sub methodify(%h, :$deeply!) { sub interceptor(%h, $parent = Nil){ use InterceptAllMethods; use nqp; class Interceptor is Callable { has Mu $!the-object; has Mu @!stack; method ^find_method(Mu \\type, Mu:D $name) { my method (Mu \\SELF: |c) is raw { my @new-stack = @!stack; my $the-object = $!the-object; if $name eq 'STORE' { # workaround for rakudobug#4203 $the-object{||@new-stack.head(*-1)}:delete if $the-object{||@new-stack.head(*-1)}:exists; $the-object{||@new-stack} = c; return-rw c } else { @new-stack.push: $name; my \\nextlevel = SELF.^new($!the-object, @new-stack, $name); nextlevel } } } method ^introspect(Mu \\type, Mu \\obj) { my method call-it() is raw { $!the-object, @!stack } obj.\u0026amp;call-it; } method ^new(Mu \\type, $the-object!, @new-stack?, $name?) { $name ?? nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object), Interceptor, '@!stack', @new-stack) !! nqp::p6bindattrinvres(nqp::create(Interceptor), Interceptor, '$!the-object', $the-object) } } Interceptor.^new(%h) } interceptor(%h) } my %h2; my $o2 = methodify(%h2, :deeply); $o2.a.b = 42; dd %h2; $o2.a.b.c = \u0026lt;answer\u0026gt;; dd %h2; say $o2.a.b.c; # OUTPUT: Hash %h2 = {:a(${:b(\\(42))})} Hash %h2 = {:a(${:b(${:c(\\(\u0026quot;answer\u0026quot;))})})} This type cannot unbox to a native string: P6opaque, Interceptor in block \u0026lt;unit\u0026gt; at /home/dex/projects/raku/any-chain.raku line 310 每当我们调用一个方法时，都会创建一个新的 Interceptor 实例，它存储了前一个方法的名称。这样我们就可以沿着方法调用链移动。由于赋值调用 STORE，我们可以将赋值转移到我们用作实际数据结构的 Hash 中。唉，检索值就不一样了，因为 Raku 不区分方法调用和 FETCH。在这里，龙比我强。我还是包含了这个一半失败的尝试，因为我对 slippy 半列表有很好的利用。这需要使用 v6.e.preview，让我踩到了一个 bug。可能还有更多这样的情况。所以请使用同样的，这样我们就可以在 .e 发布到野外之前，把所有的野兽都杀掉。\n能够完全控制方法调用链将是一件好事。也许我们可以用 RakuAST 来做到这一点。\n有了这些已经可以工作的东西，我们可以做一些有趣的事情。那些烦人的异常总是在拖我们的后腿。我们可以用 try 来化解它们，但那会破坏一个方法调用链。\nconstant no-argument-given = Mu.new; sub try(Mu $obj is raw, Mu $alternate-value = no-argument-given) { interceptor(my method (Mu \\SELF: $name, |c) { my $o = SELF; my \\m = $o.^lookup($name) orelse { my $bt = Backtrace.new; my $idx = $bt.next-interesting-index($bt.next-interesting-index + 1); (X::Method::NotFound.new(:method($name), :typename($o.^name)) but role :: { method vault-backtrace { False }}).throw(Backtrace.new($idx + 1)); } try { $o = $o.\u0026quot;$name\u0026quot;(|c); } $! ~~ Exception ?? $alternate-value.WHICH eqv no-argument-given.WHICH ?? $o !! $alternate-value !! $o }).($obj) } class C { has $.greeting; method might-throw { die \u0026quot;Not today love!\u0026quot; } method greet { say $.greeting } } C.new(greeting =\u0026gt; ‚Let's make love!‘).\u0026amp;try.might-throw.greet; # OUTPUT: Let's make love! 伪方法 try 将会化解任何异常，并允许继续调用 C 语言的方法。我必须用一个特殊的值来标记没有可选的参数 $alternate-value，因为它实际上可能会把异常对象变成 Nil。\n我很肯定还有很多这样的小帮手在等着我们去发现。未来可能会有一个模块，希望能帮助 Raku 成为一个好的编程语言。\n原文链接: https://gfldex.wordpress.com/2021/02/17/method-ish/\n"},"name":"Method-ish","published":"2021-02-28T00:00:00+08:00","summary":"Method-ish","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-17-method-isd/"},{"content":{"html":"\u003cp\u003e一直以来乐于助人的 \u003ca href=\"https://stackoverflow.com/users/1077672/raiph\"\u003eraiph\u003c/a\u003e 在回答一个关于模式匹配的\u003ca href=\"https://stackoverflow.com/questions/66233465/haskell-like-pattern-matching-in-raku\"\u003e问题\u003c/a\u003e时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eclass Hold { has $.key; }\nclass Press { has $.key; }\nclass Err { has $.msg; }\n\nsub else(\u0026amp;code) { \u0026amp;code }\n\nsub match($needle, *@tests) {\n    for @tests.head(*-1) -\u0026gt; \u0026amp;f {\n        if \u0026amp;f.cando(\\($needle)) {\n            return f($needle);\n        }\n    }\n    @tests.tail.();\n}\n\nmatch Hold.new(:key\u0026lt;a\u0026gt;),\n    -\u0026gt; Hold (:$key) { put „holding $key“; },\n    -\u0026gt; Press (:$key) { put „pressing $key“; },\n    -\u0026gt; Err (:$msg) { warn „ERR: $msg“ },\n    else { fail ‚unsopported‘ };\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e方法 \u003ccode\u003e.cando\u003c/code\u003e 需要一个 \u003ca href=\"https://docs.raku.org/type/Capture\"\u003eCapture\u003c/a\u003e 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 \u003ccode\u003e\\($arguments, $go, $here)\u003c/code\u003e。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub \u003ccode\u003eelse\u003c/code\u003e 只是为了美化。\u003c/p\u003e\n\u003cp\u003e由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \u0026amp;key-matcher = \u0026amp;match.assuming(*,[\n        -\u0026gt; Hold (:$key) { put „holding $key“; },\n        -\u0026gt; Press (:$key) { put „pressing $key“; },\n        -\u0026gt; Err (:$msg) { warn „ERR: $msg“ },\n        else { fail ‚unsopported‘ };\n]);\n\nsub key-source {\n    gather loop {\n        sleep 1;\n        take (Hold.new(:key\u0026lt;a\u0026gt;), Press.new(:key\u0026lt;b\u0026gt;), Err.new(:msg\u0026lt;WELP!\u0026gt;), 'unsupported').pick;\n    }\n}\n\n.\u0026amp;key-matcher for key-source;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们要帮助 \u003ccode\u003e.assuming\u003c/code\u003e 有点理解 slurpies，把函数列表放在一个显式 Array 中。\u003c/p\u003e\n\u003cp\u003e总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\"\u003ehttps://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\u003c/a\u003e\u003c/p\u003e\n","text":"一直以来乐于助人的 raiph 在回答一个关于模式匹配的问题时希望得到 RakuAST，就像在 Haskell 中一样。有人提出用 MMD 来解决这个问题。这样做，得到一个贯穿的默认路径是无解的。由于 dispatch 简单来说就是模式匹配，我们只需要做一些额外的工作。简而言之，dispatcher 得到一个函数列表和一个带参数的列表。第一个接受所有参数的函数获胜。\nclass Hold { has $.key; } class Press { has $.key; } class Err { has $.msg; } sub else(\u0026amp;code) { \u0026amp;code } sub match($needle, *@tests) { for @tests.head(*-1) -\u0026gt; \u0026amp;f { if \u0026amp;f.cando(\\($needle)) { return f($needle); } } @tests.tail.(); } match Hold.new(:key\u0026lt;a\u0026gt;), -\u0026gt; Hold (:$key) { put „holding $key“; }, -\u0026gt; Press (:$key) { put „pressing $key“; }, -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }, else { fail ‚unsopported‘ }; 方法 .cando 需要一个 Capture 来告诉我们一个 Routine 是否可以用一个给定的参数列表来调用。为了创建这样一个捕获，我们使用字面的 \\($arguments, $go, $here)。我们不在最后测试默认值。相反，当没有其他函数匹配时，我们会调用该函数。声明 sub else 只是为了美化。\n由于我们是在函数式的土地上，我们可以使用 Raku 提供给我们的所有方便的功能。\nmy \u0026amp;key-matcher = \u0026amp;match.assuming(*,[ -\u0026gt; Hold (:$key) { put „holding $key“; }, -\u0026gt; Press (:$key) { put „pressing $key“; }, -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }, else { fail ‚unsopported‘ }; ]); sub key-source { gather loop { sleep 1; take (Hold.new(:key\u0026lt;a\u0026gt;), Press.new(:key\u0026lt;b\u0026gt;), Err.new(:msg\u0026lt;WELP!\u0026gt;), 'unsupported').pick; } } .\u0026amp;key-matcher for key-source; 我们要帮助 .assuming 有点理解 slurpies，把函数列表放在一个显式 Array 中。\n总有一种函数式的方法来解决一个问题。有时我们甚至可以从中得到一个整齐的语法。\n原文链接: https://gfldex.wordpress.com/2021/02/24/pattern-dispatch/\n"},"name":"模式分派","published":"2021-02-28T00:00:00+08:00","summary":"Pattern Dispatch","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/"},{"content":{"html":"\u003cp\u003e我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub accord(\u0026amp;c) { (c(CALLER::\u0026lt;$_\u0026gt;); succeed) if \u0026amp;c.cando(\\(CALLER::\u0026lt;$_\u0026gt;)) }\n\ngiven Err.new(:msg\u0026lt;a\u0026gt;) {\n    accord -\u0026gt; Hold (:$key) { put „holding $key“; }\n    accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }\n    default { fail ‚unsupported‘ }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这是因为 \u003ccode\u003eaccord\u003c/code\u003e 模仿了 \u003ccode\u003ewhen\u003c/code\u003e 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 \u003ccode\u003e$_\u003c/code\u003e。利用 pointy 的签名来做\u003ca href=\"https://docs.raku.org/type/Signature#Destructuring_arguments\"\u003e解构\u003c/a\u003e是相当强大的。把这个添加到 CORE 中可能是个好主意。\u003c/p\u003e\n\u003cp\u003e我们可能要把 Raku 的定义改成: \u0026ldquo;Raku 是一种高度可组合的编程语言\u0026rdquo;, 在这里，所有的东西都会落到实处。\u0026quot;\u003c/p\u003e\n\u003cp\u003e更新一下。\u003c/p\u003e\n\u003cp\u003e有些情况下，\u003ccode\u003e$_\u003c/code\u003e 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti sub accord(\u0026amp;c) {\n    use nqp;\n    $_ := nqp::getlexcaller('$_');\n    (c($_); succeed) if \u0026amp;c.cando(\\($_))\n}\n\nfor @possibilities.roll(1) -\u0026gt; $needle {\n    given $needle {\n        accord -\u0026gt; Hold (:$key) { put „holding $key“; }\n        accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ }\n        default { warn ‚unsopported‘ }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e原文链接: \u003ca href=\"https://gfldex.wordpress.com/2021/02/25/custom-when/\"\u003ehttps://gfldex.wordpress.com/2021/02/25/custom-when/\u003c/a\u003e\u003c/p\u003e\n","text":"我不太喜欢上一篇文章中使用匹配的语法。它的参数列表中的逗号看起来很奇怪，不合适。也许是因为我的眼睛习惯了给定的块。睡一觉就好了。\nsub accord(\u0026amp;c) { (c(CALLER::\u0026lt;$_\u0026gt;); succeed) if \u0026amp;c.cando(\\(CALLER::\u0026lt;$_\u0026gt;)) } given Err.new(:msg\u0026lt;a\u0026gt;) { accord -\u0026gt; Hold (:$key) { put „holding $key“; } accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ } default { fail ‚unsupported‘ } } 这是因为 accord 模仿了 when 的工作。它做了一些匹配，当 True 时调用一个块，并在每个块的结尾添加一个 success（通过抛出一个控制异常）。given 所做的只是设置主题。它还充当了 caller 的角色，所以我们可以通过一个伪包来访问它的 $_。利用 pointy 的签名来做解构是相当强大的。把这个添加到 CORE 中可能是个好主意。\n我们可能要把 Raku 的定义改成: \u0026ldquo;Raku 是一种高度可组合的编程语言\u0026rdquo;, 在这里，所有的东西都会落到实处。\u0026quot;\n更新一下。\n有些情况下，$_ 不是动态的。另外，success 正在抛出一个控制异常，而这些的处理程序是由 when 或默认添加的。这种情况是在编译时发生的，目前不能用宏来解决。第一个问题可以用黑魔法解决。后一个问题需要用默认块。我没有找到一种方法来提供一个合理的错误信息，如果缺少这个块。\nmulti sub accord(\u0026amp;c) { use nqp; $_ := nqp::getlexcaller('$_'); (c($_); succeed) if \u0026amp;c.cando(\\($_)) } for @possibilities.roll(1) -\u0026gt; $needle { given $needle { accord -\u0026gt; Hold (:$key) { put „holding $key“; } accord -\u0026gt; Err (:$msg) { warn „ERR: $msg“ } default { warn ‚unsopported‘ } } } 原文链接: https://gfldex.wordpress.com/2021/02/25/custom-when/\n"},"name":"自定义 when","published":"2021-02-28T00:00:00+08:00","summary":"Custom When","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-28-custom-when/"},{"content":{"html":"\u003cp\u003e[113] 发表于2021年1月30日。\n这是我对 \u003ca href=\"https://perlweeklychallenge.org/blog/perl-weekly-challenge-097/\"\u003ePerl 每周挑战#097\u003c/a\u003e 的回应。\u003c/p\u003e\n\u003ch2 id=\"挑战-0971-凯撒密码\"\u003e挑战 #097.1: 凯撒密码\u003c/h2\u003e\n\u003cp\u003e给你一个只包含字母 \u003ccode\u003eA..Z\u003c/code\u003e 的字符串 \u003ccode\u003e$S\u003c/code\u003e 和一个数字 \u003ccode\u003e$N\u003c/code\u003e。\n写一个脚本，用\u003ca href=\"https://en.wikipedia.org/wiki/Caesar_cipher\"\u003e凯撒密码\u003c/a\u003e对给定的字符串 \u003ccode\u003e$S\u003c/code\u003e 进行加密，左移大小为 \u003ccode\u003e$N\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e例子:\n输入: $S = \u0026ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026rdquo;, $N = 3\n输出: \u0026ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\u0026rdquo;\u003c/p\u003e\n\u003cp\u003ePlain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ\nCipher:   XYZABCDEFGHIJKLMNOPQRSTUVW\u003c/p\u003e\n\u003cp\u003ePlaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\nCiphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;只用字母 \u003ccode\u003eA...Z\u003c/code\u003e\u0026rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。\u003c/p\u003e\n\u003cp\u003e文件: caesar-cipher\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env raku\n\nsubset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/;   # [1]\nsubset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25;            # [2]\n\nunit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',\n               PosInt $N = 3);                         # [3]\n\nsay $S.comb.map({ caesar($_, $N) }).join;              # [4]\n\nsub caesar ($char, $shift)\n{\n  return $char if $char eq \u0026quot; \u0026quot;;                        # [5]\n\n  my $code = $char.ord;                                # [6]\n\n  $code -= $shift;                                     # [7]\n\n  $code += 26 if $code \u0026lt; 65;  # 'A'                    # [8]\n  $code -= 26 if $code \u0026gt; 90;  # 'Z'                    # [8a]\n\n  return $code.chr;                                    # [9]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 所允许的字符 (或 «特定领域字母»).\u003c/p\u003e\n\u003cp\u003e[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。\u003c/p\u003e\n\u003cp\u003e[3] 参数，默认值为挑战中给出的值。\u003c/p\u003e\n\u003cp\u003e[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 \u0026ldquo;caesar\u0026rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。\u003c/p\u003e\n\u003cp\u003e[5] 不移动空格。\u003c/p\u003e\n\u003cp\u003e[6] 获取字符的代码点。\u003c/p\u003e\n\u003cp\u003e[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。\u003c/p\u003e\n\u003cp\u003e[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。\u003c/p\u003e\n\u003cp\u003e[9] 获取指定代码点的字符。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。\u003c/p\u003e\n\u003cp\u003e运行它:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3\nQEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3\nWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRaku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。\u003c/p\u003e\n\u003cp\u003e文件: caesar-cipher-map\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env raku\n\nsubset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/;\nsubset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25;\n\nunit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG',\n               PosInt $N = 3);\n\nsay caesar($S, $N);\n\nsub caesar ($string, $shift)\n{\n  return $string.ords.map({$_ == 32 ?? 32 !! (($_ - $shift - 65) % 26 ) + 65}).chrs;\n    # #################### # 1a ############# ############ # 1b  # 1c ## 1d\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -\u0026gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。\u003c/p\u003e\n\u003cp\u003e查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。\u003c/p\u003e\n\u003cp\u003e运行它的结果和之前一样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3\nQEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3\nWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"perl-版本\"\u003ePerl 版本\u003c/h2\u003e\n\u003cp\u003e这是对第一个 Raku 版的直接翻译。\u003c/p\u003e\n\u003cp\u003eFile: caesar-cipher-perl\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-perl\" data-lang=\"perl\"\u003e\u003cspan class=\"ch\"\u003e#! /usr/bin/env perl\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003estrict\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003ewarnings\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003efeature\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;say\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003euse\u003c/span\u003e \u003cspan class=\"nn\"\u003efeature\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;signatures\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eno\u003c/span\u003e \u003cspan class=\"nn\"\u003ewarnings\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;experimental::signatures\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$S\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eshift\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e@ARGV\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"sr\"\u003e//\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"nb\"\u003edie\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Illegal characters\u0026#34;\u003c/span\u003e \u003cspan class=\"k\"\u003eunless\u003c/span\u003e \u003cspan class=\"nv\"\u003e$S\u003c/span\u003e \u003cspan class=\"o\"\u003e=~\u003c/span\u003e\u003cspan class=\"sr\"\u003e /^[A-Z\\s]+$/\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eshift\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e@ARGV\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"sr\"\u003e//\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"nb\"\u003edie\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Illegal shift $N\u0026#34;\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e!~\u003c/span\u003e \u003cspan class=\"sr\"\u003e/^\\-?\\d+$/\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e25\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e25\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003esay\u003c/span\u003e \u003cspan class=\"nb\"\u003ejoin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003emap\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ecaesar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$N\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"nb\"\u003esplit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sr\"\u003e//\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nv\"\u003e$S\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003esub\u003c/span\u003e \u003cspan class=\"nf\"\u003ecaesar\u003c/span\u003e \u003cspan class=\"p\"\u003e($char, $shift)\n\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nv\"\u003e$char\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$char\u003c/span\u003e \u003cspan class=\"ow\"\u003eeq\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003emy\u003c/span\u003e \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eord\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$char\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n  \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e-=\u003c/span\u003e \u003cspan class=\"nv\"\u003e$shift\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e26\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e65\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# \u0026#39;A\u0026#39;\u003c/span\u003e\n  \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e-=\u003c/span\u003e \u003cspan class=\"mi\"\u003e26\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nv\"\u003e$code\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e90\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e# \u0026#39;Z\u0026#39;\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003echr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nv\"\u003e$code\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e运行它的结果和 Raku 版一样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3\nQEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3\nWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13\nGUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"挑战-0972二进制子字符串binary-substrings\"\u003e挑战 #097.2：二进制子字符串(Binary Substrings)\u003c/h2\u003e\n\u003cp\u003e给你一个二进制字符串 \u003ccode\u003e$B\u003c/code\u003e 和一个整数 \u003ccode\u003e$S\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e写一个脚本来拆分大小为 \u003ccode\u003e$S\u003c/code\u003e 的二进制字符串 \u003ccode\u003e$B\u003c/code\u003e，然后找出使其相同的最小翻转次数。\u003c/p\u003e\n\u003cp\u003e例 1:\n输入: $B = “101100101”, $S = 3\n输出: 1\u003c/p\u003e\n\u003cp\u003e二进制子字符串:\n\u0026ldquo;101\u0026rdquo;: 0 flip\n\u0026ldquo;100\u0026rdquo;: 1 flip to make it \u0026ldquo;101\u0026rdquo;\n\u0026ldquo;101\u0026rdquo;: 0 flip\u003c/p\u003e\n\u003cp\u003e例 2:\n输入 $B = “10110111”, $S = 4\n输出: 2\u003c/p\u003e\n\u003cp\u003e二进制子字符串:\n\u0026ldquo;1011\u0026rdquo;: 0 flip\n\u0026ldquo;0111\u0026rdquo;: 2 flips to make it \u0026ldquo;1011\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e我们先从第一个例子中的二进制子字符串中砍掉3个字符块。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; say \u0026quot;101100101\u0026quot;.comb(3);   # -\u0026gt; (101 100 101)\n\u0026gt; say \u0026quot;1011001010\u0026quot;.comb(3);  # -\u0026gt; (101 100 101 0)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。\u003c/p\u003e\n\u003cp\u003e然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 \u0026ldquo;将两个参数都强制为Int，并进行位智XOR操作\u0026rdquo;(根据文档\u0026quot;；参见docs.raku.org/language/operators#infix_+^)。\u003c/p\u003e\n\u003cp\u003e我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。\u003c/p\u003e\n\u003cp\u003e获取翻转的次数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; say (\u0026quot;10101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum;  # -\u0026gt; 1\n\u0026gt; say (\u0026quot;11101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum;  # -\u0026gt; 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。\u003c/p\u003e\n\u003cp\u003eFile: binary-substring\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env raku\n\nsubset BinaryString where /^ \u0026lt;[01]\u0026gt;+ $/;                    # [1]\nsubset PosInt of Int where * \u0026gt; 0;                           # [2]\n\nunit sub MAIN (BinaryString $B = '101100101',               # [1]\n               PosInt $S where $B.chars %% $S = 3,          # [2]\n\t       :v(:$verbose));\n\nmy @B     = $B.comb($S.Int);                                # [3]\nmy $first = @B.shift;                                       # [4]\nmy $total = 0;                                              # [5]\n\nfor @B -\u0026gt; $current                                          # [6]\n{\n  my $flip = bit-diff($first, $current);                    # [7]\n  $total += $flip;                                          # [8]\n  say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose;\n}\n\nsay $total;                                                 # [9]\n\nsub bit-diff ($a, $b)                                       # [7]\n{\n  my $flip = 0;                                             # [10]\n\n  for ^$a.chars -\u0026gt; $index                                   # [11]\n  {\n    $flip++ if $a.substr($index,1) ne $b.substr($index,1);  # [12]\n  }\n\n  return $flip;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 确保二进制字符串是合法的（只包含 \u0026ldquo;0 \u0026ldquo;和 \u0026ldquo;1\u0026rdquo;）。\u003c/p\u003e\n\u003cp\u003e[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，\u0026ldquo;4 \u0026ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)\u003c/p\u003e\n\u003cp\u003e[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。\u003c/p\u003e\n\u003cp\u003e[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。\u003c/p\u003e\n\u003cp\u003e[5] 结果会到这里。\u003c/p\u003e\n\u003cp\u003e[6] 对于每一个子串（除了第一个，见[4]）。\u003c/p\u003e\n\u003cp\u003e[7] 获取每个子串的翻转次数。\u003c/p\u003e\n\u003cp\u003e[8] 并将其添加到总数中。\u003c/p\u003e\n\u003cp\u003e[9] 打印它。\u003c/p\u003e\n\u003cp\u003e[10] 翻转的数量会在这里。\u003c/p\u003e\n\u003cp\u003e[11] 对于两个子串中的每个索引（具有相同的长度）。\u003c/p\u003e\n\u003cp\u003e[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。\u003c/p\u003e\n\u003cp\u003eSee docs.raku.org/routine/comb for more information about comb.\u003c/p\u003e\n\u003cp\u003e运行它。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./binary-substring \u0026quot;101100101\u0026quot; 3\n 1\n\n$ ./binary-substring -v \u0026quot;101100101\u0026quot; 3\n: 101 -\u0026gt; 100 -\u0026gt; Flip: 1\n: 101 -\u0026gt; 101 -\u0026gt; Flip: 0\n1\n\n$ ./binary-substring \u0026quot;10110111\u0026quot; 4\n2\n\n$ ./binary-substring -v \u0026quot;10110111\u0026quot; 4\n: 1011 -\u0026gt; 0111 -\u0026gt; Flip: 2\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看起来不错。\u003c/p\u003e\n\u003ch2 id=\"perl\"\u003ePerl\u003c/h2\u003e\n\u003cp\u003e这是对 Raku 版本的直接翻译，只是我必须实现 \u0026ldquo;comb\u0026rdquo;。\u003c/p\u003e\n\u003cp\u003e文件： binary-substring-perl\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#! /usr/bin/env perl\n\nuse strict;\nuse warnings;\nuse feature 'say';\nuse feature 'signatures';\nuse Getopt::Long;\n\nno warnings \u0026quot;experimental::signatures\u0026quot;;\n\nmy $verbose = 0;\n\nGetOptions(\u0026quot;verbose\u0026quot;  =\u0026gt; \\$verbose);\n\nmy $B = shift(@ARGV) // '101100101';\n\ndie \u0026quot;Not a binary number\u0026quot; unless $B =~ /^[01]+$/;\n\nmy $S = shift(@ARGV) // 3;\n\ndie \u0026quot;Not an integer\u0026quot; unless $S =~ /^[1-9][0-9]*$/;\ndie \u0026quot;Not a legal length\u0026quot; if length($B) % $S;\n\nmy @B     =  comb($B, $S);\nmy $first = shift(@B);\nmy $total = 0;\n\nfor my $current (@B)\n{\n  my $flip = bit_diff($first, $current);\n  $total += $flip;\n  say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose;\n}\n\nsay $total;\n\nsub bit_diff ($a, $b)\n{\n  my $flip = 0;\n\n  for my $index (0 .. length($a))\n  {\n    $flip++ if substr($a, $index,1) ne substr($b, $index,1);\n  }\n\n  return $flip;\n}\n\nsub comb ($string, $length = 1)  # [1]\n{\n  my @result;\n\n  while ($string)\n  {\n    push(@result, substr($string, 0, $length));\n    $string = substr($string, $length);\n  }\n  return @result;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e[1] 缺失的 Raku 例程 \u0026ldquo;comb\u0026rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。\u003c/p\u003e\n\u003cp\u003e运行它的结果与 Raku 版本相同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ./binary-substring-perl \u0026quot;101100101\u0026quot; 3\n1\n\n$ ./binary-substring-perl -v \u0026quot;101100101\u0026quot; 3\n: 101 -\u0026gt; 100 -\u0026gt; Flip: 1\n: 101 -\u0026gt; 101 -\u0026gt; Flip: 0\n1\n\n$ ./binary-substring-perl \u0026quot;101100111\u0026quot; 3\n2\n\n$ ./binary-substring-perl -v \u0026quot;101100111\u0026quot; 3\n: 101 -\u0026gt; 100 -\u0026gt; Flip: 1\n: 101 -\u0026gt; 111 -\u0026gt; Flip: 1\n2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e就是这样。\u003c/p\u003e\n","text":"[113] 发表于2021年1月30日。 这是我对 Perl 每周挑战#097 的回应。\n挑战 #097.1: 凯撒密码 给你一个只包含字母 A..Z 的字符串 $S 和一个数字 $N。 写一个脚本，用凯撒密码对给定的字符串 $S 进行加密，左移大小为 $N。\n例子: 输入: $S = \u0026ldquo;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026rdquo;, $N = 3 输出: \u0026ldquo;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\u0026rdquo;\nPlain: ABCDEFGHIJKLMNOPQRSTUVWXYZ Cipher: XYZABCDEFGHIJKLMNOPQRSTUVW\nPlaintext: THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n\u0026ldquo;只用字母 A...Z\u0026rdquo; 的表述是错误的，因为例子中也有几个空格。因此，应该允许这些空格。\n文件: caesar-cipher\n#! /usr/bin/env raku subset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/; # [1] subset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25; # [2] unit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', PosInt $N = 3); # [3] say $S.comb.map({ caesar($_, $N) }).join; # [4] sub caesar ($char, $shift) { return $char if $char eq \u0026quot; \u0026quot;; # [5] my $code = $char.ord; # [6] $code -= $shift; # [7] $code += 26 if $code \u0026lt; 65; # 'A' # [8] $code -= 26 if $code \u0026gt; 90; # 'Z' # [8a] return $code.chr; # [9] } [1] 所允许的字符 (或 «特定领域字母»).\n[2] 挑战说左移值是一个数字。允许除整数以外的任何东西是没有意义的，所以我把值限制在这个类型。负值应该是可以的，它们意味着右移值（而不是左移）。\n[3] 参数，默认值为挑战中给出的值。\n[4] 将字符串分割成单个字符（用梳子(comb)，在每个字符上应用 \u0026ldquo;caesar\u0026rdquo; 函数（用map），再次将字符连接成一个字符串（用join），然后打印出来。\n[5] 不移动空格。\n[6] 获取字符的代码点。\n[7] 减去移位值（当我们向左移位时，或在字母表中降低移位值）。\n[8] 绕回, 如果我们移出A-Z范围，这里为更低 - 或更高的 [8b]。\n[9] 获取指定代码点的字符。\n查看 docs.raku.org/routine/ord 获取更多关于 ord 的信息。\n查看 docs.raku.org/routine/chr 获取更多关于 chr 的信息。\n运行它:\n$ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3 QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD $ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3 WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ $ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT $ ./caesar-cipher 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT Raku 有一个 ords 变体，它接收一整个字符串，而不是一个字符作为 ord。还有 chrs，它接收一个代码点数组，并将它们变成一个字符串，而不是像 chr 那样接收一个字符的代码点。让我们用它们来写一个更短的程序。\n文件: caesar-cipher-map\n#! /usr/bin/env raku subset AZ-space of Str where /^ \u0026lt;[ A .. Z \\s ]\u0026gt;+ $/; subset PosInt of Int where -25 \u0026lt;= $_ \u0026lt;= 25; unit sub MAIN (AZ-space $S = 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', PosInt $N = 3); say caesar($S, $N); sub caesar ($string, $shift) { return $string.ords.map({$_ == 32 ?? 32 !! (($_ - $shift - 65) % 26 ) + 65}).chrs; # #################### # 1a ############# ############ # 1b # 1c ## 1d } [1] 我们使用map来改变各个代码点。我们让代码点为32的空间单独存在[1a]。每一个其他的值我们都还原成0到25之间的数字（通过减去第一个字母的代码点（A：65）和移位值[1b]）。模数运算符 (%) 为我们处理负值，做正确的事情。例如：-2 % 26 -\u0026gt; 24 [1c]。然后我们添加调整值到它们应该在的位置(从A到Z)[1d]，然后我们将整个数组的代码点变成一个字符串。\n查看 docs.raku.org/routine/ords 获取更多关于 ords 的信息。\n查看 docs.raku.org/routine/chrs 获取更多关于 chrs 的信息。\n运行它的结果和之前一样。\n$ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3 QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD $ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3 WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ $ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT $ ./caesar-cipher-map 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT Perl 版本 这是对第一个 Raku 版的直接翻译。\nFile: caesar-cipher-perl\n#! /usr/bin/env perl use strict; use warnings; use feature \u0026#39;say\u0026#39;; use feature \u0026#39;signatures\u0026#39;; no warnings \u0026#34;experimental::signatures\u0026#34;; my $S = shift(@ARGV) // \u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;; die \u0026#34;Illegal characters\u0026#34; unless $S =~/^[A-Z\\s]+$/; my $N = shift(@ARGV) // 3; die \u0026#34;Illegal shift $N\u0026#34; if $N !~ /^\\-?\\d+$/ || $N \u0026lt; -25 || $N \u0026gt; 25; say join(\u0026#34;\u0026#34;, map { caesar($_, $N) } split(//, $S)); sub caesar ($char, $shift) { return $char if $char eq \u0026#34; \u0026#34;; my $code = ord($char); $code -= $shift; $code += 26 if $code \u0026lt; 65; # \u0026#39;A\u0026#39; $code -= 26 if $code \u0026gt; 90; # \u0026#39;Z\u0026#39; return chr($code); } 运行它的结果和 Raku 版一样。\n$ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3 QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD $ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -3 WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ $ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT $ ./caesar-cipher-perl 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' -13 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT 挑战 #097.2：二进制子字符串(Binary Substrings) 给你一个二进制字符串 $B 和一个整数 $S。\n写一个脚本来拆分大小为 $S 的二进制字符串 $B，然后找出使其相同的最小翻转次数。\n例 1: 输入: $B = “101100101”, $S = 3 输出: 1\n二进制子字符串: \u0026ldquo;101\u0026rdquo;: 0 flip \u0026ldquo;100\u0026rdquo;: 1 flip to make it \u0026ldquo;101\u0026rdquo; \u0026ldquo;101\u0026rdquo;: 0 flip\n例 2: 输入 $B = “10110111”, $S = 4 输出: 2\n二进制子字符串: \u0026ldquo;1011\u0026rdquo;: 0 flip \u0026ldquo;0111\u0026rdquo;: 2 flips to make it \u0026ldquo;1011\u0026rdquo;\n我们先从第一个例子中的二进制子字符串中砍掉3个字符块。\n\u0026gt; say \u0026quot;101100101\u0026quot;.comb(3); # -\u0026gt; (101 100 101) \u0026gt; say \u0026quot;1011001010\u0026quot;.comb(3); # -\u0026gt; (101 100 101 0) 第二行显示了如果长度不匹配会发生什么。这就给了我们一个非法的值，因为我们不能将一位数翻转为三位数的值。所以我们必须添加一个检查。\n然后我们将第一个子串与其余的子串进行比较，一次一个。在这里使用bitwise XOR（Exclusive OR）运算符是一个合理的选择。这给了我们一个二进制值，其中1的数量就是该子串的翻转次数。Raku确实有一个XOR运算符。+^. 但是它 \u0026ldquo;将两个参数都强制为Int，并进行位智XOR操作\u0026rdquo;(根据文档\u0026quot;；参见docs.raku.org/language/operators#infix_+^)。\n我们可以在进行XOR操作之前，将二进制值转换为十进制值。让我们试试。\n获取翻转的次数。\n\u0026gt; say (\u0026quot;10101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum; # -\u0026gt; 1 \u0026gt; say (\u0026quot;11101\u0026quot;.parse-base(2) +^ \u0026quot;10111\u0026quot;.parse-base(2)).base(2).comb.sum; # -\u0026gt; 2 这当然可行，但需要大量的代码。所以我将使用一个更简单的方法 - 逐个比较每个数字。\nFile: binary-substring\n#! /usr/bin/env raku subset BinaryString where /^ \u0026lt;[01]\u0026gt;+ $/; # [1] subset PosInt of Int where * \u0026gt; 0; # [2] unit sub MAIN (BinaryString $B = '101100101', # [1] PosInt $S where $B.chars %% $S = 3, # [2] :v(:$verbose)); my @B = $B.comb($S.Int); # [3] my $first = @B.shift; # [4] my $total = 0; # [5] for @B -\u0026gt; $current # [6] { my $flip = bit-diff($first, $current); # [7] $total += $flip; # [8] say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose; } say $total; # [9] sub bit-diff ($a, $b) # [7] { my $flip = 0; # [10] for ^$a.chars -\u0026gt; $index # [11] { $flip++ if $a.substr($index,1) ne $b.substr($index,1); # [12] } return $flip; } [1] 确保二进制字符串是合法的（只包含 \u0026ldquo;0 \u0026ldquo;和 \u0026ldquo;1\u0026rdquo;）。\n[2] 确保是一个正整数，同时确保字符串是被它偶数分割的。(例如，\u0026ldquo;4 \u0026ldquo;给我们提供了长度为4的子串，如果最后一个较短，程序将中止。)\n[3] 梳子通常用于将一个字符串分割成单个字符，但我们可以通过指定长度来获得每个子字符串中的多个字符，比如这样。\n[4] 例子首先将第一个子串与自己进行比较，给出零翻转。这是愚蠢的(ish)，所以我跳过这一点，把第一个子串移出。\n[5] 结果会到这里。\n[6] 对于每一个子串（除了第一个，见[4]）。\n[7] 获取每个子串的翻转次数。\n[8] 并将其添加到总数中。\n[9] 打印它。\n[10] 翻转的数量会在这里。\n[11] 对于两个子串中的每个索引（具有相同的长度）。\n[12] - 如果给定位置上的字符不同，则在总数的基础上加1，意味着移动。\nSee docs.raku.org/routine/comb for more information about comb.\n运行它。\n$ ./binary-substring \u0026quot;101100101\u0026quot; 3 1 $ ./binary-substring -v \u0026quot;101100101\u0026quot; 3 : 101 -\u0026gt; 100 -\u0026gt; Flip: 1 : 101 -\u0026gt; 101 -\u0026gt; Flip: 0 1 $ ./binary-substring \u0026quot;10110111\u0026quot; 4 2 $ ./binary-substring -v \u0026quot;10110111\u0026quot; 4 : 1011 -\u0026gt; 0111 -\u0026gt; Flip: 2 2 看起来不错。\nPerl 这是对 Raku 版本的直接翻译，只是我必须实现 \u0026ldquo;comb\u0026rdquo;。\n文件： binary-substring-perl\n#! /usr/bin/env perl use strict; use warnings; use feature 'say'; use feature 'signatures'; use Getopt::Long; no warnings \u0026quot;experimental::signatures\u0026quot;; my $verbose = 0; GetOptions(\u0026quot;verbose\u0026quot; =\u0026gt; \\$verbose); my $B = shift(@ARGV) // '101100101'; die \u0026quot;Not a binary number\u0026quot; unless $B =~ /^[01]+$/; my $S = shift(@ARGV) // 3; die \u0026quot;Not an integer\u0026quot; unless $S =~ /^[1-9][0-9]*$/; die \u0026quot;Not a legal length\u0026quot; if length($B) % $S; my @B = comb($B, $S); my $first = shift(@B); my $total = 0; for my $current (@B) { my $flip = bit_diff($first, $current); $total += $flip; say \u0026quot;: $first -\u0026gt; $current -\u0026gt; Flip: $flip\u0026quot; if $verbose; } say $total; sub bit_diff ($a, $b) { my $flip = 0; for my $index (0 .. length($a)) { $flip++ if substr($a, $index,1) ne substr($b, $index,1); } return $flip; } sub comb ($string, $length = 1) # [1] { my @result; while ($string) { push(@result, substr($string, 0, $length)); $string = substr($string, $length); } return @result; } [1] 缺失的 Raku 例程 \u0026ldquo;comb\u0026rdquo;。可选的第二个参数指定了它所返回的每个子串中所包含的（第一个参数的）子串长度。\n运行它的结果与 Raku 版本相同。\n$ ./binary-substring-perl \u0026quot;101100101\u0026quot; 3 1 $ ./binary-substring-perl -v \u0026quot;101100101\u0026quot; 3 : 101 -\u0026gt; 100 -\u0026gt; Flip: 1 : 101 -\u0026gt; 101 -\u0026gt; Flip: 0 1 $ ./binary-substring-perl \u0026quot;101100111\u0026quot; 3 2 $ ./binary-substring-perl -v \u0026quot;101100111\u0026quot; 3 : 101 -\u0026gt; 100 -\u0026gt; Flip: 1 : 101 -\u0026gt; 111 -\u0026gt; Flip: 1 2 就是这样。\n"},"name":"Caesarean Substrings With Raku and Perl","published":"2021-02-07T00:00:00+08:00","summary":"Caesarean Substrings With Raku and Perl","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/"}],"name":"Raku","type":"feed","url":"https://ohmyweekly.github.io/categories/raku/"}