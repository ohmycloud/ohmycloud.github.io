{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003cp\u003e我最近写了一篇关于\u003ca href=\"https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/\"\u003e新的 MoarVM 调度机制\u003c/a\u003e的文章，并在那篇文章中指出，我在 Raku 的多重分派语义方面还有不少需要实现的地方。从那以后，我在这个方向上取得了不小的进展。这篇文章包含了对所采取的方法的概述，以及一些非常粗略的性能测量。\u003c/p\u003e\n\u003ch2 id=\"我的天啊语义太多了\"\u003e我的天啊，语义太多了\u003c/h2\u003e\n\u003cp\u003e在 Raku 的所有分派中，多重分派是最复杂的。多重分派允许我们写一组候选者，然后根据参数的数量进行选择。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti ok($condition, $desc) {\n    say ($condition ?? 'ok' !! 'not ok') ~ \u0026quot; - $desc\u0026quot;;\n}\nmulti ok($condition) {\n    ok($condition, '');\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e或根据参数的类型:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti to-json(Int $i) { ~$i }\nmulti to-json(Bool $b) { $b ?? 'true' !! 'false' }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而且不只是一个参数，而是可能有很多参数:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti truncate(Str $str, Int $chars) {\n    $str.chars \u0026lt; $chars ?? $str !! $str.substr(0, $chars) ~ '...'\n}\n\nmulti truncate(Str $str, Str $after) {\n    with $str.index($after) -\u0026gt; $pos {\n        $str.substr(0, $pos) ~ '...'\n    }\n    else {\n        $str\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们可以添加 \u003ccode\u003ewhere\u003c/code\u003e 子句来区分普通类型无法捕捉的属性上的候选者。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti fac($n where $n \u0026lt;= 1) { 1 }\nmulti fac($n) { $n * fac($n - 1) }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e每当我们写出一组这样的 \u003ccode\u003emulti\u003c/code\u003e 候选列表时，编译器就会自动生成一个 \u003ccode\u003eproto\u003c/code\u003e 例程。这就是安装在符号表中的，存放候选列表的东西。然而，我们也可以写自己的 \u003ccode\u003eproto\u003c/code\u003e，并使用特殊的术语 \u003ccode\u003e{*}\u003c/code\u003e 来决定在哪一点上进行调度，如果有的话。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-rakuu\" data-lang=\"rakuu\"\u003eproto mean($collection) {\n    $collection.elems == 0 ?? Nil !! {*}\n}\n\nmulti mean(@arr) {\n    @arr.sum / @arr.elems\n}\n\nmulti mean(%hash) {\n    %hash.values.sum / %hash.elems\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e候选者按窄度排序（使用拓扑排序）。如果多个候选者匹配，但它们窄度相同，那么这就是一个歧义错误。否则，我们调用最窄的一个。然后，我们选择的候选者可能会使用 \u003ccode\u003ecallsame\u003c/code\u003e 和它的朋友们来推迟到下一个最窄的候选者，后者可能也会这样做，直到我们达到最一般的匹配的候选者。\u003c/p\u003e\n\u003ch2 id=\"多重分派无处不在\"\u003e多重分派无处不在\u003c/h2\u003e\n\u003cp\u003eRaku 在很大程度上依赖于多重分派。Raku 中的大多数操作符都被编译成对多重分派子程序的调用。即使是 \u003ccode\u003e$a+$b\u003c/code\u003e 也会是一个多重分派。这意味着高效地进行多重分派对性能真的很重要。考虑到其语义的丰富性，这有可能有点令人担忧。不过，也有好消息。\u003c/p\u003e\n\u003ch2 id=\"大多数多重调度都很无聊\"\u003e大多数多重调度都很无聊\u003c/h2\u003e\n\u003cp\u003e我们遇到的绝大多数情况是:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个仅由参数和名义类型的数量所做的决定。\u003c/li\u003e\n\u003cli\u003e无 where 子句\u003c/li\u003e\n\u003cli\u003e无自定义 proto\u003c/li\u003e\n\u003cli\u003e无 callsame\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这并不是说其他情况不重要，它们确实相当有用，而且它们的表现也是可取的。不过，在普通情况下，我们能省则省，也是可取的。例如，我们不希望急于计算每一个单次多重调度的全部可能的候选者，因为大多数时候只有第一个才是重要的。这不仅仅是时间上的问题：回想一下，新的调度机制会在每个调用点存储调度程序，如果我们在每个调用点存储所有匹配的候选程序列表，我们也会浪费很多内存。\u003c/p\u003e\n\u003ch2 id=\"我们今天怎么做\"\u003e我们今天怎么做？\u003c/h2\u003e\n\u003cp\u003e如今 Rakuo 的情况如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e如果调度只由元数和名义类型决定，并且你不使用扁平化的参数来调用它，它可能会表现得很好，甚至可能会享受到候选者的内联和消除在慢速路径上发生的重复类型检查。这要归功于 proto 持有一个 \u0026ldquo;dispatch cache\u0026rdquo;，这是一个在 VM 中实现的特例机制，它使用搜索树，每个参数有一个级别。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果是这种情况，但它有一个自定义的 proto，也不会太差，虽然不会发生内联，它仍然可以使用搜索树。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果它使用 \u003ccode\u003ewhere\u003c/code\u003e 子句，速度会很慢，因为搜索树只处理在每一个名义类型集合中找到一个候选者，所以我们不能使用它。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e同样的道理也适用于 \u003ccode\u003ecallsame\u003c/code\u003e，它的速度也会很慢。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e实际上，今天的情况是，如果在热路径附近的任何地方，你根本不会在多重调度中使用 \u003ccode\u003ewhere\u003c/code\u003e子句（好吧，如果你知道热路径在哪里，并且知道这种调度很慢）。同理，\u003ccode\u003ecallsame\u003c/code\u003e 也是如此，虽然那不太常触达。问题是，我们能不能用新的调度器做得更好？\u003c/p\u003e\n\u003ch2 id=\"守卫类型\"\u003e守卫类型\u003c/h2\u003e\n\u003cp\u003e我们先看看最简单的情况是如何处理的，然后再从那里开始建立。(这其实是我在实现上的做法，但同时我也有一个大概的想法，我希望最终的结果是什么)。\u003c/p\u003e\n\u003cp\u003e回忆一下这对候选者。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti truncate(Str $str, Int $chars) {\n    $str.chars \u0026lt; $chars ?? $str !! $str.substr(0, $chars) ~ '...'\n}\n\nmulti truncate(Str $str, Str $after) {\n    with $str.index($after) -\u0026gt; $pos {\n        $str.substr(0, $pos) ~ '...'\n    }\n    else {\n        $str\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然后我们有一个调用 \u003ccode\u003etruncate($message, \u0026quot;\\n\u0026quot;)\u003c/code\u003e，其中 \u003ccode\u003e$message\u003c/code\u003e 是 \u003ccode\u003eStr\u003c/code\u003e 类型的。在新的调度机制下，调用是使用 \u003ccode\u003eraku-call\u003c/code\u003e dispatcher 进行的，它识别出这是一个 \u003ccode\u003emulti\u003c/code\u003e 方法调度，因此委托给 \u003ccode\u003eraku-multi\u003c/code\u003e。(\u003ccode\u003emulti\u003c/code\u003e 方法调度也会在那里结束)。\u003c/p\u003e\n\u003cp\u003e调度的记录阶段 - 在我们第一次到达这个调用点时 - 将进行如下操作。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e迭代候选者\u003c/li\u003e\n\u003cli\u003e如果某个候选者在参数数上不匹配，就直接丢弃它。由于 \u003ccode\u003ecallsite\u003c/code\u003e 的形状是一个常数，而且我们在每个 \u003ccode\u003ecallsite\u003c/code\u003e 都会计算 dispatch 程序，所以我们不需要为此建立任何防护措施。\u003c/li\u003e\n\u003cli\u003e如果在类型匹配并且成功了，注意涉及哪些参数，需要什么样的守卫。\u003c/li\u003e\n\u003cli\u003e如果没有匹配或者模棱两可，就报错，不产生调度程序。\u003c/li\u003e\n\u003cli\u003e否则，在确定了类型守卫后，将选定的候选程序委托给 \u003ccode\u003eraku-invoke\u003c/code\u003e 调度程序。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当我们再次到达同一个调用点时，我们可以运行调度程序，它可以快速检查参数类型是否与上次看到的参数类型相匹配，如果相匹配，我们就知道要调用哪个候选程序。这些检查非常便宜 - 比遍历所有候选者并检查每个候选者是否匹配要便宜得多。优化器以后可能会证明这些检查总是会成为事实，并消除它们。\u003c/p\u003e\n\u003cp\u003e因此，整个调度过程 - 至少对于这个我们只有类型和元数的简单案例 - 可以向虚拟机 \u0026ldquo;解释\u0026rdquo; 为 \u0026ldquo;如果参数具有这些确切的类型，就调用这个例程\u0026rdquo;。这和我们对方法分派所做的差不多，除了我们只关心第一个参数的类型 - 调用者 - 和方法名的值。(还记得上一篇文章中说过，如果是 \u003ccode\u003emulti\u003c/code\u003e 方法调度，那么方法调度和 \u003ccode\u003emulti\u003c/code\u003e 方法调度都会守护第一个参数的类型，但是消除了重复，所以只做一次检查)。\u003c/p\u003e\n\u003ch2 id=\"这就进入了恢复之洞\"\u003e这就进入了恢复之洞\u003c/h2\u003e\n\u003cp\u003e想出好的抽象是很难的，新的调度机制的很多挑战就在于此。Raku 有不少不同的类似调度的东西。然而，将它们全部直接编码在虚拟机中会导致很高的复杂度，这使得构建可靠的优化（甚至是可靠的未优化的实现！）具有挑战性。因此，我们的目标是研究出一套相对较小的原语，允许以这样一种方式向虚拟机 \u0026ldquo;解释\u0026rdquo; 调度，使其能够提供不错的性能。\u003c/p\u003e\n\u003cp\u003e很明显，\u003ccode\u003ecallsame\u003c/code\u003e 是一种调度恢复，但自定义 proto 这种情况和 \u003ccode\u003ewhere\u003c/code\u003e 子句这种情况呢？事实证明，这些也都可以用调度恢复的方式整齐地表达出来（\u003ccode\u003ewhere\u003c/code\u003e 子句情况需要在虚拟机层面增加一个小的内容，到时候可能对其他事情也有用）。不仅如此，用调度恢复来编码这些特性也是相当直接的，因此应该是高效的。我们教给专门人员的关于如何更好地使用调度恢复的每一个技巧，都可以让所有使用它们实现的语言特性也受益。\u003c/p\u003e\n\u003ch2 id=\"自定义-proto\"\u003e自定义 proto\u003c/h2\u003e\n\u003cp\u003e回顾这个例子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eproto mean($collection) {\n    $collection.elems == 0 ?? Nil !! {*}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在这里，我们希望运行 proto 的主体，然后在 \u003ccode\u003e{*}\u003c/code\u003e 这里进行候选者的选择。相比之下，当我们没有自定义的 proto 时，我们希望简单地继续调用正确的多。\u003c/p\u003e\n\u003cp\u003e为了达到这个目的，我首先将 \u003ccode\u003emulti\u003c/code\u003e 候选者的选择逻辑从 \u003ccode\u003eraku-multi\u003c/code\u003e 调度器移到了 \u003ccode\u003eraku-multi-core\u003c/code\u003e 调度器中。然后，\u003ccode\u003eraku-multi\u003c/code\u003e dispatcher 会检查我们是否有一个 \u0026ldquo;onlystar\u0026rdquo; proto（一个不需要我们运行的 proto）。如果有，它就会立即委托给 \u003ccode\u003eraku-multi-core\u003c/code\u003e。如果没有，它就将调度的参数保存为恢复初始化状态，然后调用 proto。proto 的 \u003ccode\u003e{*}\u003c/code\u003e 被编译成一个 dispatch resumption。然后，这个 resumption 委托给 \u003ccode\u003eraku-multi-core\u003c/code\u003e。或者，在代码中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-nqp\" data-lang=\"nqp\"\u003enqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-multi',\n    # Initial dispatch, only setting up resumption if we need to invoke the\n    # proto.\n    -\u0026gt; $capture {\n        my $callee := nqp::captureposarg($capture, 0);\n        my int $onlystar := nqp::getattr_i($callee, Routine, '$!onlystar');\n        if $onlystar {\n            # Don't need to invoke the proto itself, so just get on with the\n            # candidate dispatch.\n            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi-core', $capture);\n        }\n        else {\n            # Set resume init args and run the proto.\n            nqp::dispatch('boot-syscall', 'dispatcher-set-resume-init-args', $capture);\n            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke', $capture);\n        }\n    },\n    # Resumption means that we have reached the {*} in the proto and so now\n    # should go ahead and do the dispatch. Make sure we only do this if we\n    # are signalled to that it's a resume for an onlystar (resumption kind 5).\n    -\u0026gt; $capture {\n        my $track_kind := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0);\n        nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_kind);\n        my int $kind := nqp::captureposarg_i($capture, 0);\n        if $kind == 5 {\n            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi-core',\n                nqp::dispatch('boot-syscall', 'dispatcher-get-resume-init-args'));\n        }\n        elsif !nqp::dispatch('boot-syscall', 'dispatcher-next-resumption') {\n            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant',\n                nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj',\n                    $capture, 0, Nil));\n        }\n    });\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"合二为一\"\u003e合二为一\u003c/h2\u003e\n\u003cp\u003e推迟到下一个候选者（例如用 \u003ccode\u003ecallsame\u003c/code\u003e）和因为 \u003ccode\u003ewhere\u003c/code\u003e 子句失败而尝试下一个候选者看起来非常相似：两者都涉及遍历一个可能的候选者列表。有一些细节，但它们有很多共同点，如果能在使用新的 dispatcher 实现多重分派的过程中体现出来就更好了。\u003c/p\u003e\n\u003cp\u003e在这之前，先说一个略显可怕的细节，当我们有 \u003ccode\u003ewhere\u003c/code\u003e 子句的时候，今天在 Rakuo 中是如何工作的。首先，调度器会做一个 \u0026ldquo;试用绑定\u0026rdquo;，它问一个问题：这个签名会不会绑定？要做到这一点，它必须评估所有的 \u003ccode\u003ewhere\u003c/code\u003e 子句。更糟糕的是，它还必须使用慢路径签名绑定器，它对签名进行解释，尽管我们在很多情况下可以编译它。如果候选者匹配，很好，我们选择它，然后调用它\u0026hellip;\u0026hellip;这将第二次运行 \u003ccode\u003ewhere\u003c/code\u003e 子句，作为编译后的签名绑定代码的一部分。这样做一点也不高效，除了在开发人员的时间上要高效得多，这也是为什么要这样做的原因。\u003c/p\u003e\n\u003cp\u003e总之，毋庸置疑，在我使用新的调度器重新实现时，我相当希望尽可能避免这种重复的工作和慢路径绑定。而且，令人高兴的是，一个小小的补充提供了一个解决方案。有一个 op \u003ccode\u003eassertparamcheck\u003c/code\u003e，任何类型的参数检查都会被编译成（无论是类型检查、\u003ccode\u003ewhere\u003c/code\u003e 子句检查等），这将触发对一个函数的调用，该函数获取参数，也就是我们试图调用的东西，然后可以通过它们来产生错误信息。诀窍是提供一种调用例程的方法，使绑定失败后，不是调用报错函数，而是离开例程，然后做一个调度恢复! 这意味着我们可以将传递 \u003ccode\u003ewhere\u003c/code\u003e 子句检查失败变成一个调度恢复，然后会走到下一个候选者，并代替它进行尝试。\u003c/p\u003e\n\u003ch2 id=\"琐碎vs非琐碎\"\u003e琐碎VS非琐碎\u003c/h2\u003e\n\u003cp\u003e这让我们得到了大部分的解决方法，但在常见的情况下，仍然存在内存和时间效率的问题，即没有恢复和没有 \u003ccode\u003ewhere\u003c/code\u003e 子句。我为这种情况创造了一个术语 \u0026ldquo;trivial multiple dispatch\u0026rdquo;，这使得其他情况变得 \u0026ldquo;non-trivial\u0026rdquo;。事实上，我甚至做了一个调度器，叫做 \u003ccode\u003eraku-multi-non-trivial\u003c/code\u003e! 我们有两种方式可以结束。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e最初尝试寻找匹配的候选者，决定了我们必须考虑 \u003ccode\u003ewhere\u003c/code\u003e 子句。一旦我们看到是这种情况，我们就会继续制作一个可能匹配的候选者的完整列表。这是一个链表（原因见我之前的文章）。\u003c/li\u003e\n\u003cli\u003e最初尝试寻找匹配的候选者时，发现了一个可以纯粹根据参数数和名词类型来挑选的候选者。我们就此停止，而不是试图建立一个完整的候选列表，并运行匹配的候选。在 \u003ccode\u003ecallsame\u003c/code\u003e 的情况下，我们最终进入琐碎的调度恢复处理程序，它 - 因为这种情况现在是非琐碎的 - 建立完整的候选者列表，从它上面剪下第一项（因为我们已经运行了那项），然后委托给 \u003ccode\u003eraku-multi-non-trivial\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在这个描述中失去了另一个重要的改进：今天，当有 \u003ccode\u003ewhere\u003c/code\u003e 子句时，我们完全失去了使用 MoarVM 多重调度缓存的能力，但在新的调度器下，我们在 \u003ccode\u003ecallsite\u003c/code\u003e 存储了一个类型过滤的候选列表，然后使用廉价的类型守卫来检查它是否有效使用。\u003c/p\u003e\n\u003ch2 id=\"初步结果\"\u003e初步结果\u003c/h2\u003e\n\u003cp\u003e我做了一些基准测试，看看新的调度机制在今天 Raku 已知的几种次优情况下的表现。这些数字并不能反映出什么是可能的，因为目前专门人员对新的调度器还没有太多的了解。相反，它们反映了我们可以期望的最小改进。\u003c/p\u003e\n\u003cp\u003e考虑这个基准，使用一个带有 \u003ccode\u003ewhere\u003c/code\u003e 子句的 \u003ccode\u003emulti\u003c/code\u003e 来递归实现 factorial。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti fac($n where $n \u0026lt;= 1) { 1 }\nmulti fac($n) { $n * fac($n - 1) }\n\nfor ^100_000 {\n    fac(10)\n}\nsay now - INIT now;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这需要进行一些调整（并在环境变量下运行）以使用新的调度器；这些都是暂时的，直到我将 Rakudo 转换为默认使用新的调度器。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-nqp\" data-lang=\"nqp\"\u003euse nqp;\n\nmulti fac($n where $n \u0026lt;= 1) { 1 }\nmulti fac($n) { $n * nqp::dispatch('raku-call', \u0026amp;fac, $n - 1) }\n\nfor ^100_000 {\n    nqp::dispatch('raku-call', \u0026amp;fac, 10);\n}\nsay now - INIT now;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在我的机器上，第一个运行时间为4.86秒，第二个运行时间为1.34秒。因此，在新的调度器下，运行时间只需过去的四分之一多一点 - 这已经是一个相当大的改进了。\u003c/p\u003e\n\u003cp\u003e一个涉及 \u003ccode\u003ecallsame\u003c/code\u003e 的案例也很有意思。这里是没有使用新调度器的情况。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti fallback(Any $x) { \u0026quot;a$x\u0026quot; }\nmulti fallback(Numeric $x) { \u0026quot;n\u0026quot; ~ callsame }\nmulti fallback(Real $x) { \u0026quot;r\u0026quot; ~ callsame }\nmulti fallback(Int $x) { \u0026quot;i\u0026quot; ~ callsame }\n\nfor ^1_000_000 {\n    fallback(4+2i);\n    fallback(4.2);\n    fallback(42);\n}   \nsay now - INIT now;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而配合临时调整使用新的调度器:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-nqp\" data-lang=\"nqp\"\u003euse nqp;\n\nmulti fallback(Any $x) { \u0026quot;a$x\u0026quot; }\nmulti fallback(Numeric $x) { \u0026quot;n\u0026quot; ~ new-disp-callsame }\nmulti fallback(Real $x) { \u0026quot;r\u0026quot; ~ new-disp-callsame }\nmulti fallback(Int $x) { \u0026quot;i\u0026quot; ~ new-disp-callsame }\n\nfor ^1_000_000 {\n    nqp::dispatch('raku-call', \u0026amp;fallback, 4+2i);\n    nqp::dispatch('raku-call', \u0026amp;fallback, 4.2);\n    nqp::dispatch('raku-call', \u0026amp;fallback, 42);\n}\nsay now - INIT now;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在我的机器上，第一个运行时间为31.3s，第二个运行时间为11.5s，这意味着使用新的调度器，我们最终需要的时间只有当前 Rakudo 的三分之一多一点。\u003c/p\u003e\n\u003cp\u003e这些都是相当鼓舞人心的，但正如前面提到的，大部分的多重调度都是琐碎的那种，没有使用这些功能。如果我在让其他事情变得更好的路上把最常见的情况变得更糟，那就不好了。现在还不能对此进行公平的比较：琐碎的多重分派在特化器中已经受到了很多关注，而且它还不能很好地优化使用新调度器的代码。值得注意的是，在这样的例子中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emulti m(Int) { }\nmulti m(Str) { }\n\nfor ^1_000_000 {\n    m(1);\n    m(\u0026quot;x\u0026quot;);\n}\nsay now - INIT now;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e内嵌和其他优化会将其变成一个空循环，这是很难做到的。不过有一件事我们已经可以做了：在禁用 specializer 的情况下运行它。新的调度器版本看起来是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-nqp\" data-lang=\"nqp\"\u003euse nqp;\n\nmulti m(Int) { }\nmulti m(Str) { }\n\nfor ^1_000_000 {\n    nqp::dispatch('raku-call', \u0026amp;m, 1);\n    nqp::dispatch('raku-call', \u0026amp;m, \u0026quot;x\u0026quot;);\n}\nsay now - INIT now;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e结果分别是0.463s和0.332s。因此，基线执行时间 - 在特化器发挥其魔力之前 - 使用新的通用调度机制比使用我们目前使用的特化多重调度缓存要少。在做测量之前，我不知道这里会有什么预期。鉴于我们要从一个已经被剖析和调整过的特化机制转到一个没有受到如此关注的新的通用机制，我已经做好了最初做得差一点的准备，如果能做到平价就好了。在70%的时间里，跑进了70%的时间，这比我预期的进步更大。\u003c/p\u003e\n\u003cp\u003e我期望，一旦特化器更好地理解新的调度机制，它也能把上面的内容变成一个空循环 - 不过，由于每次优化可以进行更多的迭代，这应该还是表现为新调度器的胜利。\u003c/p\u003e\n\u003ch2 id=\"最后的想法\"\u003e最后的想法\u003c/h2\u003e\n\u003cp\u003e只要增加一个相对较小的功能，新的调度机制已经可以处理大部分的 Raku 多重调度语义。此外，即使在 specializer 和 JIT 没有真正能够做好的情况下，一些微基准已经显示出3倍-4倍的提升。这是一个很好的起点。\u003c/p\u003e\n\u003cp\u003e在我们使用新的调度器出货 Rakudo 版本之前，还有很多工作要做。然而，多重调度是设计中剩下的最大威胁：它比其他种类的调度相当多的参与，而且很有可能一个意想不到的缺点会引发新一轮的设计工作，或者揭示出一般机制与基线未优化的情况下, 与更专业的机制相比，性能会很吃力。到目前为止，没有任何迹象表明这两种情况，我谨慎乐观地认为整体设计是差不多的。\u003c/p\u003e\n","text":"我最近写了一篇关于新的 MoarVM 调度机制的文章，并在那篇文章中指出，我在 Raku 的多重分派语义方面还有不少需要实现的地方。从那以后，我在这个方向上取得了不小的进展。这篇文章包含了对所采取的方法的概述，以及一些非常粗略的性能测量。\n我的天啊，语义太多了 在 Raku 的所有分派中，多重分派是最复杂的。多重分派允许我们写一组候选者，然后根据参数的数量进行选择。\nmulti ok($condition, $desc) { say ($condition ?? 'ok' !! 'not ok') ~ \u0026quot; - $desc\u0026quot;; } multi ok($condition) { ok($condition, ''); } 或根据参数的类型:\nmulti to-json(Int $i) { ~$i } multi to-json(Bool $b) { $b ?? 'true' !! 'false' } 而且不只是一个参数，而是可能有很多参数:\nmulti truncate(Str $str, Int $chars) { $str.chars \u0026lt; $chars ?? $str !! $str.substr(0, $chars) ~ '...' } multi truncate(Str $str, Str $after) { with $str.index($after) -\u0026gt; $pos { $str.substr(0, $pos) ~ '...' } else { $str } } 我们可以添加 where 子句来区分普通类型无法捕捉的属性上的候选者。\nmulti fac($n where $n \u0026lt;= 1) { 1 } multi fac($n) { $n * fac($n - 1) } 每当我们写出一组这样的 multi 候选列表时，编译器就会自动生成一个 proto 例程。这就是安装在符号表中的，存放候选列表的东西。然而，我们也可以写自己的 proto，并使用特殊的术语 {*} 来决定在哪一点上进行调度，如果有的话。\nproto mean($collection) { $collection.elems == 0 ?? Nil !! {*} } multi mean(@arr) { @arr.sum / @arr.elems } multi mean(%hash) { %hash.values.sum / %hash.elems } 候选者按窄度排序（使用拓扑排序）。如果多个候选者匹配，但它们窄度相同，那么这就是一个歧义错误。否则，我们调用最窄的一个。然后，我们选择的候选者可能会使用 callsame 和它的朋友们来推迟到下一个最窄的候选者，后者可能也会这样做，直到我们达到最一般的匹配的候选者。\n多重分派无处不在 Raku 在很大程度上依赖于多重分派。Raku 中的大多数操作符都被编译成对多重分派子程序的调用。即使是 $a+$b 也会是一个多重分派。这意味着高效地进行多重分派对性能真的很重要。考虑到其语义的丰富性，这有可能有点令人担忧。不过，也有好消息。\n大多数多重调度都很无聊 我们遇到的绝大多数情况是:\n 一个仅由参数和名义类型的数量所做的决定。 无 where 子句 无自定义 proto 无 callsame  这并不是说其他情况不重要，它们确实相当有用，而且它们的表现也是可取的。不过，在普通情况下，我们能省则省，也是可取的。例如，我们不希望急于计算每一个单次多重调度的全部可能的候选者，因为大多数时候只有第一个才是重要的。这不仅仅是时间上的问题：回想一下，新的调度机制会在每个调用点存储调度程序，如果我们在每个调用点存储所有匹配的候选程序列表，我们也会浪费很多内存。\n我们今天怎么做？ 如今 Rakuo 的情况如下:\n  如果调度只由元数和名义类型决定，并且你不使用扁平化的参数来调用它，它可能会表现得很好，甚至可能会享受到候选者的内联和消除在慢速路径上发生的重复类型检查。这要归功于 proto 持有一个 \u0026ldquo;dispatch cache\u0026rdquo;，这是一个在 VM 中实现的特例机制，它使用搜索树，每个参数有一个级别。\n  如果是这种情况，但它有一个自定义的 proto，也不会太差，虽然不会发生内联，它仍然可以使用搜索树。\n  如果它使用 where 子句，速度会很慢，因为搜索树只处理在每一个名义类型集合中找到一个候选者，所以我们不能使用它。\n  同样的道理也适用于 callsame，它的速度也会很慢。\n  实际上，今天的情况是，如果在热路径附近的任何地方，你根本不会在多重调度中使用 where子句（好吧，如果你知道热路径在哪里，并且知道这种调度很慢）。同理，callsame 也是如此，虽然那不太常触达。问题是，我们能不能用新的调度器做得更好？\n守卫类型 我们先看看最简单的情况是如何处理的，然后再从那里开始建立。(这其实是我在实现上的做法，但同时我也有一个大概的想法，我希望最终的结果是什么)。\n回忆一下这对候选者。\nmulti truncate(Str $str, Int $chars) { $str.chars \u0026lt; $chars ?? $str !! $str.substr(0, $chars) ~ '...' } multi truncate(Str $str, Str $after) { with $str.index($after) -\u0026gt; $pos { $str.substr(0, $pos) ~ '...' } else { $str } } 然后我们有一个调用 truncate($message, \u0026quot;\\n\u0026quot;)，其中 $message 是 Str 类型的。在新的调度机制下，调用是使用 raku-call dispatcher 进行的，它识别出这是一个 multi 方法调度，因此委托给 raku-multi。(multi 方法调度也会在那里结束)。\n调度的记录阶段 - 在我们第一次到达这个调用点时 - 将进行如下操作。\n 迭代候选者 如果某个候选者在参数数上不匹配，就直接丢弃它。由于 callsite 的形状是一个常数，而且我们在每个 callsite 都会计算 dispatch 程序，所以我们不需要为此建立任何防护措施。 如果在类型匹配并且成功了，注意涉及哪些参数，需要什么样的守卫。 如果没有匹配或者模棱两可，就报错，不产生调度程序。 否则，在确定了类型守卫后，将选定的候选程序委托给 raku-invoke 调度程序。  当我们再次到达同一个调用点时，我们可以运行调度程序，它可以快速检查参数类型是否与上次看到的参数类型相匹配，如果相匹配，我们就知道要调用哪个候选程序。这些检查非常便宜 - 比遍历所有候选者并检查每个候选者是否匹配要便宜得多。优化器以后可能会证明这些检查总是会成为事实，并消除它们。\n因此，整个调度过程 - 至少对于这个我们只有类型和元数的简单案例 - 可以向虚拟机 \u0026ldquo;解释\u0026rdquo; 为 \u0026ldquo;如果参数具有这些确切的类型，就调用这个例程\u0026rdquo;。这和我们对方法分派所做的差不多，除了我们只关心第一个参数的类型 - 调用者 - 和方法名的值。(还记得上一篇文章中说过，如果是 multi 方法调度，那么方法调度和 multi 方法调度都会守护第一个参数的类型，但是消除了重复，所以只做一次检查)。\n这就进入了恢复之洞 想出好的抽象是很难的，新的调度机制的很多挑战就在于此。Raku 有不少不同的类似调度的东西。然而，将它们全部直接编码在虚拟机中会导致很高的复杂度，这使得构建可靠的优化（甚至是可靠的未优化的实现！）具有挑战性。因此，我们的目标是研究出一套相对较小的原语，允许以这样一种方式向虚拟机 \u0026ldquo;解释\u0026rdquo; 调度，使其能够提供不错的性能。\n很明显，callsame 是一种调度恢复，但自定义 proto 这种情况和 where 子句这种情况呢？事实证明，这些也都可以用调度恢复的方式整齐地表达出来（where 子句情况需要在虚拟机层面增加一个小的内容，到时候可能对其他事情也有用）。不仅如此，用调度恢复来编码这些特性也是相当直接的，因此应该是高效的。我们教给专门人员的关于如何更好地使用调度恢复的每一个技巧，都可以让所有使用它们实现的语言特性也受益。\n自定义 proto 回顾这个例子。\nproto mean($collection) { $collection.elems == 0 ?? Nil !! {*} } 在这里，我们希望运行 proto 的主体，然后在 {*} 这里进行候选者的选择。相比之下，当我们没有自定义的 proto 时，我们希望简单地继续调用正确的多。\n为了达到这个目的，我首先将 multi 候选者的选择逻辑从 raku-multi 调度器移到了 raku-multi-core 调度器中。然后，raku-multi dispatcher 会检查我们是否有一个 \u0026ldquo;onlystar\u0026rdquo; proto（一个不需要我们运行的 proto）。如果有，它就会立即委托给 raku-multi-core。如果没有，它就将调度的参数保存为恢复初始化状态，然后调用 proto。proto 的 {*} 被编译成一个 dispatch resumption。然后，这个 resumption 委托给 raku-multi-core。或者，在代码中。\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-multi', # Initial dispatch, only setting up resumption if we need to invoke the # proto. -\u0026gt; $capture { my $callee := nqp::captureposarg($capture, 0); my int $onlystar := nqp::getattr_i($callee, Routine, '$!onlystar'); if $onlystar { # Don't need to invoke the proto itself, so just get on with the # candidate dispatch. nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi-core', $capture); } else { # Set resume init args and run the proto. nqp::dispatch('boot-syscall', 'dispatcher-set-resume-init-args', $capture); nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke', $capture); } }, # Resumption means that we have reached the {*} in the proto and so now # should go ahead and do the dispatch. Make sure we only do this if we # are signalled to that it's a resume for an onlystar (resumption kind 5). -\u0026gt; $capture { my $track_kind := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0); nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_kind); my int $kind := nqp::captureposarg_i($capture, 0); if $kind == 5 { nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi-core', nqp::dispatch('boot-syscall', 'dispatcher-get-resume-init-args')); } elsif !nqp::dispatch('boot-syscall', 'dispatcher-next-resumption') { nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant', nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj', $capture, 0, Nil)); } }); 合二为一 推迟到下一个候选者（例如用 callsame）和因为 where 子句失败而尝试下一个候选者看起来非常相似：两者都涉及遍历一个可能的候选者列表。有一些细节，但它们有很多共同点，如果能在使用新的 dispatcher 实现多重分派的过程中体现出来就更好了。\n在这之前，先说一个略显可怕的细节，当我们有 where 子句的时候，今天在 Rakuo 中是如何工作的。首先，调度器会做一个 \u0026ldquo;试用绑定\u0026rdquo;，它问一个问题：这个签名会不会绑定？要做到这一点，它必须评估所有的 where 子句。更糟糕的是，它还必须使用慢路径签名绑定器，它对签名进行解释，尽管我们在很多情况下可以编译它。如果候选者匹配，很好，我们选择它，然后调用它\u0026hellip;\u0026hellip;这将第二次运行 where 子句，作为编译后的签名绑定代码的一部分。这样做一点也不高效，除了在开发人员的时间上要高效得多，这也是为什么要这样做的原因。\n总之，毋庸置疑，在我使用新的调度器重新实现时，我相当希望尽可能避免这种重复的工作和慢路径绑定。而且，令人高兴的是，一个小小的补充提供了一个解决方案。有一个 op assertparamcheck，任何类型的参数检查都会被编译成（无论是类型检查、where 子句检查等），这将触发对一个函数的调用，该函数获取参数，也就是我们试图调用的东西，然后可以通过它们来产生错误信息。诀窍是提供一种调用例程的方法，使绑定失败后，不是调用报错函数，而是离开例程，然后做一个调度恢复! 这意味着我们可以将传递 where 子句检查失败变成一个调度恢复，然后会走到下一个候选者，并代替它进行尝试。\n琐碎VS非琐碎 这让我们得到了大部分的解决方法，但在常见的情况下，仍然存在内存和时间效率的问题，即没有恢复和没有 where 子句。我为这种情况创造了一个术语 \u0026ldquo;trivial multiple dispatch\u0026rdquo;，这使得其他情况变得 \u0026ldquo;non-trivial\u0026rdquo;。事实上，我甚至做了一个调度器，叫做 raku-multi-non-trivial! 我们有两种方式可以结束。\n 最初尝试寻找匹配的候选者，决定了我们必须考虑 where 子句。一旦我们看到是这种情况，我们就会继续制作一个可能匹配的候选者的完整列表。这是一个链表（原因见我之前的文章）。 最初尝试寻找匹配的候选者时，发现了一个可以纯粹根据参数数和名词类型来挑选的候选者。我们就此停止，而不是试图建立一个完整的候选列表，并运行匹配的候选。在 callsame 的情况下，我们最终进入琐碎的调度恢复处理程序，它 - 因为这种情况现在是非琐碎的 - 建立完整的候选者列表，从它上面剪下第一项（因为我们已经运行了那项），然后委托给 raku-multi-non-trivial。  在这个描述中失去了另一个重要的改进：今天，当有 where 子句时，我们完全失去了使用 MoarVM 多重调度缓存的能力，但在新的调度器下，我们在 callsite 存储了一个类型过滤的候选列表，然后使用廉价的类型守卫来检查它是否有效使用。\n初步结果 我做了一些基准测试，看看新的调度机制在今天 Raku 已知的几种次优情况下的表现。这些数字并不能反映出什么是可能的，因为目前专门人员对新的调度器还没有太多的了解。相反，它们反映了我们可以期望的最小改进。\n考虑这个基准，使用一个带有 where 子句的 multi 来递归实现 factorial。\nmulti fac($n where $n \u0026lt;= 1) { 1 } multi fac($n) { $n * fac($n - 1) } for ^100_000 { fac(10) } say now - INIT now; 这需要进行一些调整（并在环境变量下运行）以使用新的调度器；这些都是暂时的，直到我将 Rakudo 转换为默认使用新的调度器。\nuse nqp; multi fac($n where $n \u0026lt;= 1) { 1 } multi fac($n) { $n * nqp::dispatch('raku-call', \u0026amp;fac, $n - 1) } for ^100_000 { nqp::dispatch('raku-call', \u0026amp;fac, 10); } say now - INIT now; 在我的机器上，第一个运行时间为4.86秒，第二个运行时间为1.34秒。因此，在新的调度器下，运行时间只需过去的四分之一多一点 - 这已经是一个相当大的改进了。\n一个涉及 callsame 的案例也很有意思。这里是没有使用新调度器的情况。\nmulti fallback(Any $x) { \u0026quot;a$x\u0026quot; } multi fallback(Numeric $x) { \u0026quot;n\u0026quot; ~ callsame } multi fallback(Real $x) { \u0026quot;r\u0026quot; ~ callsame } multi fallback(Int $x) { \u0026quot;i\u0026quot; ~ callsame } for ^1_000_000 { fallback(4+2i); fallback(4.2); fallback(42); } say now - INIT now; 而配合临时调整使用新的调度器:\nuse nqp; multi fallback(Any $x) { \u0026quot;a$x\u0026quot; } multi fallback(Numeric $x) { \u0026quot;n\u0026quot; ~ new-disp-callsame } multi fallback(Real $x) { \u0026quot;r\u0026quot; ~ new-disp-callsame } multi fallback(Int $x) { \u0026quot;i\u0026quot; ~ new-disp-callsame } for ^1_000_000 { nqp::dispatch('raku-call', \u0026amp;fallback, 4+2i); nqp::dispatch('raku-call', \u0026amp;fallback, 4.2); nqp::dispatch('raku-call', \u0026amp;fallback, 42); } say now - INIT now; 在我的机器上，第一个运行时间为31.3s，第二个运行时间为11.5s，这意味着使用新的调度器，我们最终需要的时间只有当前 Rakudo 的三分之一多一点。\n这些都是相当鼓舞人心的，但正如前面提到的，大部分的多重调度都是琐碎的那种，没有使用这些功能。如果我在让其他事情变得更好的路上把最常见的情况变得更糟，那就不好了。现在还不能对此进行公平的比较：琐碎的多重分派在特化器中已经受到了很多关注，而且它还不能很好地优化使用新调度器的代码。值得注意的是，在这样的例子中。\nmulti m(Int) { } multi m(Str) { } for ^1_000_000 { m(1); m(\u0026quot;x\u0026quot;); } say now - INIT now; 内嵌和其他优化会将其变成一个空循环，这是很难做到的。不过有一件事我们已经可以做了：在禁用 specializer 的情况下运行它。新的调度器版本看起来是这样的。\nuse nqp; multi m(Int) { } multi m(Str) { } for ^1_000_000 { nqp::dispatch('raku-call', \u0026amp;m, 1); nqp::dispatch('raku-call', \u0026amp;m, \u0026quot;x\u0026quot;); } say now - INIT now; 结果分别是0.463s和0.332s。因此，基线执行时间 - 在特化器发挥其魔力之前 - 使用新的通用调度机制比使用我们目前使用的特化多重调度缓存要少。在做测量之前，我不知道这里会有什么预期。鉴于我们要从一个已经被剖析和调整过的特化机制转到一个没有受到如此关注的新的通用机制，我已经做好了最初做得差一点的准备，如果能做到平价就好了。在70%的时间里，跑进了70%的时间，这比我预期的进步更大。\n我期望，一旦特化器更好地理解新的调度机制，它也能把上面的内容变成一个空循环 - 不过，由于每次优化可以进行更多的迭代，这应该还是表现为新调度器的胜利。\n最后的想法 只要增加一个相对较小的功能，新的调度机制已经可以处理大部分的 Raku 多重调度语义。此外，即使在 specializer 和 JIT 没有真正能够做好的情况下，一些微基准已经显示出3倍-4倍的提升。这是一个很好的起点。\n在我们使用新的调度器出货 Rakudo 版本之前，还有很多工作要做。然而，多重调度是设计中剩下的最大威胁：它比其他种类的调度相当多的参与，而且很有可能一个意想不到的缺点会引发新一轮的设计工作，或者揭示出一般机制与基线未优化的情况下, 与更专业的机制相比，性能会很吃力。到目前为止，没有任何迹象表明这两种情况，我谨慎乐观地认为整体设计是差不多的。\n"},"name":"Raku Multiple Dispatch With the New MoarVM Dispatcher","published":"2021-04-15T00:00:00+08:00","summary":"Raku Multiple Dispatch With the New Moarvm Dispatcher","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/"},{"content":{"html":"\u003ch1 id=\"raku-与-postgresql-的连接性一览\"\u003eRaku 与 PostgreSQL 的连接性一览\u003c/h1\u003e\n\u003cp\u003e在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。\u003c/p\u003e\n\u003cp\u003eRaku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。\n在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。\n脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。\u003c/p\u003e\n\u003cp\u003eDB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。\u003c/p\u003e\n\u003ch2 id=\"安装方法\"\u003e安装方法\u003c/h2\u003e\n\u003cp\u003e可以使用 zef 来安装 DB::Pg 模块。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e% zef install DB::Pg\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e根据你的系统速度和已经安装的库，可能需要几分钟的时间。\u003c/p\u003e\n\u003cp\u003e如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e% zef install epoll\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"连接到数据库\"\u003e连接到数据库\u003c/h2\u003e\n\u003cp\u003e现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e#!raku\n\nuse DB::Pg;\n\nsub MAIN( Str :$host = 'miguel',\n          Str :$username = 'luca',\n          Str :$password = 'secet',\n          Str :$database = 'testdb' ) {\n\n    \u0026quot;Connecting $username @ $host/$database\u0026quot;.say;\n\n    my $connection = DB::Pg.new: conninfo =\u0026gt; \u0026quot;host=$host user=$username password=$password dbname=$database\u0026quot;;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如你所见，DB::Pg模块接受一个 conninfo 字符串。\u003c/p\u003e\n\u003ch2 id=\"读取查询和结果\"\u003e读取查询和结果\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e.query\u003c/code\u003e 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 \u003ccode\u003e.hash\u003c/code\u003e 和 \u003ccode\u003e.arrays\u003c/code\u003e，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 \u003ccode\u003e.rows\u003c/code\u003e 和 \u003ccode\u003e.column\u003c/code\u003e 等特殊方法分别提供了查询返回的行数和结果集的列名。\u003c/p\u003e\n\u003cp\u003e举个例子，这里是一个简单的查询。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $query = 'SELECT current_role, current_time';\nmy $results = $connection.query: $query;\n\nsay \u0026quot;The query { $query } returned { $results.rows } rows with columns: { $results.columns.join( ', ' ) }\u0026quot;;\nfor $results.hashes -\u0026gt; $row {\n    for $row.kv -\u0026gt; $column, $value {\n        say \u0026quot;Column $column = $value\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面这段代码提供了一个类似于下面的输出。\u003c/p\u003e\n\u003cp\u003e查询 \u003ccode\u003eSELECT current_role, current_time\u003c/code\u003e 返回1行，列数为： current_role, current_time。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eColumn current_role = luca\nColumn current_time = 14:48:47.147983+02\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"光标\"\u003e光标\u003c/h2\u003e\n\u003cp\u003e默认情况下，\u003ccode\u003e.query\u003c/code\u003e 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 \u003ccode\u003e.cursor\u003c/code\u003e 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。\u003c/p\u003e\n\u003cp\u003e作为一个简单的例子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003efor $connection.cursor( 'select * from raku', fetch =\u0026gt; 2, :hash ) -\u0026gt; %row {\n    say \u0026quot;====================\u0026quot;;\n    for %row.kv -\u0026gt; $column, $value {\n        say \u0026quot;Column [ $column ] = $value\u0026quot;;\n    }\n    say \u0026quot;====================\u0026quot;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e产生和输出像这样的东西。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e====================\nColumn [ pk ] = 2\nColumn [ t ] = This is value 0\n====================\n====================\nColumn [ pk ] = 3\nColumn [ t ] = This is value 1\n====================\n====================\nColumn [ t ] = This is value 2\nColumn [ pk ] = 4\n====================\n====================\nColumn [ pk ] = 5\nColumn [ t ] = This is value 3\n====================\n...\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"撰写声明\"\u003e撰写声明\u003c/h2\u003e\n\u003cp\u003e编写语句可以通过 \u003ccode\u003e.execute\u003c/code\u003e 方法来执行，如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e$connection.execute: q\u0026lt; insert into raku( t ) values( 'Hello World' )\u0026gt;;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"交易和编制报表\"\u003e交易和编制报表\u003c/h2\u003e\n\u003cp\u003e为了处理事务，你需要访问被\u0026quot;屏蔽\u0026quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 \u003ccode\u003e.begin\u003c/code\u003e、\u003ccode\u003e.rollback\u003c/code\u003e、\u003ccode\u003e.commit\u003c/code\u003e等方法。\u003c/p\u003e\n\u003cp\u003e此外，还可以使用 \u003ccode\u003e.prepare\u003c/code\u003e 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，\u003ccode\u003e.prepare\u003c/code\u003e 方法使用了 \u003ccode\u003e$1\u003c/code\u003e、\u003ccode\u003e$2\u003c/code\u003e 等参数占位符，当语句接受单个值时，必须在 \u003ccode\u003e.execute\u003c/code\u003e 中不指定索引。\u003c/p\u003e\n\u003cp\u003e举个例子\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $database-handler = $connection.db;\nmy $statement = $database-handler.prepare: 'insert into raku( t ) values( $1 )';\n\n$database-handler.begin;\n$statement.execute( \u0026quot;This is value $_\u0026quot; )  for 0 .. 10;\n$database-handler.commit;\n$database-handler.finish;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述循环相当于一个SQL事务，如:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"k\"\u003eBEGIN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 0\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 1\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 2\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"k\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"k\"\u003eINTO\u003c/span\u003e \u003cspan class=\"n\"\u003eraku\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003eVALUES\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;This is value 10\u0026#39;\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eCOMMIT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003e.finish\u003c/code\u003e 方法是必需的，因为 DB::Pg 处理缓存。请注意，\u003ccode\u003e.commit\u003c/code\u003e 和 \u003ccode\u003e.rollback\u003c/code\u003e 方法是流畅的，并返回一个对象实例，这样你就可以调用 \u003ccode\u003e.commit.finish\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"数据库与连接\"\u003e数据库与连接\u003c/h2\u003e\n\u003cp\u003e缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 \u003ccode\u003e.\u003c/code\u003e 完成。\u003c/p\u003e\n\u003cp\u003e因此，你可以在两个对象上使用相同的 \u003ccode\u003e.query\u003c/code\u003e 和 \u003ccode\u003e.execute\u003c/code\u003e 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。\u003c/p\u003e\n\u003ch2 id=\"复制\"\u003e复制\u003c/h2\u003e\n\u003cp\u003ePostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 \u003ccode\u003e.copy-in\u003c/code\u003e 可以执行 \u003ccode\u003eCOPY FROM\u003c/code\u003e，而 \u003ccode\u003eCOPY TO\u003c/code\u003e 可以在迭代循环中使用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $file = '/tmp/raku.csv'.IO.open: :w;\nfor $connection.query: 'COPY raku TO stdout (FORMAT CSV)'  -\u0026gt; $row {\n    $file.print: $row;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上将 CSV 结果导出到文本文件上。\n如果要读回数据，可以发出 \u003ccode\u003e.copy-in\u003c/code\u003e 方法，但首先需要发出 \u003ccode\u003eSQL COPY\u003c/code\u003e。工作流程是\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eissue a COPY FROM STDIN;\nuse .copy-data to slurp all the data;\nuse .copy-end to notify the database that the COPY is concluded.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e$database-handler = $connection.db;\n$database-handler.query: 'COPY raku FROM STDIN (FORMAT CSV)';\n$database-handler.copy-data:  '/tmp/raku1.csv'.IO.slurp;\n$database-handler.copy-data:  '/tmp/raku2.csv'.IO.slurp;\n$database-handler.copy-end;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"转换器\"\u003e转换器\u003c/h2\u003e\n\u003cp\u003e可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 \u003ccode\u003einflate\u003c/code\u003e 和 \u003ccode\u003edeflate\u003c/code\u003e 选项。\n第一步是在 \u003ccode\u003eDB::Pg\u003c/code\u003e 中给转换器实例添加一个角色，这样的实例必须。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e增加一个新的类型转换方法。\u003c/li\u003e\n\u003cli\u003e增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e$connection.converter does role fluca-converter\n{\n    submethod BUILD { self.add-type( text =\u0026gt; Str ) }\n    multi method convert( Str:U, Str:D $value) {\n        $value.flip.uc;\n    }\n\n}\n\n.say for $connection.query( 'select * from raku' ).arrays;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e产生类似于的输出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[442 DLROW OLLEH]\n[454 DLROW OLLEH]\n[466 DLROW OLLEH]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其中字符串 Hello World 被翻转。\u003c/p\u003e\n\u003ch2 id=\"listen-和-notify\"\u003elisten 和 notify\u003c/h2\u003e\n\u003cp\u003eDB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。\n首先，创建一个简单的机制来通知一些事件。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003etestdb=\u0026gt; create or replace rule r_raku_insert \n         as on insert to raku \n         do also \n         SELECT pg_notify( 'insert_event', 'INSERTING ROW(S)' );\nCREATE RULE\n\ntestdb=\u0026gt; create or replace rule r_raku_delete\n         as on delete to raku \n         do also \n         SELECT pg_notify( 'delete_event', 'DELETING ROW(S)' );\nCREATE RULE\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在，可以创建一个等待传入事件的 Raku 脚本。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003ereact {\n    whenever $connection.listen( 'delete_event' ) { .say; }\n    whenever $connection.listen( 'insert_event' ) { .say; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e目的是，每次发出一个事件，\u003ccode\u003e.listen\u003c/code\u003e 都会将消息有效载荷传递给 react 代码块。因此，发出一些 \u003ccode\u003eDELETE\u003c/code\u003e 和 \u003ccode\u003eINSERT\u003c/code\u003e 会导致输出。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDELETING ROW(S)\nINSERTING ROW(S)\nINSERTING ROW(S)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以通过 \u003ccode\u003e.unlisten\u003c/code\u003e 方法停止监听反应块。也可以通过 \u003ccode\u003e.notify\u003c/code\u003e 方法发出事件。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003eDB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。\u003c/p\u003e\n\u003cp\u003e文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html\"\u003ehttps://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html\u003c/a\u003e\u003c/p\u003e\n","text":"Raku 与 PostgreSQL 的连接性一览 在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。\nRaku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。 在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。 脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。\nDB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。\n安装方法 可以使用 zef 来安装 DB::Pg 模块。\n% zef install DB::Pg 根据你的系统速度和已经安装的库，可能需要几分钟的时间。\n如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。\n% zef install epoll 连接到数据库 现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：\n#!raku use DB::Pg; sub MAIN( Str :$host = 'miguel', Str :$username = 'luca', Str :$password = 'secet', Str :$database = 'testdb' ) { \u0026quot;Connecting $username @ $host/$database\u0026quot;.say; my $connection = DB::Pg.new: conninfo =\u0026gt; \u0026quot;host=$host user=$username password=$password dbname=$database\u0026quot;; 如你所见，DB::Pg模块接受一个 conninfo 字符串。\n读取查询和结果 .query 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 .hash 和 .arrays，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 .rows 和 .column 等特殊方法分别提供了查询返回的行数和结果集的列名。\n举个例子，这里是一个简单的查询。\nmy $query = 'SELECT current_role, current_time'; my $results = $connection.query: $query; say \u0026quot;The query { $query } returned { $results.rows } rows with columns: { $results.columns.join( ', ' ) }\u0026quot;; for $results.hashes -\u0026gt; $row { for $row.kv -\u0026gt; $column, $value { say \u0026quot;Column $column = $value\u0026quot;; } } 上面这段代码提供了一个类似于下面的输出。\n查询 SELECT current_role, current_time 返回1行，列数为： current_role, current_time。\nColumn current_role = luca Column current_time = 14:48:47.147983+02 光标 默认情况下，.query 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 .cursor 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。\n作为一个简单的例子。\nfor $connection.cursor( 'select * from raku', fetch =\u0026gt; 2, :hash ) -\u0026gt; %row { say \u0026quot;====================\u0026quot;; for %row.kv -\u0026gt; $column, $value { say \u0026quot;Column [ $column ] = $value\u0026quot;; } say \u0026quot;====================\u0026quot;; } 产生和输出像这样的东西。\n==================== Column [ pk ] = 2 Column [ t ] = This is value 0 ==================== ==================== Column [ pk ] = 3 Column [ t ] = This is value 1 ==================== ==================== Column [ t ] = This is value 2 Column [ pk ] = 4 ==================== ==================== Column [ pk ] = 5 Column [ t ] = This is value 3 ==================== ... 撰写声明 编写语句可以通过 .execute 方法来执行，如:\n$connection.execute: q\u0026lt; insert into raku( t ) values( 'Hello World' )\u0026gt;; 交易和编制报表 为了处理事务，你需要访问被\u0026quot;屏蔽\u0026quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 .begin、.rollback、.commit等方法。\n此外，还可以使用 .prepare 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，.prepare 方法使用了 $1、$2 等参数占位符，当语句接受单个值时，必须在 .execute 中不指定索引。\n举个例子\nmy $database-handler = $connection.db; my $statement = $database-handler.prepare: 'insert into raku( t ) values( $1 )'; $database-handler.begin; $statement.execute( \u0026quot;This is value $_\u0026quot; ) for 0 .. 10; $database-handler.commit; $database-handler.finish; 上述循环相当于一个SQL事务，如:\nBEGIN; INSERT INTO raku( t ) VALUES (\u0026#39;This is value 0\u0026#39; ); INSERT INTO raku( t ) VALUES (\u0026#39;This is value 1\u0026#39; ); INSERT INTO raku( t ) VALUES (\u0026#39;This is value 2\u0026#39; ); ... INSERT INTO raku( t ) VALUES (\u0026#39;This is value 10\u0026#39; ); COMMIT; .finish 方法是必需的，因为 DB::Pg 处理缓存。请注意，.commit 和 .rollback 方法是流畅的，并返回一个对象实例，这样你就可以调用 .commit.finish。\n数据库与连接 缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 . 完成。\n因此，你可以在两个对象上使用相同的 .query 和 .execute 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。\n复制 PostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 .copy-in 可以执行 COPY FROM，而 COPY TO 可以在迭代循环中使用。\nmy $file = '/tmp/raku.csv'.IO.open: :w; for $connection.query: 'COPY raku TO stdout (FORMAT CSV)' -\u0026gt; $row { $file.print: $row; } 以上将 CSV 结果导出到文本文件上。 如果要读回数据，可以发出 .copy-in 方法，但首先需要发出 SQL COPY。工作流程是\nissue a COPY FROM STDIN; use .copy-data to slurp all the data; use .copy-end to notify the database that the COPY is concluded. 对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。\n$database-handler = $connection.db; $database-handler.query: 'COPY raku FROM STDIN (FORMAT CSV)'; $database-handler.copy-data: '/tmp/raku1.csv'.IO.slurp; $database-handler.copy-data: '/tmp/raku2.csv'.IO.slurp; $database-handler.copy-end; 转换器 可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 inflate 和 deflate 选项。 第一步是在 DB::Pg 中给转换器实例添加一个角色，这样的实例必须。\n 增加一个新的类型转换方法。 增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。  作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。\n$connection.converter does role fluca-converter { submethod BUILD { self.add-type( text =\u0026gt; Str ) } multi method convert( Str:U, Str:D $value) { $value.flip.uc; } } .say for $connection.query( 'select * from raku' ).arrays; 产生类似于的输出。\n[442 DLROW OLLEH] [454 DLROW OLLEH] [466 DLROW OLLEH] 其中字符串 Hello World 被翻转。\nlisten 和 notify DB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。 首先，创建一个简单的机制来通知一些事件。\ntestdb=\u0026gt; create or replace rule r_raku_insert as on insert to raku do also SELECT pg_notify( 'insert_event', 'INSERTING ROW(S)' ); CREATE RULE testdb=\u0026gt; create or replace rule r_raku_delete as on delete to raku do also SELECT pg_notify( 'delete_event', 'DELETING ROW(S)' ); CREATE RULE 现在，可以创建一个等待传入事件的 Raku 脚本。\nreact { whenever $connection.listen( 'delete_event' ) { .say; } whenever $connection.listen( 'insert_event' ) { .say; } } 目的是，每次发出一个事件，.listen 都会将消息有效载荷传递给 react 代码块。因此，发出一些 DELETE 和 INSERT 会导致输出。\nDELETING ROW(S) INSERTING ROW(S) INSERTING ROW(S) 可以通过 .unlisten 方法停止监听反应块。也可以通过 .notify 方法发出事件。\n总结 DB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。\n文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。\n原文链接: https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html\n"},"name":"Psql","published":"2021-04-05T00:00:00+08:00","summary":"Psql","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-04-05-psql/"},{"content":{"html":"\u003cp\u003e我的天啊，看来我是两年多来第一次写 Raku 内部的博文了。当然，两年前还不叫 Raku。总之，话不多说，继续说说这个共同的脑洞吧。\u003c/p\u003e\n\u003ch2 id=\"什么是调度\"\u003e什么是调度？\u003c/h2\u003e\n\u003cp\u003e我用 \u0026ldquo;dispatch\u0026rdquo; 来表示我们接受一组参数，最后根据这些参数采取一些行动的过程。一些熟悉的例子包括:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e进行一个方法调用，比如 \u003ccode\u003e$basket.add($product, $quantity)\u003c/code\u003e。传统上，我们可能只调用 \u003ccode\u003e$product\u003c/code\u003e 和 \u003ccode\u003e$qauntity\u003c/code\u003e 作为参数，但就我的目的而言，所有的 \u003ccode\u003e$basket\u003c/code\u003e、方法名  \u0026ldquo;add\u0026rdquo;、\u003ccode\u003e$product\u003c/code\u003e 和 \u003ccode\u003e$quantity\u003c/code\u003e 都是 dispatch 的参数：它们是我们需要的东西，以便决定我们要做什么。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e进行子程序调用，如 \u003ccode\u003euc($youtube-comment)\u003c/code\u003e。由于 Raku sub 调用是词法解析的，所以在这种情况下，调度的参数是 \u003ccode\u003e\u0026amp;uc\u003c/code\u003e（查找子程序的结果）和 \u003ccode\u003e$youtube-comment\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e调用多个调度子程序或方法，根据参数的数量和类型来决定调用一组候选程序中的哪一个。这个过程可以看作是发生在上述两个调度中的一个 \u0026ldquo;内部\u0026rdquo;，因为我们在 Raku 中既有多重调度子程序，也有方法。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e乍一看，也许前两个看起来相当简单，第三个就有点手忙脚乱了 - 这也算是事实。然而，Raku 还有一些其他的特性，使得调度变得相当，嗯，有趣。例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ewrap\u003c/code\u003e 允许我们包装任何 Routine (sub 或方法); 包装器可以选择用原来的参数或新的参数来服从原来的例程。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e当进行多重调度时，我们可以写一个原型例程，让它选择何时 - 甚至是否 - 调用合适的候选者。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e我们可以使用 \u003ccode\u003ecallsame\u003c/code\u003e 这样的例程，以便在调度中推迟到下一个候选者。但这意味着什么呢？如果我们是在一个多重调度中，它意味着下一个最适用的候选者，如果有的话。如果我们是在一个方法调度中，那么它意味着一个基类的方法。(同样的事情也被用来实现去下一个封装者，或者，最终也是去最初封装的例程)。而且这些都可以结合起来：我们可以包装一个 multi 方法，这意味着我们可以有 3 个层次的东西，都有可能贡献下一个要调用的东西!\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e多亏了这一点，dispatch - 至少在 Raku 中 - 并不总是我们所做的事情并产生一个结果，而是一个可能会被要求继续多次进行的过程!\u003c/p\u003e\n\u003cp\u003e最后，虽然我上面所写的例子都可以很清楚地看成是调度的例子，但在 Raku 中，其他一些常见的构造也可以表达为一种调度。分配是一个例子：它的语义取决于分配的目标和被分配的值，因此我们需要选择正确的语义。强制类型转换(Coercion)是另一个例子，返回值类型检查又是一个例子。\u003c/p\u003e\n\u003ch2 id=\"为什么调度很重要\"\u003e为什么调度很重要？\u003c/h2\u003e\n\u003cp\u003eDispatch 在我们的程序中无处不在，它悄悄地把想做事情的代码和做事情的代码联系在一起。它的无处不在意味着它在程序性能中扮演着重要的角色。在最好的情况下，我们可以将成本降为零。在最坏的情况下，调度的成本高到足以超过作为调度结果的工作的成本。\u003c/p\u003e\n\u003cp\u003e初步估计，当运行时\u0026quot;理解\u0026quot;调度时，性能至少会有些不错，但当运行时不理解时，很有可能会很糟糕。调度往往涉及到一个可以缓存的工作量，往往会有一些廉价的防护措施来验证缓存结果的有效性。例如，在方法调度中，天真地我们需要走一个线性化的继承图，并询问沿途遇到的每个类是否有指定名称的方法。显然，如果我们在每次方法调用时都这样做，速度不会非常快。然而，特定类型上的特定方法名（精确识别，不考虑子类）每次都会解析到同一个方法。因此，我们可以缓存查找的结果，只要调用者的类型与用于产生缓存结果的类型相匹配，就可以使用它。\u003c/p\u003e\n\u003ch2 id=\"语言运行时的专门化与通用化机制\"\u003e语言运行时的专门化与通用化机制\u003c/h2\u003e\n\u003cp\u003e当一个人开始构建一个针对特定语言的运行时，并且必须在相当紧张的预算下完成时，要想获得某种可容忍的性能，最明显的方法就是将各种热路径语言语义烘焙到运行时中。这正是 MoarVM 的起步方式。因此，如果我们看看 MoarVM 几年前的样子，我们会发现这样的事情。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对方法缓存的一些支持\u003c/li\u003e\n\u003cli\u003e一个与 Raku 的多重调度语义高度绑定的多重调度缓存，只有在调度都是名义类型的时候才真正能够起到帮助作用（所以使用 \u003ccode\u003ewhere\u003c/code\u003e 的代价非常高）。\u003c/li\u003e\n\u003cli\u003e一种机制，用于指定如何在封装代码对象内部找到实际的代码句柄（例如，\u003ccode\u003eSub\u003c/code\u003e 对象有一个私有属性，它持有识别要运行的字节码的低级代码句柄）。\u003c/li\u003e\n\u003cli\u003e一些有限的尝试，让我们能够在知道一个调度不会继续的情况下正确地进行优化 - 这需要编译器和运行时之间的谨慎合作（或者不那么外交地讲，这都是一个大黑客）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些今天都还在，然而也都在淘汰的路上。这个榜单最能说明问题的是什么，不包括在内。比如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e私有方法调用，需要不同的缓存 但最初的虚拟机设计限制了每一种类型的调用\u003c/li\u003e\n\u003cli\u003e合格的方法调用(\u003ccode\u003e$obj.SomeType::method-name()\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e体面优化调度恢复的方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e几年前，我开始部分解决这个问题，引入了一种机制，我称之为 \u0026ldquo;specializer 插件\u0026rdquo;。但首先，什么是特化器(specializer)？\u003c/p\u003e\n\u003cp\u003eMoarVM 刚开始的时候，它是一个比较简单的字节码解释器。它只需要足够快的速度击败 Parrot VM 就可以获得相当的使用量，我认为在继续实现一些更有趣的优化之前，这一点非常重要（当时我们还没有今天这样的发布前自动测试基础设施，因此更多的是依赖于早期采用者的反馈）。总之，在能够像其他后端一样运行 Raku 语言后不久，我就开始了动态优化器的开发。它在程序被解释时收集类型统计，识别热代码，将其放入 \u003ca href=\"https://en.wikipedia.org/wiki/Static_single_assignment_form\"\u003eSSA 形式\u003c/a\u003e，使用类型统计插入防护，将这些与字节码的静态属性一起使用来分析和优化，并为相关函数生成专门的字节码。这个字节码可以省略类型检查和各种查找，也可以使用一系列的内部操作，做出各种假设，由于优化器证明了程序的属性，这些假设是安全的。这被称为专门化的字节码，因为它的很多通用性 - 这将使它能够正确地工作在我们可能遇到的所有类型的值上 - 被删除了，转而工作在运行时实际发生的特殊情况下。(代码，尤其是动态语言中的代码，一般来说，理论上的通用性远远大于实践中的通用性。)\u003c/p\u003e\n\u003cp\u003e这个组件 - 内部称为 \u0026ldquo;spesh\u0026rdquo; 的 specializer - 为 Raku 程序的性能带来了显著的进一步提升，随着时间的推移，它的复杂程度也在不断提高，并采用了\u003ca href=\"https://en.wikipedia.org/wiki/Inline_expansion\"\u003e内联\u003c/a\u003e和\u003ca href=\"https://en.wikipedia.org/wiki/Escape_analysis\"\u003e带有标量替换的转义分析\u003c/a\u003e等优化功能。这些并不是容易构建的东西 - 但一旦运行时拥有了它们，它们就会创造出以前不存在的设计可能性，并使在没有它们的情况下做出的决定看起来是次优的。\u003c/p\u003e\n\u003cp\u003e值得注意的是，那些特殊情况下的语言特定机制，在早期为了获得一些速度而被嵌入到运行时中，反而成为了一种负担和瓶颈。它们具有复杂的语义，这意味着它们对优化器来说要么是不透明的（所以优化器无法对它们进行推理，意味着优化受到抑制），要么就是需要在优化器中进行特殊的封装（一种负担）。\u003c/p\u003e\n\u003cp\u003e所以，回到 specializer 插件。我到了一个地步，我想承担像 \u003ccode\u003e$obj.?meth(\u0026quot;call me maybe\u0026quot;, dispatch)\u003c/code\u003e、\u003ccode\u003e$obj.SomeType::meth()\u003c/code\u003e(用类开始寻找的调度限定)，以及角色中的私有方法调用(不能静态解析)这样的性能。同时，我还准备实现一定量的转义分析，但意识到它的作用将非常有限，因为赋值在虚拟机中也被特例化了，有一大块不透明的 C 代码在做热路径的事情。\u003c/p\u003e\n\u003cp\u003e但为什么我们要让 C 代码来做那些热路径的事情呢？嗯，因为让每个赋值都调用一个虚拟机级别的函数，做一堆检查和逻辑，花费太大了。为什么这样做成本很高？因为函数调用的开销和解释的成本。这在以前都是正确的。但是，若干年后的发展。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e内联被实现了，并且可以消除做一个函数调用的开销。\u003c/li\u003e\n\u003cli\u003e我们可以编译成机器代码，消除解释开销。\u003c/li\u003e\n\u003cli\u003e我们当时的处境是，我们手头有 specializer 的类型信息，可以让我们消除 C 代码中的分支，但由于我们调用的只是一个不透明的函数，所以没有办法抓住这个机会\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我解决了上面提到的分配问题和调度问题，引入了一个新的机制：specializer 插件。它们的工作原理如下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当我们第一次到达字节码中的一个给定的调用点时，我们就会运行这个插件。它产生了一个要调用的代码对象，以及一组守卫（为了使用该代码对象结果而必须满足的条件）。\u003c/li\u003e\n\u003cli\u003e下一次到达时，我们检查是否满足守卫，如果满足，就用结果\u003c/li\u003e\n\u003cli\u003e如果没有，我们再运行一次插件，并在 callsite 处堆积一个防护集。\u003c/li\u003e\n\u003cli\u003e我们统计了一个给定的防护集成功的频率，然后将其用于 specializer\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e绝大多数情况下都是单态的，这意味着只产生一组守卫，而且之后总是成功的。因此，特殊化器可以将这些守卫编译到专门的字节码中，然后假设给定的目标调用者就是将被调用的守卫。(进一步，重复的守卫可以被消除，所以某个插件引入的守卫可能会减少到零)。\u003c/p\u003e\n\u003cp\u003eSpecializer 插件感觉挺好的。一个新机制解决了多个优化头疼的问题。\u003c/p\u003e\n\u003cp\u003e新的 MoarVM 调度机制是对一个相当简单的问题的回答：如果我们把所有与调度相关的特例机制去掉，而采用有点像 specializer 插件的机制，会怎么样？由此产生的机制需要是一个比 specializer 插件更强大的机制。进一步说，我可以学习特殊器插件的一些缺点。因此，虽然它们会在比较短的寿命后消失，但我认为可以说，如果没有这些经验，我就不会有能力设计新的 MoarVM 调度机制。\u003c/p\u003e\n\u003ch2 id=\"调度操作和引导调度器\"\u003e调度操作和引导调度器\u003c/h2\u003e\n\u003cp\u003e所有的方法缓存。所有的多重调度缓存。所有的 specializer 插件。所有用于在代码对象中解包字节码句柄的调用协议的东西。这一切都将被取消，取而代之的是一个新的调度指令。它的名字很无聊，叫 \u003ccode\u003edispatch\u003c/code\u003e。它看起来像这样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003edispatch_o result, 'dispatcher-name', callsite, arg0, arg1, ..., argN\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这意味着：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用名为 dispatcher-name 的调度器。\u003c/li\u003e\n\u003cli\u003e给它指定的参数寄存器（所引用的调用点表示参数的数量）。\u003c/li\u003e\n\u003cli\u003e将调度的对象结果放入寄存器结果中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e(旁白：这意味着一个新的调用约定，即我们不再将参数复制到参数缓冲区，而是将寄存器集的基数和一个指针传递到找到寄存器参数映射的字节码中，然后做一个查询 \u003ccode\u003eregisters[map[argument_index]]\u003c/code\u003e 来获取一个参数的值。仅此一点，我们在解释时就很省事，因为我们不再需要每个参数绕着解释器循环了）。)\u003c/p\u003e\n\u003cp\u003e有些参数可能是我们传统上称之为参数的东西。有些则是针对调度过程本身。这其实并不重要 - 但如果我们安排将只针对调度的参数放在前面（例如，方法名），而将针对调度目标的参数放在后面（例如，方法参数），则会更加理想。\u003c/p\u003e\n\u003cp\u003e新的 bootstrap 机制提供了少量的内置调度器，它们的名字以 \u0026ldquo;boot-\u0026rdquo; 开头。它们是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eboot-value\u003c/code\u003e - 取第一个参数并将其作为结果（身份函数，除了丢弃任何其他参数）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eboot-constant\u003c/code\u003e - 取第一个参数并将其作为结果，但同时也将其视为一个将始终产生的常量值（因此意味着优化器可以将任何用于计算该值的纯代码视为死值）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eboot-code\u003c/code\u003e - 取第一个参数（必须是虚拟机字节码句柄），并运行该字节码，将其余参数作为参数传给它；评估为字节码的返回值。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eboot-syscall\u003c/code\u003e - 将第一个参数视为虚拟机提供的内置操作的名称，然后调用它，并将其余参数作为其参数。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eboot-resume\u003c/code\u003e - 恢复正在进行的最上层调度。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e差不多就是这样。我们构建的每一个调度器，为了教给运行时一些其他的调度行为，最终都会终止于其中一个。\u003c/p\u003e\n\u003ch2 id=\"在引导程序的基础上\"\u003e在引导程序的基础上\u003c/h2\u003e\n\u003cp\u003e教 MoarVM 了解不同种类的调度，不外乎使用调度机制本身! 在大多数情况下，\u003ccode\u003eboot-syscall\u003c/code\u003e 被用来注册一个调度器，设置守卫，并提供与它们相匹配的结果。\u003c/p\u003e\n\u003cp\u003e这里是一个最小的例子，取自 dispatcher 测试套件，展示了一个提供同一性功能的 dispatcher 的样子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003enqp::dispatch('boot-syscall', 'dispatcher-register', 'identity', -\u0026gt; $capture {\n    nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-value', $capture);\n});\nsub identity($x) {\n    nqp::dispatch('identity', $x)\n}\nok(identity(42) == 42, 'Can define identity dispatch (1)');\nok(identity('foo') eq 'foo', 'Can define identity dispatch (2)');\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在第一条语句中，我们调用 dispatcher-register MoarVM 系统调用，传递一个 dispatcher 的名称以及一个闭包，每次我们需要处理调度时，都会调用这个闭包（我倾向于将其称为\u0026quot;调度回调\u0026quot;）。它接收一个单一的参数，这是一个参数的捕获（其实不是 Raku 级别的捕获，但想法 - 一个包含一组调用参数的对象 - 是一样的）。\u003c/p\u003e\n\u003cp\u003e每一个用户定义的调度器最终都应该使用 dispatcher-delegate，以便确定另一个调度器将控制权传递给它。在这种情况下，它立即委托给 \u003ccode\u003eboot-value\u003c/code\u003e - 这意味着它除了是 \u003ccode\u003eboot-value\u003c/code\u003e 内置调度器的包装器外，其实什么都不是。\u003c/p\u003e\n\u003cp\u003esub \u003ccode\u003eidentity\u003c/code\u003e 包含一个调度操作的静态出现。鉴于我们两次调用 sub，我们在运行时将两次遇到这个 op，但这两次是非常不同的。\u003c/p\u003e\n\u003cp\u003e第一次是 \u0026ldquo;记录\u0026rdquo; 阶段。参数形成一个捕获，回调运行，回调又将其传给引导值调度器，产生结果。这样就形成了一个极其简单的调度程序，它说结果应该是捕获中的第一个参数。由于没有守卫，所以这将永远是一个有效的结果。\u003c/p\u003e\n\u003cp\u003e第二次遇到调度操作时，它那里已经记录了一个调度程序，所以我们处于运行模式。在 MoarVM 源码中开启调试模式，我们可以看到结果的调度程序是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDispatch program (1 temporaries)\n  Ops:\n    Load argument 0 into temporary 0\n    Set result object value from temporary 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也就是说，它将参数 0 读入一个临时位置，然后将其设置为调度的结果。请注意，没有提到我们经过了额外的一层调度，这些在结果调度程序中的成本为零。\u003c/p\u003e\n\u003ch2 id=\"捕获操作\"\u003e捕获操作\u003c/h2\u003e\n\u003cp\u003e参数捕获是不可改变的。各种虚拟机系统调用的存在，可以通过一些调整将它们转化为新的参数捕获，例如删除或插入参数。这里还有一个测试套件的例子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003enqp::dispatch('boot-syscall', 'dispatcher-register', 'drop-first', -\u0026gt; $capture {\n    my $capture-derived := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $capture, 0);\n    nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-value', $capture-derived);\n});\nok(nqp::dispatch('drop-first', 'first', 'second') eq 'second',\n    'dispatcher-drop-arg works');\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这就在将捕获传递给引导值调度器之前丢弃了第一个参数 - 意味着它将返回第二个参数。回头看一下之前的身份函数的调度程序。你能猜到这个程序会是什么样子吗？\u003c/p\u003e\n\u003cp\u003e好吧，就是这样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDispatch program (1 temporaries)\n  Ops:\n    Load argument 1 into temporary 0\n    Set result string value from temporary 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同样，虽然在这样一个调度器的记录阶段，我们确实是创建了捕获对象，并做了一个调度器代理，但由此产生的调度程序要简单得多。\u003c/p\u003e\n\u003cp\u003e下面是一个稍微复杂一点的例子。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $target := -\u0026gt; $x { $x + 1 }\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'call-on-target', -\u0026gt; $capture {\n    my $capture-derived := nqp::dispatch('boot-syscall',\n            'dispatcher-insert-arg-literal-obj', $capture, 0, $target);\n    nqp::dispatch('boot-syscall', 'dispatcher-delegate',\n            'boot-code-constant', $capture-derived);\n});\nsub cot() { nqp::dispatch('call-on-target', 49) }\nok(cot() == 50,\n    'dispatcher-insert-arg-literal-obj works at start of capture');\nok(cot() == 50,\n    'dispatcher-insert-arg-literal-obj works at start of capture after link too');\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里，我们有一个存储在变量 \u003ccode\u003e$target\u003c/code\u003e 中的闭包。我们把它作为捕获的第一个参数插入，然后委托给 \u003ccode\u003eboot-code-constant\u003c/code\u003e，它将调用那个代码对象，并把其他调度参数传递给它。再次，在记录阶段，我们真正要做的事情是这样的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建一个新的捕获 在开始的时候插入一个代码对象。\u003c/li\u003e\n\u003cli\u003e委托给引导代码常量分配器，它\u0026hellip;。\u003c/li\u003e\n\u003cli\u003e\u0026hellip;在没有原始参数的情况下创建一个新的捕获，并使用这些参数运行字节码。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e由此产生的调度程序呢？就是这个\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDispatch program (1 temporaries)\n  Ops:\n    Load collectable constant at index 0 into temporary 0\n    Skip first 0 args of incoming capture; callsite from 0\n    Invoke MVMCode in temporary 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也就是说，加载我们要调用的常量字节码句柄，设置 \u003ccode\u003eargs\u003c/code\u003e（在本例中等于传入捕获的参数），然后用这些参数调用字节码。参数的洗牌，又一次消失了。一般来说，只要我们做最终的字节码调用的参数是初始调度参数的尾巴，参数转换就会变得不过是一个指针的添加。\u003c/p\u003e\n\u003ch2 id=\"守卫\"\u003e守卫\u003c/h2\u003e\n\u003cp\u003e目前看到的所有调度方案都是无条件的：一旦在某一通话地点记录下来，就应一直使用。要使这样的机制具有实用性，缺少的一大块就是守卫。守卫断言了一些属性，比如参数的类型或者参数是确定的（\u003ccode\u003eInt:D\u003c/code\u003e）还是不确定的（\u003ccode\u003eInt:U\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e下面是一个有点长的测试用例，并在其中放置了一些解释。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# A couple of classes for test purposes\nmy class C1 { }\nmy class C2 { }\n \n# A counter used to make sure we're only invokving the dispatch callback as\n# many times as we expect.\nmy $count := 0;\n \n# A type-name dispatcher that maps a type into a constant string value that\n# is its name. This isn't terribly useful, but it is a decent small example.\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'type-name', -\u0026gt; $capture {\n    # Bump the counter, just for testing purposes.\n    $count++;\n \n    # Obtain the value of the argument from the capture (using an existing\n    # MoarVM op, though in the future this may go away in place of a syscall)\n    # and then obtain the string typename also.\n    my $arg-val := nqp::captureposarg($capture, 0);\n    my str $name := $arg-val.HOW.name($arg-val);\n \n    # This outcome is only going to be valid for a particular type. We track\n    # the argument (which gives us an object back that we can use to guard\n    # it) and then add the type guard.\n    my $arg := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0);\n    nqp::dispatch('boot-syscall', 'dispatcher-guard-type', $arg);\n \n    # Finally, insert the type name at the start of the capture and then\n    # delegate to the boot-constant dispatcher.\n    nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant',\n        nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-str',\n            $capture, 0, $name));\n});\n \n# A use of the dispatch for the tests. Put into a sub so there's a single\n# static dispatch op, which all dispatch programs will hang off.\nsub type-name($obj) {\n    nqp::dispatch('type-name', $obj)\n}\n \n# Check with the first type, making sure the guard matches when it should\n# (although this test would pass if the guard were ignored too).\nok(type-name(C1) eq 'C1', 'Dispatcher setting guard works');\nok($count == 1, 'Dispatch callback ran once');\nok(type-name(C1) eq 'C1', 'Can use it another time with the same type');\nok($count == 1, 'Dispatch callback was not run again');\n \n# Test it with a second type, both record and run modes. This ensures the\n# guard really is being checked.\nok(type-name(C2) eq 'C2', 'Can handle polymorphic sites when guard fails');\nok($count == 2, 'Dispatch callback ran a second time for new type');\nok(type-name(C2) eq 'C2', 'Second call with new type works');\n \n# Check that we can use it with the original type too, and it has stacked\n# the dispatch programs up at the same callsite.\nok(type-name(C1) eq 'C1', 'Call with original type still works');\nok($count == 2, 'Dispatch callback only ran a total of 2 times');\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这个时候就会产生两个调度程序，一个是 C1。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDispatch program (1 temporaries)\n  Ops:\n    Guard arg 0 (type=C1)\n    Load collectable constant at index 1 into temporary 0\n    Set result string value from temporary 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e另一个是 C2:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDispatch program (1 temporaries)\n  Ops:\n    Guard arg 0 (type=C2)\n    Load collectable constant at index 1 into temporary 0\n    Set result string value from temporary 0\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e再一次，没有捕获操作、跟踪或调度器委托的遗留问题；调度程序对一个参数进行类型防护，然后产生结果字符串。整个对 \u003ccode\u003e$arg-val.HOW.name($arg-val)\u003c/code\u003e 的调用都被省略了，我们写的调度程序将知识进行了编码 - 以虚拟机能够理解的方式 - 一个类型的名称可以被认为是不可改变的。\u003c/p\u003e\n\u003cp\u003e这个例子有点造作，但现在考虑一下，我们反而要查找一个方法，并在调用者类型上进行守卫：这就是一个方法缓存! 守护更多参数的类型，我们就有了一个多缓存。两者都做，我们就有了一个多方法缓存。\u003c/p\u003e\n\u003cp\u003e后者很有意思，因为方法调度和多调度都想对调用者进行守护。事实上，在 MoarVM 中，今天会有两个这样的类型测试，直到我们到了特殊化器做工作并消除这些重复的守卫。然而，新的调度器并没有将调度器 - guard-类型当作一种命令式操作，将守卫写入结果调度程序中。相反，它声明相关的参数必须被防护。如果其他的调度器已经这样做了，那它就是幂等的。一旦我们委派通过的所有调度程序，在通往最终结果的路径上，都有了自己的发言权，就会发出守卫。\u003c/p\u003e\n\u003cp\u003e有趣的是：特别细心的人会注意到，调度机制也被用作实现新的调度程序的一部分，事实上，这最终也将意味着特殊化者可以将调度程序特殊化，让它们也被 JIT 编译成更高效的东西。毕竟，从 MoarVM 的角度来看，这一切都只是要运行的字节码，只是有些字节码是告诉 VM 如何更高效地执行 Raku 程序的!\u003c/p\u003e\n\u003ch2 id=\"恢复调度\"\u003e恢复调度\u003c/h2\u003e\n\u003cp\u003e可恢复调度器需要做两件事。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在注册调度器的时候，提供一个恢复回调和一个调度回调。\u003c/li\u003e\n\u003cli\u003e在 dispatch 回调中，指定一个捕获，这将形成恢复初始化状态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当发生恢复时，将调用恢复回调，并提供恢复的任何参数。它还可以获得在 dispatch 回调中设置的 resume 初始化状态。resume 初始化状态包含了第一次恢复调度时继续进行调度所需要的东西。我们先来看看方法调度的工作原理，看一个具体的例子。我也会在此时，切换到看真正的 Rakudo 调度器，而不是简化的测试用例。\u003c/p\u003e\n\u003cp\u003eRakudo 调度器利用授权、重复守卫和捕获操作都没有运行时成本的优势，在结果调度程序中，至少在我看来，很好地因素了一个有些复杂的调度过程。方法调度有多个切入点：普通无聊的 \u003ccode\u003e$obj.meth()\u003c/code\u003e，限定的 \u003ccode\u003e$obj.Type::meth()\u003c/code\u003e，以及调用我也许 \u003ccode\u003e$obj.?meth()\u003c/code\u003e。这些都有共同的 resume 语义 - 或者至少，只要我们在 resume 初始化状态中始终携带一个起始类型，也就是我们做方法调度的对象的类型，就可以使它们成为。\u003c/p\u003e\n\u003cp\u003e这里是普通方法调度的切入点，去掉了报告缺失方法错误的无聊细节。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# A standard method call of the form $obj.meth($arg); also used for the\n# indirect form $obj.\u0026quot;$name\u0026quot;($arg). It receives the decontainerized invocant,\n# the method name, and the the args (starting with the invocant including any\n# container).\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call', -\u0026gt; $capture {\n    # Try to resolve the method call using the MOP.\n    my $obj := nqp::captureposarg($capture, 0);\n    my str $name := nqp::captureposarg_s($capture, 1);\n    my $meth := $obj.HOW.find_method($obj, $name);\n \n    # Report an error if there is no such method.\n    unless nqp::isconcrete($meth) {\n        !!! 'Error reporting logic elided for brevity';\n    }\n \n    # Establish a guard on the invocant type and method name (however the name\n    # may well be a literal, in which case this is free).\n    nqp::dispatch('boot-syscall', 'dispatcher-guard-type',\n        nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0));\n    nqp::dispatch('boot-syscall', 'dispatcher-guard-literal',\n        nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 1));\n \n    # Add the resolved method and delegate to the resolved method dispatcher.\n    my $capture-delegate := nqp::dispatch('boot-syscall',\n        'dispatcher-insert-arg-literal-obj', $capture, 0, $meth);\n    nqp::dispatch('boot-syscall', 'dispatcher-delegate',\n        'raku-meth-call-resolved', $capture-delegate);\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在是解析方法 dispatcher，也就是处理恢复的地方。首先，让我们看看正常的 dispatch 回调（恢复回调是包含的，但是是空的，我稍后会展示它）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Resolved method call dispatcher. This is used to call a method, once we have\n# already resolved it to a callee. Its first arg is the callee, the second and\n# third are the type and name (used in deferral), and the rest are the args to\n# the method.\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call-resolved',\n    # Initial dispatch\n    -\u0026gt; $capture {\n        # Save dispatch state for resumption. We don't need the method that will\n        # be called now, so drop it.\n        my $resume-capture := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg',\n            $capture, 0);\n        nqp::dispatch('boot-syscall', 'dispatcher-set-resume-init-args', $resume-capture);\n \n        # Drop the dispatch start type and name, and delegate to multi-dispatch or\n        # just invoke if it's single dispatch.\n        my $delegate_capture := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg',\n            nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $capture, 1), 1);\n        my $method := nqp::captureposarg($delegate_capture, 0);\n        if nqp::istype($method, Routine) \u0026amp;\u0026amp; $method.is_dispatcher {\n            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi', $delegate_capture);\n        }\n        else {\n            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke', $delegate_capture);\n        }\n    },\n    # Resumption\n    -\u0026gt; $capture {\n        ... 'Will be shown later';\n    });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eraku-meth-call 中有一个可以论证的欺骗：它实际上并没有插入调用者的类型对象来代替调用者。事实证明，这并不重要。否则，我认为注释（在真正的实现中也可以找到）很好地说明了这个问题。\u003c/p\u003e\n\u003cp\u003e有一个重要的点可能并不清楚 - 但遵循了一个重复的主题 - 那就是恢复初始化状态的设置也更多的是一种声明式而不是命令式的东西：在调度的时候并没有运行时成本，而是我们在周围保留了足够的信息，以便能够在我们需要的时候重建恢复初始化状态。事实上，当我们处于恢复的运行阶段时，我们甚至不需要在创建捕获对象的意义上重建它）。\u003c/p\u003e\n\u003cp\u003e现在说说复盘。我将介绍一个严重简化的版本，它只处理 callsame 语义（完整的东西也要处理 lastcall 和 nextcallee 这样的乐趣）。resume 初始化状态的存在是为了给 resumption 过程播种。一旦我们知道我们实际上确实要处理恢复，我们就可以做一些事情，比如计算我们想要走过的继承图中的全部方法列表。每个可恢复的调度器在调用栈上得到一个单一的存储槽，它可以用于它的状态。它可以在恢复的第一步中初始化这个，然后在我们走的时候更新它。或者更准确的说，它可以设置一个调度程序，在运行时就会这样做。\u003c/p\u003e\n\u003cp\u003e对于我们将要走过的候选链来说，链接列表原来是一个非常方便的数据结构。我们可以通过跟踪当前节点来完成链接列表的工作，也就是说只需要有一个东西发生突变，也就是当前调度的状态。调度程序机制还提供了一种从对象中读取属性的方法，这就足以将遍历链接列表表达到调度程序中。这也意味着零分配。\u003c/p\u003e\n\u003cp\u003e所以，不多说了，下面是链接列表（在 NQP 这个受限的 Raku 子集中，相当不如在完整的 Raku 中漂亮）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# A linked list is used to model the state of a dispatch that is deferring\n# through a set of methods, multi candidates, or wrappers. The Exhausted class\n# is used as a sentinel for the end of the chain. The current state of the\n# dispatch points into the linked list at the appropriate point; the chain\n# itself is immutable, and shared over (runtime) dispatches.\nmy class DeferralChain {\n    has $!code;\n    has $!next;\n    method new($code, $next) {\n        my $obj := nqp::create(self);\n        nqp::bindattr($obj, DeferralChain, '$!code', $code);\n        nqp::bindattr($obj, DeferralChain, '$!next', $next);\n        $obj\n    }\n    method code() { $!code }\n    method next() { $!next }\n};\nmy class Exhausted {};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后是恢复处理。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003enqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call-resolved',\n    # Initial dispatch\n    -\u0026gt; $capture {\n        ... 'Presented earlier;\n    },\n    # Resumption. The resume init capture's first two arguments are the type\n    # that we initially did a method dispatch against and the method name\n    # respectively.\n    -\u0026gt; $capture {\n        # Work out the next method to call, if any. This depends on if we have\n        # an existing dispatch state (that is, a method deferral is already in\n        # progress).\n        my $init := nqp::dispatch('boot-syscall', 'dispatcher-get-resume-init-args');\n        my $state := nqp::dispatch('boot-syscall', 'dispatcher-get-resume-state');\n        my $next_method;\n        if nqp::isnull($state) {\n            # No state, so just starting the resumption. Guard on the\n            # invocant type and name.\n            my $track_start_type := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $init, 0);\n            nqp::dispatch('boot-syscall', 'dispatcher-guard-type', $track_start_type);\n            my $track_name := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $init, 1);\n            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_name);\n \n            # Also guard on there being no dispatch state.\n            my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state');\n            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_state);\n \n            # Build up the list of methods to defer through.\n            my $start_type := nqp::captureposarg($init, 0);\n            my str $name := nqp::captureposarg_s($init, 1);\n            my @mro := nqp::can($start_type.HOW, 'mro_unhidden')\n                ?? $start_type.HOW.mro_unhidden($start_type)\n                !! $start_type.HOW.mro($start_type);\n            my @methods;\n            for @mro {\n                my %mt := nqp::hllize($_.HOW.method_table($_));\n                if nqp::existskey(%mt, $name) {\n                    @methods.push(%mt{$name});\n                }\n            }\n \n            # If there's nothing to defer to, we'll evaluate to Nil (just don't set\n            # the next method, and it happens below).\n            if nqp::elems(@methods) \u0026gt;= 2 {\n                # We can defer. Populate next method.\n                @methods.shift; # Discard the first one, which we initially called\n                $next_method := @methods.shift; # The immediate next one\n \n                # Build chain of further methods and set it as the state.\n                my $chain := Exhausted;\n                while @methods {\n                    $chain := DeferralChain.new(@methods.pop, $chain);\n                }\n                nqp::dispatch('boot-syscall', 'dispatcher-set-resume-state-literal', $chain);\n            }\n        }\n        elsif !nqp::istype($state, Exhausted) {\n            # Already working through a chain of method deferrals. Obtain\n            # the tracking object for the dispatch state, and guard against\n            # the next code object to run.\n            my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state');\n            my $track_method := nqp::dispatch('boot-syscall', 'dispatcher-track-attr',\n                $track_state, DeferralChain, '$!code');\n            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_method);\n \n            # Update dispatch state to point to next method.\n            my $track_next := nqp::dispatch('boot-syscall', 'dispatcher-track-attr',\n                $track_state, DeferralChain, '$!next');\n            nqp::dispatch('boot-syscall', 'dispatcher-set-resume-state', $track_next);\n \n            # Set next method, which we shall defer to.\n            $next_method := $state.code;\n        }\n        else {\n            # Dispatch already exhausted; guard on that and fall through to returning\n            # Nil.\n            my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state');\n            nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_state);\n        }\n \n        # If we found a next method...\n        if nqp::isconcrete($next_method) {\n            # Call with same (that is, original) arguments. Invoke with those.\n            # We drop the first two arguments (which are only there for the\n            # resumption), add the code object to invoke, and then leave it\n            # to the invoke or multi dispatcher.\n            my $just_args := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg',\n                nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $init, 0),\n                0);\n            my $delegate_capture := nqp::dispatch('boot-syscall',\n                'dispatcher-insert-arg-literal-obj', $just_args, 0, $next_method);\n            if nqp::istype($next_method, Routine) \u0026amp;\u0026amp; $next_method.is_dispatcher {\n                nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi',\n                        $delegate_capture);\n            }\n            else {\n                nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke',\n                        $delegate_capture);\n            }\n        }\n        else {\n            # No method, so evaluate to Nil (boot-constant disregards all but\n            # the first argument).\n            nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant',\n                nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj',\n                    $capture, 0, Nil));\n        }\n    });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这是相当多的内容，也是相当多的代码。但请记住，这只是运行在调度恢复的记录阶段。它还会在 callsame 的 callsite 产生一个调度程序，并带有通常的守卫和结果。隐式守卫是为我们在该点恢复的调度程序创建的。在最常见的情况下，这最终将是单形或双形的，尽管涉及多个调度或方法调度的嵌套的情况可能会产生一个更有形态的 callsite。\u003c/p\u003e\n\u003cp\u003e我选取的设计迫使 resume 回调处理两种情况：第一次复用和后一次复用。这在几个方面都不理想。\u003c/p\u003e\n\u003cp\u003e这对那些编写调度简历回调的人来说有点不方便。然而，这又不是特别常见的活动!\u003c/p\u003e\n\u003cp\u003e这种差异导致两个调度程序堆积在一个调用点，而在其他情况下，这个调用点可能只得到一个\n只有其中第二项真正重要。之所以不统一，是为了确保绝大多数从未恢复调度的电话，不会因其最终从未使用的功能而产生每次调度的费用。如果结果是使用该功能的人多花了一点成本，那就这样吧。事实上，早期的基准测试显示，使用新调度器的 callsame 与 wrap 和方法调用似乎比当前 Rakudo 中的速度快了 10 倍，这还没等专门人员对它有足够的了解，就已经进一步改进了!\u003c/p\u003e\n\u003ch2 id=\"目前所做的事情\"\u003e目前所做的事情\u003c/h2\u003e\n\u003cp\u003e我上面讨论的所有内容都已经实现了，只是我可能在某个地方给人的印象是，使用新的 dispatcher 已经完全实现了多重调度，而现在还不是这样（没有处理 where 子句，也不支持调度恢复）。\u003c/p\u003e\n\u003ch2 id=\"今后的步骤\"\u003e今后的步骤\u003c/h2\u003e\n\u003cp\u003e下一步显然是要完全实现多调度的缺失部分。另一个缺失的语义是对 callwith 和 nextwith 的支持，当我们希望改变移动到下一个候选人时使用的参数。抛开其他一些小问题不谈，理论上来说，这至少可以让所有的 Raku 调度语义得到支持。\u003c/p\u003e\n\u003cp\u003e目前，所有的标准方法调用（$obj.meth()）和其他调用（foo()和$foo()）都会通过现有的调度机制，而不是新的调度器。这些也需要迁移到新的调度器上，而且任何发现的错误都需要修复。这将使事情达到新调度器在语义上已经准备好的程度。\u003c/p\u003e\n\u003cp\u003e之后是性能工作：确保专用器能够处理调度程序的防护和结果。最初的目标是，让常见调用形式的稳态性能至少与当前乐道主分支中的性能相同。已经很清楚了，对于一些到目前为止还很冰冷的东西来说，会有一些大的胜利，但它不应该以最常见的调度种类的退步为代价，因为这些调度种类之前已经得到了大量的优化努力。\u003c/p\u003e\n\u003cp\u003e此外，NQP - 乐道编译器和运行时内脏的其他位写的乐的限制形式 - 也需要迁移到使用新的调度器。只有做到这一点，才有可能从 MoarVM 中扯出当前的方法缓存、多调度缓存等。\u003c/p\u003e\n\u003cp\u003e一个悬而未决的问题是，如何处理 MoarVM 以外的后端。理想情况下，新的调度机制将被移植到这些地方。相当多的内容应该可以用 JVM 的 invokedynamic 来表达（而这一切可能会在基于 Truffle 的 Raku 实现中发挥得相当好，尽管我不确定目前是否有这方面的积极努力）。\u003c/p\u003e\n\u003ch2 id=\"未来的机会\"\u003e未来的机会\u003c/h2\u003e\n\u003cp\u003e虽然我目前的重点是发布一个使用新调度机制的 Rakudo 和 MoarVM 版本，但这不会是旅程的终点。一些眼前的想法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对角色的方法调用需要把角色打入一个类中， 所以方法查找会返回一个闭包来完成这个任务并替换调用者。这是一个很大的间接性；新的调度者可以获得 pun，并产生一个调度程序，用 punn 化的类类型对象替换角色类型对象，这将使每次调用的成本大大降低。\u003c/li\u003e\n\u003cli\u003e我期望使用新的 dispatcher 可以使句柄（dlegated）和 fallback（处理缺失的方法调用）机制都能有更好的表现\u003c/li\u003e\n\u003cli\u003e当前的 assuming - 用于为例程讨价还价或其他首要参数 - 的实现并不理想，利用新调度器的参数重写能力的实现可能会有更好的表现。\n在新的调度机制的帮助下，一些新的语言功能也可能以高效的方式提供。例如，目前没有一种可靠的方式来尝试调用一段代码，如果签名绑定了就运行它，如果没有绑定就做其他事情。相反，像 Cro 路由器这样的东西，必须先做签名的试绑定，然后再做调用，这使得路由的成本相当高。还有一个建议已久的想法，就是通过签名与 \u003ccode\u003ewhen\u003c/code\u003e 构造提供模式匹配 (例如，\u003ccode\u003ewhen * -\u0026gt; ($x) {}; when * -\u0026gt; ($x, *@tail) { }\u003c/code\u003e)，这和需求差不多，只是在一个不太动态的环境下。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"最后\"\u003e最后\u0026hellip;\u003c/h2\u003e\n\u003cp\u003e在新的调度机制上的工作比我最初预期的历程要长。设计的恢复部分特别具有挑战性，而且还有一些重要的细节需要处理。一路走来，大概有四种潜在的方法被抛弃了（虽然其中的元素都影响了我在这篇文章中描述的内容）。能坚持下来的抽象真的非常非常难。\u003c/p\u003e\n\u003cp\u003e我最终也不得不从根本上离开几个月做 Raku 工作，在其他一些工作中感觉有点被压垮了，并且一直在与同样重要的 RakuAST 项目（它将因为能够承担新的调度器的存在而被简化，并且还为我提供了一系列更柔和的 Raku 黑客任务，而调度器的工作提供了很少的轻松选择）。\u003c/p\u003e\n\u003cp\u003e鉴于这些，我很高兴终于看到了隧道尽头的光亮。剩下的工作是数不胜数的，而我们使用新的调度器发布 Rakudo 和 MoarVM 的那一天，感觉还需要几个月的时间（我希望写下这句话不是在诱惑命运！）。\u003c/p\u003e\n\u003cp\u003e新的调度器可能是 MoarVM 自我创建以来最重要的变化，因为它看到我们删除了一堆从一开始就存在的东西。RakuAST 也将为 Rakudo 编译器带来十年来最大的架构变化。两者都是一个机会，将多年来学习的东西硬生生地折合到运行时和编译器中。我希望再过十年，当我回顾这一切的时候，至少会觉得自己这次犯了更多有趣的错误。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/\"\u003ehttps://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/\u003c/a\u003e\u003c/p\u003e\n","text":"我的天啊，看来我是两年多来第一次写 Raku 内部的博文了。当然，两年前还不叫 Raku。总之，话不多说，继续说说这个共同的脑洞吧。\n什么是调度？ 我用 \u0026ldquo;dispatch\u0026rdquo; 来表示我们接受一组参数，最后根据这些参数采取一些行动的过程。一些熟悉的例子包括:\n  进行一个方法调用，比如 $basket.add($product, $quantity)。传统上，我们可能只调用 $product 和 $qauntity 作为参数，但就我的目的而言，所有的 $basket、方法名 \u0026ldquo;add\u0026rdquo;、$product 和 $quantity 都是 dispatch 的参数：它们是我们需要的东西，以便决定我们要做什么。\n  进行子程序调用，如 uc($youtube-comment)。由于 Raku sub 调用是词法解析的，所以在这种情况下，调度的参数是 \u0026amp;uc（查找子程序的结果）和 $youtube-comment。\n  调用多个调度子程序或方法，根据参数的数量和类型来决定调用一组候选程序中的哪一个。这个过程可以看作是发生在上述两个调度中的一个 \u0026ldquo;内部\u0026rdquo;，因为我们在 Raku 中既有多重调度子程序，也有方法。\n  乍一看，也许前两个看起来相当简单，第三个就有点手忙脚乱了 - 这也算是事实。然而，Raku 还有一些其他的特性，使得调度变得相当，嗯，有趣。例如：\n  wrap 允许我们包装任何 Routine (sub 或方法); 包装器可以选择用原来的参数或新的参数来服从原来的例程。\n  当进行多重调度时，我们可以写一个原型例程，让它选择何时 - 甚至是否 - 调用合适的候选者。\n  我们可以使用 callsame 这样的例程，以便在调度中推迟到下一个候选者。但这意味着什么呢？如果我们是在一个多重调度中，它意味着下一个最适用的候选者，如果有的话。如果我们是在一个方法调度中，那么它意味着一个基类的方法。(同样的事情也被用来实现去下一个封装者，或者，最终也是去最初封装的例程)。而且这些都可以结合起来：我们可以包装一个 multi 方法，这意味着我们可以有 3 个层次的东西，都有可能贡献下一个要调用的东西!\n  多亏了这一点，dispatch - 至少在 Raku 中 - 并不总是我们所做的事情并产生一个结果，而是一个可能会被要求继续多次进行的过程!\n最后，虽然我上面所写的例子都可以很清楚地看成是调度的例子，但在 Raku 中，其他一些常见的构造也可以表达为一种调度。分配是一个例子：它的语义取决于分配的目标和被分配的值，因此我们需要选择正确的语义。强制类型转换(Coercion)是另一个例子，返回值类型检查又是一个例子。\n为什么调度很重要？ Dispatch 在我们的程序中无处不在，它悄悄地把想做事情的代码和做事情的代码联系在一起。它的无处不在意味着它在程序性能中扮演着重要的角色。在最好的情况下，我们可以将成本降为零。在最坏的情况下，调度的成本高到足以超过作为调度结果的工作的成本。\n初步估计，当运行时\u0026quot;理解\u0026quot;调度时，性能至少会有些不错，但当运行时不理解时，很有可能会很糟糕。调度往往涉及到一个可以缓存的工作量，往往会有一些廉价的防护措施来验证缓存结果的有效性。例如，在方法调度中，天真地我们需要走一个线性化的继承图，并询问沿途遇到的每个类是否有指定名称的方法。显然，如果我们在每次方法调用时都这样做，速度不会非常快。然而，特定类型上的特定方法名（精确识别，不考虑子类）每次都会解析到同一个方法。因此，我们可以缓存查找的结果，只要调用者的类型与用于产生缓存结果的类型相匹配，就可以使用它。\n语言运行时的专门化与通用化机制 当一个人开始构建一个针对特定语言的运行时，并且必须在相当紧张的预算下完成时，要想获得某种可容忍的性能，最明显的方法就是将各种热路径语言语义烘焙到运行时中。这正是 MoarVM 的起步方式。因此，如果我们看看 MoarVM 几年前的样子，我们会发现这样的事情。\n 对方法缓存的一些支持 一个与 Raku 的多重调度语义高度绑定的多重调度缓存，只有在调度都是名义类型的时候才真正能够起到帮助作用（所以使用 where 的代价非常高）。 一种机制，用于指定如何在封装代码对象内部找到实际的代码句柄（例如，Sub 对象有一个私有属性，它持有识别要运行的字节码的低级代码句柄）。 一些有限的尝试，让我们能够在知道一个调度不会继续的情况下正确地进行优化 - 这需要编译器和运行时之间的谨慎合作（或者不那么外交地讲，这都是一个大黑客）。  这些今天都还在，然而也都在淘汰的路上。这个榜单最能说明问题的是什么，不包括在内。比如：\n 私有方法调用，需要不同的缓存 但最初的虚拟机设计限制了每一种类型的调用 合格的方法调用($obj.SomeType::method-name()) 体面优化调度恢复的方法  几年前，我开始部分解决这个问题，引入了一种机制，我称之为 \u0026ldquo;specializer 插件\u0026rdquo;。但首先，什么是特化器(specializer)？\nMoarVM 刚开始的时候，它是一个比较简单的字节码解释器。它只需要足够快的速度击败 Parrot VM 就可以获得相当的使用量，我认为在继续实现一些更有趣的优化之前，这一点非常重要（当时我们还没有今天这样的发布前自动测试基础设施，因此更多的是依赖于早期采用者的反馈）。总之，在能够像其他后端一样运行 Raku 语言后不久，我就开始了动态优化器的开发。它在程序被解释时收集类型统计，识别热代码，将其放入 SSA 形式，使用类型统计插入防护，将这些与字节码的静态属性一起使用来分析和优化，并为相关函数生成专门的字节码。这个字节码可以省略类型检查和各种查找，也可以使用一系列的内部操作，做出各种假设，由于优化器证明了程序的属性，这些假设是安全的。这被称为专门化的字节码，因为它的很多通用性 - 这将使它能够正确地工作在我们可能遇到的所有类型的值上 - 被删除了，转而工作在运行时实际发生的特殊情况下。(代码，尤其是动态语言中的代码，一般来说，理论上的通用性远远大于实践中的通用性。)\n这个组件 - 内部称为 \u0026ldquo;spesh\u0026rdquo; 的 specializer - 为 Raku 程序的性能带来了显著的进一步提升，随着时间的推移，它的复杂程度也在不断提高，并采用了内联和带有标量替换的转义分析等优化功能。这些并不是容易构建的东西 - 但一旦运行时拥有了它们，它们就会创造出以前不存在的设计可能性，并使在没有它们的情况下做出的决定看起来是次优的。\n值得注意的是，那些特殊情况下的语言特定机制，在早期为了获得一些速度而被嵌入到运行时中，反而成为了一种负担和瓶颈。它们具有复杂的语义，这意味着它们对优化器来说要么是不透明的（所以优化器无法对它们进行推理，意味着优化受到抑制），要么就是需要在优化器中进行特殊的封装（一种负担）。\n所以，回到 specializer 插件。我到了一个地步，我想承担像 $obj.?meth(\u0026quot;call me maybe\u0026quot;, dispatch)、$obj.SomeType::meth()(用类开始寻找的调度限定)，以及角色中的私有方法调用(不能静态解析)这样的性能。同时，我还准备实现一定量的转义分析，但意识到它的作用将非常有限，因为赋值在虚拟机中也被特例化了，有一大块不透明的 C 代码在做热路径的事情。\n但为什么我们要让 C 代码来做那些热路径的事情呢？嗯，因为让每个赋值都调用一个虚拟机级别的函数，做一堆检查和逻辑，花费太大了。为什么这样做成本很高？因为函数调用的开销和解释的成本。这在以前都是正确的。但是，若干年后的发展。\n 内联被实现了，并且可以消除做一个函数调用的开销。 我们可以编译成机器代码，消除解释开销。 我们当时的处境是，我们手头有 specializer 的类型信息，可以让我们消除 C 代码中的分支，但由于我们调用的只是一个不透明的函数，所以没有办法抓住这个机会  我解决了上面提到的分配问题和调度问题，引入了一个新的机制：specializer 插件。它们的工作原理如下。\n 当我们第一次到达字节码中的一个给定的调用点时，我们就会运行这个插件。它产生了一个要调用的代码对象，以及一组守卫（为了使用该代码对象结果而必须满足的条件）。 下一次到达时，我们检查是否满足守卫，如果满足，就用结果 如果没有，我们再运行一次插件，并在 callsite 处堆积一个防护集。 我们统计了一个给定的防护集成功的频率，然后将其用于 specializer  绝大多数情况下都是单态的，这意味着只产生一组守卫，而且之后总是成功的。因此，特殊化器可以将这些守卫编译到专门的字节码中，然后假设给定的目标调用者就是将被调用的守卫。(进一步，重复的守卫可以被消除，所以某个插件引入的守卫可能会减少到零)。\nSpecializer 插件感觉挺好的。一个新机制解决了多个优化头疼的问题。\n新的 MoarVM 调度机制是对一个相当简单的问题的回答：如果我们把所有与调度相关的特例机制去掉，而采用有点像 specializer 插件的机制，会怎么样？由此产生的机制需要是一个比 specializer 插件更强大的机制。进一步说，我可以学习特殊器插件的一些缺点。因此，虽然它们会在比较短的寿命后消失，但我认为可以说，如果没有这些经验，我就不会有能力设计新的 MoarVM 调度机制。\n调度操作和引导调度器 所有的方法缓存。所有的多重调度缓存。所有的 specializer 插件。所有用于在代码对象中解包字节码句柄的调用协议的东西。这一切都将被取消，取而代之的是一个新的调度指令。它的名字很无聊，叫 dispatch。它看起来像这样。\ndispatch_o result, 'dispatcher-name', callsite, arg0, arg1, ..., argN 这意味着：\n 使用名为 dispatcher-name 的调度器。 给它指定的参数寄存器（所引用的调用点表示参数的数量）。 将调度的对象结果放入寄存器结果中。  (旁白：这意味着一个新的调用约定，即我们不再将参数复制到参数缓冲区，而是将寄存器集的基数和一个指针传递到找到寄存器参数映射的字节码中，然后做一个查询 registers[map[argument_index]] 来获取一个参数的值。仅此一点，我们在解释时就很省事，因为我们不再需要每个参数绕着解释器循环了）。)\n有些参数可能是我们传统上称之为参数的东西。有些则是针对调度过程本身。这其实并不重要 - 但如果我们安排将只针对调度的参数放在前面（例如，方法名），而将针对调度目标的参数放在后面（例如，方法参数），则会更加理想。\n新的 bootstrap 机制提供了少量的内置调度器，它们的名字以 \u0026ldquo;boot-\u0026rdquo; 开头。它们是：\n boot-value - 取第一个参数并将其作为结果（身份函数，除了丢弃任何其他参数）。 boot-constant - 取第一个参数并将其作为结果，但同时也将其视为一个将始终产生的常量值（因此意味着优化器可以将任何用于计算该值的纯代码视为死值）。 boot-code - 取第一个参数（必须是虚拟机字节码句柄），并运行该字节码，将其余参数作为参数传给它；评估为字节码的返回值。 boot-syscall - 将第一个参数视为虚拟机提供的内置操作的名称，然后调用它，并将其余参数作为其参数。 boot-resume - 恢复正在进行的最上层调度。  差不多就是这样。我们构建的每一个调度器，为了教给运行时一些其他的调度行为，最终都会终止于其中一个。\n在引导程序的基础上 教 MoarVM 了解不同种类的调度，不外乎使用调度机制本身! 在大多数情况下，boot-syscall 被用来注册一个调度器，设置守卫，并提供与它们相匹配的结果。\n这里是一个最小的例子，取自 dispatcher 测试套件，展示了一个提供同一性功能的 dispatcher 的样子。\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'identity', -\u0026gt; $capture { nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-value', $capture); }); sub identity($x) { nqp::dispatch('identity', $x) } ok(identity(42) == 42, 'Can define identity dispatch (1)'); ok(identity('foo') eq 'foo', 'Can define identity dispatch (2)'); 在第一条语句中，我们调用 dispatcher-register MoarVM 系统调用，传递一个 dispatcher 的名称以及一个闭包，每次我们需要处理调度时，都会调用这个闭包（我倾向于将其称为\u0026quot;调度回调\u0026quot;）。它接收一个单一的参数，这是一个参数的捕获（其实不是 Raku 级别的捕获，但想法 - 一个包含一组调用参数的对象 - 是一样的）。\n每一个用户定义的调度器最终都应该使用 dispatcher-delegate，以便确定另一个调度器将控制权传递给它。在这种情况下，它立即委托给 boot-value - 这意味着它除了是 boot-value 内置调度器的包装器外，其实什么都不是。\nsub identity 包含一个调度操作的静态出现。鉴于我们两次调用 sub，我们在运行时将两次遇到这个 op，但这两次是非常不同的。\n第一次是 \u0026ldquo;记录\u0026rdquo; 阶段。参数形成一个捕获，回调运行，回调又将其传给引导值调度器，产生结果。这样就形成了一个极其简单的调度程序，它说结果应该是捕获中的第一个参数。由于没有守卫，所以这将永远是一个有效的结果。\n第二次遇到调度操作时，它那里已经记录了一个调度程序，所以我们处于运行模式。在 MoarVM 源码中开启调试模式，我们可以看到结果的调度程序是这样的。\nDispatch program (1 temporaries) Ops: Load argument 0 into temporary 0 Set result object value from temporary 0 也就是说，它将参数 0 读入一个临时位置，然后将其设置为调度的结果。请注意，没有提到我们经过了额外的一层调度，这些在结果调度程序中的成本为零。\n捕获操作 参数捕获是不可改变的。各种虚拟机系统调用的存在，可以通过一些调整将它们转化为新的参数捕获，例如删除或插入参数。这里还有一个测试套件的例子。\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'drop-first', -\u0026gt; $capture { my $capture-derived := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $capture, 0); nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-value', $capture-derived); }); ok(nqp::dispatch('drop-first', 'first', 'second') eq 'second', 'dispatcher-drop-arg works'); 这就在将捕获传递给引导值调度器之前丢弃了第一个参数 - 意味着它将返回第二个参数。回头看一下之前的身份函数的调度程序。你能猜到这个程序会是什么样子吗？\n好吧，就是这样。\nDispatch program (1 temporaries) Ops: Load argument 1 into temporary 0 Set result string value from temporary 0 同样，虽然在这样一个调度器的记录阶段，我们确实是创建了捕获对象，并做了一个调度器代理，但由此产生的调度程序要简单得多。\n下面是一个稍微复杂一点的例子。\nmy $target := -\u0026gt; $x { $x + 1 } nqp::dispatch('boot-syscall', 'dispatcher-register', 'call-on-target', -\u0026gt; $capture { my $capture-derived := nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj', $capture, 0, $target); nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-code-constant', $capture-derived); }); sub cot() { nqp::dispatch('call-on-target', 49) } ok(cot() == 50, 'dispatcher-insert-arg-literal-obj works at start of capture'); ok(cot() == 50, 'dispatcher-insert-arg-literal-obj works at start of capture after link too'); 这里，我们有一个存储在变量 $target 中的闭包。我们把它作为捕获的第一个参数插入，然后委托给 boot-code-constant，它将调用那个代码对象，并把其他调度参数传递给它。再次，在记录阶段，我们真正要做的事情是这样的。\n 创建一个新的捕获 在开始的时候插入一个代码对象。 委托给引导代码常量分配器，它\u0026hellip;。 \u0026hellip;在没有原始参数的情况下创建一个新的捕获，并使用这些参数运行字节码。  由此产生的调度程序呢？就是这个\nDispatch program (1 temporaries) Ops: Load collectable constant at index 0 into temporary 0 Skip first 0 args of incoming capture; callsite from 0 Invoke MVMCode in temporary 0 也就是说，加载我们要调用的常量字节码句柄，设置 args（在本例中等于传入捕获的参数），然后用这些参数调用字节码。参数的洗牌，又一次消失了。一般来说，只要我们做最终的字节码调用的参数是初始调度参数的尾巴，参数转换就会变得不过是一个指针的添加。\n守卫 目前看到的所有调度方案都是无条件的：一旦在某一通话地点记录下来，就应一直使用。要使这样的机制具有实用性，缺少的一大块就是守卫。守卫断言了一些属性，比如参数的类型或者参数是确定的（Int:D）还是不确定的（Int:U）。\n下面是一个有点长的测试用例，并在其中放置了一些解释。\n# A couple of classes for test purposes my class C1 { } my class C2 { } # A counter used to make sure we're only invokving the dispatch callback as # many times as we expect. my $count := 0; # A type-name dispatcher that maps a type into a constant string value that # is its name. This isn't terribly useful, but it is a decent small example. nqp::dispatch('boot-syscall', 'dispatcher-register', 'type-name', -\u0026gt; $capture { # Bump the counter, just for testing purposes. $count++; # Obtain the value of the argument from the capture (using an existing # MoarVM op, though in the future this may go away in place of a syscall) # and then obtain the string typename also. my $arg-val := nqp::captureposarg($capture, 0); my str $name := $arg-val.HOW.name($arg-val); # This outcome is only going to be valid for a particular type. We track # the argument (which gives us an object back that we can use to guard # it) and then add the type guard. my $arg := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0); nqp::dispatch('boot-syscall', 'dispatcher-guard-type', $arg); # Finally, insert the type name at the start of the capture and then # delegate to the boot-constant dispatcher. nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant', nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-str', $capture, 0, $name)); }); # A use of the dispatch for the tests. Put into a sub so there's a single # static dispatch op, which all dispatch programs will hang off. sub type-name($obj) { nqp::dispatch('type-name', $obj) } # Check with the first type, making sure the guard matches when it should # (although this test would pass if the guard were ignored too). ok(type-name(C1) eq 'C1', 'Dispatcher setting guard works'); ok($count == 1, 'Dispatch callback ran once'); ok(type-name(C1) eq 'C1', 'Can use it another time with the same type'); ok($count == 1, 'Dispatch callback was not run again'); # Test it with a second type, both record and run modes. This ensures the # guard really is being checked. ok(type-name(C2) eq 'C2', 'Can handle polymorphic sites when guard fails'); ok($count == 2, 'Dispatch callback ran a second time for new type'); ok(type-name(C2) eq 'C2', 'Second call with new type works'); # Check that we can use it with the original type too, and it has stacked # the dispatch programs up at the same callsite. ok(type-name(C1) eq 'C1', 'Call with original type still works'); ok($count == 2, 'Dispatch callback only ran a total of 2 times'); 这个时候就会产生两个调度程序，一个是 C1。\nDispatch program (1 temporaries) Ops: Guard arg 0 (type=C1) Load collectable constant at index 1 into temporary 0 Set result string value from temporary 0 另一个是 C2:\nDispatch program (1 temporaries) Ops: Guard arg 0 (type=C2) Load collectable constant at index 1 into temporary 0 Set result string value from temporary 0 再一次，没有捕获操作、跟踪或调度器委托的遗留问题；调度程序对一个参数进行类型防护，然后产生结果字符串。整个对 $arg-val.HOW.name($arg-val) 的调用都被省略了，我们写的调度程序将知识进行了编码 - 以虚拟机能够理解的方式 - 一个类型的名称可以被认为是不可改变的。\n这个例子有点造作，但现在考虑一下，我们反而要查找一个方法，并在调用者类型上进行守卫：这就是一个方法缓存! 守护更多参数的类型，我们就有了一个多缓存。两者都做，我们就有了一个多方法缓存。\n后者很有意思，因为方法调度和多调度都想对调用者进行守护。事实上，在 MoarVM 中，今天会有两个这样的类型测试，直到我们到了特殊化器做工作并消除这些重复的守卫。然而，新的调度器并没有将调度器 - guard-类型当作一种命令式操作，将守卫写入结果调度程序中。相反，它声明相关的参数必须被防护。如果其他的调度器已经这样做了，那它就是幂等的。一旦我们委派通过的所有调度程序，在通往最终结果的路径上，都有了自己的发言权，就会发出守卫。\n有趣的是：特别细心的人会注意到，调度机制也被用作实现新的调度程序的一部分，事实上，这最终也将意味着特殊化者可以将调度程序特殊化，让它们也被 JIT 编译成更高效的东西。毕竟，从 MoarVM 的角度来看，这一切都只是要运行的字节码，只是有些字节码是告诉 VM 如何更高效地执行 Raku 程序的!\n恢复调度 可恢复调度器需要做两件事。\n 在注册调度器的时候，提供一个恢复回调和一个调度回调。 在 dispatch 回调中，指定一个捕获，这将形成恢复初始化状态。  当发生恢复时，将调用恢复回调，并提供恢复的任何参数。它还可以获得在 dispatch 回调中设置的 resume 初始化状态。resume 初始化状态包含了第一次恢复调度时继续进行调度所需要的东西。我们先来看看方法调度的工作原理，看一个具体的例子。我也会在此时，切换到看真正的 Rakudo 调度器，而不是简化的测试用例。\nRakudo 调度器利用授权、重复守卫和捕获操作都没有运行时成本的优势，在结果调度程序中，至少在我看来，很好地因素了一个有些复杂的调度过程。方法调度有多个切入点：普通无聊的 $obj.meth()，限定的 $obj.Type::meth()，以及调用我也许 $obj.?meth()。这些都有共同的 resume 语义 - 或者至少，只要我们在 resume 初始化状态中始终携带一个起始类型，也就是我们做方法调度的对象的类型，就可以使它们成为。\n这里是普通方法调度的切入点，去掉了报告缺失方法错误的无聊细节。\n# A standard method call of the form $obj.meth($arg); also used for the # indirect form $obj.\u0026quot;$name\u0026quot;($arg). It receives the decontainerized invocant, # the method name, and the the args (starting with the invocant including any # container). nqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call', -\u0026gt; $capture { # Try to resolve the method call using the MOP. my $obj := nqp::captureposarg($capture, 0); my str $name := nqp::captureposarg_s($capture, 1); my $meth := $obj.HOW.find_method($obj, $name); # Report an error if there is no such method. unless nqp::isconcrete($meth) { !!! 'Error reporting logic elided for brevity'; } # Establish a guard on the invocant type and method name (however the name # may well be a literal, in which case this is free). nqp::dispatch('boot-syscall', 'dispatcher-guard-type', nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 0)); nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $capture, 1)); # Add the resolved method and delegate to the resolved method dispatcher. my $capture-delegate := nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj', $capture, 0, $meth); nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-meth-call-resolved', $capture-delegate); }); 现在是解析方法 dispatcher，也就是处理恢复的地方。首先，让我们看看正常的 dispatch 回调（恢复回调是包含的，但是是空的，我稍后会展示它）。\n# Resolved method call dispatcher. This is used to call a method, once we have # already resolved it to a callee. Its first arg is the callee, the second and # third are the type and name (used in deferral), and the rest are the args to # the method. nqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call-resolved', # Initial dispatch -\u0026gt; $capture { # Save dispatch state for resumption. We don't need the method that will # be called now, so drop it. my $resume-capture := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $capture, 0); nqp::dispatch('boot-syscall', 'dispatcher-set-resume-init-args', $resume-capture); # Drop the dispatch start type and name, and delegate to multi-dispatch or # just invoke if it's single dispatch. my $delegate_capture := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $capture, 1), 1); my $method := nqp::captureposarg($delegate_capture, 0); if nqp::istype($method, Routine) \u0026amp;\u0026amp; $method.is_dispatcher { nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi', $delegate_capture); } else { nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke', $delegate_capture); } }, # Resumption -\u0026gt; $capture { ... 'Will be shown later'; }); raku-meth-call 中有一个可以论证的欺骗：它实际上并没有插入调用者的类型对象来代替调用者。事实证明，这并不重要。否则，我认为注释（在真正的实现中也可以找到）很好地说明了这个问题。\n有一个重要的点可能并不清楚 - 但遵循了一个重复的主题 - 那就是恢复初始化状态的设置也更多的是一种声明式而不是命令式的东西：在调度的时候并没有运行时成本，而是我们在周围保留了足够的信息，以便能够在我们需要的时候重建恢复初始化状态。事实上，当我们处于恢复的运行阶段时，我们甚至不需要在创建捕获对象的意义上重建它）。\n现在说说复盘。我将介绍一个严重简化的版本，它只处理 callsame 语义（完整的东西也要处理 lastcall 和 nextcallee 这样的乐趣）。resume 初始化状态的存在是为了给 resumption 过程播种。一旦我们知道我们实际上确实要处理恢复，我们就可以做一些事情，比如计算我们想要走过的继承图中的全部方法列表。每个可恢复的调度器在调用栈上得到一个单一的存储槽，它可以用于它的状态。它可以在恢复的第一步中初始化这个，然后在我们走的时候更新它。或者更准确的说，它可以设置一个调度程序，在运行时就会这样做。\n对于我们将要走过的候选链来说，链接列表原来是一个非常方便的数据结构。我们可以通过跟踪当前节点来完成链接列表的工作，也就是说只需要有一个东西发生突变，也就是当前调度的状态。调度程序机制还提供了一种从对象中读取属性的方法，这就足以将遍历链接列表表达到调度程序中。这也意味着零分配。\n所以，不多说了，下面是链接列表（在 NQP 这个受限的 Raku 子集中，相当不如在完整的 Raku 中漂亮）。\n# A linked list is used to model the state of a dispatch that is deferring # through a set of methods, multi candidates, or wrappers. The Exhausted class # is used as a sentinel for the end of the chain. The current state of the # dispatch points into the linked list at the appropriate point; the chain # itself is immutable, and shared over (runtime) dispatches. my class DeferralChain { has $!code; has $!next; method new($code, $next) { my $obj := nqp::create(self); nqp::bindattr($obj, DeferralChain, '$!code', $code); nqp::bindattr($obj, DeferralChain, '$!next', $next); $obj } method code() { $!code } method next() { $!next } }; my class Exhausted {}; 最后是恢复处理。\nnqp::dispatch('boot-syscall', 'dispatcher-register', 'raku-meth-call-resolved', # Initial dispatch -\u0026gt; $capture { ... 'Presented earlier; }, # Resumption. The resume init capture's first two arguments are the type # that we initially did a method dispatch against and the method name # respectively. -\u0026gt; $capture { # Work out the next method to call, if any. This depends on if we have # an existing dispatch state (that is, a method deferral is already in # progress). my $init := nqp::dispatch('boot-syscall', 'dispatcher-get-resume-init-args'); my $state := nqp::dispatch('boot-syscall', 'dispatcher-get-resume-state'); my $next_method; if nqp::isnull($state) { # No state, so just starting the resumption. Guard on the # invocant type and name. my $track_start_type := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $init, 0); nqp::dispatch('boot-syscall', 'dispatcher-guard-type', $track_start_type); my $track_name := nqp::dispatch('boot-syscall', 'dispatcher-track-arg', $init, 1); nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_name); # Also guard on there being no dispatch state. my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state'); nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_state); # Build up the list of methods to defer through. my $start_type := nqp::captureposarg($init, 0); my str $name := nqp::captureposarg_s($init, 1); my @mro := nqp::can($start_type.HOW, 'mro_unhidden') ?? $start_type.HOW.mro_unhidden($start_type) !! $start_type.HOW.mro($start_type); my @methods; for @mro { my %mt := nqp::hllize($_.HOW.method_table($_)); if nqp::existskey(%mt, $name) { @methods.push(%mt{$name}); } } # If there's nothing to defer to, we'll evaluate to Nil (just don't set # the next method, and it happens below). if nqp::elems(@methods) \u0026gt;= 2 { # We can defer. Populate next method. @methods.shift; # Discard the first one, which we initially called $next_method := @methods.shift; # The immediate next one # Build chain of further methods and set it as the state. my $chain := Exhausted; while @methods { $chain := DeferralChain.new(@methods.pop, $chain); } nqp::dispatch('boot-syscall', 'dispatcher-set-resume-state-literal', $chain); } } elsif !nqp::istype($state, Exhausted) { # Already working through a chain of method deferrals. Obtain # the tracking object for the dispatch state, and guard against # the next code object to run. my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state'); my $track_method := nqp::dispatch('boot-syscall', 'dispatcher-track-attr', $track_state, DeferralChain, '$!code'); nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_method); # Update dispatch state to point to next method. my $track_next := nqp::dispatch('boot-syscall', 'dispatcher-track-attr', $track_state, DeferralChain, '$!next'); nqp::dispatch('boot-syscall', 'dispatcher-set-resume-state', $track_next); # Set next method, which we shall defer to. $next_method := $state.code; } else { # Dispatch already exhausted; guard on that and fall through to returning # Nil. my $track_state := nqp::dispatch('boot-syscall', 'dispatcher-track-resume-state'); nqp::dispatch('boot-syscall', 'dispatcher-guard-literal', $track_state); } # If we found a next method... if nqp::isconcrete($next_method) { # Call with same (that is, original) arguments. Invoke with those. # We drop the first two arguments (which are only there for the # resumption), add the code object to invoke, and then leave it # to the invoke or multi dispatcher. my $just_args := nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', nqp::dispatch('boot-syscall', 'dispatcher-drop-arg', $init, 0), 0); my $delegate_capture := nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj', $just_args, 0, $next_method); if nqp::istype($next_method, Routine) \u0026amp;\u0026amp; $next_method.is_dispatcher { nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-multi', $delegate_capture); } else { nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'raku-invoke', $delegate_capture); } } else { # No method, so evaluate to Nil (boot-constant disregards all but # the first argument). nqp::dispatch('boot-syscall', 'dispatcher-delegate', 'boot-constant', nqp::dispatch('boot-syscall', 'dispatcher-insert-arg-literal-obj', $capture, 0, Nil)); } }); 这是相当多的内容，也是相当多的代码。但请记住，这只是运行在调度恢复的记录阶段。它还会在 callsame 的 callsite 产生一个调度程序，并带有通常的守卫和结果。隐式守卫是为我们在该点恢复的调度程序创建的。在最常见的情况下，这最终将是单形或双形的，尽管涉及多个调度或方法调度的嵌套的情况可能会产生一个更有形态的 callsite。\n我选取的设计迫使 resume 回调处理两种情况：第一次复用和后一次复用。这在几个方面都不理想。\n这对那些编写调度简历回调的人来说有点不方便。然而，这又不是特别常见的活动!\n这种差异导致两个调度程序堆积在一个调用点，而在其他情况下，这个调用点可能只得到一个 只有其中第二项真正重要。之所以不统一，是为了确保绝大多数从未恢复调度的电话，不会因其最终从未使用的功能而产生每次调度的费用。如果结果是使用该功能的人多花了一点成本，那就这样吧。事实上，早期的基准测试显示，使用新调度器的 callsame 与 wrap 和方法调用似乎比当前 Rakudo 中的速度快了 10 倍，这还没等专门人员对它有足够的了解，就已经进一步改进了!\n目前所做的事情 我上面讨论的所有内容都已经实现了，只是我可能在某个地方给人的印象是，使用新的 dispatcher 已经完全实现了多重调度，而现在还不是这样（没有处理 where 子句，也不支持调度恢复）。\n今后的步骤 下一步显然是要完全实现多调度的缺失部分。另一个缺失的语义是对 callwith 和 nextwith 的支持，当我们希望改变移动到下一个候选人时使用的参数。抛开其他一些小问题不谈，理论上来说，这至少可以让所有的 Raku 调度语义得到支持。\n目前，所有的标准方法调用（$obj.meth()）和其他调用（foo()和$foo()）都会通过现有的调度机制，而不是新的调度器。这些也需要迁移到新的调度器上，而且任何发现的错误都需要修复。这将使事情达到新调度器在语义上已经准备好的程度。\n之后是性能工作：确保专用器能够处理调度程序的防护和结果。最初的目标是，让常见调用形式的稳态性能至少与当前乐道主分支中的性能相同。已经很清楚了，对于一些到目前为止还很冰冷的东西来说，会有一些大的胜利，但它不应该以最常见的调度种类的退步为代价，因为这些调度种类之前已经得到了大量的优化努力。\n此外，NQP - 乐道编译器和运行时内脏的其他位写的乐的限制形式 - 也需要迁移到使用新的调度器。只有做到这一点，才有可能从 MoarVM 中扯出当前的方法缓存、多调度缓存等。\n一个悬而未决的问题是，如何处理 MoarVM 以外的后端。理想情况下，新的调度机制将被移植到这些地方。相当多的内容应该可以用 JVM 的 invokedynamic 来表达（而这一切可能会在基于 Truffle 的 Raku 实现中发挥得相当好，尽管我不确定目前是否有这方面的积极努力）。\n未来的机会 虽然我目前的重点是发布一个使用新调度机制的 Rakudo 和 MoarVM 版本，但这不会是旅程的终点。一些眼前的想法。\n 对角色的方法调用需要把角色打入一个类中， 所以方法查找会返回一个闭包来完成这个任务并替换调用者。这是一个很大的间接性；新的调度者可以获得 pun，并产生一个调度程序，用 punn 化的类类型对象替换角色类型对象，这将使每次调用的成本大大降低。 我期望使用新的 dispatcher 可以使句柄（dlegated）和 fallback（处理缺失的方法调用）机制都能有更好的表现 当前的 assuming - 用于为例程讨价还价或其他首要参数 - 的实现并不理想，利用新调度器的参数重写能力的实现可能会有更好的表现。 在新的调度机制的帮助下，一些新的语言功能也可能以高效的方式提供。例如，目前没有一种可靠的方式来尝试调用一段代码，如果签名绑定了就运行它，如果没有绑定就做其他事情。相反，像 Cro 路由器这样的东西，必须先做签名的试绑定，然后再做调用，这使得路由的成本相当高。还有一个建议已久的想法，就是通过签名与 when 构造提供模式匹配 (例如，when * -\u0026gt; ($x) {}; when * -\u0026gt; ($x, *@tail) { })，这和需求差不多，只是在一个不太动态的环境下。  最后\u0026hellip; 在新的调度机制上的工作比我最初预期的历程要长。设计的恢复部分特别具有挑战性，而且还有一些重要的细节需要处理。一路走来，大概有四种潜在的方法被抛弃了（虽然其中的元素都影响了我在这篇文章中描述的内容）。能坚持下来的抽象真的非常非常难。\n我最终也不得不从根本上离开几个月做 Raku 工作，在其他一些工作中感觉有点被压垮了，并且一直在与同样重要的 RakuAST 项目（它将因为能够承担新的调度器的存在而被简化，并且还为我提供了一系列更柔和的 Raku 黑客任务，而调度器的工作提供了很少的轻松选择）。\n鉴于这些，我很高兴终于看到了隧道尽头的光亮。剩下的工作是数不胜数的，而我们使用新的调度器发布 Rakudo 和 MoarVM 的那一天，感觉还需要几个月的时间（我希望写下这句话不是在诱惑命运！）。\n新的调度器可能是 MoarVM 自我创建以来最重要的变化，因为它看到我们删除了一堆从一开始就存在的东西。RakuAST 也将为 Rakudo 编译器带来十年来最大的架构变化。两者都是一个机会，将多年来学习的东西硬生生地折合到运行时和编译器中。我希望再过十年，当我回顾这一切的时候，至少会觉得自己这次犯了更多有趣的错误。\n原文链接: https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/\n"},"name":"争取在 MoarVM 中建立一个新的总调度机制","published":"2021-03-15T00:00:00+08:00","summary":"Towards a New General Dispatch Mechanism in Moarvm","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/"},{"content":{"html":"\u003cp\u003e在过去的几周里，我看到了一些\u003ca href=\"https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/\"\u003e文章\u003c/a\u003e和\u003ca href=\"https://youtu.be/GAqfMNB-YBU\"\u003e视频\u003c/a\u003e，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文\u003ca href=\"http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg\"\u003eRaku 是我的 MMORPG\u003c/a\u003e。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 \u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 编程语言的法师。\u003c/p\u003e\n\u003ch2 id=\"选择一个任务\"\u003e选择一个任务\u003c/h2\u003e\n\u003cp\u003e让我们挑选一些编译器的 bug，并修复它。让我们去 \u003ca href=\"https://rakudo.org/\"\u003eRakudo\u003c/a\u003e 编译器 \u003ca href=\"https://github.com/rakudo/rakudo/issues\"\u003eissues\u003c/a\u003e中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究\u003ca href=\"https://www.apress.com/gp/book/9781484232279\"\u003e编译器语法\u003c/a\u003e，看了一本这方面的好书。找到了四个问题。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。\u003c/li\u003e\n\u003cli\u003e标签 \u0026ldquo;需要共识\u0026rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。\u003c/li\u003e\n\u003cli\u003e标签为 \u0026ldquo;grammar and actions\u0026rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。\u003c/p\u003e\n\u003ch2 id=\"建立工作环境\"\u003e建立工作环境\u003c/h2\u003e\n\u003cp\u003e为源码和我们建立的编译器建立文件夹。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003emkdir ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e mkdir ~/dev-rakudo-install\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eRakudo 编译器由三部分组成。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。\u003c/li\u003e\n\u003cli\u003eNQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 \u0026ldquo;子集\u0026rdquo;。虚拟机可以执行用 NQP 编写的代码。\u003c/li\u003e\n\u003cli\u003eRakudo 编译器本身，用 NQP 和 Raku 编写。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:MoarVM/MoarVM.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e MoarVM\nperl Configure.pl --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\n\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:Raku/nqp.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e nqp\nperl Configure.pl --backend\u003cspan class=\"o\"\u003e=\u003c/span\u003emoar --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\n\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone git@github.com:rakudo/rakudo.git \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e rakudo\nperl Configure.pl --backend\u003cspan class=\"o\"\u003e=\u003c/span\u003emoar --prefix ~/dev-rakudo-install \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make -j \u003cspan class=\"m\"\u003e4\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注意参数。\u003ccode\u003e--prefix\u003c/code\u003e 显示了 \u003ccode\u003emake install\u003c/code\u003e 命令后可执行文件的复制位置，\u003ccode\u003e--backend=moar\u003c/code\u003e 表示正在使用的虚拟机，而 \u003ccode\u003e-j 4\u003c/code\u003e 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 \u003ccode\u003e~/dev-rakudo-install/bin/raku\u003c/code\u003e。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/dev-rakudo/rakudo \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e git clone https://github.com/Raku/roast.git t/spec\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。\u003c/p\u003e\n\u003cp\u003e这里和下面我将在 \u003ccode\u003e~/dev-rakudo/rakudo\u003c/code\u003e 文件夹中工作，除非另有说明。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make spectest\n[...]\nTest Summary Report\n-------------------\nt/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)\n  Non-zero exit status: 255\n  Parse errors: Bad plan.  You planned 66 tests but ran 54.\nFiles=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)\nResult: FAIL\nmake: *** [m-spectest5] Error 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!\u003c/p\u003e\n\u003ch2 id=\"让我们来看看问题的陈述\"\u003e让我们来看看问题的陈述\u003c/h2\u003e\n\u003cp\u003e问题陈述说，某个元运算符 \u003ccode\u003eR\u003c/code\u003e 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esay 3 R- 2 == -1 # Output: True\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eColonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 \u003ccode\u003e:foo(42)\u003c/code\u003e 是一个名称为 \u003ccode\u003efoo\u003c/code\u003e、值为 \u003ccode\u003e42\u003c/code\u003e 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-with-named-parameter(:$foo) {\n    say $foo;\n}\n\nsub-with-named-parameter(:foo(42)); # Output: 42\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-without-named-parameter($foo) { # \u0026lt;- 没有冒号\n  say $foo;\n}\n\nsub-without-named-parameter(:foo(42)); # Unexpected named argument 'foo' passed\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-without-named-parameter($foo) {\n  say $foo;\n}\n\nsub-without-named-parameter((:foo(42))); # Output: foo =\u0026gt; 42\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sub-with-capture(|foo) { # \u0026lt;- 参数捕获\n  say foo;\n}\n\nsub-with-capture(:foo(42));     # Output: \\(:foo(42))\nsub-with-capture(42);           # Output: \\(42)\nsub-with-capture(:foo(3 Z- 2)); # Output: \\(:foo((1,).Seq))\nsub-with-capture(:foo(3 R- 2)); # Output: \\(-1)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。\u003c/p\u003e\n\u003cp\u003e在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。\u003c/p\u003e\n\u003ch2 id=\"我们需要一个新的测试\"\u003e我们需要一个新的测试\u003c/h2\u003e\n\u003cp\u003e为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（\u003ca href=\"https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t\"\u003eS03-metops/reverse.t\u003c/a\u003e）。下面我将补充以下测试。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# https://github.com/rakudo/rakudo/issues/1632\n{\n  sub subroutine($expected, |actual) {\n    is actual.gist, $expected, \u0026quot;Сolonpair exists\u0026quot;\n  }\n\n  subroutine('\\(:foo(-1))', :foo(3 R- 2));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 \u003ccode\u003emake\u003c/code\u003e 对新构建的编译器进行单独测试。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make t/spec/S03-metaops/reverse.t\n[...]\nok 69 - [R~]=\nnot ok 70 - Colonpair exists\n# Failed test 'Colonpair exists'\n# at t/spec/S03-metaops/reverse.t line 191\n# expected: '\\(:foo(-1))'\n#      got: '\\(-1)'\n# You planned 69 tests, but ran 70\n# You failed 1 test of 70\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 \u003ccode\u003eplan\u003c/code\u003e 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。\u003c/p\u003e\n\u003ch2 id=\"凝视法\"\u003e凝视法\u003c/h2\u003e\n\u003cp\u003e一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e基础解析器代码在文件 \u003ccode\u003erakudo/src/Perl6/Grammar.nqp\u003c/code\u003e 中。\u003c/li\u003e\n\u003cli\u003e这个解析器是从 \u003ccode\u003enqp/src/HLL/Grammar.nqp\u003c/code\u003e 文件中的基础解析器继承的。\u003c/li\u003e\n\u003cli\u003e元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e我在基础解析器代码中找到了对元操作符的引用。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003etoken infix_prefix_meta_operator:sym\u0026lt;R\u0026gt; {\n  \u0026lt;sym\u0026gt; \u0026lt;infixish('R')\u0026gt; {}\n  \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;reverse the args of\u0026quot;)\u0026gt;\n  \u0026lt;O=.revO($\u0026lt;infixish\u0026gt;)\u0026gt;\n}\n\ntoken infix_prefix_meta_operator:sym\u0026lt;Z\u0026gt; {\n  \u0026lt;sym\u0026gt; \u0026lt;infixish('Z')\u0026gt; {}\n  \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;zip with\u0026quot;)\u0026gt;\n  \u0026lt;O(|%list_infix)\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 \u003ccode\u003emy $r = :foo(3 R- 2); say $r; # Output: foo =\u0026gt; -1\u003c/code\u003e 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。\u003c/p\u003e\n\u003ch2 id=\"编译器将帮助我们\"\u003e编译器将帮助我们\u003c/h2\u003e\n\u003cp\u003e颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 \u003ccode\u003e--target\u003c/code\u003e 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 \u003ccode\u003e--target=parse\u003c/code\u003e（因为我只知道这一个）。\u003c/p\u003e\n\u003cp\u003e我从 \u003ccode\u003e~/dev-rakudo/rakudo\u003c/code\u003e 文件夹中使用 \u003ccode\u003erakumo-m\u003c/code\u003e，这样我就不必等待通过 \u003ccode\u003emake install\u003c/code\u003e 命令将所需文件复制到 \u003ccode\u003e~/dev-rakudo-install\u003c/code\u003e。简单的脚本可以这样运行。更复杂的脚本必须在 \u003ccode\u003emake install\u003c/code\u003e 之后从 \u003ccode\u003e-install\u003c/code\u003e 中运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; cat ~/test.raku\nsub s(|c) { say c }\ns(:foo(3 R- 2));\ns(:foo(3 Z- 2));\n\n\u0026gt; ./rakudo-m --target=parse ~/test.raku\n[...]\n- args: (:foo(3 R- 2))\n  - semiarglist: :foo(3 R- 2)\n    - arglist: 1 matches\n      - EXPR: :foo(3 R- 2)\n        - colonpair: :foo(3 R- 2)\n          - identifier: foo\n          - coloncircumfix: (3 R- 2)\n            - circumfix: (3 R- 2)\n              - semilist: 3 R- 2\n                - statement: 1 matches\n                  - EXPR: R- 2\n[...]\n- args: (:foo(3 Z- 2))\n  - semiarglist: :foo(3 Z- 2)\n    - arglist: 1 matches\n      - EXPR: :foo(3 Z- 2)\n        - colonpair: :foo(3 Z- 2)\n          - identifier: foo\n          - coloncircumfix: (3 Z- 2)\n            - circumfix: (3 Z- 2)\n              - semilist: 3 Z- 2\n                - statement: 1 matches\n                  - EXPR: Z- 2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e结论：R 和 Z 的解析是一样的。\u003c/p\u003e\n\u003ch2 id=\"这不是解析\"\u003e这不是解析\u003c/h2\u003e\n\u003cp\u003e所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 \u003ccode\u003erakudo/src/Perl6/Actions.nqp\u003c/code\u003e 和 \u003ccode\u003enqp/src/HLL/Actions.nqp\u003c/code\u003e 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。\u003c/p\u003e\n\u003cp\u003e我在主 Actions 中找到了以下代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\nelsif $\u0026lt;infix_prefix_meta_operator\u0026gt; {\n[...]\n  if    $metasym eq 'R' { $helper := '\u0026amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }\n  elsif $metasym eq 'X' { $helper := '\u0026amp;METAOP_CROSS'; $t := nqp::uc($t); }\n  elsif $metasym eq 'Z' { $helper := '\u0026amp;METAOP_ZIP'; $t := nqp::uc($t); }\n  \n  my $metapast := QAST::Op.new( :op\u0026lt;call\u0026gt;, :name($helper), WANTED($basepast,'infixish') );\n  $metapast.push(QAST::Var.new(:name(baseop_reduce($base\u0026lt;OPER\u0026gt;\u0026lt;O\u0026gt;.made)), :scope\u0026lt;lexical\u0026gt;))\n    if $metasym eq 'X' || $metasym eq 'Z';\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e它说，如果在代码中解析了元操作符 \u003ccode\u003eR\u003c/code\u003e、\u003ccode\u003eZ\u003c/code\u003e 或 \u003ccode\u003eX\u003c/code\u003e，就应该在语法树中添加一些 \u003ccode\u003eMETAOP_\u003c/code\u003e 函数调用。在 \u003ccode\u003eZ\u003c/code\u003e 和 \u003ccode\u003eX\u003c/code\u003e 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 \u003ccode\u003erakudo/src/core.c/metaops.pm6\u003c/code\u003e 中找到。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub METAOP_REVERSE(\\op) is implementation-detail {\n  -\u0026gt; |args { op.(|args.reverse) }\n}\n\nsub METAOP_ZIP(\\op, \u0026amp;reduce) is implementation-detail {\n nqp::if(op.prec('thunky').starts-with('.'),\n  -\u0026gt; +lol {\n    my $arity = lol.elems;\n    [...]\n  },\n  -\u0026gt; +lol {\n    Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op))\n  }\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e给你：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e\\op\u003c/code\u003e 是由我们的元操作符，即-，在前面的操作。\u003c/li\u003e\n\u003cli\u003eTrait \u003ccode\u003eimplementation-detail\u003c/code\u003e 只是表明这不是公共代码，是编译器实现的一部分。\u003c/li\u003e\n\u003cli\u003e由于-操作没有笨重的特性，所以 \u003ccode\u003e\u0026amp;reduce\u003c/code\u003e 函数不会参与计算，\u003ccode\u003eZ\u003c/code\u003e 的结果是 \u003ccode\u003eSeq.new(...)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eR\u003c/code\u003e 的结果是一个操作调用 - 参数顺序相反。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这时我想起还有一个 - 目标，即星。它将显示行动的结果。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=ast ~/test.raku\n[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-\n    - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2))\n  - QAST::Op+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z-\n    - QAST::Op(call \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n      - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT)\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一如所料。除了调用不同的 \u003ccode\u003eMETAOP_\u003c/code\u003e 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 \u003ccode\u003eInt\u003c/code\u003e 和 \u003ccode\u003eSeq\u003c/code\u003e。众所周知，Raku 对不同类型的对象的上下文相当敏感\u0026hellip;\u0026hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub METAOP_REVERSE(\\op) is implementation-detail {\n  -\u0026gt; |args { Seq.new(op.(|args.reverse)) }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e编译、运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make\n[...]\nStage start      :   0.000\nStage parse      :  61.026\nStage syntaxcheck:   0.000\nStage ast        :   0.000\nStage optimize   :   7.076\nStage mast       :  14.120\nStage mbc        :   3.941\n[...]\n\u0026gt; ./rakudo-m ~/test.raku\n\\(-1)\n\\(:foo((1,).Seq))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一切都没有改变。所以，不是返回值\u0026hellip;\u0026hellip;想了想，不知道为什么结果又是 \u003ccode\u003e-1\u003c/code\u003e 而不是 \u003ccode\u003e(-1,).Seq\u003c/code\u003e。而且，从代码来看，\u003ccode\u003eSeq\u003c/code\u003e 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 结果只是为了崩溃。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub METAOP_REVERSE(\\op) is implementation-detail {\n  -\u0026gt; |args { die }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e编译、运行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make\n[...]\n\u0026gt; ./rakudo-m ~/test.raku\n\\(-1)\n\\(:foo((1,).Seq))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e怎么会呢？语法树中包含了对 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 \u003ccode\u003e-1\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这些都不是《行动》。\u003c/p\u003e\n\u003cp\u003e这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 \u003ccode\u003e--target=mast\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=mast ~/test.raku\n[...]\nMAST::Frame name\u0026lt;s\u0026gt;, cuuid\u0026lt;1\u0026gt;\n  Local types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;int\u0026gt;, 5\u0026lt;str\u0026gt;, 6\u0026lt;obj\u0026gt;, 7\u0026lt;obj\u0026gt;, 8\u0026lt;obj\u0026gt;,\n  Lexical types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;obj\u0026gt;,\n  Lexical names: 0\u0026lt;c\u0026gt;, 1\u0026lt;$¢\u0026gt;, 2\u0026lt;$!\u0026gt;, 3\u0026lt;$/\u0026gt;, 4\u0026lt;$*DISPATCHER\u0026gt;,\n  Lexical map: $!\u0026lt;2\u0026gt;, c\u0026lt;0\u0026gt;, $*DISPATCHER\u0026lt;4\u0026gt;, $¢\u0026lt;1\u0026gt;, $/\u0026lt;3\u0026gt;,\n  Outer: name\u0026lt;\u0026lt;unit\u0026gt;\u0026gt;, cuuid\u0026lt;2\u0026gt;\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; ./rakudo-m --target=optimize ~/test.raku\n[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z-\n    - QAST::Op(callstatic \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n      - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT)\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(3)  3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n      - QAST::WVal(Int)\n      - Ii\n      - QAST::IVal(2)  2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e哈，就是这样。在优化阶段后，行将失踪。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eQAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-.\u003c/code\u003e\n并将整个 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 调用替换为通常的操作 \u003ccode\u003e(\u0026amp;infix:\u0026lt;-\u0026gt;)\u003c/code\u003e。所以问题一定在优化器的某个地方。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e只有在 \u003ccode\u003eoptim_nameless_call\u003c/code\u003e 方法中才会提到 \u003ccode\u003e\u0026amp;METAOP_ASSIGN\u003c/code\u003e，其中 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;)\u003c/code\u003e。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 \u003ccode\u003e_\u003c/code\u003e 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n  elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') {\n    return NQPMu unless nqp::istype($metaop[0], QAST::Var)\n      \u0026amp;\u0026amp; nqp::elems($op) == 3;\n    return QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name),\n      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;\n  }\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e让我提醒你，优化前的树是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-\n    - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt;\n      - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而精简之后，是这样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也就是说，优化 \u003ccode\u003e_nameless_call\u003c/code\u003e 做了以下工作。\u003c/p\u003e\n\u003cp\u003e如果我们的 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}\u003c/code\u003e 操作没有三个参数，如果 \u003ccode\u003eMETAOP_REVERSE\u003c/code\u003e 调用没有一个正确的类型，我们就返回空。这不是我们的情况。\n否则，我们将返回一个新的操作，代替我们的 \u003ccode\u003eQAST::Op+{QAST::SpecialArg}\u003c/code\u003e 操作，以相反的顺序调用 \u003ccode\u003e\u0026amp;infix:\u0026lt;-\u0026gt;\u003c/code\u003e 参数。就是说，把结果打包成一对就没了。\u003c/p\u003e\n\u003cp\u003e在摸索了一下如何解决这个问题，并阅读了 \u003ccode\u003eQAST::SpecialArg\u003c/code\u003e 和 \u003ccode\u003eQAST::Node\u003c/code\u003e 的实现后，我想到了下面的代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n  elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') {\n    return NQPMu unless nqp::istype($metaop[0], QAST::Var)\n      \u0026amp;\u0026amp; nqp::elems($op) == 3;\n    my $opt_result := QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name),\n      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;\n    if $op.named { $opt_result.named($op.named) } # 添加选项 named \n    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat\n    return $opt_result;\n  }\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e还有木头。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Op+{QAST::SpecialArg}(call \u0026amp;infix:\u0026lt;-\u0026gt; :named\u0026lt;foo\u0026gt;)  :METAOP_opt_result\u0026lt;?\u0026gt;\n    - QAST::Want \u0026lt;wanted\u0026gt; 2\n    - QAST::Want \u0026lt;wanted\u0026gt; 3\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e命名的参数返回到它的位置。测试也开始通过。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt; make t/spec/S03-metaops/reverse.t\n[...]\nAll tests successful.\nFiles=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)\nResult: PASS\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 \u003ccode\u003eself.visit_op: $opt_result;\u003c/code\u003e，对产生的非优化操作调用优化器，那么产生的树就会像这样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[...]\n- QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2))\n  - QAST::Want+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;)\n    - QAST::WVal+{QAST::SpecialArg}(Int :named\u0026lt;foo\u0026gt;)\n    - QAST::IVal(-1)\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在一切都很理想。\u003c/p\u003e\n\u003ch2 id=\"分享成果\"\u003e分享成果\u003c/h2\u003e\n\u003cp\u003e我们已经到了终点线。现在我们只需要分享我们的经验。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e重要的是：运行所有的 \u003ccode\u003emake spectest\u003c/code\u003e 测试，确保没有新的东西被破坏。\u003c/li\u003e\n\u003cli\u003e在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。\u003c/li\u003e\n\u003cli\u003e将 fork 仓库添加为新的 git 远程仓库。\u003c/li\u003e\n\u003cli\u003ecd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git remote add fork \u003c!-- raw HTML omitted --\u003e。\u003c/li\u003e\n\u003cli\u003ecd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git remote add fork \u003c!-- raw HTML omitted --\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。\u003c/p\u003e\n\u003cp\u003e提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。\u003c/p\u003e\n\u003cp\u003e运行提交。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git push fork\ncd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git push fork\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e结论\u003c/h2\u003e\n\u003cp\u003e对开源软件的贡献是：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e趣味性和趣味性。\u003c/li\u003e\n\u003cli\u003e给你的感觉是，你正在做一些有用的事情，你真的是。\u003c/li\u003e\n\u003cli\u003e让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 \u003ccode\u003e#raku IRC\u003c/code\u003e 频道中得到回答）。\u003c/li\u003e\n\u003cli\u003e解决非标准任务，没有截止日期的压力，是一种很好的体验。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e选择你觉得最舒服的角色等级，去做新的任务吧!\u003c/p\u003e\n","text":"在过去的几周里，我看到了一些文章和视频，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文Raku 是我的 MMORPG。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 Raku 编程语言的法师。\n选择一个任务 让我们挑选一些编译器的 bug，并修复它。让我们去 Rakudo 编译器 issues中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究编译器语法，看了一本这方面的好书。找到了四个问题。\n 标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。 标签 \u0026ldquo;需要共识\u0026rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。 标签为 \u0026ldquo;grammar and actions\u0026rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。  任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。\n建立工作环境 为源码和我们建立的编译器建立文件夹。\nmkdir ~/dev-rakudo \u0026amp;\u0026amp; mkdir ~/dev-rakudo-install Rakudo 编译器由三部分组成。\n 虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。 NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 \u0026ldquo;子集\u0026rdquo;。虚拟机可以执行用 NQP 编写的代码。 Rakudo 编译器本身，用 NQP 和 Raku 编写。  下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。\ncd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:MoarVM/MoarVM.git \u0026amp;\u0026amp; cd MoarVM perl Configure.pl --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install cd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:Raku/nqp.git \u0026amp;\u0026amp; cd nqp perl Configure.pl --backend=moar --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install cd ~/dev-rakudo \u0026amp;\u0026amp; git clone git@github.com:rakudo/rakudo.git \u0026amp;\u0026amp; cd rakudo perl Configure.pl --backend=moar --prefix ~/dev-rakudo-install \u0026amp;\u0026amp; make -j 4 \u0026amp;\u0026amp; make install 注意参数。--prefix 显示了 make install 命令后可执行文件的复制位置，--backend=moar 表示正在使用的虚拟机，而 -j 4 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 ~/dev-rakudo-install/bin/raku。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。\ncd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git clone https://github.com/Raku/roast.git t/spec 我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。\n这里和下面我将在 ~/dev-rakudo/rakudo 文件夹中工作，除非另有说明。\n\u0026gt; make spectest [...] Test Summary Report ------------------- t/spec/S32-str/utf8-c8.t (Wstat: 65280 Tests: 54 Failed: 0) Non-zero exit status: 255 Parse errors: Bad plan. You planned 66 tests but ran 54. Files=1346, Tests=117144, 829 wallclock secs (27.70 usr 6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU) Result: FAIL make: *** [m-spectest5] Error 1 14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!\n让我们来看看问题的陈述 问题陈述说，某个元运算符 R 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。\nsay 3 R- 2 == -1 # Output: True Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 :foo(42) 是一个名称为 foo、值为 42 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。\nsub sub-with-named-parameter(:$foo) { say $foo; } sub-with-named-parameter(:foo(42)); # Output: 42 如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。\nsub sub-without-named-parameter($foo) { # \u0026lt;- 没有冒号 say $foo; } sub-without-named-parameter(:foo(42)); # Unexpected named argument 'foo' passed 如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。\nsub sub-without-named-parameter($foo) { say $foo; } sub-without-named-parameter((:foo(42))); # Output: foo =\u0026gt; 42 在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。\nsub sub-with-capture(|foo) { # \u0026lt;- 参数捕获 say foo; } sub-with-capture(:foo(42)); # Output: \\(:foo(42)) sub-with-capture(42); # Output: \\(42) sub-with-capture(:foo(3 Z- 2)); # Output: \\(:foo((1,).Seq)) sub-with-capture(:foo(3 R- 2)); # Output: \\(-1) 倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。\n在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。\n我们需要一个新的测试 为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（S03-metops/reverse.t）。下面我将补充以下测试。\n# https://github.com/rakudo/rakudo/issues/1632 { sub subroutine($expected, |actual) { is actual.gist, $expected, \u0026quot;Сolonpair exists\u0026quot; } subroutine('\\(:foo(-1))', :foo(3 R- 2)); } 该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 make 对新构建的编译器进行单独测试。\n\u0026gt; make t/spec/S03-metaops/reverse.t [...] ok 69 - [R~]= not ok 70 - Colonpair exists # Failed test 'Colonpair exists' # at t/spec/S03-metaops/reverse.t line 191 # expected: '\\(:foo(-1))' # got: '\\(-1)' # You planned 69 tests, but ran 70 # You failed 1 test of 70 你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 plan 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。\n凝视法 一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：\n 基础解析器代码在文件 rakudo/src/Perl6/Grammar.nqp 中。 这个解析器是从 nqp/src/HLL/Grammar.nqp 文件中的基础解析器继承的。 元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。  我在基础解析器代码中找到了对元操作符的引用。\ntoken infix_prefix_meta_operator:sym\u0026lt;R\u0026gt; { \u0026lt;sym\u0026gt; \u0026lt;infixish('R')\u0026gt; {} \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;reverse the args of\u0026quot;)\u0026gt; \u0026lt;O=.revO($\u0026lt;infixish\u0026gt;)\u0026gt; } token infix_prefix_meta_operator:sym\u0026lt;Z\u0026gt; { \u0026lt;sym\u0026gt; \u0026lt;infixish('Z')\u0026gt; {} \u0026lt;.can_meta($\u0026lt;infixish\u0026gt;, \u0026quot;zip with\u0026quot;)\u0026gt; \u0026lt;O(|%list_infix)\u0026gt; } 这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 my $r = :foo(3 R- 2); say $r; # Output: foo =\u0026gt; -1 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。\n编译器将帮助我们 颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 --target 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 --target=parse（因为我只知道这一个）。\n我从 ~/dev-rakudo/rakudo 文件夹中使用 rakumo-m，这样我就不必等待通过 make install 命令将所需文件复制到 ~/dev-rakudo-install。简单的脚本可以这样运行。更复杂的脚本必须在 make install 之后从 -install 中运行。\n\u0026gt; cat ~/test.raku sub s(|c) { say c } s(:foo(3 R- 2)); s(:foo(3 Z- 2)); \u0026gt; ./rakudo-m --target=parse ~/test.raku [...] - args: (:foo(3 R- 2)) - semiarglist: :foo(3 R- 2) - arglist: 1 matches - EXPR: :foo(3 R- 2) - colonpair: :foo(3 R- 2) - identifier: foo - coloncircumfix: (3 R- 2) - circumfix: (3 R- 2) - semilist: 3 R- 2 - statement: 1 matches - EXPR: R- 2 [...] - args: (:foo(3 Z- 2)) - semiarglist: :foo(3 Z- 2) - arglist: 1 matches - EXPR: :foo(3 Z- 2) - colonpair: :foo(3 Z- 2) - identifier: foo - coloncircumfix: (3 Z- 2) - circumfix: (3 Z- 2) - semilist: 3 Z- 2 - statement: 1 matches - EXPR: Z- 2 [...] 结论：R 和 Z 的解析是一样的。\n这不是解析 所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 rakudo/src/Perl6/Actions.nqp 和 nqp/src/HLL/Actions.nqp 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。\n我在主 Actions 中找到了以下代码。\n[...] elsif $\u0026lt;infix_prefix_meta_operator\u0026gt; { [...] if $metasym eq 'R' { $helper := '\u0026amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; } elsif $metasym eq 'X' { $helper := '\u0026amp;METAOP_CROSS'; $t := nqp::uc($t); } elsif $metasym eq 'Z' { $helper := '\u0026amp;METAOP_ZIP'; $t := nqp::uc($t); } my $metapast := QAST::Op.new( :op\u0026lt;call\u0026gt;, :name($helper), WANTED($basepast,'infixish') ); $metapast.push(QAST::Var.new(:name(baseop_reduce($base\u0026lt;OPER\u0026gt;\u0026lt;O\u0026gt;.made)), :scope\u0026lt;lexical\u0026gt;)) if $metasym eq 'X' || $metasym eq 'Z'; [...] 它说，如果在代码中解析了元操作符 R、Z 或 X，就应该在语法树中添加一些 METAOP_ 函数调用。在 Z 和 X 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 rakudo/src/core.c/metaops.pm6 中找到。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { op.(|args.reverse) } } sub METAOP_ZIP(\\op, \u0026amp;reduce) is implementation-detail { nqp::if(op.prec('thunky').starts-with('.'), -\u0026gt; +lol { my $arity = lol.elems; [...] }, -\u0026gt; +lol { Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op)) } ) } 给你：\n \\op 是由我们的元操作符，即-，在前面的操作。 Trait implementation-detail 只是表明这不是公共代码，是编译器实现的一部分。 由于-操作没有笨重的特性，所以 \u0026amp;reduce 函数不会参与计算，Z 的结果是 Seq.new(...)。 R 的结果是一个操作调用 - 参数顺序相反。  这时我想起还有一个 - 目标，即星。它将显示行动的结果。\n\u0026gt; ./rakudo-m --target=ast ~/test.raku [...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R- - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2)) - QAST::Op+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z- - QAST::Op(call \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT) - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] 一如所料。除了调用不同的 METAOP_ 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 Int 和 Seq。众所周知，Raku 对不同类型的对象的上下文相当敏感\u0026hellip;\u0026hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { Seq.new(op.(|args.reverse)) } } 编译、运行。\n\u0026gt; make [...] Stage start : 0.000 Stage parse : 61.026 Stage syntaxcheck: 0.000 Stage ast : 0.000 Stage optimize : 7.076 Stage mast : 14.120 Stage mbc : 3.941 [...] \u0026gt; ./rakudo-m ~/test.raku \\(-1) \\(:foo((1,).Seq)) 一切都没有改变。所以，不是返回值\u0026hellip;\u0026hellip;想了想，不知道为什么结果又是 -1 而不是 (-1,).Seq。而且，从代码来看，Seq 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 METAOP_REVERSE 结果只是为了崩溃。\nsub METAOP_REVERSE(\\op) is implementation-detail { -\u0026gt; |args { die } } 编译、运行。\n\u0026gt; make [...] \u0026gt; ./rakudo-m ~/test.raku \\(-1) \\(:foo((1,).Seq)) 怎么会呢？语法树中包含了对 METAOP_REVERSE 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 -1。\n这些都不是《行动》。\n这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 --target=mast。\n\u0026gt; ./rakudo-m --target=mast ~/test.raku [...] MAST::Frame name\u0026lt;s\u0026gt;, cuuid\u0026lt;1\u0026gt; Local types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;int\u0026gt;, 5\u0026lt;str\u0026gt;, 6\u0026lt;obj\u0026gt;, 7\u0026lt;obj\u0026gt;, 8\u0026lt;obj\u0026gt;, Lexical types: 0\u0026lt;obj\u0026gt;, 1\u0026lt;obj\u0026gt;, 2\u0026lt;obj\u0026gt;, 3\u0026lt;obj\u0026gt;, 4\u0026lt;obj\u0026gt;, Lexical names: 0\u0026lt;c\u0026gt;, 1\u0026lt;$¢\u0026gt;, 2\u0026lt;$!\u0026gt;, 3\u0026lt;$/\u0026gt;, 4\u0026lt;$*DISPATCHER\u0026gt;, Lexical map: $!\u0026lt;2\u0026gt;, c\u0026lt;0\u0026gt;, $*DISPATCHER\u0026lt;4\u0026gt;, $¢\u0026lt;1\u0026gt;, $/\u0026lt;3\u0026gt;, Outer: name\u0026lt;\u0026lt;unit\u0026gt;\u0026gt;, cuuid\u0026lt;2\u0026gt; [...] 某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。\n\u0026gt; ./rakudo-m --target=optimize ~/test.raku [...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 [...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;7\u0026gt; s(:foo(3 Z- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;8\u0026gt; :before_promotion\u0026lt;?\u0026gt; Z- - QAST::Op(callstatic \u0026amp;METAOP_ZIP) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Var(lexical \u0026amp;METAOP_REDUCE_LEFT) - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::WVal(Int) - Ii - QAST::IVal(3) 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::WVal(Int) - Ii - QAST::IVal(2) 2 [...] 哈，就是这样。在优化阶段后，行将失踪。\n QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R-. 并将整个 METAOP_REVERSE 调用替换为通常的操作 (\u0026amp;infix:\u0026lt;-\u0026gt;)。所以问题一定在优化器的某个地方。  只有在 optim_nameless_call 方法中才会提到 \u0026amp;METAOP_ASSIGN，其中 QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;)。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 _ 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。\n[...] elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') { return NQPMu unless nqp::istype($metaop[0], QAST::Var) \u0026amp;\u0026amp; nqp::elems($op) == 3; return QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name), $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1; } [...] 让我提醒你，优化前的树是这样的。\n[...] - QAST::Op(call \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call :named\u0026lt;foo\u0026gt;) \u0026lt;wanted\u0026gt; :statement_id\u0026lt;5\u0026gt; :before_promotion\u0026lt;?\u0026gt; R- - QAST::Op(call \u0026amp;METAOP_REVERSE) \u0026lt;wanted\u0026gt; :is_pure\u0026lt;?\u0026gt; - QAST::Var(lexical \u0026amp;infix:\u0026lt;-\u0026gt;) \u0026lt;wanted\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 3 - QAST::Want \u0026lt;wanted\u0026gt; 2 [...] 而精简之后，是这样的。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op(call \u0026amp;infix:\u0026lt;-\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 [...] 也就是说，优化 _nameless_call 做了以下工作。\n如果我们的 QAST::Op+{QAST::SpecialArg} 操作没有三个参数，如果 METAOP_REVERSE 调用没有一个正确的类型，我们就返回空。这不是我们的情况。 否则，我们将返回一个新的操作，代替我们的 QAST::Op+{QAST::SpecialArg} 操作，以相反的顺序调用 \u0026amp;infix:\u0026lt;-\u0026gt; 参数。就是说，把结果打包成一对就没了。\n在摸索了一下如何解决这个问题，并阅读了 QAST::SpecialArg 和 QAST::Node 的实现后，我想到了下面的代码。\n[...] elsif self.op_eq_core($metaop, '\u0026amp;METAOP_REVERSE') { return NQPMu unless nqp::istype($metaop[0], QAST::Var) \u0026amp;\u0026amp; nqp::elems($op) == 3; my $opt_result := QAST::Op.new(:op\u0026lt;call\u0026gt;, :name($metaop[0].name), $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1; if $op.named { $opt_result.named($op.named) } # 添加选项 named if $op.flat { $opt_result.flat($op.flat) } # 添加选项 flat return $opt_result; } [...] 还有木头。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Op+{QAST::SpecialArg}(call \u0026amp;infix:\u0026lt;-\u0026gt; :named\u0026lt;foo\u0026gt;) :METAOP_opt_result\u0026lt;?\u0026gt; - QAST::Want \u0026lt;wanted\u0026gt; 2 - QAST::Want \u0026lt;wanted\u0026gt; 3 [...] 命名的参数返回到它的位置。测试也开始通过。\n\u0026gt; make t/spec/S03-metaops/reverse.t [...] All tests successful. Files=1, Tests=70, 3 wallclock secs ( 0.03 usr 0.01 sys + 3.61 cusr 0.17 csys = 3.82 CPU) Result: PASS 我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 self.visit_op: $opt_result;，对产生的非优化操作调用优化器，那么产生的树就会像这样。\n[...] - QAST::Op(callstatic \u0026amp;s) \u0026lt;sunk\u0026gt; :statement_id\u0026lt;4\u0026gt; s(:foo(3 R- 2)) - QAST::Want+{QAST::SpecialArg}(:named\u0026lt;foo\u0026gt;) - QAST::WVal+{QAST::SpecialArg}(Int :named\u0026lt;foo\u0026gt;) - QAST::IVal(-1) [...] 现在一切都很理想。\n分享成果 我们已经到了终点线。现在我们只需要分享我们的经验。\n 重要的是：运行所有的 make spectest 测试，确保没有新的东西被破坏。 在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。 将 fork 仓库添加为新的 git 远程仓库。 cd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git remote add fork 。 cd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git remote add fork 。  重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。\n提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。\n运行提交。\ncd ~/dev-rakudo/rakudo \u0026amp;\u0026amp; git push fork cd ~/dev-rakudo/t/spec \u0026amp;\u0026amp; git push fork 向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。\n结论 对开源软件的贡献是：\n 趣味性和趣味性。 给你的感觉是，你正在做一些有用的事情，你真的是。 让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 #raku IRC 频道中得到回答）。 解决非标准任务，没有截止日期的压力，是一种很好的体验。  选择你觉得最舒服的角色等级，去做新的任务吧!\n"},"name":"为最年轻的 Raku 贡献力量","published":"2021-02-16T00:00:00+08:00","summary":"Contributing to Raku","type":"entry","url":"https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/"},{"content":{"html":"\u003ch2 id=\"贪婪-junction-的奇闻异事\"\u003e贪婪 junction 的奇闻异事\u003c/h2\u003e\n\u003cp\u003e说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 有一个整洁的功能，叫做 \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 \u003ccode\u003epair\u003c/code\u003e 数据结构，它可以接受两个不同类型的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eenum RGB \u0026lt;R G B\u0026gt;;\n\n# Pair Constructor: the arguments of pair() are captured\n# in a closure that is returned\nsub pair(\\x, \\y) {\n    sub (\u0026amp;p){ p(x, y) } \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以 \u003ccode\u003epair\u003c/code\u003e 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 \u003ccode\u003epair\u003c/code\u003e 中的值。我将把这些访问(accessor)函数称为 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Accessors to get the values from the closure\nmy sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})}\nmy sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e做实际选择的函数是由 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 \u003ccode\u003epair\u003c/code\u003e，而不是必须将它们作为参数传递。让我们看一个例子，一个 \u003ccode\u003eInt\u003c/code\u003e 和一个 \u003ccode\u003eRGB\u003c/code\u003e 的 pair。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\p1 = pair 42, R;\n\nif ( 42 == fst p1) {\n    say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以我们用两个值调用 \u003ccode\u003epair\u003c/code\u003e 来创建一个 pair，并使用 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\u003c/p\u003e\n\u003cp\u003e现在让我们使用 junction 作为其中一个参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Example instance with a 'one'-type junction\nmy Junction \\p1j = pair (42^43),R;\n\nif ( 42 == fst p1j) {\n    say snd p1j; #=\u0026gt; one(R, R)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里发生的情况是，原始参数 \u003ccode\u003eR\u003c/code\u003e 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 \u003ccode\u003eR\u003c/code\u003e 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\"\u003e重构 Raku 的 Junction\u003c/a\u003e\u0026quot;。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/type/Junction\"\u003eRaku 关于 junction 的文档\u003c/a\u003e中说，你不应该真正尝试从 junction 中获取值。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，有一个 FAQ \u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e勉强地告诉你如何做\u003c/a\u003e。FAQ 再次警告不要这样做。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\u003c/p\u003e\n\u003cp\u003e因此，我建议增加一个折叠(\u003ccode\u003ecollapse\u003c/code\u003e)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif ( 42 == fst p1j) {\n    say collapse(snd p1j); #=\u0026gt; says 'R'\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该函数的实现取自\u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e上述常见问题\u003c/a\u003e，并增加了一个检查，以确保 junction 上的所有值都相同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub collapse(Junction \\j) {    \n    my @vvs;\n    -\u0026gt; Any \\s { push @vvs, s }.(j);    \n    my $v =  shift @vvs;        \n    my @ts = grep {!($_ ~~ $v)}, @vvs;\n    if (@ts.elems==0) {  \n        $v\n    } else {\n        die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果能把这个功能作为一个 \u003ccode\u003ecollapse\u003c/code\u003e 方法添加到 \u003ccode\u003eJunction\u003c/code\u003e 类中就更好了。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003ehttps://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\u003c/a\u003e\u003c/p\u003e\n","text":"贪婪 junction 的奇闻异事 说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\nRaku 有一个整洁的功能，叫做 Junction。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 pair 数据结构，它可以接受两个不同类型的值。\nenum RGB \u0026lt;R G B\u0026gt;; # Pair Constructor: the arguments of pair() are captured # in a closure that is returned sub pair(\\x, \\y) { sub (\u0026amp;p){ p(x, y) } } 所以 pair 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 pair 中的值。我将把这些访问(accessor)函数称为 fst 和 snd。\n# Accessors to get the values from the closure my sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})} my sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})} 做实际选择的函数是由 fst 和 snd 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 pair，而不是必须将它们作为参数传递。让我们看一个例子，一个 Int 和一个 RGB 的 pair。\nmy \\p1 = pair 42, R; if ( 42 == fst p1) { say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot; } 所以我们用两个值调用 pair 来创建一个 pair，并使用 fst 和 snd 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\n现在让我们使用 junction 作为其中一个参数。\n# Example instance with a 'one'-type junction my Junction \\p1j = pair (42^43),R; if ( 42 == fst p1j) { say snd p1j; #=\u0026gt; one(R, R) } 这里发生的情况是，原始参数 R 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 R 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;重构 Raku 的 Junction\u0026quot;。\nRaku 关于 junction 的文档中说，你不应该真正尝试从 junction 中获取值。\n\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\n然而，有一个 FAQ 勉强地告诉你如何做。FAQ 再次警告不要这样做。\n\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\n然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\n因此，我建议增加一个折叠(collapse)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\nif ( 42 == fst p1j) { say collapse(snd p1j); #=\u0026gt; says 'R' } 该函数的实现取自上述常见问题，并增加了一个检查，以确保 junction 上的所有值都相同。\nsub collapse(Junction \\j) { my @vvs; -\u0026gt; Any \\s { push @vvs, s }.(j); my $v = shift @vvs; my @ts = grep {!($_ ~~ $v)}, @vvs; if (@ts.elems==0) { $v } else { die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;; } } 如果能把这个功能作为一个 collapse 方法添加到 Junction 类中就更好了。\n原文链接: https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\n"},"name":"贪婪 Junction 的奇闻异事","published":"2020-10-04T00:00:00+08:00","summary":"The Strange Case of the Greedy Junction","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/"},{"content":{"html":"\u003ch2 id=\"重构-raku-的-junction\"\u003e重构 Raku 的 Junction\u003c/h2\u003e\n\u003cp\u003eRaku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。\u003c/p\u003e\n\u003ch3 id=\"raku-中的-junction\"\u003eRaku 中的 Junction\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/\"\u003eRaku\u003c/a\u003e 有一个整洁的功能叫做 \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(\u003ccode\u003e\u0026amp;\u003c/code\u003e)、any(\u003ccode\u003e|\u003c/code\u003e)、one(\u003ccode\u003e^\u003c/code\u003e) 或 \u003ccode\u003enone\u003c/code\u003e (空结点)。\u003c/p\u003e\n\u003cp\u003e例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $j = 11|22; # short for any(11,22)\nif 33 == $j + 11 {\n    say 'yes';\n}\n\nsay so 3 == (1..30).one;         #=\u0026gt; True \nsay so (\u0026quot;a\u0026quot; ^ \u0026quot;b\u0026quot; ^ \u0026quot;c\u0026quot;) eq \u0026quot;a\u0026quot;; #=\u0026gt; True\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e函数 \u003ccode\u003eso\u003c/code\u003e 强制使用布尔上下文。\u003c/p\u003e\n\u003cp\u003eJunction 有 \u003ccode\u003eJunction\u003c/code\u003e 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 \u003ccode\u003esq\u003c/code\u003e 从 \u003ccode\u003eInt\u003c/code\u003e 到 \u003ccode\u003eInt\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sq(Int $x --\u0026gt; Int) { $x*$x }\n\nmy Int $res = sq(11); # OK\nsay $res; #=\u0026gt; 121\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在让我们定义一个类型为任何 \u003ccode\u003eInt\u003c/code\u003e 值的 Junction。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $j = 11 | 22; \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我们将 \u003ccode\u003esq\u003c/code\u003e 应用于 \u003ccode\u003e$j\u003c/code\u003e 时，我们没有得到一个类型错误，即使函数的类型是 \u003ccode\u003e:(Int --\u0026gt; Int)\u003c/code\u003e，Junction 的类型是 \u003ccode\u003eJunction\u003c/code\u003e。相反，我们得到的是一个结果的 Junction。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esay sq($j); #=\u0026gt; any(121, 484)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果我们像之前一样将其赋值给一个类型为 \u003ccode\u003eInt\u003c/code\u003e 的变量，我们会得到一个类型错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Int $rj = sq($j); #=\u0026gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e取而代之的是，现在返回值的类型为 \u003ccode\u003eJunction\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $rj = sq(11|22); # OK\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。\u003c/p\u003e\n\u003cp\u003e另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 \u003ccode\u003eJunction\u003c/code\u003e 类型。例如，如果我们创建了一个由 \u003ccode\u003eStr\u003c/code\u003e 值组成的 Junction，并试图将这个 Junction 的值传递到 \u003ccode\u003esq\u003c/code\u003e 中，我们会得到一个类型错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $sj = '11' | '22';\nsay $sj.WHAT; #=\u0026gt;(Junction)\n\nmy Junction $svj = sq($sj); #=\u0026gt; Type check failed in binding to parameter 'x'; expected Int but got Str (\u0026quot;11\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"junction-不遵循静态类型规则\"\u003eJunction 不遵循静态类型规则\u003c/h3\u003e\n\u003cp\u003e虽然这样做是有道理的(如果原始函数期望使用 \u003ccode\u003eInt\u003c/code\u003e，我们不希望它与 \u003ccode\u003eStr\u003c/code\u003e 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 \u003ccode\u003eInt\u003c/code\u003e，那么可以使用类型图中低于它的任何类型来代替。但是 \u003ccode\u003eInt\u003c/code\u003e 和 \u003ccode\u003eJunction\u003c/code\u003e 的简化类型图如下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eInt -\u0026gt; Cool -\u0026gt; Any -\u0026gt; Mu \u0026lt;- Junction\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以 Junction 永远不是 \u003ccode\u003eAny\u003c/code\u003e 以下任何东西的子类型。因此，将 Junction 放在类型为 \u003ccode\u003eAny\u003c/code\u003e 或其子类型的槽中应该是一个类型错误。\u003c/p\u003e\n\u003cp\u003e此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。\u003c/p\u003e\n\u003cp\u003e那么这里到底发生了什么？\u003c/p\u003e\n\u003ch3 id=\"一个工作假设\"\u003e一个工作假设\u003c/h3\u003e\n\u003cp\u003e一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。\u003c/p\u003e\n\u003ch3 id=\"重构-junction-的第一部分类型\"\u003e重构 Junction 的第一部分：类型\u003c/h3\u003e\n\u003cp\u003e让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。\u003c/p\u003e\n\u003ch4 id=\"junction-类型\"\u003eJunction 类型\u003c/h4\u003e\n\u003cp\u003eJunction 是一个由 Junction 类型 \u003ccode\u003eJType\u003c/code\u003e 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003edata JType = JAny | JAll | JOne | JNone\n\ndata Junction a = Junction JType [a]\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"应用结点\"\u003e应用结点\u003c/h4\u003e\n\u003cp\u003e对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将非 Junction 函数应用于 Junction 表达式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(•￮) :: (a -\u0026gt; b) -\u0026gt; Junction a -\u0026gt;  Junction b\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e将 Junction 函数应用于非 Junction 表达式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(￮•) ::  Junction (b -\u0026gt; c) -\u0026gt; b -\u0026gt; Junction c\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(￮￮) ::  Junction (b -\u0026gt; c) -\u0026gt; Junction b -\u0026gt; Junction (Junction c)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e-- and similar for /-, \u0026gt;, \u0026lt;, \u0026lt;=,\u0026gt;=\n(￮==•) :: Junction a -\u0026gt; a -\u0026gt; Bool\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"折叠-junction\"\u003e折叠 Junction\u003c/h4\u003e\n\u003cp\u003e那么我们就有了 \u003ccode\u003eso\u003c/code\u003e，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eso :: Junction Bool -\u0026gt; Bool\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后我们有 \u003ccode\u003ecollapse\u003c/code\u003e，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003ecollapse :: (Show a,Eq a) =\u0026gt; Junction a -\u0026gt; a\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在\u0026quot;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的奇怪情况\u003c/a\u003e\u0026ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。\u003c/p\u003e\n\u003ch4 id=\"重新审视贪婪-junction-的奇怪情况\"\u003e重新审视贪婪 Junction 的奇怪情况\u003c/h4\u003e\n\u003cp\u003e假设我们有一个两个参数的函数 \u003ccode\u003ef :: a -\u0026gt; b -\u0026gt; c\u003c/code\u003e，我们对第一个参数应用一个结点 \u003ccode\u003ej :: Junction\u003c/code\u003e a 应用到第一个参数 \u003ccode\u003ef •￮ j\u003c/code\u003e 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：\u003ccode\u003efp :: Junction b -\u0026gt; c\u003c/code\u003e。如果我们现在想用 \u003ccode\u003efp ￮• v\u003c/code\u003e 将这个函数应用于一个非结点的值 \u003ccode\u003ev :: b\u003c/code\u003e，那么结果就是 \u003ccode\u003eJunction c\u003c/code\u003e 类型的。\u003c/p\u003e\n\u003cp\u003e现在，让我们考虑类型 \u003ccode\u003ec\u003c/code\u003e 是 \u003ccode\u003eforall d . (a -\u0026gt; b -\u0026gt; d) -\u0026gt; d\u003c/code\u003e 的特殊情况。所以我们有 \u003ccode\u003eJunction\u003c/code\u003e(\u003ccode\u003eforall d . (a-\u0026gt;b-\u0026gt;d) -\u0026gt; d\u003c/code\u003e)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 \u003ccode\u003eforall\u003c/code\u003e，所以 \u003ccode\u003ed\u003c/code\u003e 可以是任何东西，但在实践中我们希望它是 \u003ccode\u003ea\u003c/code\u003e 或 \u003ccode\u003eb\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e假设我们将这个函数(称它为 \u003ccode\u003ep\u003c/code\u003e)应用于 \u003ccode\u003efst :: a-\u0026gt;b-\u0026gt;a\u003c/code\u003e，使用 \u003ccode\u003ep ￮• fst\u003c/code\u003e，那么我们得到 \u003ccode\u003eJunction a\u003c/code\u003e。但是如果我们将它应用于 \u003ccode\u003esnd :: a-\u0026gt;b-\u0026gt;b\u003c/code\u003e，使用 \u003ccode\u003ep ￮• snd\u003c/code\u003e，那么我们得到 \u003ccode\u003eJunction b\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在\u0026rdquo;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的奇怪情况\u003c/a\u003e\u0026ldquo;中已经解释过。而这也是我们需要 \u003ccode\u003ecollapse\u003c/code\u003e 函数的原因。\u003c/p\u003e\n\u003ch4 id=\"重构-junction-的第2部分raku-的实现\"\u003e重构 Junction 的第2部分：Raku 的实现。\u003c/h4\u003e\n\u003cp\u003e我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# The types of Junctions\nenum JType \u0026lt;JAny  JAll  JOne  JNone \u0026gt;;\n\n# The actual Junction type\nrole Junction[\\jt, @vs] {\n    has JType $.junction-type=jt;\n    has @.values=@vs;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub all_(@vs) {\n    Junction[ JAll, @vs].new;\n}\n\nour sub any_(@vs) {\n    Junction[ JAny, @vs].new;\n}\n\nour sub one_(@vs) {\n    Junction[ JOne, @vs].new;\n}\n\nour sub none_(@vs) {\n    Junction[ JNone, @vs].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将一个（单参数）函数应用于 junction 参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;●○\u0026gt;( \u0026amp;f, \\j ) is export {\n    my \\jt=j.junction-type; \n    my @vs = j.values;\n  \n    Junction[ jt, map( {\u0026amp;f($_)}, @vs)].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e要将 Junction 内的函数应用于非 Junction 的参数:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;○●\u0026gt;( \\jf, \\v ) is export {\n    my \\jt=jf.junction-type; \n    my @fs = jf.values;\n\n    Junction[ jt, map( {$_( v)}, @fs)].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;○○\u0026gt;( \\jf, \\jv ) is export {\n    my \\jft= jf.junction-type; \n    my @fs = jf.values;\n    my \\jvt = jv.junction-type;\n    my @vs = jv.values;\n    if (jvt == JAll and jft != JAll) {        \n        Junction[ jvt, map( sub (\\v){jf ○● v}, @vs)].new;  \n    } else {        \n        Junction[ jft, map( sub (\u0026amp;f){ \u0026amp;f ●○ jv}, @fs)].new;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了完整，这里是 \u003ccode\u003e○==●\u003c/code\u003e 的定义。\u003ccode\u003e○!=●\u003c/code\u003e、\u003ccode\u003e○\u0026gt;●\u003c/code\u003e 等的定义是类似的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt; ○==● \u0026gt;( \\j, \\v ) is export {\n    sub (\\x){x==v} ●○ j\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来我们有 \u003ccode\u003eso\u003c/code\u003e，它把布尔值的 junction 变成了布尔值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub so (\\jv) { \n    my @vs = jv.values;\n    given jv.junction-type {\n        when JAny { elems(grep {$_},  @vs) \u0026gt;0}\n        when JAll { elems(grep {!$_}, @vs)==0}\n        when JOne { elems(grep {$_},  @vs)==1}\n        when JOne { elems(grep {$_},  @vs)==0}\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后我们有 \u003ccode\u003ecollapse\u003c/code\u003e，正如\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的文章\u003c/a\u003e中所定义的那样， \u003ccode\u003ecollapse\u003c/code\u003e 返回 Junction 的值，只要它们都是一样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub collapse( \\j ) {\n    my \\jt=j.junction-type; \n    my @vvs = j.values;\n    my $v =  shift @vvs;        \n    my @ts = grep {!($_ ~~ $v)}, @vvs;\n    if (@ts.elems==0) {  \n        $v\n    } else {\n        die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"junction-清理\"\u003eJunction 清理\u003c/h3\u003e\n\u003cp\u003e现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sq(Int $x --\u0026gt; Int) { $x*$x }\nmy Junction $j = 11 | 22; \nmy Junction $rj = sq($j); \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e去语法塘后这变成了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $j = any_ [11,22];\nmy Junction $rj = \u0026amp;sq ●○ $j;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e类似地,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif ($j == 42) {...} \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e变成了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif (so ($j ○==● 42)) {...}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e和其他布尔上下文类似。\u003c/p\u003e\n\u003cp\u003e如果我们仔细看\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 文章\u003c/a\u003e中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction \\p1j = pair R,(42^43);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e去语法塘后变为:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction \\p1j = \u0026amp;pair.assuming(R) ●○ one_ [42,43];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们使用 \u003ccode\u003e.assuming()\u003c/code\u003e 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\p1jr = ( sub ($y){ \u0026amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后，举一个两个参数都是 Junction 的例子。由于 \u003ccode\u003e○○\u003c/code\u003e 的定义，应用的顺序并不重要。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub m(\\x,\\y){x*y}\n\nmy \\p4 = ( sub (\\x){ \u0026amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44];\nmy \\p4r = ( sub (\\x){ \u0026amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22];\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"结论\"\u003e结论\u003c/h3\u003e\n\u003cp\u003e从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\"\u003ehttps://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\u003c/a\u003e\u003c/p\u003e\n","text":"重构 Raku 的 Junction Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。\nRaku 中的 Junction Raku 有一个整洁的功能叫做 Junction。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(\u0026amp;)、any(|)、one(^) 或 none (空结点)。\n例如:\nmy $j = 11|22; # short for any(11,22) if 33 == $j + 11 { say 'yes'; } say so 3 == (1..30).one; #=\u0026gt; True say so (\u0026quot;a\u0026quot; ^ \u0026quot;b\u0026quot; ^ \u0026quot;c\u0026quot;) eq \u0026quot;a\u0026quot;; #=\u0026gt; True 函数 so 强制使用布尔上下文。\nJunction 有 Junction 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 sq 从 Int 到 Int。\nsub sq(Int $x --\u0026gt; Int) { $x*$x } my Int $res = sq(11); # OK say $res; #=\u0026gt; 121 现在让我们定义一个类型为任何 Int 值的 Junction。\nmy Junction $j = 11 | 22; 当我们将 sq 应用于 $j 时，我们没有得到一个类型错误，即使函数的类型是 :(Int --\u0026gt; Int)，Junction 的类型是 Junction。相反，我们得到的是一个结果的 Junction。\nsay sq($j); #=\u0026gt; any(121, 484) 如果我们像之前一样将其赋值给一个类型为 Int 的变量，我们会得到一个类型错误。\nmy Int $rj = sq($j); #=\u0026gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484)) 取而代之的是，现在返回值的类型为 Junction。\nmy Junction $rj = sq(11|22); # OK 所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。\n另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 Junction 类型。例如，如果我们创建了一个由 Str 值组成的 Junction，并试图将这个 Junction 的值传递到 sq 中，我们会得到一个类型错误。\nmy $sj = '11' | '22'; say $sj.WHAT; #=\u0026gt;(Junction) my Junction $svj = sq($sj); #=\u0026gt; Type check failed in binding to parameter 'x'; expected Int but got Str (\u0026quot;11\u0026quot;) Junction 不遵循静态类型规则 虽然这样做是有道理的(如果原始函数期望使用 Int，我们不希望它与 Str 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 Int，那么可以使用类型图中低于它的任何类型来代替。但是 Int 和 Junction 的简化类型图如下。\nInt -\u0026gt; Cool -\u0026gt; Any -\u0026gt; Mu \u0026lt;- Junction  所以 Junction 永远不是 Any 以下任何东西的子类型。因此，将 Junction 放在类型为 Any 或其子类型的槽中应该是一个类型错误。\n此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。\n那么这里到底发生了什么？\n一个工作假设 一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。\n重构 Junction 的第一部分：类型 让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。\nJunction 类型 Junction 是一个由 Junction 类型 JType 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。\ndata JType = JAny | JAll | JOne | JNone data Junction a = Junction JType [a] 应用结点 对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。\n 将非 Junction 函数应用于 Junction 表达式  (•￮) :: (a -\u0026gt; b) -\u0026gt; Junction a -\u0026gt; Junction b  将 Junction 函数应用于非 Junction 表达式。  (￮•) :: Junction (b -\u0026gt; c) -\u0026gt; b -\u0026gt; Junction c  将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。  (￮￮) :: Junction (b -\u0026gt; c) -\u0026gt; Junction b -\u0026gt; Junction (Junction c) 为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。\n-- and similar for /-, \u0026gt;, \u0026lt;, \u0026lt;=,\u0026gt;= (￮==•) :: Junction a -\u0026gt; a -\u0026gt; Bool 折叠 Junction 那么我们就有了 so，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。\nso :: Junction Bool -\u0026gt; Bool 最后我们有 collapse，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。\ncollapse :: (Show a,Eq a) =\u0026gt; Junction a -\u0026gt; a 这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在\u0026quot;贪婪 Junction 的奇怪情况\u0026ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。\n重新审视贪婪 Junction 的奇怪情况 假设我们有一个两个参数的函数 f :: a -\u0026gt; b -\u0026gt; c，我们对第一个参数应用一个结点 j :: Junction a 应用到第一个参数 f •￮ j 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：fp :: Junction b -\u0026gt; c。如果我们现在想用 fp ￮• v 将这个函数应用于一个非结点的值 v :: b，那么结果就是 Junction c 类型的。\n现在，让我们考虑类型 c 是 forall d . (a -\u0026gt; b -\u0026gt; d) -\u0026gt; d 的特殊情况。所以我们有 Junction(forall d . (a-\u0026gt;b-\u0026gt;d) -\u0026gt; d)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 forall，所以 d 可以是任何东西，但在实践中我们希望它是 a 或 b。\n假设我们将这个函数(称它为 p)应用于 fst :: a-\u0026gt;b-\u0026gt;a，使用 p ￮• fst，那么我们得到 Junction a。但是如果我们将它应用于 snd :: a-\u0026gt;b-\u0026gt;b，使用 p ￮• snd，那么我们得到 Junction b。\n这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在\u0026rdquo;贪婪 Junction 的奇怪情况\u0026ldquo;中已经解释过。而这也是我们需要 collapse 函数的原因。\n重构 Junction 的第2部分：Raku 的实现。 我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。\n# The types of Junctions enum JType \u0026lt;JAny JAll JOne JNone \u0026gt;; # The actual Junction type role Junction[\\jt, @vs] { has JType $.junction-type=jt; has @.values=@vs; } 接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。\nour sub all_(@vs) { Junction[ JAll, @vs].new; } our sub any_(@vs) { Junction[ JAny, @vs].new; } our sub one_(@vs) { Junction[ JOne, @vs].new; } our sub none_(@vs) { Junction[ JNone, @vs].new; } 将一个（单参数）函数应用于 junction 参数。\nsub infix:\u0026lt;●○\u0026gt;( \u0026amp;f, \\j ) is export { my \\jt=j.junction-type; my @vs = j.values; Junction[ jt, map( {\u0026amp;f($_)}, @vs)].new; } 要将 Junction 内的函数应用于非 Junction 的参数:\nsub infix:\u0026lt;○●\u0026gt;( \\jf, \\v ) is export { my \\jt=jf.junction-type; my @fs = jf.values; Junction[ jt, map( {$_( v)}, @fs)].new; } 将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。\nsub infix:\u0026lt;○○\u0026gt;( \\jf, \\jv ) is export { my \\jft= jf.junction-type; my @fs = jf.values; my \\jvt = jv.junction-type; my @vs = jv.values; if (jvt == JAll and jft != JAll) { Junction[ jvt, map( sub (\\v){jf ○● v}, @vs)].new; } else { Junction[ jft, map( sub (\u0026amp;f){ \u0026amp;f ●○ jv}, @fs)].new; } } 为了完整，这里是 ○==● 的定义。○!=●、○\u0026gt;● 等的定义是类似的。\nsub infix:\u0026lt; ○==● \u0026gt;( \\j, \\v ) is export { sub (\\x){x==v} ●○ j } 接下来我们有 so，它把布尔值的 junction 变成了布尔值。\nour sub so (\\jv) { my @vs = jv.values; given jv.junction-type { when JAny { elems(grep {$_}, @vs) \u0026gt;0} when JAll { elems(grep {!$_}, @vs)==0} when JOne { elems(grep {$_}, @vs)==1} when JOne { elems(grep {$_}, @vs)==0} } } 最后我们有 collapse，正如贪婪 Junction 的文章中所定义的那样， collapse 返回 Junction 的值，只要它们都是一样的。\nour sub collapse( \\j ) { my \\jt=j.junction-type; my @vvs = j.values; my $v = shift @vvs; my @ts = grep {!($_ ~~ $v)}, @vvs; if (@ts.elems==0) { $v } else { die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;; } } Junction 清理 现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。\nsub sq(Int $x --\u0026gt; Int) { $x*$x } my Junction $j = 11 | 22; my Junction $rj = sq($j); 去语法塘后这变成了:\nmy Junction $j = any_ [11,22]; my Junction $rj = \u0026amp;sq ●○ $j; 类似地,\nif ($j == 42) {...} 变成了:\nif (so ($j ○==● 42)) {...} 和其他布尔上下文类似。\n如果我们仔细看贪婪 Junction 文章中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:\nmy Junction \\p1j = pair R,(42^43); 去语法塘后变为:\nmy Junction \\p1j = \u0026amp;pair.assuming(R) ●○ one_ [42,43]; 我们使用 .assuming() 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。\nmy \\p1jr = ( sub ($y){ \u0026amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R; 最后，举一个两个参数都是 Junction 的例子。由于 ○○ 的定义，应用的顺序并不重要。\nsub m(\\x,\\y){x*y} my \\p4 = ( sub (\\x){ \u0026amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44]; my \\p4r = ( sub (\\x){ \u0026amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22]; 结论 从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。\n原文链接: https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\n"},"name":"重构 Raku 的 Junction","published":"2020-10-04T00:00:00+08:00","summary":"Reconstructing Raku\u0026rsquo;s Junctions","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/"}],"name":"rakulang","type":"feed","url":"https://ohmyweekly.github.io/categories/rakulang/"}