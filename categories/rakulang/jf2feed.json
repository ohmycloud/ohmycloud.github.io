{"author":{"name":null,"type":"card","url":"https://ohmyweekly.github.io"},"children":[{"content":{"html":"\u003ch2 id=\"贪婪-junction-的奇闻异事\"\u003e贪婪 junction 的奇闻异事\u003c/h2\u003e\n\u003cp\u003e说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://raku.org/\"\u003eRaku\u003c/a\u003e 有一个整洁的功能，叫做 \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 \u003ccode\u003epair\u003c/code\u003e 数据结构，它可以接受两个不同类型的值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eenum RGB \u0026lt;R G B\u0026gt;;\n\n# Pair Constructor: the arguments of pair() are captured\n# in a closure that is returned\nsub pair(\\x, \\y) {\n    sub (\u0026amp;p){ p(x, y) } \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以 \u003ccode\u003epair\u003c/code\u003e 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 \u003ccode\u003epair\u003c/code\u003e 中的值。我将把这些访问(accessor)函数称为 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Accessors to get the values from the closure\nmy sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})}\nmy sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e做实际选择的函数是由 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 \u003ccode\u003epair\u003c/code\u003e，而不是必须将它们作为参数传递。让我们看一个例子，一个 \u003ccode\u003eInt\u003c/code\u003e 和一个 \u003ccode\u003eRGB\u003c/code\u003e 的 pair。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\p1 = pair 42, R;\n\nif ( 42 == fst p1) {\n    say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以我们用两个值调用 \u003ccode\u003epair\u003c/code\u003e 来创建一个 pair，并使用 \u003ccode\u003efst\u003c/code\u003e 和 \u003ccode\u003esnd\u003c/code\u003e 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\u003c/p\u003e\n\u003cp\u003e现在让我们使用 junction 作为其中一个参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# Example instance with a 'one'-type junction\nmy Junction \\p1j = pair (42^43),R;\n\nif ( 42 == fst p1j) {\n    say snd p1j; #=\u0026gt; one(R, R)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里发生的情况是，原始参数 \u003ccode\u003eR\u003c/code\u003e 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 \u003ccode\u003eR\u003c/code\u003e 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\"\u003e重构 Raku 的 Junction\u003c/a\u003e\u0026quot;。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/type/Junction\"\u003eRaku 关于 junction 的文档\u003c/a\u003e中说，你不应该真正尝试从 junction 中获取值。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，有一个 FAQ \u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e勉强地告诉你如何做\u003c/a\u003e。FAQ 再次警告不要这样做。\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\u003c/p\u003e\n\u003cp\u003e因此，我建议增加一个折叠(\u003ccode\u003ecollapse\u003c/code\u003e)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif ( 42 == fst p1j) {\n    say collapse(snd p1j); #=\u0026gt; says 'R'\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该函数的实现取自\u003ca href=\"https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)\"\u003e上述常见问题\u003c/a\u003e，并增加了一个检查，以确保 junction 上的所有值都相同。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub collapse(Junction \\j) {    \n    my @vvs;\n    -\u0026gt; Any \\s { push @vvs, s }.(j);    \n    my $v =  shift @vvs;        \n    my @ts = grep {!($_ ~~ $v)}, @vvs;\n    if (@ts.elems==0) {  \n        $v\n    } else {\n        die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果能把这个功能作为一个 \u003ccode\u003ecollapse\u003c/code\u003e 方法添加到 \u003ccode\u003eJunction\u003c/code\u003e 类中就更好了。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003ehttps://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\u003c/a\u003e\u003c/p\u003e\n","text":"贪婪 junction 的奇闻异事 说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。\nRaku 有一个整洁的功能，叫做 Junction。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 pair 数据结构，它可以接受两个不同类型的值。\nenum RGB \u0026lt;R G B\u0026gt;; # Pair Constructor: the arguments of pair() are captured # in a closure that is returned sub pair(\\x, \\y) { sub (\u0026amp;p){ p(x, y) } } 所以 pair 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 pair 中的值。我将把这些访问(accessor)函数称为 fst 和 snd。\n# Accessors to get the values from the closure my sub fst (\u0026amp;p) {p( sub (\\x,\\y){x})} my sub snd (\u0026amp;p) {p( sub (\\x,\\y){y})} 做实际选择的函数是由 fst 和 snd 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 pair，而不是必须将它们作为参数传递。让我们看一个例子，一个 Int 和一个 RGB 的 pair。\nmy \\p1 = pair 42, R; if ( 42 == fst p1) { say snd p1;\t#=\u0026gt; says \u0026quot;R\u0026quot; } 所以我们用两个值调用 pair 来创建一个 pair，并使用 fst 和 snd 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。\n现在让我们使用 junction 作为其中一个参数。\n# Example instance with a 'one'-type junction my Junction \\p1j = pair (42^43),R; if ( 42 == fst p1j) { say snd p1j; #=\u0026gt; one(R, R) } 这里发生的情况是，原始参数 R 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 R 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章\u0026quot;重构 Raku 的 Junction\u0026quot;。\nRaku 关于 junction 的文档中说，你不应该真正尝试从 junction 中获取值。\n\u0026ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。\u0026rdquo;\n然而，有一个 FAQ 勉强地告诉你如何做。FAQ 再次警告不要这样做。\n\u0026ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。\u0026rdquo;\n然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。\n因此，我建议增加一个折叠(collapse)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。\nif ( 42 == fst p1j) { say collapse(snd p1j); #=\u0026gt; says 'R' } 该函数的实现取自上述常见问题，并增加了一个检查，以确保 junction 上的所有值都相同。\nsub collapse(Junction \\j) { my @vvs; -\u0026gt; Any \\s { push @vvs, s }.(j); my $v = shift @vvs; my @ts = grep {!($_ ~~ $v)}, @vvs; if (@ts.elems==0) { $v } else { die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;; } } 如果能把这个功能作为一个 collapse 方法添加到 Junction 类中就更好了。\n原文链接: https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\n"},"name":"贪婪 Junction 的奇闻异事","published":"2020-10-04T00:00:00+08:00","summary":"The Strange Case of the Greedy Junction","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/"},{"content":{"html":"\u003ch2 id=\"重构-raku-的-junction\"\u003e重构 Raku 的 Junction\u003c/h2\u003e\n\u003cp\u003eRaku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。\u003c/p\u003e\n\u003ch3 id=\"raku-中的-junction\"\u003eRaku 中的 Junction\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://docs.raku.org/\"\u003eRaku\u003c/a\u003e 有一个整洁的功能叫做 \u003ca href=\"https://docs.raku.org/type/Junction\"\u003eJunction\u003c/a\u003e。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(\u003ccode\u003e\u0026amp;\u003c/code\u003e)、any(\u003ccode\u003e|\u003c/code\u003e)、one(\u003ccode\u003e^\u003c/code\u003e) 或 \u003ccode\u003enone\u003c/code\u003e (空结点)。\u003c/p\u003e\n\u003cp\u003e例如:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $j = 11|22; # short for any(11,22)\nif 33 == $j + 11 {\n    say 'yes';\n}\n\nsay so 3 == (1..30).one;         #=\u0026gt; True \nsay so (\u0026quot;a\u0026quot; ^ \u0026quot;b\u0026quot; ^ \u0026quot;c\u0026quot;) eq \u0026quot;a\u0026quot;; #=\u0026gt; True\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e函数 \u003ccode\u003eso\u003c/code\u003e 强制使用布尔上下文。\u003c/p\u003e\n\u003cp\u003eJunction 有 \u003ccode\u003eJunction\u003c/code\u003e 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 \u003ccode\u003esq\u003c/code\u003e 从 \u003ccode\u003eInt\u003c/code\u003e 到 \u003ccode\u003eInt\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sq(Int $x --\u0026gt; Int) { $x*$x }\n\nmy Int $res = sq(11); # OK\nsay $res; #=\u0026gt; 121\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在让我们定义一个类型为任何 \u003ccode\u003eInt\u003c/code\u003e 值的 Junction。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $j = 11 | 22; \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当我们将 \u003ccode\u003esq\u003c/code\u003e 应用于 \u003ccode\u003e$j\u003c/code\u003e 时，我们没有得到一个类型错误，即使函数的类型是 \u003ccode\u003e:(Int --\u0026gt; Int)\u003c/code\u003e，Junction 的类型是 \u003ccode\u003eJunction\u003c/code\u003e。相反，我们得到的是一个结果的 Junction。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esay sq($j); #=\u0026gt; any(121, 484)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果我们像之前一样将其赋值给一个类型为 \u003ccode\u003eInt\u003c/code\u003e 的变量，我们会得到一个类型错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Int $rj = sq($j); #=\u0026gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e取而代之的是，现在返回值的类型为 \u003ccode\u003eJunction\u003c/code\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $rj = sq(11|22); # OK\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。\u003c/p\u003e\n\u003cp\u003e另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 \u003ccode\u003eJunction\u003c/code\u003e 类型。例如，如果我们创建了一个由 \u003ccode\u003eStr\u003c/code\u003e 值组成的 Junction，并试图将这个 Junction 的值传递到 \u003ccode\u003esq\u003c/code\u003e 中，我们会得到一个类型错误。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy $sj = '11' | '22';\nsay $sj.WHAT; #=\u0026gt;(Junction)\n\nmy Junction $svj = sq($sj); #=\u0026gt; Type check failed in binding to parameter 'x'; expected Int but got Str (\u0026quot;11\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"junction-不遵循静态类型规则\"\u003eJunction 不遵循静态类型规则\u003c/h3\u003e\n\u003cp\u003e虽然这样做是有道理的(如果原始函数期望使用 \u003ccode\u003eInt\u003c/code\u003e，我们不希望它与 \u003ccode\u003eStr\u003c/code\u003e 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 \u003ccode\u003eInt\u003c/code\u003e，那么可以使用类型图中低于它的任何类型来代替。但是 \u003ccode\u003eInt\u003c/code\u003e 和 \u003ccode\u003eJunction\u003c/code\u003e 的简化类型图如下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eInt -\u0026gt; Cool -\u0026gt; Any -\u0026gt; Mu \u0026lt;- Junction\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以 Junction 永远不是 \u003ccode\u003eAny\u003c/code\u003e 以下任何东西的子类型。因此，将 Junction 放在类型为 \u003ccode\u003eAny\u003c/code\u003e 或其子类型的槽中应该是一个类型错误。\u003c/p\u003e\n\u003cp\u003e此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。\u003c/p\u003e\n\u003cp\u003e那么这里到底发生了什么？\u003c/p\u003e\n\u003ch3 id=\"一个工作假设\"\u003e一个工作假设\u003c/h3\u003e\n\u003cp\u003e一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。\u003c/p\u003e\n\u003ch3 id=\"重构-junction-的第一部分类型\"\u003e重构 Junction 的第一部分：类型\u003c/h3\u003e\n\u003cp\u003e让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。\u003c/p\u003e\n\u003ch4 id=\"junction-类型\"\u003eJunction 类型\u003c/h4\u003e\n\u003cp\u003eJunction 是一个由 Junction 类型 \u003ccode\u003eJType\u003c/code\u003e 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003edata JType = JAny | JAll | JOne | JNone\n\ndata Junction a = Junction JType [a]\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"应用结点\"\u003e应用结点\u003c/h4\u003e\n\u003cp\u003e对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将非 Junction 函数应用于 Junction 表达式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(•￮) :: (a -\u0026gt; b) -\u0026gt; Junction a -\u0026gt;  Junction b\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e将 Junction 函数应用于非 Junction 表达式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(￮•) ::  Junction (b -\u0026gt; c) -\u0026gt; b -\u0026gt; Junction c\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e(￮￮) ::  Junction (b -\u0026gt; c) -\u0026gt; Junction b -\u0026gt; Junction (Junction c)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e-- and similar for /-, \u0026gt;, \u0026lt;, \u0026lt;=,\u0026gt;=\n(￮==•) :: Junction a -\u0026gt; a -\u0026gt; Bool\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"折叠-junction\"\u003e折叠 Junction\u003c/h4\u003e\n\u003cp\u003e那么我们就有了 \u003ccode\u003eso\u003c/code\u003e，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eso :: Junction Bool -\u0026gt; Bool\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后我们有 \u003ccode\u003ecollapse\u003c/code\u003e，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003ecollapse :: (Show a,Eq a) =\u0026gt; Junction a -\u0026gt; a\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在\u0026quot;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的奇怪情况\u003c/a\u003e\u0026ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。\u003c/p\u003e\n\u003ch4 id=\"重新审视贪婪-junction-的奇怪情况\"\u003e重新审视贪婪 Junction 的奇怪情况\u003c/h4\u003e\n\u003cp\u003e假设我们有一个两个参数的函数 \u003ccode\u003ef :: a -\u0026gt; b -\u0026gt; c\u003c/code\u003e，我们对第一个参数应用一个结点 \u003ccode\u003ej :: Junction\u003c/code\u003e a 应用到第一个参数 \u003ccode\u003ef •￮ j\u003c/code\u003e 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：\u003ccode\u003efp :: Junction b -\u0026gt; c\u003c/code\u003e。如果我们现在想用 \u003ccode\u003efp ￮• v\u003c/code\u003e 将这个函数应用于一个非结点的值 \u003ccode\u003ev :: b\u003c/code\u003e，那么结果就是 \u003ccode\u003eJunction c\u003c/code\u003e 类型的。\u003c/p\u003e\n\u003cp\u003e现在，让我们考虑类型 \u003ccode\u003ec\u003c/code\u003e 是 \u003ccode\u003eforall d . (a -\u0026gt; b -\u0026gt; d) -\u0026gt; d\u003c/code\u003e 的特殊情况。所以我们有 \u003ccode\u003eJunction\u003c/code\u003e(\u003ccode\u003eforall d . (a-\u0026gt;b-\u0026gt;d) -\u0026gt; d\u003c/code\u003e)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 \u003ccode\u003eforall\u003c/code\u003e，所以 \u003ccode\u003ed\u003c/code\u003e 可以是任何东西，但在实践中我们希望它是 \u003ccode\u003ea\u003c/code\u003e 或 \u003ccode\u003eb\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e假设我们将这个函数(称它为 \u003ccode\u003ep\u003c/code\u003e)应用于 \u003ccode\u003efst :: a-\u0026gt;b-\u0026gt;a\u003c/code\u003e，使用 \u003ccode\u003ep ￮• fst\u003c/code\u003e，那么我们得到 \u003ccode\u003eJunction a\u003c/code\u003e。但是如果我们将它应用于 \u003ccode\u003esnd :: a-\u0026gt;b-\u0026gt;b\u003c/code\u003e，使用 \u003ccode\u003ep ￮• snd\u003c/code\u003e，那么我们得到 \u003ccode\u003eJunction b\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在\u0026rdquo;\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的奇怪情况\u003c/a\u003e\u0026ldquo;中已经解释过。而这也是我们需要 \u003ccode\u003ecollapse\u003c/code\u003e 函数的原因。\u003c/p\u003e\n\u003ch4 id=\"重构-junction-的第2部分raku-的实现\"\u003e重构 Junction 的第2部分：Raku 的实现。\u003c/h4\u003e\n\u003cp\u003e我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003e# The types of Junctions\nenum JType \u0026lt;JAny  JAll  JOne  JNone \u0026gt;;\n\n# The actual Junction type\nrole Junction[\\jt, @vs] {\n    has JType $.junction-type=jt;\n    has @.values=@vs;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub all_(@vs) {\n    Junction[ JAll, @vs].new;\n}\n\nour sub any_(@vs) {\n    Junction[ JAny, @vs].new;\n}\n\nour sub one_(@vs) {\n    Junction[ JOne, @vs].new;\n}\n\nour sub none_(@vs) {\n    Junction[ JNone, @vs].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将一个（单参数）函数应用于 junction 参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;●○\u0026gt;( \u0026amp;f, \\j ) is export {\n    my \\jt=j.junction-type; \n    my @vs = j.values;\n  \n    Junction[ jt, map( {\u0026amp;f($_)}, @vs)].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e要将 Junction 内的函数应用于非 Junction 的参数:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;○●\u0026gt;( \\jf, \\v ) is export {\n    my \\jt=jf.junction-type; \n    my @fs = jf.values;\n\n    Junction[ jt, map( {$_( v)}, @fs)].new;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt;○○\u0026gt;( \\jf, \\jv ) is export {\n    my \\jft= jf.junction-type; \n    my @fs = jf.values;\n    my \\jvt = jv.junction-type;\n    my @vs = jv.values;\n    if (jvt == JAll and jft != JAll) {        \n        Junction[ jvt, map( sub (\\v){jf ○● v}, @vs)].new;  \n    } else {        \n        Junction[ jft, map( sub (\u0026amp;f){ \u0026amp;f ●○ jv}, @fs)].new;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了完整，这里是 \u003ccode\u003e○==●\u003c/code\u003e 的定义。\u003ccode\u003e○!=●\u003c/code\u003e、\u003ccode\u003e○\u0026gt;●\u003c/code\u003e 等的定义是类似的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub infix:\u0026lt; ○==● \u0026gt;( \\j, \\v ) is export {\n    sub (\\x){x==v} ●○ j\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来我们有 \u003ccode\u003eso\u003c/code\u003e，它把布尔值的 junction 变成了布尔值。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub so (\\jv) { \n    my @vs = jv.values;\n    given jv.junction-type {\n        when JAny { elems(grep {$_},  @vs) \u0026gt;0}\n        when JAll { elems(grep {!$_}, @vs)==0}\n        when JOne { elems(grep {$_},  @vs)==1}\n        when JOne { elems(grep {$_},  @vs)==0}\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后我们有 \u003ccode\u003ecollapse\u003c/code\u003e，正如\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 的文章\u003c/a\u003e中所定义的那样， \u003ccode\u003ecollapse\u003c/code\u003e 返回 Junction 的值，只要它们都是一样的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eour sub collapse( \\j ) {\n    my \\jt=j.junction-type; \n    my @vvs = j.values;\n    my $v =  shift @vvs;        \n    my @ts = grep {!($_ ~~ $v)}, @vvs;\n    if (@ts.elems==0) {  \n        $v\n    } else {\n        die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"junction-清理\"\u003eJunction 清理\u003c/h3\u003e\n\u003cp\u003e现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub sq(Int $x --\u0026gt; Int) { $x*$x }\nmy Junction $j = 11 | 22; \nmy Junction $rj = sq($j); \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e去语法塘后这变成了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction $j = any_ [11,22];\nmy Junction $rj = \u0026amp;sq ●○ $j;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e类似地,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif ($j == 42) {...} \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e变成了:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003eif (so ($j ○==● 42)) {...}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e和其他布尔上下文类似。\u003c/p\u003e\n\u003cp\u003e如果我们仔细看\u003ca href=\"https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8\"\u003e贪婪 Junction 文章\u003c/a\u003e中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction \\p1j = pair R,(42^43);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e去语法塘后变为:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy Junction \\p1j = \u0026amp;pair.assuming(R) ●○ one_ [42,43];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们使用 \u003ccode\u003e.assuming()\u003c/code\u003e 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003emy \\p1jr = ( sub ($y){ \u0026amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后，举一个两个参数都是 Junction 的例子。由于 \u003ccode\u003e○○\u003c/code\u003e 的定义，应用的顺序并不重要。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-raku\" data-lang=\"raku\"\u003esub m(\\x,\\y){x*y}\n\nmy \\p4 = ( sub (\\x){ \u0026amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44];\nmy \\p4r = ( sub (\\x){ \u0026amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22];\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"结论\"\u003e结论\u003c/h3\u003e\n\u003cp\u003e从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。\u003c/p\u003e\n\u003cp\u003e原文链接: \u003ca href=\"https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\"\u003ehttps://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\u003c/a\u003e\u003c/p\u003e\n","text":"重构 Raku 的 Junction Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。\nRaku 中的 Junction Raku 有一个整洁的功能叫做 Junction。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(\u0026amp;)、any(|)、one(^) 或 none (空结点)。\n例如:\nmy $j = 11|22; # short for any(11,22) if 33 == $j + 11 { say 'yes'; } say so 3 == (1..30).one; #=\u0026gt; True say so (\u0026quot;a\u0026quot; ^ \u0026quot;b\u0026quot; ^ \u0026quot;c\u0026quot;) eq \u0026quot;a\u0026quot;; #=\u0026gt; True 函数 so 强制使用布尔上下文。\nJunction 有 Junction 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 sq 从 Int 到 Int。\nsub sq(Int $x --\u0026gt; Int) { $x*$x } my Int $res = sq(11); # OK say $res; #=\u0026gt; 121 现在让我们定义一个类型为任何 Int 值的 Junction。\nmy Junction $j = 11 | 22; 当我们将 sq 应用于 $j 时，我们没有得到一个类型错误，即使函数的类型是 :(Int --\u0026gt; Int)，Junction 的类型是 Junction。相反，我们得到的是一个结果的 Junction。\nsay sq($j); #=\u0026gt; any(121, 484) 如果我们像之前一样将其赋值给一个类型为 Int 的变量，我们会得到一个类型错误。\nmy Int $rj = sq($j); #=\u0026gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484)) 取而代之的是，现在返回值的类型为 Junction。\nmy Junction $rj = sq(11|22); # OK 所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。\n另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 Junction 类型。例如，如果我们创建了一个由 Str 值组成的 Junction，并试图将这个 Junction 的值传递到 sq 中，我们会得到一个类型错误。\nmy $sj = '11' | '22'; say $sj.WHAT; #=\u0026gt;(Junction) my Junction $svj = sq($sj); #=\u0026gt; Type check failed in binding to parameter 'x'; expected Int but got Str (\u0026quot;11\u0026quot;) Junction 不遵循静态类型规则 虽然这样做是有道理的(如果原始函数期望使用 Int，我们不希望它与 Str 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 Int，那么可以使用类型图中低于它的任何类型来代替。但是 Int 和 Junction 的简化类型图如下。\nInt -\u0026gt; Cool -\u0026gt; Any -\u0026gt; Mu \u0026lt;- Junction  所以 Junction 永远不是 Any 以下任何东西的子类型。因此，将 Junction 放在类型为 Any 或其子类型的槽中应该是一个类型错误。\n此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。\n那么这里到底发生了什么？\n一个工作假设 一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。\n重构 Junction 的第一部分：类型 让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。\nJunction 类型 Junction 是一个由 Junction 类型 JType 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。\ndata JType = JAny | JAll | JOne | JNone data Junction a = Junction JType [a] 应用结点 对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。\n 将非 Junction 函数应用于 Junction 表达式  (•￮) :: (a -\u0026gt; b) -\u0026gt; Junction a -\u0026gt; Junction b  将 Junction 函数应用于非 Junction 表达式。  (￮•) :: Junction (b -\u0026gt; c) -\u0026gt; b -\u0026gt; Junction c  将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。  (￮￮) :: Junction (b -\u0026gt; c) -\u0026gt; Junction b -\u0026gt; Junction (Junction c) 为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。\n-- and similar for /-, \u0026gt;, \u0026lt;, \u0026lt;=,\u0026gt;= (￮==•) :: Junction a -\u0026gt; a -\u0026gt; Bool 折叠 Junction 那么我们就有了 so，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。\nso :: Junction Bool -\u0026gt; Bool 最后我们有 collapse，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。\ncollapse :: (Show a,Eq a) =\u0026gt; Junction a -\u0026gt; a 这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在\u0026quot;贪婪 Junction 的奇怪情况\u0026ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。\n重新审视贪婪 Junction 的奇怪情况 假设我们有一个两个参数的函数 f :: a -\u0026gt; b -\u0026gt; c，我们对第一个参数应用一个结点 j :: Junction a 应用到第一个参数 f •￮ j 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：fp :: Junction b -\u0026gt; c。如果我们现在想用 fp ￮• v 将这个函数应用于一个非结点的值 v :: b，那么结果就是 Junction c 类型的。\n现在，让我们考虑类型 c 是 forall d . (a -\u0026gt; b -\u0026gt; d) -\u0026gt; d 的特殊情况。所以我们有 Junction(forall d . (a-\u0026gt;b-\u0026gt;d) -\u0026gt; d)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 forall，所以 d 可以是任何东西，但在实践中我们希望它是 a 或 b。\n假设我们将这个函数(称它为 p)应用于 fst :: a-\u0026gt;b-\u0026gt;a，使用 p ￮• fst，那么我们得到 Junction a。但是如果我们将它应用于 snd :: a-\u0026gt;b-\u0026gt;b，使用 p ￮• snd，那么我们得到 Junction b。\n这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在\u0026rdquo;贪婪 Junction 的奇怪情况\u0026ldquo;中已经解释过。而这也是我们需要 collapse 函数的原因。\n重构 Junction 的第2部分：Raku 的实现。 我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。\n# The types of Junctions enum JType \u0026lt;JAny JAll JOne JNone \u0026gt;; # The actual Junction type role Junction[\\jt, @vs] { has JType $.junction-type=jt; has @.values=@vs; } 接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。\nour sub all_(@vs) { Junction[ JAll, @vs].new; } our sub any_(@vs) { Junction[ JAny, @vs].new; } our sub one_(@vs) { Junction[ JOne, @vs].new; } our sub none_(@vs) { Junction[ JNone, @vs].new; } 将一个（单参数）函数应用于 junction 参数。\nsub infix:\u0026lt;●○\u0026gt;( \u0026amp;f, \\j ) is export { my \\jt=j.junction-type; my @vs = j.values; Junction[ jt, map( {\u0026amp;f($_)}, @vs)].new; } 要将 Junction 内的函数应用于非 Junction 的参数:\nsub infix:\u0026lt;○●\u0026gt;( \\jf, \\v ) is export { my \\jt=jf.junction-type; my @fs = jf.values; Junction[ jt, map( {$_( v)}, @fs)].new; } 将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。\nsub infix:\u0026lt;○○\u0026gt;( \\jf, \\jv ) is export { my \\jft= jf.junction-type; my @fs = jf.values; my \\jvt = jv.junction-type; my @vs = jv.values; if (jvt == JAll and jft != JAll) { Junction[ jvt, map( sub (\\v){jf ○● v}, @vs)].new; } else { Junction[ jft, map( sub (\u0026amp;f){ \u0026amp;f ●○ jv}, @fs)].new; } } 为了完整，这里是 ○==● 的定义。○!=●、○\u0026gt;● 等的定义是类似的。\nsub infix:\u0026lt; ○==● \u0026gt;( \\j, \\v ) is export { sub (\\x){x==v} ●○ j } 接下来我们有 so，它把布尔值的 junction 变成了布尔值。\nour sub so (\\jv) { my @vs = jv.values; given jv.junction-type { when JAny { elems(grep {$_}, @vs) \u0026gt;0} when JAll { elems(grep {!$_}, @vs)==0} when JOne { elems(grep {$_}, @vs)==1} when JOne { elems(grep {$_}, @vs)==0} } } 最后我们有 collapse，正如贪婪 Junction 的文章中所定义的那样， collapse 返回 Junction 的值，只要它们都是一样的。\nour sub collapse( \\j ) { my \\jt=j.junction-type; my @vvs = j.values; my $v = shift @vvs; my @ts = grep {!($_ ~~ $v)}, @vvs; if (@ts.elems==0) { $v } else { die \u0026quot;Can't collapse this Junction: elements are not identical: {$v,@vvs}\u0026quot;; } } Junction 清理 现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。\nsub sq(Int $x --\u0026gt; Int) { $x*$x } my Junction $j = 11 | 22; my Junction $rj = sq($j); 去语法塘后这变成了:\nmy Junction $j = any_ [11,22]; my Junction $rj = \u0026amp;sq ●○ $j; 类似地,\nif ($j == 42) {...} 变成了:\nif (so ($j ○==● 42)) {...} 和其他布尔上下文类似。\n如果我们仔细看贪婪 Junction 文章中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:\nmy Junction \\p1j = pair R,(42^43); 去语法塘后变为:\nmy Junction \\p1j = \u0026amp;pair.assuming(R) ●○ one_ [42,43]; 我们使用 .assuming() 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。\nmy \\p1jr = ( sub ($y){ \u0026amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R; 最后，举一个两个参数都是 Junction 的例子。由于 ○○ 的定义，应用的顺序并不重要。\nsub m(\\x,\\y){x*y} my \\p4 = ( sub (\\x){ \u0026amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44]; my \\p4r = ( sub (\\x){ \u0026amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22]; 结论 从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。\n原文链接: https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e\n"},"name":"重构 Raku 的 Junction","published":"2020-10-04T00:00:00+08:00","summary":"Reconstructing Raku\u0026rsquo;s Junctions","type":"entry","url":"https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/"}],"name":"rakulang","type":"feed","url":"https://ohmyweekly.github.io/categories/rakulang/"}