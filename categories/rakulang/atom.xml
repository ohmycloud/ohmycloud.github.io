<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[rakulang on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/categories/rakulang/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/categories/rakulang/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/categories/rakulang/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/categories/rakulang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-06T20:48:33+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/categories/rakulang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Roles or When One Is Many]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-06-22-roles-or-when-one-is-many/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-06-17-raku-syntax-i-miss-in-other-languages/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Syntax I Miss in Other Languages" />
                <link href="https://ohmyweekly.github.io/notes/2021-06-05-learn-raku-from-roast/?utm_source=atom_feed" rel="related" type="text/html" title="Learn Raku From Roast" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Multiple Dispatch With the New MoarVM Dispatcher" />
                <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 的标准库 Trait 之旅" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
            
                <id>https://ohmyweekly.github.io/notes/2021-06-22-roles-or-when-one-is-many/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-06-22T00:00:00+08:00</published>
            <updated>2021-06-22T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Roles or When One Is Many</blockquote><p>让 Raku 与 Perl 相当不同的一点是，<a href="https://raku.org/">Raku</a> 避免了魔法。有几个地方人们可以说，&ldquo;它神奇地发生了&rdquo;。但仔细看一下，通常会发现行为背后有相当好解释的机制。这就像看魔术师的把戏：我们总是知道有解释，而且它们肯定是符合逻辑的。</p>
<p>因此，我有个小把戏给你。看一下代码，告诉我：你在这里看到了多少个角色？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{</span> <span class="k">has</span> <span class="nb">T</span> <span class="nv">$.a</span><span class="p">;</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="ow">R</span><span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>直观的答案当然是 1，这也是事实。但这里的部分技巧是术语的替换：在使用&quot;角色&quot;一词的地方，更准确的术语应该是&quot;角色类型对象&quot;。现在，试着猜出正确答案。而且，要确定的是，它不止一个。</p>
<h2 id="raku-魔术是如何不神奇的">Raku 魔术是如何不神奇的</h2>
<p>Raku 的最大优点之一，随着时间的推移，我越来越学会重视，就是它做任何事情都要保持逻辑性。有时这并不意味着要有直觉。有些行为一开始甚至可能使初学者感到困惑。但是，在解释时，逻辑通常是相当有说服力的。Raku 提供的一套广泛的内省工具，通常对理解它有很大帮助。在这篇文章中，我将尝试以&quot;魔术师&quot;的方式演示如何使用其中的一些工具来将一只兔子变成许多只。</p>
<p>我还将在很大程度上依赖于 <a href="https://rakudo.org/">Rakudo</a> 对 Raku 的实现，它是基于 <a href="https://vrurg.github.io/arfb-publication/02-everything-is-an-object-mop/#rakudo-nqp-runtime-vm-and-implementation-stack">NQP</a> 的，这使得在某些情况下相当容易看到 Raku 语法的幕后。顺便说一下，这也是 Raku 中的魔法量处于可忽略不计的水平的另一个原因。你们当中有多少人，我的读者，曾经研究过 Perl 或任何你最喜欢的语言的来源？如果我为自己回答，那么就是一个词：从未。尽管 C 语言是我多年来的首选语言。但现在我会坚持要求你在你的主目录下的某个地方做 git clone <a href="https://github.com/rakudo/rakudo.git">https://github.com/rakudo/rakudo.git</a>，所有其他项目都放在那里。然后，只要你遇到问题，答案很可能就在 Rakudo 项目的 src/Perl6/Metamodel 目录下的一个文件里。</p>
<h2 id="四位一体">四位一体</h2>
<p>我不得不谷歌一下这个词。从第一部《黑客帝国》电影开始，&ldquo;三位一体&quot;对我来说就很熟悉了，但对这一行中的其他词却不熟悉。是的，这个词就是这个棘手问题的答案。Raku 角色是四位一体。这篇文章将一步一步地告诉你为什么。</p>
<p>在这一点上，我想提醒的是，反省和乐库元模型的一般知识将是非常有益的。一些信息可以在本周期的前几篇文章中找到，一些可以在Raku文档中找到。</p>
<h3 id="第1步-多重性">第1步: 多重性</h3>
<p>让我们从最简单的自省开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">⇒ <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">role R[::T] { }; say R.WHAT</span><span class="p">&#39;</span>
<span class="p">(</span><span class="ow">R</span><span class="err">)</span>
</code></pre></div><p>不要和 &lsquo;⇒&rsquo; 字符混淆，这只是我最喜欢的命令行提示。</p>
<p>注意，我们只用方括号来声明角色，而不是对它调用方法。还要注意的是，这个角色报告自己只是 <code>R</code>；同样，没有涉及方括号。</p>
<p>接下来，你可能已经知道，在 Raku 中，同一个角色有可能有不同的变体。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">⇒ <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">role R[::T] { }; role R { }; say R.WHAT</span><span class="p">&#39;</span>
<span class="p">(</span><span class="ow">R</span><span class="err">)</span>
</code></pre></div><p>我们有两个声明，但仍然只使用 <code>R</code> 来调用 <code>WHAT</code>。</p>
<p>让我们换个角度，看看这个角色是如何实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">⇒ <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">role R[::T] { }; say R.HOW.^name</span><span class="p">&#39;</span>
<span class="n">Perl6::Metamodel::ParametricRoleGroupHOW</span>
</code></pre></div><p>注意名字中的 <code>Group</code> 部分。新手可能会对这个词感到困惑，只要他们只使用一个角色的变体。但是当他们到了本节第二个例子的时候，事情就开始变得比较清楚了。让我再把它们变得更加混乱。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="nb">say</span> <span class="ow">R</span><span class="o">.^</span><span class="err">lookup(&#39;foo&#39;);</span>
</code></pre></div><p>你希望这段代码能输出什么？根据<a href="https://docs.raku.org/routine/lookup">文档</a>，在一个类上这样做会得到相当可预测的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="p">}</span> <span class="p">};</span> 
<span class="nb">say</span> <span class="n">Foo</span><span class="o">.^</span><span class="nb">lookup</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;);</span> <span class="c1"># foo</span>
</code></pre></div><p>现在，忘记这个经验吧。因为对于上面的例子中的 <code>R</code>，我们会得到 <code>(Mu)</code>，意思是没有找到方法！而对于 <code>R</code>，我们会得到 <code>(Mu)</code>。</p>
<p>在这一点上，我想退一步说。如果你读了 Raku 的文档或书，做了关于角色和参数化的部分，有一个细节可能会让你觉得相当熟悉。如果这也是我要指出的&quot;东西&rdquo;，那么你就不会错了：参数化是关于参数的；有了参数，就有了签名！&quot;。现在这段代码一定是完全有意义的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="err">[Int</span><span class="o">:</span><span class="err">D</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="nv">$b</span><span class="o">]</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>角色声明中被方括号括起来的部分是一个签名，这有另一层意思，我将在后面再谈。</p>
<p>不幸的是，我在写这篇文章的时候有点超时，它应该在涉及到几个更基本的主题之后再完成。出于这个原因，我为下面的一点离题而道歉。</p>
<h2 id="多重分派">多重分派</h2>
<p>人们可以在 Raku 文档中找到这一<a href="https://docs.raku.org/language/glossary#Multi-dispatch">部分</a>。<a href="https://docs.raku.org/syntax/multi">另一节</a>阐述了其语法和功能。但我想简单地谈谈这个功能的内部实现。让我们从一个基本的声明开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">foo</span><span class="ow">(|)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
<span class="k">multi</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">Int:D</span> <span class="nv">$i</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">multi</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">Str:D</span> <span class="nv">$s</span><span class="p">)</span> <span class="p">{}</span>
<span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="c1"># proto sub foo (|) {*}</span>
</code></pre></div><p>正如你所看到的，<code>raku</code> 方法只报告了 <code>proto</code>。另外，如果我们对 <code>&amp;foo</code> 调用 <code>is_dispatcher</code> 方法，它将返回 <code>True</code>。好的，但是这两个 <code>multi</code> 在哪里，当我们调用 <code>foo(&quot;bar&quot;)</code> 时会发生什么？用两句话来说，Raku 首先会找到 <code>proto</code> 方法。如果它通过检查 <code>is_dispatcher</code> 的返回值识别出它是这样的，那么它就会通过调用 <code>&amp;foo.candidates</code> 来获取已知的候选列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="nb">candidates</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">raku</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># multi sub foo (Int:D $i) { #`(Sub|140560053018928) ... }</span>
<span class="c1"># multi sub foo (Str:D $s) { #`(Sub|140560053019072) ... }</span>
</code></pre></div><p>然后，它试图将提供的参数与每个候选者的签名绑定。如果绑定成功，则调用该候选程序（如果没有找到，则抛出一个异常）。</p>
<p>显然，在现实生活中，事情要复杂得多，但我们还不需要知道这些&hellip;&hellip;</p>
<h2 id="回到多重角色的问题上">回到多重角色的问题上</h2>
<p>有时我对不能在文章的纯文本中递归到一个子主题感到奇怪。就把这一节的标题看成是上一节的 <code>return</code> 语句&hellip;&hellip;啊，算了！不说了。</p>
<p>好吧，我的观点是什么，就是要讲述多重调度的故事？当我们看到 <code>R.HOW</code> 在类名中报告了一个 <code>Group</code>，就可以和多重调度实现中的 <code>proto</code> 相提并论了。事实上，我们调用 <code>HOW</code> 方法的类型对象 <code>R</code> 是一个伞状的实体，在其共同的名字下代表了角色的所有变体。而且，当我们把 <code>R[Int]</code> 应用于一个类时，实际发生的过程是一种多重分派，Raku 试图把方括号中的参数与角色候选者的签名相匹配。类似于我们如何列出 <code>&amp;foo</code> 的候选者，我们也可以列出 <code>R</code> 的候选者。</p>
<p>``raku
say R.^candidates.map(*.^name).join(&quot;, &ldquo;); # R, R</p>
<pre><code>
唯一不同的是，这次我们使用了一个元方法 `.^candidates`。

在这一点上，还有一个谜团没有被揭开。还记得使用 `.^lookup` 的那个例子吗？为什么它不能找到这个方法？

`Perl6::Metamodel::ParametricRoleGroupHOW` 所支持的类型对象并不是一个我们可以实际使用的角色。它既没有方法也没有属性。然而，在某些情况下，我们可能希望它假装是一个成熟的角色。为了做到这一点，它选择了一个候选角色作为默认角色，然后在其上重新分配外部请求。当有一个没有签名的候选者时（如我们的 `role R {}`），它就成为隐式默认。否则，第一个声明的有签名的候选者就会成为默认的候选者。

回到我们的例子，`R.^lookup('foo')` 失败了，因为 `role R {}` 没有声明一个有这个名字的方法。

### 第二步: 候选者

直奔主题，让我们对候选者本身进行自省。

```raku
say R.^candidates.map({ .HOW.^name }).join(&quot;, &quot;);
</code></pre><p>这看起来一定很熟悉，只是我们加入了.HOW的调用。下面是我们用它得到的东西。</p>
<pre><code>Perl6::Metamodel::ParametricRoleHOW, Perl6::Metamodel::ParametricRoleHOW
</code></pre><p>它看起来也很熟悉，除了&hellip;&hellip;是的，在类名称中没有 <code>Group</code>，我想欢迎我们的第二种角色! 实际上，我们已经知道了。如果我像这样挥舞着我的手，让我的观众分心，用&hellip;</p>
<p>哎呀，最后一句话应该是落在另一个窗口里的! 对于你，我的观众，我还有一行代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{}</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># Perl6::Metamodel::ParametricRoleHOW</span>
</code></pre></div><p>BTW，这是一个很好的例子，说明无处不在的 Raku 概念，即所有东西都是一个对象。甚至声明也是；而且，只是为了好玩。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">}</span><span class="o">.^</span><span class="nb">name</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># Block</span>
</code></pre></div><p>但是我分心了&hellip;</p>
<p>所以，这里真正重要的是，当我们声明一个角色时，Raku 为我们创建一个 <code>Perl6::Metamodel::ParametricRoleHOW</code> 类的实例。每个声明都有一个独特的类的实例支持，它负责持有角色类型对象的每个细节。例如，要想知道它是否可以被参数化，可以这样做。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">is_parameterized</span><span class="p">(</span><span class="nb">Mu</span> \<span class="nb">r</span> <span class="k">--&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">?</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">signatured</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nf">is_parameterized</span><span class="p">(</span><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{});</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="nf">is_parameterized</span><span class="p">(</span><span class="k">role</span> <span class="ow">R</span> <span class="p">{});</span> <span class="c1"># False</span>
</code></pre></div><p>请注意，由于 <code>signatured</code> 是在 NQP 中实现的方法，它不知道高级类型，并返回0或1。有时情况会变得更糟糕。我上面提到的查找元方法实际上返回 <code>nqp::null()</code>，这是一种 VM 级的对象。它决不能出现在 Raku 上。因此语言把它变成了 <code>Mu</code>，这是最基本的 Raku 类。</p>
<p>关于 <code>Perl6::Metamodel::ParametricRoleHOW</code>，在这一点上没有什么可说的。但我们稍后会回到它上面去。</p>
<h3 id="第三步-不确定性">第三步: 不确定性</h3>
<p>为了更接近我们的第三种角色，我们从下面这个片段开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span> <span class="nb">Stringy</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span><span class="o">]</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">stringy</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span> <span class="nb">Numeric</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span><span class="o">]</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">numeric</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">my</span> <span class="nv">\r</span> <span class="o">=</span> <span class="k">role</span> <span class="nc">R2</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">T</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>让我们自省一下 <code>R1</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># We know there is only one role, </span>
<span class="c1"># hence .head for prettier output</span>
<span class="nb">say</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">roles</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span><span class="o">.</span><span class="nb">head</span><span class="p">;</span>
<span class="c1"># R1[Int,T] of Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>输出显示了两个明显的变化。首先，角色名称现在报告了它的参数。第二，元对象现在属于 <code>Perl6::Metamodel::CurriedRoleHOW</code> 类。这是 Rakudo 在幕后做的另一种&quot;魔法&rdquo;，我将在本节中披露。</p>
<p>在上面的例子中，R2 声明最引人注目的特点是什么？事实上，在它消耗 <code>R1</code> 的地方，我们只知道第一个参数，而第二个参数仍然是一个通用参数。为了表示这种情况，我们对角色的了解是不完整的，Rakudo 使用了柯里化的角色。</p>
<p>从起源的角度来看，柯里化角色与前两种角色的关键区别在于，没有办法声明一个角色。柯里化只能是一个组的参数化的结果。而且，实际上，我很清楚，正式的组在 Raku 语法中并没有表示。但是只要它作为第一个角色声明的结果出现，我们就可以说它是由它产生的。而柯里化则完全由参数化产生。</p>
<p>也许有些令人惊讶，但在所有参数都为编译器所熟知的情况下，也可以发现柯里化的存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">R2</span><span class="o">[</span><span class="nb">Str</span><span class="o">].</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>部分原因是，当我们使用这样的角色时，我们所需要的也许是一些内省、类型检查或任何其他不需要具体对象的操作。比如说。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="n">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="o">]</span> <span class="nv">$a</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>我们在这里需要的是 <code>foo</code> 参数，以通过对 <code>R1[Int, Str]</code> 的类型检查。因为柯里化会帮我们完成这个工作，所以 Rakudo 在这里使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="nb">signature</span><span class="o">.</span><span class="nb">params</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
<span class="c1"># Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>这是因为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">R2</span><span class="o">[</span><span class="nb">Str</span><span class="o">]</span> <span class="o">~~</span> <span class="n">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="o">]</span><span class="p">;</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="n">R2</span><span class="o">[</span><span class="nb">Int</span><span class="o">]</span> <span class="o">~~</span> <span class="n">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="o">]</span><span class="p">;</span> <span class="c1"># False</span>
</code></pre></div><p>但还有一个主要原因。它将在下一节中披露。</p>
<h3 id="第4步-具体性">第4步: 具体性</h3>
<p>任何角色的命运都是被一个类所吞噬。(BTW，这里的双关语也不例外。)现在是时候考虑这最后阶段了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R2</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R3</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="nc">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R2</span><span class="o">[</span><span class="nb">Str</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R3</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>通过反省类，我们会遇到所有的老朋友。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">C</span><span class="o">.^</span><span class="nf">roles</span>
     <span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span>
     <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># R3 of Perl6::Metamodel::ParametricRoleGroupHOW</span>
<span class="c1"># R2[Str] of Perl6::Metamodel::CurriedRoleHOW</span>
<span class="c1"># R1[Int] of Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>有趣的是，我们在这里发现了不同种类的角色的混合。其原因是浮在上面的：与 <code>R3</code> 相反，另外两个角色是参数化的。</p>
<p>但由于我喜欢迷惑听众，所以我要告诉你：这些其实不是这个类所建立的角色！这是另一个操作。</p>
<p>当然，这是另一种操作。完整的短语必须是使用这个。&ldquo;不是直接使用的角色&rdquo;。</p>
<p>当我们尝试另一种方法时，情况就会大不相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">C</span><span class="o">.^</span><span class="nb">mro</span><span class="p">(:</span><span class="s">roles</span><span class="p">)</span>
     <span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span>
     <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># C of Perl6::Metamodel::ClassHOW</span>
<span class="c1"># R3 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R2 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R1 of Perl6::Metamodel::ConcreteRoleHOW</span>
</code></pre></div><p><code>.^roles</code> 和 <code>.^mro</code> 的区别在于，前者为我们提供了用于声明类的内容；而后者则为我们提供了实际构建的内容。</p>
<p>正如 <code>HOW</code> 类的名字所暗示的，我们现在处理的是角色的具体表现。换句话说，这是一种所有细节都知道的角色，它们是为这个特定的类专门设计的。这里强调的是目的：这个过程被称为特化；而 specialize 是实现它的元模型方法的名称。</p>
<p>我还想提醒你一下上一节的最后一句话。为什么每当人们使用 <code>R[Int]</code> 或类似形式的角色参数化时，他们都要处理一个柯里化的角色，原因是完全的特化需要角色被消耗的类。稍后我将说明原因。</p>
<p>我们现在可以退一步，概述一下角色的生命周期。</p>
<ol>
<li>一个 <code>Perl6::Metamodel::ParametricRoleGroupHOW</code> 被创建。</li>
<li>一个 <code>Perl6::Metamodel::ParametricRoleHOW</code> 被创建并添加到该组。</li>
<li>一个类被声明并 <code>does</code> 这个角色。编译器尝试对角色进行参数化，如果需要参数化，<code>Perl6::Metamodel::CurriedRoleHOW</code> 就会被创建；否则就会使用原来的 <code>Perl6::Metamodel::ParametricRoleHOW</code>。</li>
<li>参数化的结果被添加到类的角色列表中。</li>
<li>当类被组成时，所有在上一步中添加的角色都被赋予了各自的参数和类的类型对象。在这一点上，我们得到了由 <code>Perl6::Metamodel::ConcreteRoleHOW</code> 支持的角色类型对象，或者换句话说，角色具体化。</li>
<li>这些具体化被添加到类中。</li>
<li>具体化是通过将其属性和方法迁移到类的类型对象中来应用的。</li>
</ol>
<p>值得注意的是，具体化被保留为独立的实体，与它们所产生的角色分开。这就是我们在上面通过使用 <code>.^roles</code> 和 <code>.^mro</code> 进行内省观察到的。它们也可以使用 <code>.^concretizations</code> 元模型方法来访问。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">C</span><span class="o">.^</span><span class="nf">concretizations</span>
     <span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span>
     <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># R3 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R2 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R1 of Perl6::Metamodel::ConcreteRoleHOW</span>
</code></pre></div><p>在这一点上，有两个相当大的主题仍然故意不清楚：一个角色候选人是如何被选择的？ 以及特化是做什么的？第一个问题我也许可以或多或少地完整地介绍一下。第二个问题对本文来说太复杂了，但有几个关键点绝对值得一提。</p>
<h3 id="第1a步-选择">第1a步: 选择</h3>
<p>震惊一个无辜的读者在媒体中非常流行。虽然我勉强算是个记者，但只要我把这篇文章称为文章&ndash;我有什么资格打破规则？所以，请坐好，握紧你的大脑。</p>
<p>我们开始了&hellip;&hellip;准备好了没有&hellip;&hellip;真相即将揭晓！&quot;。</p>
<p>角色是一种例程。</p>
<p>很好，开始了。我说了！我一直想说的!</p>
<p>说真的，正如经常发现的关于点击率的新闻一样，这并不完全是真的，但有一点是真的。我想让你考虑一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside the role</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">module</span> <span class="nn">Foo</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside Foo</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside the class</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="c1"># inside Foo</span>
<span class="c1"># inside the class</span>
</code></pre></div><p>我们只看到两行输出，让我们了解到类的声明与模块的行为是一样的。但不是角色。让我们在这个例子中再加一行。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ow">R</span><span class="o">.^</span><span class="err">candidates[0</span><span class="o">].^</span><span class="nf">body_block</span><span class="o">.</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
<span class="c1"># inside the role</span>
</code></pre></div><p>为什么是这样，为什么我把 <code>C</code> 作为一个参数传递，我将在下面关于特化的部分尝试回答。</p>
<p>现在我建议对主体块进行内省，但首先要在上述片段中增加一个角色的变体。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">\r</span> <span class="o">=</span> <span class="k">role</span> <span class="ow">R</span><span class="err">[</span><span class="o">::</span><span class="err">T</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span> <span class="nb">Numeric</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="nb">say</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">body_block</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># multi sub (::$?CLASS ::::?CLASS Mu $, ::T Mu $, ::V Numeric $) { #`(Sub|94052949943024) ... }</span>
</code></pre></div><p>现在有印象了吗？<code>sub</code> 前面的 <code>multi</code> 这个词说明了一切，我现在的工作已经减少到所需的最小的措辞。</p>
<p>当编译器建立一个角色组时，它也创建了一个多调度例程。在内部，它被称为选择器。在每一个新添加的参数化角色中，它的主体块（实际上是一个 <code>multi sub</code>）都会被抽取出来，并作为一个多重调度候选程序添加到选择器中。现在，当人们在他们的代码中写下像 <code>R[Int, Str]</code> 这样的东西时，编译器会做一个类似于选择多重调度例程候选者的过程。基于进程提供的主体块候选，它选择了该块所属的角色。</p>
<p>所以，现在当我们提到角色签名时，一定会有更多的意义。因为它是一个签名，作为一个事实。如果我把一个角色声明 <code>role R[::T, ::V] {}</code> 以某种更适合人类程序员阅读的方式重新表述，它可能看起来像。</p>
<blockquote>
<p>声明一个候选角色 <code>R</code>，其主体为块<code>sub (::T, ::V) {...}</code>。</p>
</blockquote>
<p>很好，我们现在已经解决了这个问题。但是，我细心的读者，是不是有什么事情困扰着你？上面的&quot;类似&quot;一词是不是意味着某种&hellip;&hellip;呃&hellip;&hellip;惊喜？好吧，不幸的是，候选的选择并不遵循完整的多重调度协议，因为它缺乏对命名参数的支持。这是由于类型参数化的低级实现的限制。这意味着下面的两个声明被认为是相同的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="err">[Int</span><span class="o">,</span> <span class="nb">Bool</span> <span class="o">:</span><span class="nv">$foo</span><span class="o">]</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">role</span> <span class="ow">R</span><span class="err">[Int</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="o">:</span><span class="nv">$bar</span><span class="o">]</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>希望当新的分派机制到达 Raku 时，情况会有所改变，但我在此不做任何承诺。</p>
<p>与此同时，你仍然可以使用这些名字，只是不要依靠它们来唯一地识别你的角色候选人。</p>
<h2 id="一个黑魔法塞恩斯">一个黑魔法塞恩斯</h2>
<p>这其实与选择候选者无关，但我不能忍受不给你看一些棘手的东西。此外，在许多小说和童话故事中，黑魔法是一种可以让你实现目标的东西，但有一个附加的价格标签。有时这个标签是相当血腥的，但这不是我的情况。实际上，我的目标和代价是一样的：我想用不同的东西来吸引你。</p>
<p>这就是要施的法术。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">\r</span> <span class="o">=</span> <span class="k">role</span> <span class="ow">R</span><span class="err">[</span><span class="o">::</span><span class="err">T</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span> <span class="nb">Numeric</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">my</span> <span class="nv">\tenv</span> <span class="o">=</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">body_block</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">C</span><span class="o">,</span> <span class="nb">Str</span><span class="o">,</span> <span class="nb">Int</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">\ctx</span> <span class="o">=</span> <span class="nf">nqp::atpos</span><span class="p">(</span><span class="n">tenv</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">\iter</span> <span class="o">=</span> <span class="nf">nqp::iterator</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="k">while</span> <span class="n">iter</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\elem</span> <span class="o">=</span> <span class="nf">nqp::shift</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="nb">say</span> <span class="nf">nqp::iterkey_s</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2"> =&gt; </span><span class="p">&#34;</span><span class="o">,</span> <span class="nf">nqp::iterval</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>只要主体块是一个例程，显然我们可以自己调用它。为了理解剩下的几行和所有使用的 <code>nqp:: ops</code>，人们需要参考 <a href="https://github.com/Raku/nqp/blob/master/docs/ops.markdown">NQP ops</a> 文档。</p>
<p>总之，&ldquo;咒语&quot;产生的输出可能看起来像这样。</p>
<pre><code>::?CLASS =&gt; (C)
$?ROLE =&gt; (R)
T =&gt; (Str)
$?CONCRETIZATION =&gt; (Mu)
$?PACKAGE =&gt; (R)
::?PACKAGE =&gt; (R)
V =&gt; (Int)
::?ROLE =&gt; (R)
$?CLASS =&gt; (C)
$_ =&gt; (Mu)
</code></pre><p>用两个字来说，角色体块返回一个包含两个元素的数组。第二个元素是符号名称到其具体值的映射。也就是说，在 <code>=&gt;</code> 箭头左侧的键中，你可以很容易地从角色签名中发现我们的 <code>T</code> 和 <code>V</code> 类型捕获；以及编译器常量，如 <code>::?CLASS</code> 和其他。</p>
<p>总的来说，代码返回的东西被称为内部类型环境，并被用于另一种广泛采用的机制，即泛型实例化。但这个话题肯定远远超出了本文的目的。这里确实值得一提的是，所有包含在环境中的符号实际上都是角色体词法。例如，如果我们把我的 <code>FOO = 42</code> 加入到主体中，那么上面的输出就会有以下一行加入到其中。</p>
<pre><code>FOO =&gt; 42
</code></pre><p>另外，看着这些符号，你现在甚至可以更好地理解为什么角色的特化需要一个类来消耗它。你下次在做类似的事情时可能会考虑到这一点。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">foo</span><span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>最后我想指出的一点是 <code>$?CONCRETIZATION</code> 符号，它还没有被记录下来。它只在角色主体和角色方法中可用，并且当它可用时被绑定到角色的具体化中。这个符号主要是用于自省的目的。</p>
<h3 id="步骤4a-特化">步骤4a: 特化</h3>
<p>所以，我们有一个候选者。我们知道具体的参数。我们知道消耗它的类。因此，我们确实知道了一切，可以进行特化，并得到具体化，最终将这个角色纳入消费它的类中。</p>
<p>正如我在上面已经提到的，特化是一个相当复杂的过程。在 Rakudo 元模型的实现中，它分布在几个源文件中，并涉及到一些其他的内部机制，如通用实例化，我在上面也暗示过。我最好不要深究其中的细节，而是专注于主要的阶段。那些真正好奇的人可以从 Rakudo 编译器源文件 src/Perl6/Metamodel/ParametricRoleHOW.nqp 中的方法特化开始。</p>
<p>特化一个新的角色，首先要创建一个 <code>Perl6::Metamodel::ConcreteRoleHOW</code> 的新实例和相应的具体角色类型对象。然后调用 body block 来获得一个类型环境结构。我将重点介绍一下这个。像往常一样，我们先举一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside the role, class is </span><span class="p">&#34;</span><span class="o">,</span> <span class="vg">::?CLASS</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">class is composed? </span><span class="p">&#34;</span><span class="o">,</span> <span class="vg">::?CLASS</span><span class="o">.^</span><span class="nf">is_composed</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">C1</span> <span class="k">does</span> <span class="nc">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C2</span> <span class="k">does</span> <span class="nc">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1"># inside the role, class is C1</span>
<span class="c1"># class is composed? no</span>
<span class="c1"># inside the role, class is C2</span>
<span class="c1"># class is composed? no</span>
</code></pre></div><p>我们在这里观察到的是，角色主体已经被调用了两次，它知道它所应用的类，而且这个类还没有被组成（我在<a href="https://vrurg.github.io/arfb-publication/02-everything-is-an-object-mop/#raku-metamodel">另一篇文章</a>中介绍了一些关于类生命周期的信息）。另外，正如我已经提到的，具体化在这一点上存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span>
	<span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># R</span>
<span class="p">}</span>
</code></pre></div><p>但它还是空的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nb">attributes</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span> <span class="c1"># 0</span>
<span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nb">methods</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>    <span class="c1"># 0</span>
</code></pre></div><p>而且，很明显，没有组成。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nf">is_composed</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;;</span> <span class="c1"># no</span>
</code></pre></div><p>所有这些使得角色体成为一个好地方，可以在角色被实际消费时做需要做的事情。</p>
<p>现在，有了所有必要的信息，元模型通过实例化原始参数化或柯里化角色的属性和方法，并将它们安装到新创建的具体化中来最终完成专业化。例如这个片段的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{</span> <span class="k">has</span> <span class="nb">T</span> <span class="nv">$.attr</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="ow">R</span><span class="p">[</span><span class="nb">Str</span><span class="p">]</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>如果我们转储原始角色和具体化的属性，我们可能会看到类似于下面的输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">attr:</span> <span class="p">(</span><span class="nb">Attribute</span><span class="o">|</span><span class="mi">94613946040184</span> <span class="nb">T</span> <span class="nv">$!attr</span><span class="p">)</span>
<span class="nf">concretization</span> <span class="n">attr:</span> <span class="p">(</span><span class="nb">Attribute</span><span class="o">|</span><span class="mi">94613946043184</span> <span class="nb">Str</span> <span class="nv">$!attr</span><span class="p">)</span>
</code></pre></div><p>当用属性和方法完成时，任何被消耗的角色都会被实例化和具体化。例如，对于这个声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R2</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p><code>R2</code> 的具体化将被添加到 <code>R1</code> 的具体化中，然后 <code>R2</code> 的具体化将被添加到 <code>R1</code> 的具体化中。</p>
<p>最后，如果有任何父类添加到角色中，它们也会被实例化和添加。</p>
<p>当所有上述准备工作完成后，我们的具体化就被组成了。它现在已经准备好被添加到它的消费类中。</p>
<p>故事就这样结束了。</p>
<h2 id="偿还债务">偿还债务</h2>
<p>知道很久以前的承诺最终得到了兑现，真的让人松了一口气。不幸的是，为了涵盖这个主题，我已经跳过了其他一些更基本的主题。例如，让读者更好地了解多重调度、类型对象的组成，以及 Rakudo、NQP 和后端虚拟机是如何相互作用的，这对读者是有益的。如果我写了足够多的文章，并考虑把这些材料编成一本书，那么由这段文字组成的章节将被放在离书的开头更远的地方。</p>
<p>不管怎么说，我已经尽了最大的努力，远离那些还未被提及的概念，希望你在这里找到有用的信息。</p>
<p>原文链接: <a href="https://vrurg.github.io/arfb-publication/07-roles-or-when-one-is-many/">https://vrurg.github.io/arfb-publication/07-roles-or-when-one-is-many/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/role" term="role" label="Role" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Syntax I Miss in Other Languages]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-06-17-raku-syntax-i-miss-in-other-languages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-06-05-learn-raku-from-roast/?utm_source=atom_feed" rel="related" type="text/html" title="Learn Raku From Roast" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Multiple Dispatch With the New MoarVM Dispatcher" />
                <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 的标准库 Trait 之旅" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
            
                <id>https://ohmyweekly.github.io/notes/2021-06-17-raku-syntax-i-miss-in-other-languages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-06-17T00:00:00+08:00</published>
            <updated>2021-06-17T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Syntax I Miss in Other Languages</blockquote><h1 id="self-describing-code">Self-describing code</h1>
<h2 id="junctions">Junctions</h2>
<ul>
<li>Distributive</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span><span class="p">{</span><span class="nb">any</span><span class="p">(</span><span class="nv">@keys</span><span class="p">)}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">any</span><span class="p">(</span><span class="nv">%hash</span><span class="p">{</span><span class="nv">@keys</span><span class="p">})</span>
</code></pre></div><ul>
<li>Boolean</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">操作符</th>
<th style="text-align:left">True if &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">any</td>
<td style="text-align:left">|</td>
<td style="text-align:left">至少一个值为真</td>
</tr>
<tr>
<td style="text-align:left">all</td>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">所有值都为真</td>
</tr>
<tr>
<td style="text-align:left">one</td>
<td style="text-align:left">^</td>
<td style="text-align:left">只有一个值为真</td>
</tr>
<tr>
<td style="text-align:left">none</td>
<td style="text-align:left"></td>
<td style="text-align:left">值都不为真</td>
</tr>
</tbody>
</table>
<p>Junctions 通常出现在布尔上下文中。例如, 在下面的例子中, <code>$value</code> 和几个值进行相等性比较。很容易写出这样的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div><p>使用 <code>any</code> Junction 会简洁不少:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="nb">any</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="nb">any</span>
</code></pre></div><p>惯用法是使用 <code>|</code> 操作符号来进行多值比较:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">1</span><span class="o">|</span><span class="mi">2</span><span class="o">|</span><span class="mi">5</span>
</code></pre></div><p>找出数组中满足条件的第一个元素, 我们首先想到的可能是, 使用 <code>for</code> 循环迭代数组, 找出满足条件的元素就立即退出循环:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nb">False</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@values</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$value</span> <span class="o">&gt;</span> <span class="mi">42</span> <span class="p">{</span>
        <span class="nv">$result</span> <span class="o">=</span> <span class="nb">True</span><span class="p">;</span>
        <span class="nb">last</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nv">$result</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>改用 Junction 后等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">42</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>还可以在 Junction 上调用方法或运算符:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">one</span><span class="p">(</span><span class="nv">@values</span><span class="p">)</span><span class="o">.</span><span class="nb">is-prime</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nv">@values</span><span class="p">)</span> <span class="nv">%%</span> <span class="mi">3</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="named-arguments命名参数">Named arguments(命名参数)</h2>
<p>Colonpair(冒号对儿) 通常用于命名参数中:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="s">foo</span> <span class="o">=&gt;</span> <span class="mi">42</span>

<span class="k">sub</span> <span class="nf">bar</span><span class="p">(</span><span class="o">:</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">bar</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</code></pre></div><p>有几种特殊形式的冒号对儿:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">foo</span>
<span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="nb">True</span><span class="p">)</span>

<span class="p">:!</span><span class="s">foo</span>
<span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="nb">False</span><span class="p">)</span>

<span class="p">:</span><span class="s">foo</span><span class="p">&lt;</span><span class="s">bar</span><span class="p">&gt;</span>
<span class="p">:</span><span class="s">foo</span><span class="p">(&#34;</span><span class="s2">bar</span><span class="p">&#34;)</span>
</code></pre></div><p><code>:foo</code> 与 <code>foo =&gt; True</code> 相同, <code>:!foo</code> 等价于 <code>foo =&gt; False</code>。<code>:foo&lt;bar&gt;</code> 使用了一组尖括号引起了值, 值在尖括号中不进行插值。</p>
<p>来看一个命名参数例子, 下面的代码遍历 <code>@dirs</code> 中的目录, 找出后缀名为 txt 且不为空的文件:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nb">find</span><span class="p">(</span><span class="nv">@dirs</span><span class="o">,</span> <span class="p">:</span><span class="s">file</span><span class="o">,</span> <span class="p">:</span><span class="s">ext</span><span class="p">&lt;</span><span class="s">txt</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:!</span><span class="s">empty</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$file</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>冒号对儿的值可以是变量, 但是在圆括号中再写一遍变量名就显得啰嗦:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">foo</span><span class="p">(:</span><span class="s">bar</span><span class="p">(</span><span class="nv">$bar</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">baz</span><span class="p">(</span><span class="nv">$baz</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">quz</span><span class="p">(</span><span class="nv">$quz</span><span class="p">))</span>
</code></pre></div><p>因此, 冒号对儿提供了一种简写形式, 如果冒号后面紧跟着 <code>$</code>、<code>@</code>、<code>%</code> 和 <code>&amp;</code> 等符号, 那么冒号对儿的值就是 <code>$sth</code>、<code>@sth</code>、<code>%sth</code> 和 <code>&amp;sth</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">foo</span><span class="p">(</span><span class="o">:</span><span class="nv">$bar</span><span class="o">,</span> <span class="o">:</span><span class="nv">$baz</span><span class="o">,</span> <span class="o">:</span><span class="nv">$quz</span><span class="p">)</span>
</code></pre></div><p>这种简写形式消除了命名参数的重复。</p>
<h2 id="pointy-blocks尖号块儿">Pointy blocks(尖号块儿)</h2>
<p>All blocks are <strong>Callable</strong>, 即所有的块儿都是可调用的。</p>
<ul>
<li><code>for</code> blocks</li>
</ul>
<p><code>-&gt; $elem { ...}</code> 就是尖号块儿:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@array</span> <span class="k">-&gt;</span> <span class="nv">$elem</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><code>for</code> 循环依次把 <code>@array</code> 中的每个元素赋值给尖号块儿中的 <code>$elem</code> 变量, 然后执行尖号块儿的主体。</p>
<ul>
<li>Ordering</li>
</ul>
<p>如果 <code>foo</code> 例程有返回值且不为假, 则赋值给 <code>$value</code>, 然后执行块儿的主体:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>但是上面的语句在 Raku  中是不合法的, 要使用尖号块儿的方式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="signatures签名">Signatures(签名)</h2>
<p><code>for</code> 循环可以一次迭代两个(或多个)元素。尖号块儿相当于匿名函数, 其中的 <code>$first, $second</code> 就是尖号块儿的签名。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@array</span> <span class="k">-&gt;</span> <span class="nv">$first</span><span class="o">,</span> <span class="nv">$second</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>下面的智能匹配中, 变量 <code>$1</code> 和 <code>$2</code> 有些多余:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="o">/</span> <span class="p">(</span>\<span class="k">S</span><span class="err">+</span><span class="p">)</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr"> / </span><span class="p">{</span> 
    <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$1</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nv">$2</span><span class="p">;</span>
    <span class="o">...</span>
 <span class="p">}</span><span class="sr">
</span></code></pre></div><p>通过尖号块儿, 把匹配结果直接赋值给 <code>$name</code> 和 <code>$value</code>, 节省了两个变量名:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="o">/</span> <span class="p">(</span>\<span class="k">S</span><span class="err">+</span><span class="p">)</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr"> / -</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><code>for</code> 尖号块儿和 <code>if</code> 尖号块儿的结构类似, 语法上非常整齐:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nf">expression</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="nf">expression</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="whatever-code">Whatever code</h2>
<p>如果 grep 的过滤条件中有多个变量, 那么使用尖号块儿这种匿名函数比较合适:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@numbers</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">});</span>
</code></pre></div><p>如果过滤条件中只有一个变量, 那么形式更短的 Whatever code 更符合惯用法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@numbers</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div><h2 id="meta-operators">Meta-operators</h2>
<ul>
<li>Reduction</li>
<li>Zip</li>
<li>Corss</li>
<li>Hyper</li>
</ul>
<p>Reduction meta operators</p>
<ul>
<li>fold/reduce an infix operator</li>
<li>Respects associativity</li>
</ul>
<p><code>reduce</code> 运算符可以用于求和:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="nb">reduce</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@list</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="o">[+]</span> <span class="nv">@list</span>
</code></pre></div><pre><code>[+]   # sum
[*]   # product
[~]   # join
[===] # all equal
[&lt;&gt;]  # ascending order
[||]  # first true value, if any
</code></pre>
<p>Zip 元运算符用于连接列表:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">Z</span><span class="o">+</span> <span class="p">(</span><span class="mi">30</span><span class="o">,</span> <span class="mi">20</span> <span class="o">,</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># (21, 22, 13)</span>
</code></pre></div><p><code>-&gt; ($a, $b)</code> 解构 Zip 后的元素:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><code>Z=&gt;</code> 运算符通常用于从两个列表中制作哈希:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span> <span class="o">=</span> <span class="nv">@keys</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@values</span>
</code></pre></div><p>Zip 元运算符可以写成链式的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="ow">Z</span> <span class="nv">@c</span>
<span class="o">[</span><span class="ow">Z</span><span class="o">]</span> <span class="nv">@list-of-lists</span>
</code></pre></div><p>Cross 是交叉运算符。使用两层 for 循环也可以实现交叉运算符的功能, 就是代码稍长:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">gather</span> <span class="k">for</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">10</span> <span class="k">-&gt;</span> <span class="nv">$j</span> <span class="p">{</span>
        <span class="nb">take</span> <span class="nv">$i</span> <span class="o">+</span> <span class="nv">$j</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>而使用交叉运算符, 一行代码搞定:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="ow">X</span><span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">10</span>
</code></pre></div><p>添加前缀也很简单:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">prefix-</span><span class="p">&#34;</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@list</span>
</code></pre></div><p>Hyper 运算符可以把任何运算符(中缀、前缀和后缀等)应用到列表上:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@list</span><span class="o">».</span><span class="nb">abs</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">abs</span><span class="p">)</span>

<span class="o">!</span><span class="p">«</span><span class="nv">@list</span><span class="s2">
</span><span class="s2"></span><span class="nv">@list</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="o">!*</span><span class="p">)</span><span class="s2">
</span><span class="s2">
</span><span class="s2"></span><span class="nv">@list</span><span class="p">»</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
</code></pre></div><p>欧几里得距离:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span>
</code></pre></div><p>Squared(平方)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span><span class="p">)</span><span class="o">»</span>²
</code></pre></div><p>Summed(求和)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[+]</span> <span class="p">(</span><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span><span class="p">)</span><span class="o">»</span>²
</code></pre></div><p>Square root(求平方根)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">sqrt</span> <span class="o">[+]</span> <span class="p">(</span><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span><span class="p">)</span><span class="o">»</span>²
</code></pre></div><h2 id="smartmatch智能匹配">Smartmatch(智能匹配)</h2>
<p>“Is the value part of this set”</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="nv">$_</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">})</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">isa</span><span class="p">(</span><span class="n">Innt</span><span class="p">)</span> <span class="p">})</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(/</span><span class="sr">foo </span><span class="ni">.</span><span class="o">*</span><span class="sr"> bar</span><span class="p">/)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">foo </span><span class="ni">.</span><span class="o">*</span><span class="sr"> bar</span><span class="p">/)</span> <span class="p">})</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">4</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="p">})</span>

<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(:</span><span class="s">is-prime</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">is-prime</span> <span class="p">})</span>
</code></pre></div><p>combine junctions(结合 Junctions):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(:</span><span class="s">is-prime</span> <span class="o">&amp;</span> <span class="o">/</span><span class="mi">22</span><span class="o">/</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">is-prime</span> <span class="o">&amp;&amp;</span> <span class="o">.</span><span class="nf">matches</span><span class="p">(/</span><span class="mi">22</span><span class="p">/)</span> <span class="p">})</span>

<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="nb">none</span><span class="p">(/</span><span class="mi">22</span><span class="p">/))</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">!.</span><span class="nf">matches</span><span class="p">(/</span><span class="mi">22</span><span class="p">/)</span> <span class="p">})</span>
</code></pre></div><p>最后, 还是查找文件的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">find</span><span class="p">(</span><span class="nv">@dirs</span><span class="o">,</span>
  <span class="p">:</span><span class="s">ext</span><span class="p">(&#39;</span><span class="s1">rakumo</span><span class="p">&#39;</span><span class="o">|</span><span class="p">&#39;</span><span class="s1">pm6</span><span class="p">&#39;)</span><span class="o">,</span>
  <span class="p">:</span><span class="s">size</span><span class="p">(</span><span class="o">*</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">)</span><span class="o">,</span>
  <span class="p">:</span><span class="s">depth</span><span class="p">(</span><span class="mi">3</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span><span class="o">,</span>
  <span class="p">:</span><span class="s">contains</span><span class="p">(/</span><span class="sr">raku</span><span class="p">/)</span>
<span class="p">);</span>
</code></pre></div><p>原文链接: <a href="https://www.youtube.com/watch?v=elalwvfmYgk">https://www.youtube.com/watch?v=elalwvfmYgk</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Multiple Dispatch With the New MoarVM Dispatcher]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 的标准库 Trait 之旅" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-15T00:00:00+08:00</published>
            <updated>2021-04-15T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Multiple Dispatch With the New Moarvm Dispatcher</blockquote><p>我最近写了一篇关于<a href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/">新的 MoarVM 调度机制</a>的文章，并在那篇文章中指出，我在 Raku 的多重分派语义方面还有不少需要实现的地方。从那以后，我在这个方向上取得了不小的进展。这篇文章包含了对所采取的方法的概述，以及一些非常粗略的性能测量。</p>
<h2 id="我的天啊语义太多了">我的天啊，语义太多了</h2>
<p>在 Raku 的所有分派中，多重分派是最复杂的。多重分派允许我们写一组候选者，然后根据参数的数量进行选择。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nb">ok</span><span class="p">(</span><span class="nv">$condition</span><span class="o">,</span> <span class="nv">$desc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">$condition</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">ok</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">not ok</span><span class="p">&#39;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> - </span><span class="nv">$desc</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">multi</span> <span class="nb">ok</span><span class="p">(</span><span class="nv">$condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">ok</span><span class="p">(</span><span class="nv">$condition</span><span class="o">,</span> <span class="p">&#39;&#39;);</span>
<span class="p">}</span>
</code></pre></div><p>或根据参数的类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">to-json</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$i</span><span class="p">)</span> <span class="p">{</span> <span class="o">~</span><span class="nv">$i</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">to-json</span><span class="p">(</span><span class="nb">Bool</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$b</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">true</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">false</span><span class="p">&#39;</span> <span class="p">}</span>
</code></pre></div><p>而且不只是一个参数，而是可能有很多参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$chars</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$str</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&lt;</span> <span class="nv">$chars</span> <span class="o">??</span> <span class="nv">$str</span> <span class="o">!!</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$chars</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$after</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">with</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">index</span><span class="p">(</span><span class="nv">$after</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$pos</span> <span class="p">{</span>
        <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$pos</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nv">$str</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们可以添加 <code>where</code> 子句来区分普通类型无法捕捉的属性上的候选者。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>每当我们写出一组这样的 <code>multi</code> 候选列表时，编译器就会自动生成一个 <code>proto</code> 例程。这就是安装在符号表中的，存放候选列表的东西。然而，我们也可以写自己的 <code>proto</code>，并使用特殊的术语 <code>{*}</code> 来决定在哪一点上进行调度，如果有的话。</p>
<pre><code class="language-rakuu" data-lang="rakuu">proto mean($collection) {
    $collection.elems == 0 ?? Nil !! {*}
}

multi mean(@arr) {
    @arr.sum / @arr.elems
}

multi mean(%hash) {
    %hash.values.sum / %hash.elems
}
</code></pre><p>候选者按窄度排序（使用拓扑排序）。如果多个候选者匹配，但它们窄度相同，那么这就是一个歧义错误。否则，我们调用最窄的一个。然后，我们选择的候选者可能会使用 <code>callsame</code> 和它的朋友们来推迟到下一个最窄的候选者，后者可能也会这样做，直到我们达到最一般的匹配的候选者。</p>
<h2 id="多重分派无处不在">多重分派无处不在</h2>
<p>Raku 在很大程度上依赖于多重分派。Raku 中的大多数操作符都被编译成对多重分派子程序的调用。即使是 <code>$a+$b</code> 也会是一个多重分派。这意味着高效地进行多重分派对性能真的很重要。考虑到其语义的丰富性，这有可能有点令人担忧。不过，也有好消息。</p>
<h2 id="大多数多重调度都很无聊">大多数多重调度都很无聊</h2>
<p>我们遇到的绝大多数情况是:</p>
<ul>
<li>一个仅由参数和名义类型的数量所做的决定。</li>
<li>无 where 子句</li>
<li>无自定义 proto</li>
<li>无 callsame</li>
</ul>
<p>这并不是说其他情况不重要，它们确实相当有用，而且它们的表现也是可取的。不过，在普通情况下，我们能省则省，也是可取的。例如，我们不希望急于计算每一个单次多重调度的全部可能的候选者，因为大多数时候只有第一个才是重要的。这不仅仅是时间上的问题：回想一下，新的调度机制会在每个调用点存储调度程序，如果我们在每个调用点存储所有匹配的候选程序列表，我们也会浪费很多内存。</p>
<h2 id="我们今天怎么做">我们今天怎么做？</h2>
<p>如今 Rakuo 的情况如下:</p>
<ul>
<li>
<p>如果调度只由元数和名义类型决定，并且你不使用扁平化的参数来调用它，它可能会表现得很好，甚至可能会享受到候选者的内联和消除在慢速路径上发生的重复类型检查。这要归功于 proto 持有一个 &ldquo;dispatch cache&rdquo;，这是一个在 VM 中实现的特例机制，它使用搜索树，每个参数有一个级别。</p>
</li>
<li>
<p>如果是这种情况，但它有一个自定义的 proto，也不会太差，虽然不会发生内联，它仍然可以使用搜索树。</p>
</li>
<li>
<p>如果它使用 <code>where</code> 子句，速度会很慢，因为搜索树只处理在每一个名义类型集合中找到一个候选者，所以我们不能使用它。</p>
</li>
<li>
<p>同样的道理也适用于 <code>callsame</code>，它的速度也会很慢。</p>
</li>
</ul>
<p>实际上，今天的情况是，如果在热路径附近的任何地方，你根本不会在多重调度中使用 <code>where</code>子句（好吧，如果你知道热路径在哪里，并且知道这种调度很慢）。同理，<code>callsame</code> 也是如此，虽然那不太常触达。问题是，我们能不能用新的调度器做得更好？</p>
<h2 id="守卫类型">守卫类型</h2>
<p>我们先看看最简单的情况是如何处理的，然后再从那里开始建立。(这其实是我在实现上的做法，但同时我也有一个大概的想法，我希望最终的结果是什么)。</p>
<p>回忆一下这对候选者。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$chars</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$str</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&lt;</span> <span class="nv">$chars</span> <span class="o">??</span> <span class="nv">$str</span> <span class="o">!!</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$chars</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$after</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">with</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">index</span><span class="p">(</span><span class="nv">$after</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$pos</span> <span class="p">{</span>
        <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$pos</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nv">$str</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后我们有一个调用 <code>truncate($message, &quot;\n&quot;)</code>，其中 <code>$message</code> 是 <code>Str</code> 类型的。在新的调度机制下，调用是使用 <code>raku-call</code> dispatcher 进行的，它识别出这是一个 <code>multi</code> 方法调度，因此委托给 <code>raku-multi</code>。(<code>multi</code> 方法调度也会在那里结束)。</p>
<p>调度的记录阶段 - 在我们第一次到达这个调用点时 - 将进行如下操作。</p>
<ol>
<li>迭代候选者</li>
<li>如果某个候选者在参数数上不匹配，就直接丢弃它。由于 <code>callsite</code> 的形状是一个常数，而且我们在每个 <code>callsite</code> 都会计算 dispatch 程序，所以我们不需要为此建立任何防护措施。</li>
<li>如果在类型匹配并且成功了，注意涉及哪些参数，需要什么样的守卫。</li>
<li>如果没有匹配或者模棱两可，就报错，不产生调度程序。</li>
<li>否则，在确定了类型守卫后，将选定的候选程序委托给 <code>raku-invoke</code> 调度程序。</li>
</ol>
<p>当我们再次到达同一个调用点时，我们可以运行调度程序，它可以快速检查参数类型是否与上次看到的参数类型相匹配，如果相匹配，我们就知道要调用哪个候选程序。这些检查非常便宜 - 比遍历所有候选者并检查每个候选者是否匹配要便宜得多。优化器以后可能会证明这些检查总是会成为事实，并消除它们。</p>
<p>因此，整个调度过程 - 至少对于这个我们只有类型和元数的简单案例 - 可以向虚拟机 &ldquo;解释&rdquo; 为 &ldquo;如果参数具有这些确切的类型，就调用这个例程&rdquo;。这和我们对方法分派所做的差不多，除了我们只关心第一个参数的类型 - 调用者 - 和方法名的值。(还记得上一篇文章中说过，如果是 <code>multi</code> 方法调度，那么方法调度和 <code>multi</code> 方法调度都会守护第一个参数的类型，但是消除了重复，所以只做一次检查)。</p>
<h2 id="这就进入了恢复之洞">这就进入了恢复之洞</h2>
<p>想出好的抽象是很难的，新的调度机制的很多挑战就在于此。Raku 有不少不同的类似调度的东西。然而，将它们全部直接编码在虚拟机中会导致很高的复杂度，这使得构建可靠的优化（甚至是可靠的未优化的实现！）具有挑战性。因此，我们的目标是研究出一套相对较小的原语，允许以这样一种方式向虚拟机 &ldquo;解释&rdquo; 调度，使其能够提供不错的性能。</p>
<p>很明显，<code>callsame</code> 是一种调度恢复，但自定义 proto 这种情况和 <code>where</code> 子句这种情况呢？事实证明，这些也都可以用调度恢复的方式整齐地表达出来（<code>where</code> 子句情况需要在虚拟机层面增加一个小的内容，到时候可能对其他事情也有用）。不仅如此，用调度恢复来编码这些特性也是相当直接的，因此应该是高效的。我们教给专门人员的关于如何更好地使用调度恢复的每一个技巧，都可以让所有使用它们实现的语言特性也受益。</p>
<h2 id="自定义-proto">自定义 proto</h2>
<p>回顾这个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">mean</span><span class="p">(</span><span class="nv">$collection</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$collection</span><span class="o">.</span><span class="nb">elems</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">??</span> <span class="nb">Nil</span> <span class="o">!!</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这里，我们希望运行 proto 的主体，然后在 <code>{*}</code> 这里进行候选者的选择。相比之下，当我们没有自定义的 proto 时，我们希望简单地继续调用正确的多。</p>
<p>为了达到这个目的，我首先将 <code>multi</code> 候选者的选择逻辑从 <code>raku-multi</code> 调度器移到了 <code>raku-multi-core</code> 调度器中。然后，<code>raku-multi</code> dispatcher 会检查我们是否有一个 &ldquo;onlystar&rdquo; proto（一个不需要我们运行的 proto）。如果有，它就会立即委托给 <code>raku-multi-core</code>。如果没有，它就将调度的参数保存为恢复初始化状态，然后调用 proto。proto 的 <code>{*}</code> 被编译成一个 dispatch resumption。然后，这个 resumption 委托给 <code>raku-multi-core</code>。或者，在代码中。</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="c1"># Initial dispatch, only setting up resumption if we need to invoke the</span>
    <span class="c1"># proto.</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$callee</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">my</span> <span class="nb">int</span> <span class="nv">$onlystar</span> <span class="o">:=</span> <span class="nf">nqp::getattr_i</span><span class="p">(</span><span class="nv">$callee</span><span class="o">,</span> <span class="nb">Routine</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!onlystar</span><span class="p">&#39;);</span>
        <span class="k">if</span> <span class="nv">$onlystar</span> <span class="p">{</span>
            <span class="c1"># Don&#39;t need to invoke the proto itself, so just get on with the</span>
            <span class="c1"># candidate dispatch.</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi-core</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1"># Set resume init args and run the proto.</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-init-args</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-invoke</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="o">,</span>
    <span class="c1"># Resumption means that we have reached the {*} in the proto and so now</span>
    <span class="c1"># should go ahead and do the dispatch. Make sure we only do this if we</span>
    <span class="c1"># are signalled to that it&#39;s a resume for an onlystar (resumption kind 5).</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$track_kind</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_kind</span><span class="p">);</span>
        <span class="k">my</span> <span class="nb">int</span> <span class="nv">$kind</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg_i</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="nv">$kind</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi-core</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-get-resume-init-args</span><span class="p">&#39;));</span>
        <span class="p">}</span>
        <span class="k">elsif</span> <span class="o">!</span><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-next-resumption</span><span class="p">&#39;)</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-constant</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span>
                    <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nb">Nil</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">});</span>
</code></pre></div><h2 id="合二为一">合二为一</h2>
<p>推迟到下一个候选者（例如用 <code>callsame</code>）和因为 <code>where</code> 子句失败而尝试下一个候选者看起来非常相似：两者都涉及遍历一个可能的候选者列表。有一些细节，但它们有很多共同点，如果能在使用新的 dispatcher 实现多重分派的过程中体现出来就更好了。</p>
<p>在这之前，先说一个略显可怕的细节，当我们有 <code>where</code> 子句的时候，今天在 Rakuo 中是如何工作的。首先，调度器会做一个 &ldquo;试用绑定&rdquo;，它问一个问题：这个签名会不会绑定？要做到这一点，它必须评估所有的 <code>where</code> 子句。更糟糕的是，它还必须使用慢路径签名绑定器，它对签名进行解释，尽管我们在很多情况下可以编译它。如果候选者匹配，很好，我们选择它，然后调用它&hellip;&hellip;这将第二次运行 <code>where</code> 子句，作为编译后的签名绑定代码的一部分。这样做一点也不高效，除了在开发人员的时间上要高效得多，这也是为什么要这样做的原因。</p>
<p>总之，毋庸置疑，在我使用新的调度器重新实现时，我相当希望尽可能避免这种重复的工作和慢路径绑定。而且，令人高兴的是，一个小小的补充提供了一个解决方案。有一个 op <code>assertparamcheck</code>，任何类型的参数检查都会被编译成（无论是类型检查、<code>where</code> 子句检查等），这将触发对一个函数的调用，该函数获取参数，也就是我们试图调用的东西，然后可以通过它们来产生错误信息。诀窍是提供一种调用例程的方法，使绑定失败后，不是调用报错函数，而是离开例程，然后做一个调度恢复! 这意味着我们可以将传递 <code>where</code> 子句检查失败变成一个调度恢复，然后会走到下一个候选者，并代替它进行尝试。</p>
<h2 id="琐碎vs非琐碎">琐碎VS非琐碎</h2>
<p>这让我们得到了大部分的解决方法，但在常见的情况下，仍然存在内存和时间效率的问题，即没有恢复和没有 <code>where</code> 子句。我为这种情况创造了一个术语 &ldquo;trivial multiple dispatch&rdquo;，这使得其他情况变得 &ldquo;non-trivial&rdquo;。事实上，我甚至做了一个调度器，叫做 <code>raku-multi-non-trivial</code>! 我们有两种方式可以结束。</p>
<ol>
<li>最初尝试寻找匹配的候选者，决定了我们必须考虑 <code>where</code> 子句。一旦我们看到是这种情况，我们就会继续制作一个可能匹配的候选者的完整列表。这是一个链表（原因见我之前的文章）。</li>
<li>最初尝试寻找匹配的候选者时，发现了一个可以纯粹根据参数数和名词类型来挑选的候选者。我们就此停止，而不是试图建立一个完整的候选列表，并运行匹配的候选。在 <code>callsame</code> 的情况下，我们最终进入琐碎的调度恢复处理程序，它 - 因为这种情况现在是非琐碎的 - 建立完整的候选者列表，从它上面剪下第一项（因为我们已经运行了那项），然后委托给 <code>raku-multi-non-trivial</code>。</li>
</ol>
<p>在这个描述中失去了另一个重要的改进：今天，当有 <code>where</code> 子句时，我们完全失去了使用 MoarVM 多重调度缓存的能力，但在新的调度器下，我们在 <code>callsite</code> 存储了一个类型过滤的候选列表，然后使用廉价的类型守卫来检查它是否有效使用。</p>
<h2 id="初步结果">初步结果</h2>
<p>我做了一些基准测试，看看新的调度机制在今天 Raku 已知的几种次优情况下的表现。这些数字并不能反映出什么是可能的，因为目前专门人员对新的调度器还没有太多的了解。相反，它们反映了我们可以期望的最小改进。</p>
<p>考虑这个基准，使用一个带有 <code>where</code> 子句的 <code>multi</code> 来递归实现 factorial。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">100_000</span> <span class="p">{</span>
    <span class="nf">fac</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>这需要进行一些调整（并在环境变量下运行）以使用新的调度器；这些都是暂时的，直到我将 Rakudo 转换为默认使用新的调度器。</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fac</span><span class="o">,</span> <span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">100_000</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fac</span><span class="o">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>在我的机器上，第一个运行时间为4.86秒，第二个运行时间为1.34秒。因此，在新的调度器下，运行时间只需过去的四分之一多一点 - 这已经是一个相当大的改进了。</p>
<p>一个涉及 <code>callsame</code> 的案例也很有意思。这里是没有使用新调度器的情况。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Any</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">a</span><span class="nv">$x</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nb">callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">r</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nb">callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">i</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nb">callsame</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="nf">fallback</span><span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">);</span>
    <span class="nf">fallback</span><span class="p">(</span><span class="mf">4.2</span><span class="p">);</span>
    <span class="nf">fallback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>   
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>而配合临时调整使用新的调度器:</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Any</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">a</span><span class="nv">$x</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">new-disp-callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">r</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">new-disp-callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">i</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">new-disp-callsame</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fallback</span><span class="o">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fallback</span><span class="o">,</span> <span class="mf">4.2</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fallback</span><span class="o">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>在我的机器上，第一个运行时间为31.3s，第二个运行时间为11.5s，这意味着使用新的调度器，我们最终需要的时间只有当前 Rakudo 的三分之一多一点。</p>
<p>这些都是相当鼓舞人心的，但正如前面提到的，大部分的多重调度都是琐碎的那种，没有使用这些功能。如果我在让其他事情变得更好的路上把最常见的情况变得更糟，那就不好了。现在还不能对此进行公平的比较：琐碎的多重分派在特化器中已经受到了很多关注，而且它还不能很好地优化使用新调度器的代码。值得注意的是，在这样的例子中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="k">m</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">m</span><span class="p">(&#34;</span><span class="s2">x</span><span class="p">&#34;);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>内嵌和其他优化会将其变成一个空循环，这是很难做到的。不过有一件事我们已经可以做了：在禁用 specializer 的情况下运行它。新的调度器版本看起来是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;m</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;m</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">x</span><span class="p">&#34;);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>结果分别是0.463s和0.332s。因此，基线执行时间 - 在特化器发挥其魔力之前 - 使用新的通用调度机制比使用我们目前使用的特化多重调度缓存要少。在做测量之前，我不知道这里会有什么预期。鉴于我们要从一个已经被剖析和调整过的特化机制转到一个没有受到如此关注的新的通用机制，我已经做好了最初做得差一点的准备，如果能做到平价就好了。在70%的时间里，跑进了70%的时间，这比我预期的进步更大。</p>
<p>我期望，一旦特化器更好地理解新的调度机制，它也能把上面的内容变成一个空循环 - 不过，由于每次优化可以进行更多的迭代，这应该还是表现为新调度器的胜利。</p>
<h2 id="最后的想法">最后的想法</h2>
<p>只要增加一个相对较小的功能，新的调度机制已经可以处理大部分的 Raku 多重调度语义。此外，即使在 specializer 和 JIT 没有真正能够做好的情况下，一些微基准已经显示出3倍-4倍的提升。这是一个很好的起点。</p>
<p>在我们使用新的调度器出货 Rakudo 版本之前，还有很多工作要做。然而，多重调度是设计中剩下的最大威胁：它比其他种类的调度相当多的参与，而且很有可能一个意想不到的缺点会引发新一轮的设计工作，或者揭示出一般机制与基线未优化的情况下, 与更专业的机制相比，性能会很吃力。到目前为止，没有任何迹象表明这两种情况，我谨慎乐观地认为整体设计是差不多的。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Rust 的标准库 Trait 之旅]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Multiple Dispatch With the New MoarVM Dispatcher" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
            
                <id>https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-15T00:00:00+08:00</published>
            <updated>2021-04-15T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Multiple Dispatch With the New Moarvm Dispatcher</blockquote><h1 id="rust-的标准库-trait-之旅">Rust 的标准库 Trait 之旅</h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#trait-basics">Trait Basics</a>
<ul>
<li><a href="#trait-items">Trait Items</a>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
</ul>
</li>
<li><a href="#scope">Scope</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
<li><a href="#unsafe-traits">Unsafe Traits</a></li>
</ul>
</li>
<li><a href="#auto-traits-1">Auto Traits</a>
<ul>
<li><a href="#send--sync">Send &amp; Sync</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
</li>
<li><a href="#general-traits">General Traits</a>
<ul>
<li><a href="#default">Default</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#any">Any</a></li>
</ul>
</li>
<li><a href="#formatting-traits">Formatting Traits</a>
<ul>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
</ul>
</li>
<li><a href="#operator-traits">Operator Traits</a>
<ul>
<li><a href="#comparison-traits">Comparison Traits</a>
<ul>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
</li>
<li><a href="#arithmetic-traits">Arithmetic Traits</a>
<ul>
<li><a href="#add--addassign">Add &amp; AddAssign</a></li>
</ul>
</li>
<li><a href="#closure-traits">Closure Traits</a>
<ul>
<li><a href="#fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</a></li>
</ul>
</li>
<li><a href="#other-traits">Other Traits</a>
<ul>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
<li><a href="#index--indexmut">Index &amp; IndexMut</a></li>
<li><a href="#drop">Drop</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conversion-traits">Conversion Traits</a>
<ul>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
</li>
<li><a href="#error-handling">Error Handling</a>
<ul>
<li><a href="#error">Error</a></li>
</ul>
</li>
<li><a href="#conversion-traits-continued">Conversion Traits Continued</a>
<ul>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
<li><a href="#fromstr">FromStr</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
<li><a href="#toowned">ToOwned</a></li>
</ul>
</li>
<li><a href="#iteration-traits">Iteration Traits</a>
<ul>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#fromiterator">FromIterator</a></li>
</ul>
</li>
<li><a href="#io-traits">I/O Traits</a>
<ul>
<li><a href="#read--write">Read &amp; Write</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#discuss">Discuss</a></li>
<li><a href="#notifications">Notifications</a></li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>你有没有想过，这两者之间有什么区别?</p>
<ul>
<li><code>Deref&lt;Target = T&gt;</code>, <code>AsRef&lt;T&gt;</code> 和 <code>Borrow&lt;T&gt;</code>?</li>
<li><code>Clone</code>, <code>Copy</code> 和 <code>ToOwned</code>?</li>
<li><code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code>?</li>
<li><code>TryFrom&lt;&amp;str&gt;</code> 和 <code>FromStr</code>?</li>
<li><code>FnOnce</code>, <code>FnMut</code>, <code>Fn</code> 和 <code>fn</code>?</li>
</ul>
<p>或者曾经问过自己这样的问题:</p>
<ul>
<li>在我的 trait 中, 我什么时候使用关联类型, 什么时候使用泛型类型?</li>
<li>什么是泛型的 blanket 实现?</li>
<li>subtrait 和 supertrait 是如何工作的?</li>
<li>为什么这个 trait 没有任何方法?</li>
</ul>
<p>那么这篇文章就是为你准备的! 它回答了以上所有的问题以及更多的问题。我们将一起对 Rust 标准库中所有最流行、最常用的 trait 进行快速飞越之旅!</p>
<p>你可以按顺序逐节阅读本文，也可以跳转到你最感兴趣的 trait，因为每个 trait 部分都有一个链接列表，链接到 “先决知识” 部分，你应该阅读这些链接，以便有足够的背景来理解当前部分的解释。</p>
<h2 id="trait-基础">Trait 基础</h2>
<p>We&rsquo;ll cover just enough of the basics so that the rest of the article can be streamlined without having to repeat the same explanations of the same concepts over and over as they reappear in different traits.</p>
<p>我们将只涉及足够的基础知识，以便文章的其余部分可以精简，而不必在不同的 trait 中重新出现时重复相同的概念解释。</p>
<h3 id="trait-项">Trait 项</h3>
<p>Trait 项是指作为 trait 声明一部分的任何项。</p>
<h4 id="self">Self</h4>
<p><code>Self</code> 总是指实现类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// always returns i32
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// returns implementing type
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">5</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// Self == SomeType
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SomeType</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">6</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// Self == OtherType
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">OtherType</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="函数">函数</h4>
<p>Trait 函数是任何第一个参数不使用 <code>self</code> 关键字的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// function
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 函数可以通过 trait 或实现类型按照命名空间的方式来调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">zero</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="nb">Default</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="方法">方法</h4>
<p>Trait 方法是指第一个参数使用 <code>self</code> 关键字并且类型为 <code>Self</code>、<code>&amp;Self</code>、<code>&amp;mut Self</code> 的任何函数。前面的类型也可以用 <code>Box</code>、<code>Rc</code>、<code>Arc</code> 或 <code>Pin</code> 来包装。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// methods
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_self</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_immut_self</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_mut_self</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// above methods desugared
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_self</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_immut_self</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_mut_self</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example from standard library
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以使用实现类型上的点运算符来调用方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，与函数类似，它们也可以通过 trait 或实现类型按照命名空间的方式来调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="关联类型">关联类型</h4>
<p>Trait 可以有关联类型。当我们需要在函数签名中使用 <code>Self</code> 以外的其他类型，但又希望类型由实现者选择，而不是在 trait 声明中硬编码时，这很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// any type implementing Trait can
</span><span class="c1">// choose the type of AssociatedType
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i8</span><span class="p">;</span><span class="w"> </span><span class="c1">// chooses i8
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="c1">// chooses u8
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span>::<span class="n">func</span><span class="p">(</span><span class="o">-</span><span class="mi">1_</span><span class="k">i8</span><span class="p">);</span><span class="w"> </span><span class="c1">// can only call func with i8 on SomeType
</span><span class="c1"></span><span class="w">    </span><span class="n">OtherType</span>::<span class="n">func</span><span class="p">(</span><span class="mi">1_</span><span class="k">u8</span><span class="p">);</span><span class="w"> </span><span class="c1">// can only call func with u8 on OtherType
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="泛型参数">泛型参数</h4>
<p>“泛型参数” 泛指泛型类型参数、泛型 lifetime 参数和泛型常量参数。由于这些说起来都很拗口，所以人们通常把它们缩写为 <em>&ldquo;generic types&rdquo;</em>, <em>&ldquo;lifetimes&rdquo;</em> 和 <em>&ldquo;generic consts&rdquo;</em>。由于 generic consts 没有在我们将要涉及的任何标准库 trait 中使用，所以它们不在本文的范围之内。</p>
<p>我们可以使用参数来泛型化一个 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// trait declaration generalized with lifetime &amp; type parameters
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// signature uses generic type
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">T</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// signature uses lifetime
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// signature uses generic type &amp; lifetime
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">i8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以为泛型类型提供默认值。最常用的默认值是 <code>Self</code>，但任何类型都可以。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// make T = Self by default
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// any type can be used as the default
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// omitting the generic type will
</span><span class="c1">// cause the impl to use the default
</span><span class="c1">// value, which is Self here
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">SomeType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// default value here is i32
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// the default is overridable as we&#39;d expect
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// overridable here too
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>除了对 trait 进行参数化外，还可以对单个函数和方法进行参数化。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="泛型类型-vs-关联类型">泛型类型 vs 关联类型</h4>
<p>泛型类型和关联类型都将决定权交给了实现者，让他们决定在 trait 的函数和方法中应该使用哪种具体类型，所以本节试图解释什么时候使用一种类型而不是另一种类型。</p>
<p>一般的经验法则是</p>
<ul>
<li>当每个类型只能有一个 trait 的实现时，使用关联类型。</li>
<li>当每个类型可以有许多可能的 trait 的实现时，使用泛型类型。</li>
</ul>
<p>假设我们想定义一个名为 <code>Add</code> 的 trait，它允许我们将值加在一起。下面是一个初始设计和只使用关联类型的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span>::<span class="n">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>比方说，我们想给 <code>Point</code> 添加和 <code>i32</code> 相加的能力，其中 <code>i32</code> 将和 <code>x</code> 和 <code>y</code> 成员相加。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span>::<span class="n">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这抛出:</p>
<pre><code class="language-none" data-lang="none">error[E0119]: conflicting implementations of trait `Add` for type `Point`:
  --&gt; src/main.rs:23:1
   |
12 | impl Add for Point {
   | ------------------ first implementation here
...
23 | impl Add for Point {
   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point`
</code></pre><p>由于 <code>Add</code> trait 没有任何泛型类型的参数化，我们只能对每个类型进行一次实现，这意味着我们只能为 <code>Rhs</code> 和 <code>Output</code> 选择一次类型！为了允许 <code>Point</code> 和 <code>Point</code> 相加,以及 <code>i32</code> 和 <code>Point</code> 相加，我们必须将 <code>Rhs</code> 从关联类型重构为泛型类型，这将允许我们用不同的类型参数为 <code>Rhs</code> 多次实现 <code>Point</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>比方说，我们添加了一个名为 <code>Line</code> 的新类型，它包含两个 <code>Point</code>，现在在我们的程序中，将两个 <code>Point</code> 相加应该产生一个 <code>Line</code> 而不是 <code>Point</code>。考虑到 <code>Add</code> trait 当前的设计，这是不可能的，因为 <code>Output</code> 是一个关联类型，但是我们可以通过将 <code>Output</code> 从关联类型重构为泛型类型来满足这些新的要求。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="w"> </span><span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">start</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">end</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Line</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">start</span>: <span class="nc">self</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">end</span>: <span class="nc">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>那么，上面的 <code>Add</code> trait 哪种最好呢？这真的取决于你的程序的要求! 合适的就是最好的。</p>
<h3 id="作用域">作用域</h3>
<p>Trait 项不能使用，除非该 trait 在作用域内。大多数 Rustaceans 在第一次尝试写一个用 I/O 做任何事情的程序时，都会艰难地学会这一点，因为 <code>Read</code> 和 <code>Write</code> trait 不在标准库的预加载中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;Cargo.toml&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ read_to_string not found in File
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>read_to_string(buf: &amp;mut String)</code> 由 <code>std::io::Read</code> trait 声明，并由 <code>std::fs::File</code> 结构体实现，但为了调用它，<code>std::io::Read</code> 必须在作用域内。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;Cargo.toml&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的 prelude 是标准库中的一个模块，即 <code>std::prelude::v1</code>，它在每个其他模块的顶部被自动导入，即 <code>use std::prelude::v1::*</code>。因此，下面的 trait 总是在作用域内，我们永远不需要显式导入它们，因为它们是 prelude 的一部分。</p>
<ul>
<li><a href="#asref--asmut">AsMut</a></li>
<li><a href="#asref--asmut">AsRef</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#drop">Drop</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#fnonce-fnmut--fn">Fn</a></li>
<li><a href="#fnonce-fnmut--fn">FnMut</a></li>
<li><a href="#fnonce-fnmut--fn">FnOnce</a></li>
<li><a href="#from--into">From</a></li>
<li><a href="#from--into">Into</a></li>
<li><a href="#toowned">ToOwned</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
<li><a href="#send--sync">Send</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#send--sync">Sync</a></li>
<li><a href="#display--tostring">ToString</a></li>
<li><a href="#partialord--ord">Ord</a></li>
</ul>
<h3 id="派生宏">派生宏</h3>
<p>标准库导出了一些派生宏，如果一个类型的所有成员都实现了某个 trait, 我们可以使用这些宏来快速方便地在这个类型上实现该 trait。这些派生宏以它们所实现的 trait 命名。</p>
<ul>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">Ord</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
</ul>
<p>使用示例:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// macro derives Copy &amp; Clone impl for SomeType
</span><span class="c1"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>注意：派生宏只是过程宏，可以做任何事情，没有硬性规定一定要实现一个 trait，也没有规定只有在类型的所有成员都实现一个 trait 的情况下才能工作，这些只是标准库中派生宏所遵循的约定。</p>
<h3 id="默认实现">默认实现</h3>
<p>Trait 可以为其函数和方法提供默认的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;default impl&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// use default impl for Trait::method
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// use our own impl for Trait::method
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OtherType impl&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;default impl&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">OtherType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;OtherType impl&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一些 trait 方法可以只用其他 trait 方法来实现，这就特别方便。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet_loudly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hello</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hola</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hello {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// use default impl for greet_loudly
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Hola</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hola {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// override default impl
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet_loudly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">greeting</span><span class="p">.</span><span class="n">insert_str</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;¡&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hello</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hello John&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hello</span><span class="p">.</span><span class="n">greet_loudly</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hello John!&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hola</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hola John&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hola</span><span class="p">.</span><span class="n">greet_loudly</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;¡Hola John!&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的许多 trait 为它们的许多方法提供了默认的实现。</p>
<h3 id="generic-blanket-impls">Generic Blanket Impls</h3>
<p>通用全面实现是在泛型类型而不是具体类型上的实现。为了解释为什么以及如何使用，让我们从为数字类型编写一个 <code>is_even</code> 方法开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">i8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">i8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">u8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">u8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">i16</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">i16</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// etc
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_is_even</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2_</span><span class="k">i8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4_</span><span class="k">u8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">6_</span><span class="k">i16</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>显然，这是很啰嗦的。而且，我们所有的实现几乎都是一样的。此外，如果 Rust 决定在未来添加更多的数字类型，我们必须记得回到这段代码，并用新的数字类型更新它。我们可以使用一个通用的全面实现来解决所有这些问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryInto</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Rem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// generic blanket impl
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">u8</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>::<span class="n">Error</span>: <span class="nc">Debug</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// these unwraps will never panic
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">2.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_is_even</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2_</span><span class="k">i8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4_</span><span class="k">u8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">6_</span><span class="k">i16</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Unlike default impls, which provide <em>an</em> impl, generic blanket impls provide <em>the</em> impl, so they are not overridable.
与默认实现不同，默认的实现提供了一个实现，而通用的全面实现提供了特定的实现，所以它们是不可覆盖的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryInto</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Rem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">u8</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>::<span class="n">Error</span>: <span class="nc">Debug</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">2.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">u8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">u8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这抛出:</p>
<pre><code class="language-none" data-lang="none">error[E0119]: conflicting implementations of trait `Even` for type `u8`:
  --&gt; src/lib.rs:22:1
   |
10 | / impl&lt;T&gt; Even for T
11 | | where
12 | |     T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
13 | |     u8: TryInto&lt;T&gt;,
...  |
19 | |     }
20 | | }
   | |_- first implementation here
21 | 
22 |   impl Even for u8 {
   |   ^^^^^^^^^^^^^^^^ conflicting implementation for `u8`
</code></pre><p>These impls overlap, hence they conflict, hence Rust rejects the code to ensure trait coherence. Trait coherence is the property that there exists at most one impl of a trait for any given type. The rules Rust uses to enforce trait coherence, the implications of those rules, and workarounds for the implications are outside the scope of this article.</p>
<p>这些实现重叠了，因此它们冲突，因此 Rust 拒绝了确保 trait 一致性的代码。Trait 一致性是指任何给定类型的 trait 最多存在一个实现的属性。Rust 用来强制执行 trait 一致性的规则，这些规则的含义，以及含义的变通方法都不在本文的范围内。</p>
<h3 id="subtraits--supertraits">Subtraits &amp; Supertraits</h3>
<p>&ldquo;subtrait&rdquo; 中的 &ldquo;sub&rdquo; 指的是子集，&ldquo;supertrait&rdquo; 中的 &ldquo;super&rdquo; 指的是超集。如果我们有一个这样的 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>All of the types which impl <code>Subtrait</code> are a subset of all the types which impl <code>Supertrait</code>, or to put it in opposite but equivalent terms: all the types which impl <code>Supertrait</code> are a superset of all the types which impl <code>Subtrait</code>.</p>
<p>Also, the above is just syntax sugar for:
所有实现 <code>Subtrait</code> 的类型都是所有实现 <code>Supertrait</code> 的类型的子集，或者用相反但等价的词语来表达：所有实现 <code>Supertrait</code> 的类型都是所有实现 <code>Subtrait</code> 的类型的超集。</p>
<p>另外，上面的代码只是下面这段代码的语法糖:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这是一个微妙而又重要的区别，要理解的是，约束是在 <code>Self</code> 上的，即实现 <code>Subtrait</code> 的类型，而不是在 <code>Subtrait</code> 本身。后者是没有任何意义的，因为 trait 约束只能应用于具体的类型，这些类型可以实现 trait。Trait 不能实现其他 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in supertrait&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// this looks like it might impl or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// override Supertrait::method but it
</span><span class="c1"></span><span class="w">    </span><span class="c1">// does not
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in subtrait&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// adds Supertrait::method to SomeType
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// adds Subtrait::method to SomeType
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// both methods exist on SomeType simultaneously
</span><span class="c1">// neither overriding or shadowing the other
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// ❌ ambiguous method call
</span><span class="c1"></span><span class="w">    </span><span class="c1">// must disambiguate using fully-qualified syntax
</span><span class="c1"></span><span class="w">    </span><span class="o">&lt;</span><span class="n">SomeType</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Supertrait</span><span class="o">&gt;</span>::<span class="n">method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅ prints &#34;in supertrait&#34;
</span><span class="c1"></span><span class="w">    </span><span class="o">&lt;</span><span class="n">SomeType</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Subtrait</span><span class="o">&gt;</span>::<span class="n">method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅ prints &#34;in subtrait&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Furthermore, there are no rules for how a type must impl both a subtrait and a supertrait. It can use the methods from either in the impl of the other.
此外，没有规定一个类型必须同时实现一个 subtrait 和一个 supertrait。它可以在另一个类型的实现中使用其中一个类型的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallSuperFromSub</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSuperFromSub</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSuperFromSub</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallSubFromSuper</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSubFromSuper</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSubFromSuper</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallEachOther</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallEachOther</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallEachOther</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CallSuperFromSub</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallSuperFromSub</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;, &#34;in super&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="n">CallSubFromSuper</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;, &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallSubFromSuper</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="n">CallEachOther</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;, &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallEachOther</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;, &#34;in super&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Hopefully the examples above show that the relationship between subtraits and supertraits can be complex. Before introducing a mental model that neatly encapsulates all of that complexity let&rsquo;s quickly review and establish the mental model we use for understanding trait bounds on generic types:
希望上面的例子能表明，subtrait 和 supertrait 之间的关系可能很复杂。在介绍一个能整齐地概括所有这些复杂性的心理模型之前，让我们快速回顾并建立我们用于理解泛型上的 trait 约束的心理模型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Without knowing anything about the impl of this function we could reasonably guess that <code>t.clone()</code> gets called at some point because when a generic type is bounded by a trait that strongly implies it has a dependency on the trait. The mental model for understanding the relationship between generic types and their trait bounds is a simple and intuitive one: generic types <em>depend on</em> their trait bounds.</p>
<p>Now let&rsquo;s look the trait declaration for <code>Copy</code>:
在不了解这个函数的实现的情况下，我们可以合理地猜测 <code>t.clone()</code> 在某些时候会被调用，因为当一个泛型被一个 trait 约束时，强烈地意味着它对 trait 有依赖性。理解泛型与其 trait 约束之间关系的心理模型是一个简单而直观的模型：泛型 “依赖” 其 trait 约束。</p>
<p>现在让我们看看 <code>Copy</code> 的 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{}</span><span class="w">
</span></code></pre></div><p>上面的语法看起来非常类似于在泛型类型上应用 trait 约束的语法，然而 <code>Copy</code> 根本不依赖于 <code>Clone</code>。我们前面开发的心理模型在这里并不能帮助我们。在我看来，理解 subtrait 和 supertrait 之间关系的最简单、最优雅的心理模型是：subtrait “精炼” 其 supertrait。</p>
<p>“精炼” 这个词故意保持有些模糊，因为它在不同的语境中可以有不同的含义。</p>
<ul>
<li>subtrait 可能会使它的 supertrait 的方法更加特化，速度更快，使用更少的内存，例如：<code>Copy: Clone</code></li>
<li>subtrait 可以对 supertrait 的方法的实现做出额外的保证，例如 <code>Eq: PartialEq</code>, <code>Ord: PartialOrd</code>, <code>ExactSizeIterator: Iterator</code></li>
<li>subtrait 可能使 supertrait 的方法更灵活或更容易调用，例如 <code>FnMut: FnOnce</code>, `Fn: FnMut</li>
<li>subtrait 可以扩展一个 supertrait，并添加新的方法，例如 <code>DoubleEndedIterator: Iterator</code>, <code>ExactSizeIterator: Iterator</code></li>
</ul>
<h3 id="trait-对象">Trait 对象</h3>
<p>泛型给了我们编译时的多态性，而 trait 对象给了我们运行时的多态性。我们可以使用 trait 对象来允许函数在运行时动态地返回不同的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">condition</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Has type:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// But is cast to:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Has type:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// But is cast to:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 对象还允许我们在集合中存储异构类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">f64</span>::<span class="n">consts</span>::<span class="n">PI</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Circle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">radius</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Square</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">side</span>: <span class="kt">f64</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Square</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">side</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">side</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_total_area</span><span class="p">(</span><span class="n">shapes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">shapes</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">area</span><span class="p">()).</span><span class="n">sum</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">shapes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span>: <span class="mf">1.0</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="c1">// Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Square</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">side</span>: <span class="mf">1.0</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="c1">// Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;
</span><span class="c1"></span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">PI</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">get_total_area</span><span class="p">(</span><span class="n">shapes</span><span class="p">));</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 对象是不确定大小的，所以它们必须总是在指针后面。我们可以根据类型中是否存在 <code>dyn</code> 关键字来区分具体类型和 trait 对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// regular struct
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">Struct</span><span class="w">
</span><span class="w"></span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// trait objects
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w">
</span><span class="w"></span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>并非所有的 trait 都可以转换为 trait 对象。如果一个 trait 满足这些要求，它就是对象安全的。</p>
<ul>
<li>trait 不需要 <code>Self: Sized</code>。</li>
<li>所有 trait 的方法都是对象安全的。</li>
</ul>
<p>如果 trait 方法满足这些要求，它就是对象安全的。</p>
<ul>
<li>方法需要 <code>Self: Sized</code> 或</li>
<li>该方法只在接收器位置使用 <code>Self</code> 类型。</li>
</ul>
<p>理解为什么要求是这样的，与本文其他部分无关，但如果你仍然好奇，在 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a> 中会有介绍。</p>
<h3 id="marker-traits">Marker Traits</h3>
<p>标记 trait 是没有 trait 项的 trait。它们的工作是将实现类型 “标记” 为具有某些属性，否则不可能用类型系统来表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Impling PartialEq for a type promises
</span><span class="c1">// that equality for the type has these properties:
</span><span class="c1">// - symmetry: a == b implies b == a, and
</span><span class="c1">// - transitivity: a == b &amp;&amp; b == c implies a == c
</span><span class="c1">// But DOES NOT promise this property:
</span><span class="c1">// - reflexivity: a == a
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Eq has no trait items! The eq method is already
</span><span class="c1">// declared by PartialEq, but &#34;impling&#34; Eq
</span><span class="c1">// for a type promises this additional equality property:
</span><span class="c1">// - reflexivity: a == a
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">Eq</span>: <span class="nb">PartialEq</span> <span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// f64 impls PartialEq but not Eq because NaN != NaN
</span><span class="c1">// i32 impls PartialEq &amp; Eq because there&#39;s no NaNs :)
</span></code></pre></div><h3 id="auto-traits">Auto Traits</h3>
<p>自动 trait 是指如果一个类型的所有成员都实现了这个 trait，那么这个 trait 就会被自动实现。“成员” 的含义取决于类型，例如：结构体的字段、枚举的变体、数组的元素、元组的项等等。</p>
<p>所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait。自动 trait 必须是标记 trait，这样编译器就可以为它们提供一个自动的缺省实现，如果它们有任何 trait 项，那就不可能了。</p>
<p>自动 trait 的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// implemented for types which are safe to send between threads
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// implemented for types whose references are safe to send between threads
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="unsafe-traits">Unsafe Traits</h3>
<p>Trait 可以被标记为不安全，以表明实现该 trait 可能需要不安全的代码。<code>Send</code> 和 <code>Sync</code> 都被标记为 <code>unsafe</code>，因为如果它们没有被自动实现，就意味着它一定包含一些非 <code>Send</code> 或非 <code>Sync</code> 成员，如果我们想手动标记类型为 <code>Send</code> 和 <code>Sync</code>，我们作为实现者必须格外小心，以确保没有数据竞争。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// SomeType is not Send or Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">not_send_or_sync</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// but if we&#39;re confident that our impl doesn&#39;t have any data
</span><span class="c1">// races we can explicitly mark it as Send and Sync using unsafe
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h2 id="auto-traits-1">Auto Traits</h2>
<h3 id="send--sync">Send &amp; Sync</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
<li><a href="#unsafe-traits">Unsafe Traits</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>如果一个类型是 <code>Send</code>，意味着在线程之间发送是安全的。如果一个类型是 <code>Sync</code>，这意味着在线程之间共享它的引用是安全的。更准确地说，如果且仅当 <code>&amp;T</code> 是 <code>Send</code> 时，一些类型 <code>T</code> 是 <code>Sync</code>。</p>
<p>几乎所有类型都是 <code>Send</code> 和 <code>Sync</code> 的。唯一值得注意的 <code>Send</code> 异常是 <code>Rc</code>，唯一值得注意的 <code>Sync</code> 异常是 <code>Rc</code>、<code>Cell</code> 和 <code>RefCell</code>。如果我们需要一个 <code>Rc</code> 的 <code>Send</code> 版本，我们可以使用 <code>Arc</code>。如果我们需要 <code>Cell</code> 或 <code>RefCell</code> 的 <code>Sync</code> 版本，我们可以 <code>Mutex</code> 或 <code>RwLock</code>。虽然如果我们使用 <code>Mutex</code> 或 <code>RwLock</code> 只是包裹一个原语类型，通常最好使用标准库提供的原子原语类型，如 <code>AtomicBool</code>、<code>AtomicI32</code>、<code>AtomicUsize</code> 等。</p>
<p>几乎所有的类型都是 <code>Sync</code>，这可能会让一些人感到惊讶，但是是的，即使对于没有任何内部同步的类型也是如此。这要归功于 Rust 严格的借用规则。</p>
<p>我们可以将同一数据的许多不可变的引用传递给许多线程，而且我们保证不会出现数据竞争，因为只要有任何不可变的引用存在， Rust 就会静态地保证底层数据不能被修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">greeting</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">scoped_thread</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// spawn 3 threads
</span><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="o">=</span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// greeting_ref copied into every thread
</span><span class="c1"></span><span class="w">            </span><span class="n">scoped_thread</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting_ref</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello {n}&#34;
</span><span class="c1"></span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="c1">// line below could cause UB or data races but compiler rejects it
</span><span class="c1"></span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ cannot mutate greeting while immutable refs exist
</span><span class="c1"></span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// can mutate greeting after every thread has joined
</span><span class="c1"></span><span class="w">    </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>同样，我们可以将单个可变引用传递给一些数据到一个线程，我们可以保证不会出现数据竞争，因为 Rust 静态地保证了别名的可变引用不能存在，底层数据不能通过现有的单个可变引用以外的任何东西进行修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">scoped_thread</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// greeting_ref moved into thread
</span><span class="c1"></span><span class="w">        </span><span class="n">scoped_thread</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">*</span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting_ref</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world&#34;
</span><span class="c1"></span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="c1">// line below could cause UB or data races but compiler rejects it
</span><span class="c1"></span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!!!&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ cannot mutate greeting while mutable refs exist
</span><span class="c1"></span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// can mutate greeting after the thread has joined
</span><span class="c1"></span><span class="w">    </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!!!&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world!!!&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这就是为什么大多数类型都是 <code>Sync</code> 而不需要任何显式同步。如果我们需要在多个线程中同时修改一些数据 <code>T</code>，编译器不会让我们这样做，直到我们将数据包裹在 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> 中，所以编译器强制要求在需要时使用显式同步。</p>
<h3 id="sized">Sized</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
</ul>
<p>如果一个类型是 <code>Sized</code> 的，这意味着它的字节大小在编译时是已知的，并且可以将该类型的实例放在栈上。</p>
<p>类型的大小和它的含义是一个微妙而又巨大的话题，它影响到语言的很多不同方面。它是如此重要，以至于我写了整整一篇文章，叫做 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a>，我强烈推荐任何想深入了解类型大小的人阅读。我总结一下与本文相关的几个关键内容。</p>
<ol>
<li>所有的泛型类型都会得到一个隐式的 <code>Sized</code> 约束。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example above desugared
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><ol start="2">
<li>由于所有泛型类型都有一个隐式的 <code>Sized</code> 约束，如果我们想退出这个隐式约束，我们需要使用特殊的 &ldquo;放宽约束&rdquo; 语法 <code>?Sized</code>，它目前只存在于 <code>Sized</code> trait。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// now T can be unsized
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><ol start="3">
<li>所有的 trait 都有一个隐式的 <code>?Sized</code> 约束。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example above desugared
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这是为了让 trait 对象可以实现 trait。同样，所有的琐碎细节都在 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a> 中。</p>
<h2 id="general-traits">General traits</h2>
<h3 id="default">Default</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以构建 <code>Default</code> 类型的默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// default color is black
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">g</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">b</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这对快速建立原型很有用，但在任何情况下，我们只需要一个类型的实例，而且对它是什么并不挑剔。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// just give me some color!
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这也是一个我们可能想明确地暴露给我们的函数用户的选项。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Canvas</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Circle</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Rectangle</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Canvas</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// let user optionally pass a color
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">paint</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span>: <span class="nc">Shape</span><span class="p">,</span><span class="w"> </span><span class="n">color</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// if no color is passed use the default color
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">.</span><span class="n">unwrap_or_default</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// etc
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Default</code> 在我们需要构造泛型类型的泛型语境中也很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">guarantee_length</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">min_len</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">min_len</span><span class="p">.</span><span class="n">saturating_sub</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">T</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以利用 <code>Default</code> 类型的另一种方式是使用 Rust 的结构体更新语法对结构体进行部分初始化。我们可以为 <code>Color</code> 设置一个 <code>new</code> 构造函数，将每个成员作为一个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，我们也可以使用方便的构造函数，每个构造函数只接受一个特定的结构体成员，其他结构体成员则使用默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">red</span><span class="p">(</span><span class="n">r</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">green</span><span class="p">(</span><span class="n">g</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">blue</span><span class="p">(</span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>还有一个 <code>Default</code> 的派生宏，所以我们可以像这样编写 <code>Color</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// default color is still black
</span><span class="c1">// because u8::default() == 0
</span><span class="c1"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="kt">u8</span>
<span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="clone">Clone</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">source</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以将 <code>Clone</code> 类型的不可变引用转换为自有值(owned values)，即 <code>&amp;T</code> -&gt; <code>T</code>。<code>Clone</code> 没有对这种转换的效率做出承诺，所以它可能是缓慢和昂贵的。为了快速地在一个类型上实现 <code>Clone</code>，我们可以使用派生宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">cloneable_member1</span>: <span class="nc">CloneableType1</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cloneable_member2</span>: <span class="nc">CloneableType2</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// macro generates impl below
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">cloneable_member1</span>: <span class="nc">self</span><span class="p">.</span><span class="n">cloneable_member1</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">cloneable_member2</span>: <span class="nc">self</span><span class="p">.</span><span class="n">cloneable_member2</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="c1">// etc
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Clone</code> 也可以在泛型上下文中构建一个类型的实例。下面是上一节中的一个例子，除了使用 <code>Clone</code> 而不是 <code>Default</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">guarantee_length</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">min_len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">fill_with</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">min_len</span><span class="p">.</span><span class="n">saturating_sub</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fill_with</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>人们也经常使用克隆作为逃避的方法，以避免与借用检查器打交道。管理带有引用的结构体可能很有挑战性，但我们可以通过克隆将引用变成自有值(owned values)。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// oof, we gotta worry about lifetimes 😟
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeStruct</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now we&#39;re on easy street 😎
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeStruct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们正在开发的程序的性能不是最重要的，那么我们就不需要为克隆数据而烦恼。Rust 是一种低级别的语言，暴露了很多低级别的细节，所以很容易被过早的优化所吸引，而不是真正解决手头的问题。对于许多程序来说，最好的优先顺序通常是首先建立正确性，其次是优雅性，第三是性能，只有在对程序进行剖析并确定了性能瓶颈之后才关注性能。这是很好的一般性建议，如果它不适用于你的特定程序，你就会知道。</p>
<h3 id="copy">Copy</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{}</span><span class="w">
</span></code></pre></div><p>我们复制 <code>Copy</code> 类型，例如：<code>T</code> -&gt; <code>T</code>。<code>Copy</code> 承诺复制操作将是一个简单的按位(bitwise)拷贝，所以它将是非常快速和高效的。我们不能自己实现 <code>Copy</code>，只有编译器可以提供一个实现，但是我们可以通过使用 <code>Copy</code> 派生宏，以及 <code>Clone</code> 派生宏来告诉编译器这样做，因为 <code>Copy</code> 是 <code>Clone</code> 的一个子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span></code></pre></div><p><code>Copy</code> 完善了(refine) <code>Clone</code>。<code>Clone</code> 可能是缓慢和昂贵的，但 <code>Copy</code> 保证是快速和便宜的，所以 <code>Copy</code> 只是一个快速 <code>Clone</code>。如果一个类型实现了 <code>Copy</code>，这就使得 <code>Clone</code> 的实现变得微不足道了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this is what the derive macro generates
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Copy</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// the clone method becomes just a copy
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当一个类型被移动时，实现该类型的 <code>Copy</code> 会改变其行为。默认情况下，所有类型都有“移动语义”，但是一旦一个类型实现了 `Copy'，它就会得到“复制语义”。为了解释这两者之间的区别，我们来看看这些简单的场景。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// a &#34;move&#34;, src: !Copy
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span><span class="w"> 
</span><span class="w">
</span><span class="w"></span><span class="c1">// a &#34;copy&#34;, src: Copy
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>在这两种情况下，<code>dest = src</code> 对 <code>src</code> 的内容进行简单的按位复制，并将结果移动到 <code>dest</code> 中，唯一的区别是，在“移动”的情况下，借用检查器使 <code>src</code> 变量无效，并确保它以后不会被用于其他地方，而在“复制”的情况下，<code>src</code> 仍然有效并可使用。</p>
<p>一言以蔽之。拷贝就“是”移动。移动就“是”拷贝。唯一的区别是借用检查器对它们的处理方式。</p>
<p>关于移动的一个更具体的例子，假设 <code>src</code> 是一个 <code>Vec&lt;i32&gt;</code>，其内容是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>当我们写下 <code>dest = src</code> 时，我们的结果是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>这个时候，<code>src</code> 和 <code>dest</code> 都有对相同数据的别名可变引用，这是一个大忌，所以借用检查器使 <code>src</code> 变量无效，这样它就不能再被使用而不会产生编译错误。</p>
<p>对于一个更具体的拷贝例子，假设 <code>src</code> 是一个 <code>Option&lt;i32&gt;</code>，它的内容是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>现在，当我们写下 <code>dest = src</code> 时，我们的结果是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>这些都是可以同时使用的! 因此 <code>Option&lt;i32&gt;</code> 是可以 <code>Copy</code> 的。</p>
<p>虽然 <code>Copy</code> 可以是一个自动 trait，但 Rust 语言的设计者决定让类型显式地选择复制语义，而不是在类型符合条件时默默地继承复制语义，因为后者会导致令人惊讶的混乱行为，经常导致错误。</p>
<h3 id="any">Any</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Any</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">type_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TypeId</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Rust 的多态性风格是参数化的，但如果我们想使用类似于动态类型语言的多态性风格，那么我们可以使用 <code>Any</code> trait 来模仿。我们不需要为我们的类型手动实现这个 trait，因为下面这个泛型全面实现已经覆盖了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Any</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">type_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TypeId</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">TypeId</span>::<span class="n">of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们从 <code>dyn Any</code> 中得到 <code>T</code> 的方法是通过使用 <code>downcast_ref::&lt;T&gt;()</code> 和 <code>downcast_mut::&lt;T&gt;()</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">any</span>::<span class="n">Any</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">map_any</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">any</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">point</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">any</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Point</span>::<span class="n">default</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">map_any</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 trait 很少需要使用，因为在大多数情况下，参数化多态性要优于临时多态性，后者也可以用枚举来模拟，因为枚举的类型更安全，需要的迂回更少。例如，我们可以把上面的例子写成这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Integer</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="n">Point</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">map_stuff</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">stuff</span>: <span class="nc">Stuff</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Integer</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="nb">String</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">inc</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">stuff</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="nb">String</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Point</span><span class="p">(</span><span class="n">Point</span>::<span class="n">default</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">map_stuff</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>尽管 <code>Any</code> 很少被需要，但有时使用起来还是很方便的，我们将在后面的“错误处理”部分看到。</p>
<h2 id="formatting-traits">Formatting Traits</h2>
<p>我们可以使用 <code>std::fmt</code> 中的格式化宏将类型序列化为字符串，其中最著名的是 <code>println!</code>。我们可以将格式化参数传递给格式 <code>str</code> 中使用的 <code>{}</code> 占位符，然后用来选择使用哪个 trait 实现来序列化占位符的参数。</p>
<table>
<thead>
<tr>
<th>Trait</th>
<th>Placeholder</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Display</code></td>
<td><code>{}</code></td>
<td>display representation</td>
</tr>
<tr>
<td><code>Debug</code></td>
<td><code>{:?}</code></td>
<td>debug representation</td>
</tr>
<tr>
<td><code>Octal</code></td>
<td><code>{:o}</code></td>
<td>octal representation</td>
</tr>
<tr>
<td><code>LowerHex</code></td>
<td><code>{:x}</code></td>
<td>lowercase hex representation</td>
</tr>
<tr>
<td><code>UpperHex</code></td>
<td><code>{:X}</code></td>
<td>uppercase hex representation</td>
</tr>
<tr>
<td><code>Pointer</code></td>
<td><code>{:p}</code></td>
<td>memory address</td>
</tr>
<tr>
<td><code>Binary</code></td>
<td><code>{:b}</code></td>
<td>binary representation</td>
</tr>
<tr>
<td><code>LowerExp</code></td>
<td><code>{:e}</code></td>
<td>lowercase exponential representation</td>
</tr>
<tr>
<td><code>UpperExp</code></td>
<td><code>{:E}</code></td>
<td>uppercase exponential representation</td>
</tr>
</tbody>
</table>
<h3 id="display--tostring">Display &amp; ToString</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Display</code> 类型可以被序列化为 <code>String</code>，这对程序的终端用户很友好。例如，给 <code>Point</code> 实现 <code>Display</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;({}, {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;origin: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// prints &#34;origin: (0, 0)&#34;
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// get Point&#39;s Display representation as a String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stringified_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;(0, 0)&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">stringified_point</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>除了使用 <code>format!</code> 宏来获得一个类型的显示表示为 <code>String</code> 之外，我们还可以使用 <code>ToString</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们没有必要自己去实现这个 trait。事实上，我们不能这样做，因为下面这个泛型全面实现，对于任何实现 <code>Display</code> 的类型，都自动实现 <code>ToString</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>将 <code>ToString</code> 与 <code>Point</code> 一起使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">display_point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;(0, 0)&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">point_to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;(0, 0)&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">display_equals_to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="p">),</span><span class="w"> </span><span class="n">origin</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="debug">Debug</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Debug</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Debug</code> 与 <code>Display</code> 有相同的签名。唯一的区别是，当我们使用 <code>{:?}</code> 格式符时，<code>Debug</code> 实现被调用。`Debug' 可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// derive macro generates impl below
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">f</span><span class="p">.</span><span class="n">debug_struct</span><span class="p">(</span><span class="s">&#34;Point&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#34;x&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#34;y&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">finish</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为一个类型实现 <code>Debug</code> 也允许它在 <code>dbg!</code> 宏中使用，这比 <code>println!</code> 更有利于临时应急的打印日志。它的一些优点如下:</p>
<ol>
<li><code>dbg!</code> 打印到 stderr 而不是 stdout，所以调试日志很容易与我们程序的实际 stdout 输出分开。</li>
<li><code>dbg!</code> 打印传递给它的表达式，以及表达式所评估的值。</li>
<li><code>dbg!</code> 拥有其参数的所有权，并返回这些参数，所以你可以在表达式中使用它。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">some_condition</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kc">true</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// no logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">some_condition</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// println! logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_println</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 🤦
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_condition</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"> </span><span class="c1">// just prints &#34;true&#34;
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// dbg! logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_dbg</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 😍
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">some_condition</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// prints &#34;[src/main.rs:22] some_condition() = true&#34;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>唯一的缺点是，<code>dbg!</code> 在发布版本中不会被自动剥离，所以如果我们不想在最终的可执行文件中使用它，就必须从我们的代码中手动删除它。</p>
<h2 id="operator-traits">Operator Traits</h2>
<p>Rust 中的所有运算符都与 trait 相关。如果我们想为我们的类型实现运算符，就必须实现相关的 trait。</p>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>
<h3 id="comparison-traits">Comparison Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
</tbody>
</table>
<h4 id="partialeq--eq">PartialEq &amp; Eq</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Rhs</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialEq&lt;Rhs&gt;</code> 类型可以使用 <code>==</code> 运算符检查是否与 <code>Rhs</code> 类型相等。</p>
<p>所有的 <code>PartialEq&lt;Rhs&gt;</code> 实现必须确保相等是对称的和传递的。这意味着对于所有的 <code>a</code>, <code>b</code>, 和 <code>c</code>:</p>
<ul>
<li><code>a == b</code> 意味着 <code>b == a</code> (对称性)</li>
<li><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code> (传递性)</li>
</ul>
<p>默认情况下 <code>Rhs = Self</code>，因为我们几乎总是想把一个类型的实例相互比较，而不是与不同类型的实例比较。这也自动保证了我们的实现是对称的和传递的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Rhs == Self == Point
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl automatically symmetric &amp; transitive
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型的所有成员都实现了 `PartialEq'，那么它可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Heart</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Club</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Diamond</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一旦为我们的类型实现了 <code>PartialEq</code>，我们也可以免费得到我们类型的引用之间的相等性比较，这要感谢这些泛型全面实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this impl only gives us: Point == Point
</span><span class="c1"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// all of the generic blanket impls below
</span><span class="c1">// are provided by the standard library
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;Point == &amp;Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;mut Point == &amp;Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;Point == &amp;mut Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;mut Point == &amp;mut Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>由于这个 trait 是泛型化的，我们可以定义不同类型之间的相等性。标准库利用这一点，允许检查许多类似字符串的类型，如<code>String</code>、<code>&amp;str</code>、<code>PathBuf</code>、<code>&amp;Path</code>、<code>OsString</code>、<code>&amp;OsStr</code> 等之间的相等性。</p>
<p>一般来说，我们只应该在不同类型之间实现相等性关系，如果它们实现同一种数据，并且类型之间的唯一区别是它们如何表示数据或如何允许与数据进行交互。</p>
<p>这里有一个可爱但糟糕的例子，说明有人可能会被诱惑实现 <code>PartialEq</code> 来检查不符合上述标准的不同类型之间的相等。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Club</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Heart</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Diamond</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Rank</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Two</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Three</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Four</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Five</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Six</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Seven</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Eight</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Nine</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Ten</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Jack</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Queen</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">King</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">suit</span>: <span class="nc">Suit</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">rank</span>: <span class="nc">Rank</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s suit
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Suit</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Suit</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s rank
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rank</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rank</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Suit</span>::<span class="n">Spade</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Rank</span>::<span class="n">Ace</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这很有效，而且有点道理。一张黑桃A的牌既是A又是黑桃，如果我们要写一个处理扑克牌的库，那么我们想让它简单方便地单独检查一张牌的花色和等级是合理的。然而，我们还缺少一些东西：对称性。 我们可以 <code>Card == Suit</code> 和 <code>Card == Rank</code>，但我们不能 <code>Suit == Card</code> 或 <code>Rank == Card</code>，所以让我们解决这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// check equality of Card&#39;s suit
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Suit</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Suit</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// added for symmetry
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Card</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">suit</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s rank
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rank</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rank</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// added for symmetry
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Rank</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Card</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">rank</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们有对称性! 太好了。增加对称性只是打破了传递性！这是不可能的。哎呀。现在可以这样了：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Ace of Spades
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Suit</span>::<span class="n">Spade</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">// King of Spades
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">King</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>实现 <code>PartialEq</code> 以检查不同类型之间的相等关系的一个好例子是一个处理距离的程序，它使用不同的类型来代表不同的测量单位。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foot</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Yard</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Mile</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Mile</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Mile</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5280</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Foot</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mile</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Foot</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5280</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Mile</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Yard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Mile</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1760</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Yard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mile</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Yard</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1760</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Foot</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Yard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Foot</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Yard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Yard</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foot</span><span class="p">(</span><span class="mi">5280</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Yard</span><span class="p">(</span><span class="mi">1760</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mile</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// symmetry
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// transitivity
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Eq</code> 是一个标记 trait，是 <code>PartialEq&lt;Self&gt;</code> 的子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Eq</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>如果我们为一个类型实现 <code>Eq</code>，在 <code>PartialEq</code> 所要求的对称性和传递性的基础上，我们还保证了自反性，即 对所有 <code>a</code>, <code>a == a</code>。在这个意义上，<code>Eq</code> 完善了 <code>PartialEq</code>，因为它代表了一个更严格的相等性版本。如果一个类型的所有成员都是<code>Eq</code> 的，那么 <code>Eq</code> 实现就可以为该类型派生。</p>
<p>浮点类型是 <code>PartialEq</code> 的，但不是 <code>Eq</code> 的，因为 <code>NaN != NaN</code>。几乎所有其他的 <code>PartialEq</code> 类型都是 <code>Eq</code>，当然，除非它们包含浮点。</p>
<p>一旦一个类型实现了 <code>PartialEq</code> 和 <code>Debug</code>，我们就可以在 <code>assert_eq!</code> 宏中使用它。我们也可以比较 <code>PartialEq</code> 类型的集合。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq, Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_assert</span><span class="p">(</span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_compare_collections</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialEq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vec1</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// if T: PartialEq this now works!
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// other code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="hash">Hash</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash_slice</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Self</span><span class="p">],</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 trait 与任何运算符无关，但谈论它的最好时机是在 <code>PartialEq</code> &amp; <code>Eq</code> 之后，所以它在这里。<code>Hash</code> 类型可以使用 <code>Hasher</code> 进行散列。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hash</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">hasher</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">hasher</span><span class="p">.</span><span class="n">write_i32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">hasher</span><span class="p">.</span><span class="n">write_i32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>有一个派生宏，它生成的实现与上述相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Hash)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型同时实现了 <code>Hash</code> 和 <code>Eq</code>，这些实现必须相互一致，即对于所有的 <code>a</code> 和 <code>b</code>，如果 <code>a == b</code>，那么 <code>a.hash() == b.hash()</code>。所以我们应该总是使用派生宏来实现两者，或者手动实现两者，但不能混合使用，否则就有可能破坏上述不变性。</p>
<p>为一个类型实现 <code>Eq</code> 和 <code>Hash</code> 的主要好处是，它允许我们将该类型作为键存储在 <code>HashMap</code> 和 <code>HashSet</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashSet</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now our type can be stored
</span><span class="c1">// in HashSets and HashMaps!
</span><span class="c1"></span><span class="cp">#[derive(PartialEq, Eq, Hash)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_hashset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">points</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="partialord--ord">PartialOrd &amp; Ord</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Less</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Equal</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Greater</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Rhs</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">lt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">le</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">gt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ge</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd&lt;Rhs&gt;</code> 类型可以使用 <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, 和 <code>&gt;=</code> 运算符与 <code>Rhs</code> 类型进行比较。</p>
<p>所有的 <code>PartialOrd</code> 实现必须确保比较是不对称的和传递的。这意味着对于所有的 <code>a</code>, <code>b</code>, 和 <code>c</code>:</p>
<ul>
<li><code>a &lt; b</code> 意味着 <code>!(a &gt; b)</code> (不对称性)</li>
<li><code>a &lt; b &amp;&amp; b &lt; c</code> 意味着 <code>a &lt; c</code> (传递性)</li>
</ul>
<p><code>PartialOrd</code> 是 <code>PartialEq</code> 的一个子 trait，它们的实现必须总是相互一致。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">must_always_agree</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="p">),</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd</code> 是对 <code>PartialEq</code> 的细化，当比较 <code>PartialEq</code> 类型时，我们可以检查它们是否相等，但当比较 <code>PartialOrd</code> 类型时，我们可以检查它们是否相等，如果它们不相等，我们可以检查它们是否不相等，因为第一项小于或大于第二项。</p>
<p>默认情况下 <code>Rhs = Self</code>，因为我们几乎总是想把一个类型的实例相互比较，而不是和不同类型的实例比较。这也自动保证了我们的实现是对称的和传递的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Rhs == Self == Point
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl automatically symmetric &amp; transitive
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">ordering</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型的所有成员都实现了 <code>PartialOrd</code>，那么它可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Stoplight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Red</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Yellow</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Green</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd</code> 派生宏基于其成员的字母顺序对类型进行排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// generates PartialOrd impl which orders
</span><span class="c1">// Points based on x member first and
</span><span class="c1">// y member second because that&#39;s the order
</span><span class="c1">// they appear in the source code
</span><span class="c1"></span><span class="cp">#[derive(PartialOrd, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// generates DIFFERENT PartialOrd impl
</span><span class="c1">// which orders Points based on y member
</span><span class="c1">// first and x member second
</span><span class="c1"></span><span class="cp">#[derive(PartialOrd, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Ord</code> is a subtrait of <code>Eq</code> and <code>PartialOrd&lt;Self&gt;</code>:
<code>Ord</code> 是 <code>Eq</code> 和 <code>PartialOrd&lt;Self&gt;</code> 的子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Ord</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">min</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">max</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们为一个类型实现 <code>Ord</code>，在 <code>PartialOrd</code> 所要求的不对称性和传递性的基础上，我们还保证不对称性是完全的，即对于任何给定的 <code>a</code> 和 <code>b</code>，<code>a == b</code> 或 <code>a &gt; b</code> 中只有一个是真的。在这个意义上，<code>Ord</code> 完善了 <code>Eq</code> 和 <code>PartialOrd</code>，因为它代表了一个更严格的比较版本。如果一个类型实现了 <code>Ord</code>，我们就可以用这个实现来实现 <code>PartialOrd</code>、<code>PartialEq</code> 和 <code>Eq</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// of course we can use the derive macros here
</span><span class="c1"></span><span class="cp">#[derive(Ord, PartialOrd, Eq, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// note: as with PartialOrd, the Ord derive macro
</span><span class="c1">// orders a type based on the lexicographical order
</span><span class="c1">// of its members
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// but here&#39;s the impls if we wrote them out by hand
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">ordering</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>浮点数实现了 <code>PartialOrd</code>，但不是 <code>Ord</code>，因为 <code>NaN &lt; 0 == false</code> 和 <code>NaN &gt;= 0 == false</code> 同时为真。几乎所有其他的 <code>PartialOrd</code> 类型都是 <code>Ord</code>，当然，除非它们包含浮点数。</p>
<p>一旦一个类型被认为是 <code>Ord</code> 的，我们就可以将其存储在 <code>BTreeMap</code> 和 <code>BTreeSet</code> 中，并且可以使用 <code>sort()</code> 方法对其进行排序，以及对数组、<code>Vec</code> 和 <code>VecDeque</code> 等任何类型的切片进行解引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">BTreeSet</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now our type can be stored
</span><span class="c1">// in BTreeSets and BTreeMaps!
</span><span class="c1"></span><span class="cp">#[derive(Ord, PartialOrd, PartialEq, Eq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_btreeset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">points</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// we can also .sort() Ord types in collections!
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_sort</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">sortable</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">sortable</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortable</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="arithmetic-traits">Arithmetic Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
</tbody>
</table>
<p>仔细研究所有这些将是非常多余的。反正大多数只适用于数字类型。我们只讨论 <code>Add</code> 和 <code>AddAssign</code>，因为 <code>+</code> 操作符通常被重载来做其他事情，如向集合添加项目或将事物串联起来，这样我们就能覆盖最有趣的地方，而不会重复。</p>
<h4 id="add--addassign">Add &amp; AddAssign</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Add&lt;Rhs, Output = T&gt;</code> 类型可以和 <code>Rhs</code> 类型相加，并将产生 <code>T</code> 作为输出。</p>
<p>例子 <code>Add&lt;Point, Output = Point&gt;</code> 是针对 <code>Point</code> 实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone, Copy)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是如果我们只有对 <code>Point</code> 的引用呢？那我们还能让它们相加吗？让我们试试。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不幸的是没有。编译器会抛出异常：</p>
<pre><code class="language-none" data-lang="none">error[E0369]: cannot add `&amp;Point` to `&amp;Point`
  --&gt; src/main.rs:50:25
   |
50 |     let p3: Point = &amp;p1 + &amp;p2;
   |                     --- ^ --- &amp;Point
   |                     |
   |                     &amp;Point
   |
   = note: an implementation of `std::ops::Add` might be missing for `&amp;Point`
</code></pre><p>在 Rust 的类型系统中，对于某些类型 <code>T</code> 来说，<code>T</code>、<code>&amp;T</code> 和 <code>&amp;mut T</code> 都被视为唯一的不同类型，这意味着我们必须为它们分别提供 trait 实现。让我们为 <code>&amp;Point</code> 定义一个 <code>Add</code> 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，有些事情还是感觉不大对劲。我们有两个独立的 <code>Add</code> 实现，分别用于 <code>Point</code> 和 <code>&amp;Point</code>，它们目前做的是同样的事情，但不能保证将来也会这样做。例如，我们决定当我们把两个 <code>Point</code> 相加时，我们想创建一个包含这两个 <code>Point</code> 的 <code>Line</code>，而不是创建一个新的 <code>Point</code>，我们会像这样更新我们的 <code>Add</code> 程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">start</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">end</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// we updated this impl
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Line</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">start</span>: <span class="nc">self</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">end</span>: <span class="nc">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// but forgot to update this impl, uh oh!
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ expected Line, found Point
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们目前对 <code>&amp;Point</code> 的 <code>Add</code> 实现造成了不必要的维护负担，我们希望这个实现与 <code>Point</code> 的实现相匹配，而不必在每次改变 <code>Point</code> 的实现时都要手动更新。我们希望尽可能地保持我们的代码是 DRY（Don&rsquo;t Repeat Yourself）。幸运的是这是可以实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// updated, DRY impl
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Add</span><span class="o">&gt;</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span>::<span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rhs</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>AddAssign&lt;Rhs&gt;</code> 类型允许我们相加并分配 <code>Rhs</code> 类型给它们。Trait 声明如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为 <code>Point</code> 和 <code>&amp;Point</code> 类型的实现的例子如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">AddAssign</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;&amp;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span>::<span class="n">add_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rhs</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="闭包-traits">闭包 Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
</tbody>
</table>
<h4 id="fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然这些 trait 存在，但在稳定的 Rust 中，我们不可能为自己的类型实现这些特性。我们唯一能创建的实现这些 trait 的类型是闭包。根据闭包从其环境中捕获的内容，决定了它是实现了 <code>FnOnce</code>、<code>FnMut</code> 还是 <code>Fn</code>。</p>
<p><code>FnOnce</code> 闭包只能被调用一次，因为它在执行中会消耗一些值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">get_range_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">range</span><span class="p">.</span><span class="n">count</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">get_range_count</span><span class="p">(),</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">get_range_count</span><span class="p">();</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>迭代器上的 <code>.count()</code> 方法会消耗迭代器，所以它只能被调用一次。因此，我们的闭包只能被调用一次。这就是为什么当我们试图第二次调用它时，会出现这个错误。</p>
<pre><code class="language-none" data-lang="none">error[E0382]: use of moved value: `get_range_count`
 --&gt; src/main.rs:5:5
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ----------------- `get_range_count` moved due to this call
5 |     get_range_count();
  |     ^^^^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `range` out of its environment
 --&gt; src/main.rs:3:30
  |
3 |     let get_range_count = || range.count();
  |                              ^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; src/main.rs:4:16
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ^^^^^^^^^^^^^^^
</code></pre><p><code>FnMut</code> 闭包可以被多次调用，也可以改变它从环境中捕获的变量。我们可以说 <code>FnMut</code> 闭包是执行副作用的，或者说是有状态的。下面是一个闭包的例子，它通过跟踪到目前为止看到的最小值，从迭代器中过滤出所有非升序的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">MIN</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ascending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kc">false</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="kc">true</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">],</span><span class="w"> </span><span class="n">ascending</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FnMut</code> 完善了 <code>FnOnce</code>，即 <code>FnOnce</code> 需要取得其参数的所有权，只能调用一次，但 <code>FnMut</code> 只需要取得可变的引用，可以多次调用。<code>FnMut</code> 可以在任何可以使用 <code>FnOnce</code> 的地方使用。</p>
<p><code>Fn</code> 闭包可以被多次调用，并且不改变它从环境中捕获的任何变量。我们可以说 <code>Fn</code> 闭包没有副作用或无状态。下面是一个闭包的例子，它过滤掉了所有小于它从环境中捕获的迭代器中的某个栈变量的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greater_than_9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">min</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">],</span><span class="w"> </span><span class="n">greater_than_9</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Fn</code> 细化了 <code>FnMut</code>，即 <code>FnMut</code> 需要可变的引用并可多次调用，但 <code>Fn</code> 只需要不可变的引用并可多次调用。<code>Fn</code> 可以用在任何可以使用 <code>FnMut</code> 的地方，包括可以使用 <code>FnOnce</code> 的地方。</p>
<p>如果一个闭包没有从它的环境中捕获任何东西，那么从技术上讲，它不是一个闭包，而只是一个匿名声明的内联函数，并且可以作为一个普通的函数指针被转换、使用和传递，也就是 <code>fn</code>。函数指针可以在任何可以使用 <code>Fn</code> 的地方使用，这包括可以使用 <code>FnMut</code> 和 <code>FnOnce </code>的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fn_ptr</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">add_one</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">fn_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// capture-less closure cast to fn pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">fn_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// same as add_one
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">fn_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>传递普通函数指针以代替闭包的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">absolutes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="kt">i32</span>::<span class="n">abs</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">absolutes</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="其他-trait">其他 Trait</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>
<h4 id="deref--derefmut">Deref &amp; DerefMut</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">DerefMut</span>: <span class="nc">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以使用解引用操作符 <code>*</code> 把实现了 <code>Deref&lt;Target = T&gt;</code> trait 的类型解引用为  <code>T</code> 类型。这对于智能指针类型（如 <code>Box</code> 和 <code>Rc</code>）有明显的用途。然而，我们很少看到在 Rust 代码中显式地使用解引用操作符，这是因为 Rust 的一个叫做 “强制解引用”(<em>deref coercion</em>)的特性。</p>
<p>当类型作为函数参数传递、从函数返回或作为方法调用的一部分使用时，Rust 会自动地对类型进行解引用。这就是为什么我们可以将 <code>&amp;String</code> 和 <code>&amp;Vec&lt;T&gt;</code> 传递给期望 <code>&amp;str</code> 和 <code>&amp;[T]</code> 的函数的原因，因为 <code>String</code> 实现了 <code>Deref&lt;Target = str&gt;</code>, <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target = [T]&gt;</code>。</p>
<p><code>Deref</code> 和 <code>DerefMut</code> 只应为智能指针类型而实现。人们试图误用和滥用这些 trait 的最常见方式是试图将某种 OOP 式的数据继承塞进 Rust 中。这是行不通的。Rust 不是面向对象的。让我们来看看几种不同的情况，在哪些情况下，如何以及为什么它不起作用。让我们从这个例子开始:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Weapon</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spear</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Axe</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Sword</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Soldier is just a Human with a Weapon
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Mount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Horse</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Donkey</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Cow</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Knight is just a Soldier with a Mount
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">mount</span>: <span class="nc">Mount</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Soldier</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Spell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MagicMissile</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">FireBolt</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ThornWhip</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Mage is just a Human who can cast Spells
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">spells</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Staff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Wooden</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Metallic</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Plastic</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Wizard is just a Mage with a Staff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">staff</span>: <span class="nc">Staff</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mage</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_human</span><span class="p">(</span><span class="n">human</span>: <span class="kp">&amp;</span><span class="nc">Human</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_soldier</span><span class="p">(</span><span class="n">soldier</span>: <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_knight</span><span class="p">(</span><span class="n">knight</span>: <span class="kp">&amp;</span><span class="nc">Knight</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_mage</span><span class="p">(</span><span class="n">mage</span>: <span class="kp">&amp;</span><span class="nc">Mage</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_wizard</span><span class="p">(</span><span class="n">wizard</span>: <span class="kp">&amp;</span><span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types can be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights can be used as Soldiers
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Wizards can be used as Mages
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights &amp; Wizards passed as themselves
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_knight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_wizard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>因此，乍一看，上面的内容看起来很不错！然而，在仔细研究后，很快就发现了问题。首先，强制解引用只对引用起作用，所以当我们真正想要传递所有权时，它就不起作用了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">takes_human</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types CANNOT be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">soldier</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">knight</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">mage</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">wizard</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>此外，强制解引用在泛型上下文中不起作用。比方说，我们只在人类身上实现一些 trait：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rest</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rest</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">take_rest</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Rest</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rester</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">rester</span><span class="p">.</span><span class="n">rest</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types CANNOT be used as Rest types, only Human
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，尽管强制解引用在很多地方都能工作，但并不是所有地方都能工作。它对操作数不起作用，尽管操作符只是方法调用的语法糖。比方说，我们想让 <code>Mage</code>(法师) 用 <code>+=</code> 运算符来学习 <code>Spell</code>(咒语)，这很可爱。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">spell</span>: <span class="nc">Spell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">spells</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">spell</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">,</span><span class="w"> </span><span class="n">spell</span>: <span class="nc">Spell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">spell</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">wizard</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">spell</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ wizard not coerced to mage here
</span><span class="c1"></span><span class="w">    </span><span class="n">wizard</span><span class="p">.</span><span class="n">add_assign</span><span class="p">(</span><span class="n">spell</span><span class="p">);</span><span class="w"> </span><span class="c1">// oof, we have to call it like this 🤦
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 OOP 式数据继承的语言中，方法中 <code>self</code> 的值总是等于调用该方法的类型，但在 Rust 中，<code>self</code> 的值总是等于实现该方法的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">profession</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// self will always be a Human here, even if we call it on a Soldier
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">state_profession</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m a {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">profession</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">soldier</span>: <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;servant&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;spearman&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="p">.</span><span class="n">state_profession</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;I&#39;m a servant!&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">soldier</span><span class="p">.</span><span class="n">state_profession</span><span class="p">();</span><span class="w"> </span><span class="c1">// still prints &#34;I&#39;m a servant!&#34; 🤦
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当在一个新类型上实现 <code>Deref</code> 或 <code>DerefMut</code> 时，上述的问题尤其严重。假设我们想创建一个 <code>SortedVec</code> 类型，它只是一个 <code>Vec</code>，但它总是按排序顺序排列。下面是我们如何做的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">SortedVec</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>很明显，我们不能在这里实现 <code>DerefMut&lt;Target = Vec&lt;T&gt;&gt;</code>，否则任何使用 <code>SortedVec</code> 的人都可以轻易地破坏排序的顺序。然而，实现 <code>Deref&lt;Target = Vec&lt;T&gt;&gt;</code> 肯定是安全的，对吗？试着在下面的程序中发现这个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">SortedVec</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedVec</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">sorted</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sortedClone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorted</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortedClone</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们从未为 <code>SortedVec</code> 实现 <code>Clone</code>，所以当我们调用 <code>.clone()</code> 方法时，编译器使用强制解引用来解决对 <code>Vec</code> 的方法调用，所以它返回一个 <code>Vec</code> 而不是 <code>SortedVec</code>!</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sorted</span>: <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedVec</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">sorted</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// still sorted
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// calling clone on SortedVec actually returns a Vec 🤦
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sortedClone</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorted</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortedClone</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// sortedClone no longer sorted 💀
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>总之，以上这些限制、约束或麻烦都不是 Rust 的缺点，因为 Rust 一开始就没有被设计成一种 OO 语言或支持任何 OOP 模式。</p>
<p>本节的主要启示是，不要试图用 <code>Deref</code> 和 <code>DerefMut</code> 实现来表现可爱或聪明。它们实际上只适合于智能指针类型，目前只能在标准库中实现，因为智能指针类型目前需要不稳定的特性和编译器的魔法才能工作。如果我们想要类似于 <code>Deref</code> 和 <code>DerefMut</code> 的功能和行为，那么我们实际上可能要找的是 <code>AsRef</code> 和 <code>AsMut</code>，我们将在后面讨论。</p>
<h4 id="index--indexmut">Index &amp; IndexMut</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">Idx</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">IndexMut</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span>: <span class="nc">Index</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Idx</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以将 <code>[]</code> 索引到有 <code>T</code> 值的 <code>Index&lt;T, Output = U&gt;</code> 类型，索引操作将返回 <code>&amp;U</code> 值。对于语法糖，编译器会在任何从索引操作返回的值前面自动插入一个解引用运算符 <code>*</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so
</span><span class="c1"></span><span class="w">    </span><span class="c1">// indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ❌ expected &amp;i32 found i32
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// above line actually desugars to
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ❌ expected &amp;i32 found i32
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// both of these alternatives work
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一开始有点让人困惑，因为看起来 <code>Index</code> trait 并不遵循它自己的方法签名，但实际上这只是有问题的语法糖。</p>
<p>因为 <code>Idx</code> 是一个泛型类型，<code>Index</code> trait 可以为一个给定的类型实现很多次，在 <code>Vec&lt;T&gt;</code> 的情况下，我们不仅可以使用 <code>usize</code> 对其进行索引，我们还可以使用 <code>Range&lt;usize&gt;</code> 对其进行索引，以获得切片。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[..],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">..],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了展示我们如何实现 <code>Index</code>，这里有一个有趣的例子，展示了我们如何使用一个新类型和 <code>Index</code> trait 来实现 <code>Vec</code> 的包装索引和负索引。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Index</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="kt">i128</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">i128</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">self_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i128</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">0_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">1_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">2_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">wrapping_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">3_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">4_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">5_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">neg_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">3_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">2_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">wrapping_neg_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">6_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">5_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">4_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>没有要求 <code>Idx</code> 类型必须是数字类型或 <code>Range</code>，它可以是一个枚举! 下面是一个例子，使用篮球位置索引到一个篮球队，以检索该队的球员。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Index</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">BasketballPosition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">PointGuard</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ShootingGuard</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Center</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">PowerForward</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">SmallForward</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">BasketballPlayer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">position</span>: <span class="nc">BasketballPosition</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">BasketballTeam</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">point_guard</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">shooting_guard</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">center</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">power_forward</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">small_forward</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">BasketballPosition</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BasketballTeam</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BasketballPlayer</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">position</span>: <span class="nc">BasketballPosition</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">BasketballPlayer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">PointGuard</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">point_guard</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">ShootingGuard</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">shooting_guard</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">Center</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">center</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">PowerForward</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">power_forward</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">SmallForward</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">small_forward</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="drop">Drop</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型实现了 <code>Drop</code>，那么当它超出作用域但在被销毁之前，<code>drop</code> 将在该类型上调用。我们很少需要为我们的类型实现这个功能，但是一个很好的例子是，如果一个类型持有一些外部资源，当类型被销毁时，这些资源需要被清理掉。</p>
<p>在标准库中有一个 <code>BufWriter</code> 类型，允许我们对 <code>Write</code> 类型进行缓冲写入。然而，如果 <code>BufWriter</code> 在其缓冲区的内容被刷新到底层的 <code>Write</code> 类型之前就被销毁了呢？幸好这是不可能的! <code>BufWriter</code> 实现了 <code>Drop</code> trait，所以每当它离开作用域时，<code>flush</code> 总是被调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">flush_buf</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，Rust 中的 <code>Mutex</code> 没有 <code>unlock()</code> 方法，因为它们不需要这些方法。在一个 <code>Mutex</code> 上调用 <code>lock()</code> 会返回一个 <code>MutexGuard</code>，当 <code>Mutex</code> 超出作用域时，由于它的 <code>Drop</code> 实现，它会自动解锁。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MutexGuard</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">raw_unlock</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一般来说，如果你在某些资源上实现一个抽象，在使用后需要清理，那么这就是使用 <code>Drop</code> trait 的一个很好的理由。</p>
<h2 id="转换-traits">转换 Traits</h2>
<h3 id="from--into">From &amp; Into</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>From&lt;T&gt;</code> 类型允许我们将 <code>T</code> 转换为 <code>Self</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Into&lt;T&gt;</code> 类型允许我们将 <code>Self</code> 转换为 <code>T</code>。</p>
<p>这些 trait 是一个硬币的两个不同侧面。我们只能为我们的类型实现 <code>From&lt;T&gt;</code>，因为 <code>Into&lt;T&gt;</code> 的实现是由下面这个泛型全面实现自动提供的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">U</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>::<span class="n">from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这两个  trait 存在的原因是，它允许我们以稍微不同的方式在泛型类型上编写 trait 约束(trait bound)。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="c1">// these bounds are equivalent
</span><span class="c1"></span><span class="w">    </span><span class="n">T</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">i32</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// these examples are equivalent
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">example</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">from</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">example</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>关于何时使用这两种方法并没有硬性规定，所以在每种情况下都要选择最合理的方法。现在让我们看看一些关于 <code>Point</code> 的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Into
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>实现不是对称的，所以如果我们想把 <code>Point</code> 转换成元组和数组，我们也必须显示地地添加这些。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// from (i32, i32) into Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from Point into (i32, i32)
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="n">point</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from [i32; 2] into Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from Point into [i32; 2]
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="n">point</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>From&lt;T&gt;</code> 的一个普遍用途是缩减模板代码。假设我们在程序中加入一个包含三个 <code>Point</code> 的 <code>Triangle</code> 类型，这里有许多方法可以构建它。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Triangle</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">P</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">]</span>: <span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">p1</span>: <span class="nc">p1</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">p2</span>: <span class="nc">p2</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">p3</span>: <span class="nc">p3</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// manual construction
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Point::new
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From&lt;(i32, i32)&gt; for Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Triangle::new + From&lt;(i32, i32)&gt; for Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From&lt;[Into&lt;Point&gt;; 3]&gt; for Triangle
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span>: <span class="nc">Triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对于何时、如何或为什么我们应该为我们的类型实现 <code>From&lt;T&gt;</code>，没有任何规则，所以这取决于我们对每种情况的最佳判断。</p>
<p><code>Into&lt;T&gt;</code> 的一个流行用法是使需要自有值(owned values)的函数在接受自有值或借用值时具有通用性。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// accepts:
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - String
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new1</span><span class="p">(</span><span class="n">name</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// accepts:
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - String
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - &amp;String
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - &amp;str
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - Box&lt;str&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - Cow&lt;&#39;_, str&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - char
</span><span class="c1"></span><span class="w">    </span><span class="c1">// since all of the above types can be converted into String
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new2</span><span class="o">&lt;</span><span class="n">N</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">name</span>: <span class="nc">N</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span>: <span class="nc">name</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="错误处理">错误处理</h2>
<p>谈论错误处理和 <code>Error</code> trait 的最佳时机是在讨论完 <code>Display</code>、<code>Debug</code>、<code>Any</code> 和 <code>From</code> 之后，在讨论 <code>TryFrom</code> 之前，因此错误处理部分与转换 trait 部分尴尬地一分为二。</p>
<h3 id="error">Error</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#any">Any</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Error</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">backtrace</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Backtrace</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cause</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 Rust 中，错误被返回，而不是被抛出。我们来看看一些例子。</p>
<p>由于整数类型除以0会引起 panic，如果我们想让我们的程序更安全、更明确，我们可以实现一个 <code>safe_div</code> 函数，返回一个 <code>Result</code>，就像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">DivByZero</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DivByZero</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;division by zero error&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DivByZero</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">numerator</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">denominator</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">DivByZero</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">denominator</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">DivByZero</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">numerator</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">denominator</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_safe_div</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">safe_div</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">safe_div</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">DivByZero</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于错误是返回的，而不是抛出的，所以必须显式处理，如果当前函数不能处理一个错误，它应该将其传播给调用者。传播错误的最习惯的方法是使用 <code>?</code> 操作符，它只是现在被废弃的 <code>try!</code> 宏的语法糖，它只是做这个。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="cp">$expr</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="cp">$expr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// if Ok just unwrap the value
</span><span class="c1"></span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="c1">// if Err map the err value using From and return
</span><span class="c1"></span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们想写一个将文件读成 <code>String</code> 的函数，我们可以这样写，用 <code>?</code> 将 <code>io::Error</code> 传播到它们可能出现的任何地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_file_to_string</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是，假设我们正在读取的文件实际上是一个数字列表，我们想把它们加在一起，我们会像这样更新我们的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="cm">/* What to put here? */</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是现在我们的 <code>Result</code> 的错误类型是什么？它可以返回一个 <code>io::Error</code> 或者一个 <code>ParseIntError</code>。我们将看一下解决这个问题的三种方法，从临时应急的方法开始，最后是最稳健的方法。</p>
<p>第一种方法是认识到所有实现了 <code>Error</code> 的类型也实现了 <code>Display</code>，所以我们可以将所有的错误映射到 <code>String</code>，并使用 <code>String</code> 作为我们的错误类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对每个错误进行字符串化处理的明显缺点是，我们丢弃了类型信息，这使得调用者更难处理错误。</p>
<p>上述方法的一个非显而易见的好处是我们可以定制字符串以提供更多的特定环境信息。例如，<code>ParseIntError</code> 通常字符串化为 &ldquo;invalid digit found in string&rdquo;，这是非常模糊的，没有提到无效的字符串是什么或者它试图解析成什么整数类型。如果我们要调试这个问题，这个错误信息几乎是无用的。然而，我们可以通过自己提供所有与上下文相关的信息来使其明显改善。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;failed to parse {} into i32&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>第二种方法是利用标准库中的这种泛型全面实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">E</span>: <span class="nc">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这意味着任何 <code>Error</code> 类型都可以通过 <code>?</code> 运算符隐式地转换为 <code>Box&lt;dyn error::Error&gt;</code>，所以我们可以在任何产生错误的函数的 <code>Result</code> 返回类型中把错误类型设置为 <code>Box&lt;dyn error::Error&gt;</code>，<code>?</code> 运算符将为我们完成其余的工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然更加简洁，但这似乎与之前的方法有相同的缺点，即丢弃了类型信息。这大部分是真的，但是如果调用者知道我们函数的实现细节，他们仍然可以使用 <code>error::Error</code> 上的 <code>downcast_ref()</code> 方法来处理不同的错误类型，这和它在 <code>dyn Any</code> 类型上的作用是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">handle_sum_file_errors</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">sum_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;the sum is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">downcast_ref</span>::<span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// handle io::Error
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">downcast_ref</span>::<span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// handle ParseIntError
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// we know sum_file can only return one of the
</span><span class="c1"></span><span class="w">                </span><span class="c1">// above errors so this branch is unreachable
</span><span class="c1"></span><span class="w">                </span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>第三种方法是最稳健和类型安全的方法，可以聚合这些不同的错误，是使用一个枚举建立我们自己的自定义错误类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Parse</span><span class="p">(</span><span class="n">ParseIntError</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;sum file error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;sum file error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// the default impl for this method always returns None
</span><span class="c1"></span><span class="w">    </span><span class="c1">// but we can now override it to make it way more useful!
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">SumFileError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">handle_sum_file_errors</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">sum_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;the sum is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// handle io::Error
</span><span class="c1"></span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// handle ParseIntError
</span><span class="c1"></span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="conversion-traits-continued">Conversion Traits Continued</h2>
<h3 id="tryfrom--tryinto">TryFrom &amp; TryInto</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
<li><a href="#error">Error</a></li>
</ul>
<p><code>TryFrom</code> and <code>TryInto</code> are the  versions of <code>From</code> and <code>Into</code>.
<code>TryFrom</code> 和 <code>TryInto</code> 是 <code>From</code> 和 <code>Into</code> 的不可靠版本。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Similarly to <code>Into</code> we cannot impl <code>TryInto</code> because its impl is provided by this generic blanket impl:
与 <code>Into</code> 类似，我们不能实现 <code>TryInto</code>，因为它的实现是由下面这个泛型全面实现提供的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">U</span>: <span class="nc">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>::<span class="n">try_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Let&rsquo;s say that in the context of our program it doesn&rsquo;t make sense for <code>Point</code>s to have <code>x</code> and <code>y</code> values that are less than <code>-1000</code> or greater than <code>1000</code>. This is how we&rsquo;d rewrite our earlier <code>From</code> impls using <code>TryFrom</code> to signal to the users of our type that this conversion can now fail:
假设在我们的程序中，<code>Point</code> 的 <code>x</code> 和 <code>y</code> 的值小于 <code>-1000</code> 或大于 <code>1000</code> 是不合理的。这就是我们如何使用 <code>TryFrom</code> 重写我们先前的 <code>From</code> 实现，向我们类型的用户发出信号，这个转换现在可以失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryFrom</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;out of bounds&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now fallible
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">OutOfBounds</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// still infallible
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>And here&rsquo;s the refactored <code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code> impl for <code>Triangle</code>:
这里是重构后的 <code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code> 实现，用于 <code>Triangle</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="p">{</span><span class="n">TryFrom</span><span class="p">,</span><span class="w"> </span><span class="n">TryInto</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;out of bounds&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">OutOfBounds</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Triangle</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">P</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">]</span>: <span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">p1</span>: <span class="nc">p1</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">p2</span>: <span class="nc">p2</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">p3</span>: <span class="nc">p3</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="p">,</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nc">Triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)].</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="fromstr">FromStr</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#error">Error</a></li>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromStr</code> types allow performing a fallible conversion from <code>&amp;str</code> into <code>Self</code>. The idiomatic way to use <code>FromStr</code> is to call the <code>.parse()</code> method on <code>&amp;str</code>s:
<code>FromStr</code> 类型允许执行从 <code>&amp;str</code> 到 <code>Self</code> 的错误转换。使用 <code>FromStr</code> 的习惯方法是对 <code>&amp;str</code> 调用 <code>.parse()</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">FromStr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// these are all equivalent
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FromStr</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// most idiomatic
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Point</code> 实现的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">Enumerate</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="p">{</span><span class="n">Chars</span><span class="p">,</span><span class="w"> </span><span class="n">FromStr</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, Eq, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">ParsePointError</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;failed to parse point&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">_e</span>: <span class="nc">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">ParsePointError</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="n">ParsePointError</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">is_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">char</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">..</span><span class="o">=</span><span class="sc">&#39;9&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">isnt_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">!</span><span class="n">is_num</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">get_num</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="n">char_idxs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Enumerate</span><span class="o">&lt;</span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;&gt;|</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span><span class="w"> </span><span class="n">ParsePointError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char_idxs</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">skip_while</span><span class="p">(</span><span class="n">isnt_num</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char_idxs</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">skip_while</span><span class="p">(</span><span class="n">is_num</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">((</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">))</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">enumerate</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span><span class="w"> </span><span class="n">x_end</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span><span class="w"> </span><span class="n">y_end</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">x_start</span><span class="p">..</span><span class="n">x_end</span><span class="p">].</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">y_start</span><span class="p">..</span><span class="n">y_end</span><span class="p">].</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">pos_x_y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;(4, 5)&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">neg_x_y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;(-6, -2)&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">not_a_point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;not a point&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromStr</code> has the same signature as <code>TryFrom&lt;&amp;str&gt;</code>. It doesn&rsquo;t matter which one we impl for a type first as long as we forward the impl to the other one. Here&rsquo;s a <code>TryFrom&lt;&amp;str&gt;</code> impl for <code>Point</code> assuming it already has a <code>FromStr</code> impl:
<code>FromStr</code> 与 <code>TryFrom&lt;&amp;str&gt;</code> 的签名相同。只要我们把实现转发给另一个类型，哪一个实现并不重要。下面是一个针对 <code>Point</code> 的 <code>TryFrom&lt;&amp;str&gt;</code> 实现，假设它已经有一个 <code>FromStr</code> 实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FromStr</span><span class="o">&gt;</span>::<span class="nb">Err</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FromStr</span><span class="o">&gt;</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="asref--asmut">AsRef &amp; AsMut</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">AsMut</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>?Sized</code> 说明 T 类型是大小不确定的。<code>As</code> 作为介词, 表明发生了类型转换。</p>
<p><code>AsRef</code> is for cheap reference to reference conversions. However, one of the most common ways it&rsquo;s used is to make functions generic over whether they take ownership or not:</p>
<p><code>AsRef</code> 是用于廉价的引用到引用的转换。然而，它最常见的使用方式之一是使函数在是否拥有所有权上通用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// accepts:
</span><span class="c1">//  - &amp;str
</span><span class="c1">//  - &amp;String
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">takes_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// use &amp;str
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// accepts:
</span><span class="c1">//  - &amp;str
</span><span class="c1">//  - &amp;String
</span><span class="c1">//  - String
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">takes_asref_str</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// use &amp;str
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">borrow</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">owned</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">borrow</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">owned</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">borrow</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">owned</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The other most common use-case is returning a reference to inner private data wrapped by a type which protects some invariant. A good example from the standard library is <code>String</code> which is just a wrapper around <code>Vec&lt;u8&gt;</code>:</p>
<p>另一个最常见的用例是返回一个对内部私有数据的引用，该数据由一个保护某些不变性的类型包裹。标准库中的一个很好的例子是 <code>String</code>，它只是 <code>Vec&lt;u8&gt;</code> 的一个包装器。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This inner <code>Vec</code> cannot be made public because if it was people could mutate any byte and break the <code>String</code>&rsquo;s valid UTF-8 encoding. However, it&rsquo;s safe to expose an immutable read-only reference to the inner byte array, hence this impl:
这个内部的 <code>Vec</code> 不能被公开，因为如果它被公开，人们可以改变任何字节并破坏 <code>String</code> 的有效 UTF-8 编码。然而，公开内部字节数组的不可变的只读引用是安全的，因此有了这个实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>Generally, it often only makes sense to impl <code>AsRef</code> for a type if it wraps some other type to either provide additional functionality around the inner type or protect some invariant on the inner type.</p>
<p>Let&rsquo;s examine a example of bad <code>AsRef</code> impls:
一般来说，只有当一个类型包装了其他类型，为内部类型提供了额外的功能，或者保护了内部类型的某些不变性时，为其实现 <code>AsRef</code> 才有意义。</p>
<p>让我们来看看一个不好的 <code>AsRef</code> 实现的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">age</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This works and kinda makes sense at first, but quickly falls apart if we add more members to <code>User</code>:
这在一开始是可行的，而且有点道理，但如果我们给 <code>User</code> 增加更多的成员，很快就会崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// uh, do we return name or email here?
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// uh, do we return age or height here?
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>A <code>User</code> is composed of <code>String</code>s and <code>u32</code>s but it&rsquo;s not really the same thing as a <code>String</code> or a <code>u32</code>. Even if we had much more specific types:
<code>User</code> 是由 <code>String</code> 和 <code>u32</code> 组成的，但它和 <code>String</code> 或 <code>u32</code> 并不是真正的一回事。即使我们有更具体的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nc">Name</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nc">Email</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="nc">Age</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">height</span>: <span class="nc">Height</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>It wouldn&rsquo;t make much sense to impl <code>AsRef</code> for any of those because <code>AsRef</code> is for cheap reference to reference conversions between semantically equivalent things, and <code>Name</code>, <code>Email</code>, <code>Age</code>, and <code>Height</code> by themselves are not the same thing as a <code>User</code>.</p>
<p>A good example where we would impl <code>AsRef</code> would be if we introduced a new type <code>Moderator</code> that just wrapped a <code>User</code> and added some moderation specific privileges:
实现 <code>AsRef</code> 对这些都没有意义，因为 <code>AsRef</code> 是用来在语义上等同的事物之间进行廉价的引用转换，而 <code>Name</code>、<code>Email</code>、<code>Age</code> 和 <code>Height</code> 本身就和 <code>User</code> 不是一回事。</p>
<p>一个很好的例子是，如果我们引入一个新的类型 <code>Moderator</code>，它只是包裹了一个 <code>User</code>，并增加了一些特定的管理权限，我们就会使用 <code>AsRef</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// unfortunately the standard library cannot provide
</span><span class="c1">// a generic blanket impl to save us from this boilerplate
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Privilege</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">BanUsers</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">EditPosts</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">DeletePosts</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// although Moderators have some special
</span><span class="c1">// privileges they are still regular Users
</span><span class="c1">// and should be able to do all the same stuff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">user</span>: <span class="nc">User</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">privileges</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Privilege</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Moderator</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">user</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this should be callable with Users
</span><span class="c1">// and Moderators (who are also Users)
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">create_post</span><span class="o">&lt;</span><span class="n">U</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">user</span>: <span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="n">moderator</span>: <span class="nc">Moderator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">create_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">create_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">moderator</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This works because <code>Moderator</code>s are just <code>User</code>s. Here&rsquo;s the example from the <code>Deref</code> section except using <code>AsRef</code> instead:
这样做是因为 <code>Moderator</code> 就是 <code>User</code>。下面是 <code>Deref</code> 部分的例子，只是用 <code>AsRef</code> 代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="nb">AsRef</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Weapon</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spear</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Axe</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Sword</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Soldier is just a Human with a Weapon
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Mount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Horse</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Donkey</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Cow</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Knight is just a Soldier with a Mount
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">mount</span>: <span class="nc">Mount</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Knight</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Spell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MagicMissile</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">FireBolt</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ThornWhip</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Mage is just a Human who can cast Spells
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">spells</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Staff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Wooden</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Metallic</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Plastic</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Wizard is just a Mage with a Staff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">staff</span>: <span class="nc">Staff</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Wizard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_human</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">human</span>: <span class="nc">H</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_soldier</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">soldier</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_knight</span><span class="o">&lt;</span><span class="n">K</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Knight</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">knight</span>: <span class="nc">K</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_mage</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">mage</span>: <span class="nc">M</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_wizard</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Wizard</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">wizard</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types can be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights can be used as Soldiers
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Wizards can be used as Mages
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights &amp; Wizards passed as themselves
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_knight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_wizard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Deref</code> didn&rsquo;t work in the prior version of the example above because deref coercion is an implicit conversion between types which leaves room for people to mistakenly formulate the wrong ideas and expectations for how it will behave. <code>AsRef</code> works above because it makes the conversion between types explicit and there&rsquo;s no room leftover to develop any wrong ideas or expectations.
<code>Deref</code> 在上述例子的先前版本中不起作用，因为 deref coercion 是一种隐式类型转换，为人们错误地制定错误的想法和期望留下了空间。<code>AsRef</code> 在上面起作用，因为它使类型间的转换变得明确，没有余地来发展任何错误的想法或期望。</p>
<h3 id="borrow--borrowmut">Borrow &amp; BorrowMut</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">BorrowMut</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrow_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Borrowed</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>These traits were invented to solve the very specific problem of looking up <code>String</code> keys in <code>HashSet</code>s, <code>HashMap</code>s, <code>BTreeSet</code>s, and <code>BTreeMap</code>s using <code>&amp;str</code> values.</p>
<p>We can view <code>Borrow&lt;T&gt;</code> and <code>BorrowMut&lt;T&gt;</code> as stricter versions of <code>AsRef&lt;T&gt;</code> and <code>AsMut&lt;T&gt;</code>, where the returned reference <code>&amp;T</code> has equivalent <code>Eq</code>, <code>Hash</code>, and <code>Ord</code> impls to <code>Self</code>. This is more easily explained with a commented example:
这些 trait 的发明是为了解决在 <code>HashSet</code>, <code>HashMap</code>, <code>BTreeSet</code>, 和 <code>BTreeMap</code> 中使用 <code>&amp;str</code> 值查找 <code>String</code> 键的特殊问题。</p>
<p>我们可以把 <code>Borrow&lt;T&gt;</code> 和 <code>BorrowMut&lt;T&gt;</code> 看作是 <code>AsRef&lt;T&gt;</code> 和 <code>AsMut&lt;T&gt;</code> 的更严格的版本，其中返回的引用 <code>&amp;T</code> 与 <code>Self</code> 的 <code>Eq</code>、<code>Hash</code> 和 <code>Ord</code> 等值。用一个注释的例子可以更容易地解释这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">borrow</span>::<span class="n">Borrow</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">hash_map</span>::<span class="n">DefaultHasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hash</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_hash</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Hash</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hasher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultHasher</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hasher</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">hasher</span><span class="p">.</span><span class="n">finish</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">asref_example</span><span class="o">&lt;</span><span class="n">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">Ref</span><span class="o">&gt;</span><span class="p">(</span><span class="n">owned1</span>: <span class="nc">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">owned2</span>: <span class="nc">Owned</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Owned</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Ref</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Ref</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1</span>: <span class="kp">&amp;</span><span class="nc">Ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned1</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2</span>: <span class="kp">&amp;</span><span class="nc">Ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned2</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// refs aren&#39;t required to be equal if owned types are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2</span><span class="p">,</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ref2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// ref hashes aren&#39;t required to be equal if owned type hashes are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2_hash</span><span class="p">,</span><span class="w"> </span><span class="n">ref1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ref2_hash</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// ref comparisons aren&#39;t required to match owned type comparisons
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">),</span><span class="w"> </span><span class="n">ref1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="p">));</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrow_example</span><span class="o">&lt;</span><span class="n">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="p">(</span><span class="n">owned1</span>: <span class="nc">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">owned2</span>: <span class="nc">Owned</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Owned</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow1</span>: <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned1</span><span class="p">.</span><span class="n">borrow</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow2</span>: <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned2</span><span class="p">.</span><span class="n">borrow</span><span class="p">();</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrows are required to be equal if owned types are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2</span><span class="p">,</span><span class="w"> </span><span class="n">borrow1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">borrow2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow2</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrow hashes are required to be equal if owned type hashes are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2_hash</span><span class="p">,</span><span class="w"> </span><span class="n">borrow1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">borrow2_hash</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrow comparisons are required to match owned type comparisons
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">),</span><span class="w"> </span><span class="n">borrow1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow2</span><span class="p">));</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>It&rsquo;s good to be aware of these traits and understand why they exist since it helps demystify some of the methods on <code>HashSet</code>, <code>HashMap</code>, <code>BTreeSet</code>, and <code>BTreeMap</code> but it&rsquo;s very rare that we would ever need to impl these traits for any of our types because it&rsquo;s very rare that we would ever need create a pair of types where one is the &ldquo;borrowed&rdquo; version of the other in the first place. If we have some <code>T</code> then <code>&amp;T</code> will get the job done 99.99% of the time, and <code>T: Borrow&lt;T&gt;</code> is already implemented for all <code>T</code> because of a generic blanket impl, so we don&rsquo;t need to manually impl it and we don&rsquo;t need to create some <code>U</code> such that <code>T: Borrow&lt;U&gt;</code>.</p>
<p>知道这些 trait 并理解它们存在的原因是很好的，因为这有助于解开 <code>HashSet</code>、<code>HashMap</code>、<code>BTreeSet</code> 和 <code>BTreeMap</code> 上的一些方法，但是我们很少需要为我们的任何类型实现这些 trait，因为我们很少需要创建一对类型，其中一个是另一个的 &ldquo;借用&rdquo; 版本。如果我们有一些 <code>T</code>，那么 <code>T</code> 在 99.99% 的情况下都能完成工作，而且 <code>T: Borrow&lt;T&gt;</code> 已经为所有的 <code>T</code> 实现了，因为有一个通用的一揽子实现，所以我们不需要手动实现它，我们也不需要创建一些 <code>U</code>，使 <code>T: Borrow&lt;U&gt;</code>。</p>
<h3 id="toowned">ToOwned</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">ToOwned</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Owned</span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Owned</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_into</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">target</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Owned</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>ToOwned</code> is a more generic version of <code>Clone</code>. <code>Clone</code> allows us to take a <code>&amp;T</code> and turn it into an <code>T</code> but <code>ToOwned</code> allows us to take a <code>&amp;Borrowed</code> and turn it into a <code>Owned</code> where <code>Owned: Borrow&lt;Borrowed&gt;</code>.</p>
<p>In other words, we can&rsquo;t &ldquo;clone&rdquo; a <code>&amp;str</code> into a <code>String</code>, or a <code>&amp;Path</code> into a <code>PathBuf</code>, or an <code>&amp;OsStr</code> into an <code>OsString</code>, since the <code>clone</code> method signature doesn&rsquo;t support this kind of cross-type cloning, and that&rsquo;s what <code>ToOwned</code> was made for.</p>
<p>For similar reasons as <code>Borrow</code> and <code>BorrowMut</code>, it&rsquo;s good to be aware of this trait and understand why it exists but it&rsquo;s very rare we&rsquo;ll ever need to impl it for any of our types.</p>
<p><code>ToOwned</code> 是 <code>Clone</code> 的一个更通用的版本。<code>Clone</code> 允许我们把一个 <code>&amp;T</code> 变成一个 <code>T</code>，但 <code>ToOwned</code> 允许我们把一个 <code>&amp;Borrowed</code> 变成一个 <code>Owned</code>，其中 <code>Owned: Borrow&lt;Borrowed&gt;</code>。</p>
<p>换句话说，我们不能把一个 <code>&amp;str</code> 克隆成一个 <code>String</code>，或者把一个 <code>&amp;Path</code> 克隆成一个 <code>PathBuf</code>，或者把一个 <code>&amp;OsStr</code> 克隆成一个 <code>OsString</code>，因为 <code>clone</code> 方法签名不支持这种跨类型克隆，而这正是 <code>ToOwned</code> 的用途。</p>
<p>出于与 <code>Borrow</code> 和 <code>BorrowMut</code> 类似的原因，知道这个 trait 并理解它存在的原因是很好的，但我们很少需要为我们的任何类型实现这个 trait。</p>
<h2 id="iteration-traits">Iteration Traits</h2>
<h3 id="iterator">Iterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#default-impls">Default Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">size_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">advance_by</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">step_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">step</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">StepBy</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">chain</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">other</span>: <span class="nc">U</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Chain</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">U</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">IntoIter</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">zip</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Zip</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">U</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">IntoIter</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Map</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">for_each</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">filter</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Filter</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">filter_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">FilterMap</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Enumerate</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">peekable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Peekable</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">skip_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">SkipWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TakeWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">map_while</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MapWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Skip</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Take</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">scan</span><span class="o">&lt;</span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">initial_state</span>: <span class="nc">St</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Scan</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flat_map</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">FlatMap</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Flatten</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fuse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fuse</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inspect</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Inspect</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partition</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partition_in_place</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">DoubleEndedIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_partitioned</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_fold</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">init</span>: <span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_for_each</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fold</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">init</span>: <span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fold_first</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">all</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">any</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">find</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">find_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_find</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">f</span>: <span class="nc">F</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">R</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Try</span><span class="o">&gt;</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">position</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rposition</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">ExactSizeIterator</span> <span class="o">+</span><span class="w"> </span><span class="nb">DoubleEndedIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max_by_key</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min_by_key</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rev</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Rev</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">DoubleEndedIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">unzip</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">FromA</span><span class="p">,</span><span class="w"> </span><span class="n">FromB</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">FromA</span><span class="p">,</span><span class="w"> </span><span class="n">FromB</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">FromA</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">FromB</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">copied</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Copied</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cloned</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cloned</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cycle</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Clone</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sum</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">S</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">S</span>: <span class="nc">Sum</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">product</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">P</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nc">Product</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">partial_cmp</span>: <span class="nc">F</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialEq</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> </span><span class="n">eq</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialEq</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">lt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">le</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">gt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ge</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted_by_key</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">K</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">K</span>: <span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Iterator&lt;Item = T&gt;</code> 类型可以被迭代，并会产生 <code>T</code> 类型。没有 <code>IteratorMut</code> trait。每个 <code>Iterator</code> 实现可以通过 <code>Item</code> 关联类型指定它是返回不可变引用、可变引用还是拥有其值。</p>
<table>
<thead>
<tr>
<th><code>Vec&lt;T&gt;</code> 方法</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.iter()</code></td>
<td><code>Iterator&lt;Item = &amp;T&gt;</code></td>
</tr>
<tr>
<td><code>.iter_mut()</code></td>
<td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td>
</tr>
<tr>
<td><code>.into_iter()</code></td>
<td><code>Iterator&lt;Item = T&gt;</code></td>
</tr>
</tbody>
</table>
<p>对于初学者来说，有些东西不是很明显，但中级 Rustaceans 认为是理所当然的，那就是大多数类型都不是他们本身的迭代器。如果一个类型是可迭代的，我们几乎总是实现一些自定义的迭代器类型来迭代它，而不是试图让它自己迭代。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">MyTypeIterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">index</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">items</span>: <span class="kp">&amp;</span><span class="nc">self</span><span class="p">.</span><span class="n">items</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MyTypeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyTypeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="p">];</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了便于教学，上面的例子展示了如何从头开始实现一个 <code>Iterator</code>，但在这种情况下，习惯性的解决方案将只是遵从 <code>Vec</code> 的 <code>iter</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，这也是一个很好的通用全面实现，要注意。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span> <span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">I</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>它说任何对迭代器的可变引用也是迭代器，这一点很有用，因为它允许我们使用 <code>self</code> 接收器，就像使用 <code>&amp;mut self</code> 接收器一样。了解这一点很有用，因为它允许我们使用迭代器方法与 <code>self</code> 接收器，就像它们有 <code>&amp;mut self</code> 接收器一样。</p>
<p>举个例子，想象一下，我们有一个函数，它可以处理一个超过三个项的迭代器，但是函数的第一步是取出迭代器的前三项，并在迭代剩下的项之前分别处理它们，下面是一个初学者可能尝试写这个函数的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌ iter consumed in line above
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>嗯，这很烦人。<code>take</code> 方法有一个 <code>self</code> 接收器，所以我们似乎不能在不消耗整个迭代器的情况下调用它。下面是上面代码的一个天真的重构。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这还算好的。然而，惯用的重构其实是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">by_ref</span><span class="p">().</span><span class="n">take</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不太容易发现。但无论如何，现在我们知道了。</p>
<p>另外，对于什么可以是迭代器，什么不能是迭代器，并没有什么规则或约定。如果类型是 <code>Iterator</code>，那么它就是一个迭代器。标准库中的一些创造性的例子如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">mpsc</span>::<span class="n">channel</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">paths_can_be_iterated</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// iterate over parts of a path
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">receivers_can_be_iterated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">send</span><span class="p">,</span><span class="w"> </span><span class="n">recv</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">recv</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// iterate over received values
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="intoiterator">IntoIterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#iterator">Iterator</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">IntoIter</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">IntoIter</span>: <span class="nb">Iterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">IntoIter</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>IntoIterator</code> 类型可以被转换为迭代器，因此得名。当一个类型在 <code>for-in</code> 循环中使用时，会调用 <code>into_iter</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above line desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>不仅 <code>Vec</code> 实现了 <code>IntoIterator</code>，如果我们想分别迭代不可变引用或可变引用而不是拥有其值，<code>&amp;Vec</code> 和 <code>&amp;mut Vec</code> 也分别实现了 <code>IntoIterator</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = &amp;T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above example desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">).</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = &amp;mut T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above example desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="p">).</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="fromiterator">FromIterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">FromIterator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromIterator</code> 类型可以从迭代器中创建，因此也被称为 <code>FromIterator</code>。<code>FromIterator</code> 最常见和最习惯的用法是调用 <code>Iterator</code> 上的 <code>collect</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">B</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>将 <code>Iterator&lt;Item = char&gt;</code> 收集成 <code>String</code> 的例子如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">filter_letters</span><span class="p">(</span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">is_alphabetic</span><span class="p">()).</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的所有集合都实现了 <code>IntoIterator</code> 和 <code>FromIterator</code>，这样可以更容易在它们之间进行转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="p">{</span><span class="n">BTreeSet</span><span class="p">,</span><span class="w"> </span><span class="n">HashMap</span><span class="p">,</span><span class="w"> </span><span class="n">HashSet</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedList</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// String -&gt; HashSet&lt;char&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">unique_chars</span><span class="p">(</span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">HashSet</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">ordered_unique_items</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BTreeSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">entry_list</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">map</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">map</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// and countless more possible examples
</span></code></pre></div><h2 id="io-traits">I/O Traits</h2>
<h3 id="read--write">Read &amp; Write</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#scope">Scope</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">IoSliceMut</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_read_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">initializer</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Initializer</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_to_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Bytes</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">chain</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Chain</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">limit</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Take</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">IoSlice</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_write_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_all_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">IoSlice</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="nc">Arguments</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>通用的全面实现值得了解。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">W</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这说明任何对 <code>Read</code> 类型的可变引用也是 <code>Read</code>，对 <code>Write</code> 也是如此。了解这一点很有用，因为它允许我们使用任何带有 <code>self</code> 接收器的方法，就像它有一个 <code>&amp;mut self</code> 接收器一样。我们已经在 <code>Iterator</code> trait 部分介绍了如何做到这一点以及为什么它很有用，所以我不打算在这里再次重复。</p>
<p>我想指出，<code>&amp;[u8]</code> 实现了 <code>Read</code>，<code>Vec&lt;u8&gt;</code> 实现了 <code>Write</code>，所以我们可以很容易地使用 <code>String</code> 对我们的文件处理函数进行单元测试，这些函数很容易转换为 <code>&amp;[u8]</code> 和 <code>Vec&lt;u8&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// function we want to test
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">uppercase</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w"> </span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">read</span>: <span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">write</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">read</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">uppercase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">to_uppercase</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">write</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">uppercase</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">write</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// in actual program we&#39;d pass Files
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">in_path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">out_path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">in_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">in_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">out_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">uppercase</span><span class="p">(</span><span class="n">in_file</span><span class="p">,</span><span class="w"> </span><span class="n">out_file</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// however in unit tests we can use Strings!
</span><span class="c1"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">in_file</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;i am screaming&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">out_file</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">uppercase</span><span class="p">(</span><span class="n">in_file</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">out_file</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">out_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8</span><span class="p">(</span><span class="n">out_file</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">out_result</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;I AM SCREAMING&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="结论">结论</h2>
<p>我们一起学到了很多东西! 事实上，太多了。它现在是我们的了:</p>
<p><img src="../assets/jason-jarvis-stdlib-traits.png" alt="rust standard library traits"></p>
<p><em>Artist credit: <a href="https://thejenkinscomic.wordpress.com/2020/05/06/memory/">The Jenkins Comic</a></em></p>
<h2 id="讨论">讨论</h2>
<p>在这里讨论这篇文章</p>
<ul>
<li><a href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
<li><a href="https://www.reddit.com/r/learnrust/comments/ml9shl/tour_of_rusts_standard_library_traits/">learnrust subreddit</a></li>
<li><a href="https://users.rust-lang.org/t/blog-post-tour-of-rusts-standard-library-traits/57974">official Rust users forum</a></li>
<li><a href="https://twitter.com/pretzelhammer/status/1379561720176336902">Twitter</a></li>
<li><a href="https://lobste.rs/s/g27ezp/tour_rust_s_standard_library_traits">lobste.rs</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/mmrao0/tour_of_rusts_standard_library_traits/">rust subreddit</a></li>
</ul>
<h2 id="通知">通知</h2>
<p>当下一篇博文发布时，会收到通知</p>
<ul>
<li><a href="https://twitter.com/pretzelhammer">Following pretzelhammer on Twitter</a> or</li>
<li>Watching this repo&rsquo;s releases (click <code>Watch</code> -&gt; click <code>Custom</code> -&gt; select <code>Releases</code> -&gt; click <code>Apply</code>)</li>
</ul>
<h2 id="更多阅读">更多阅读</h2>
<ul>
<li><a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a></li>
<li><a href="./common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a></li>
<li><a href="./learning-rust-in-2020.md">Learning Rust in 2020</a></li>
<li><a href="./too-many-brainfuck-compilers.md">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Psql]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-psql/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Psql</blockquote><h1 id="raku-与-postgresql-的连接性一览">Raku 与 PostgreSQL 的连接性一览</h1>
<p>在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。</p>
<p>Raku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。
在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。
脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。</p>
<p>DB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。</p>
<h2 id="安装方法">安装方法</h2>
<p>可以使用 zef 来安装 DB::Pg 模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">% zef install DB::Pg
</code></pre></div><p>根据你的系统速度和已经安装的库，可能需要几分钟的时间。</p>
<p>如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">% zef install epoll
</code></pre></div><h2 id="连接到数据库">连接到数据库</h2>
<p>现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!raku</span>

<span class="k">use</span> <span class="nn">DB::Pg</span><span class="p">;</span>

<span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="nb">Str</span> <span class="o">:</span><span class="nv">$host</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">miguel</span><span class="p">&#39;</span><span class="o">,</span>
          <span class="nb">Str</span> <span class="o">:</span><span class="nv">$username</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">luca</span><span class="p">&#39;</span><span class="o">,</span>
          <span class="nb">Str</span> <span class="o">:</span><span class="nv">$password</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">secet</span><span class="p">&#39;</span><span class="o">,</span>
          <span class="nb">Str</span> <span class="o">:</span><span class="nv">$database</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">testdb</span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">{</span>

    <span class="p">&#34;</span><span class="s2">Connecting </span><span class="nv">$username</span><span class="s2"> @ </span><span class="nv">$host</span><span class="s2">/</span><span class="nv">$database</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

    <span class="k">my</span> <span class="nv">$connection</span> <span class="o">=</span> <span class="n">DB::Pg</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="s">conninfo</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">host=</span><span class="nv">$host</span><span class="s2"> user=</span><span class="nv">$username</span><span class="s2"> password=</span><span class="nv">$password</span><span class="s2"> dbname=</span><span class="nv">$database</span><span class="p">&#34;;</span>
</code></pre></div><p>如你所见，DB::Pg模块接受一个 conninfo 字符串。</p>
<h2 id="读取查询和结果">读取查询和结果</h2>
<p><code>.query</code> 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 <code>.hash</code> 和 <code>.arrays</code>，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 <code>.rows</code> 和 <code>.column</code> 等特殊方法分别提供了查询返回的行数和结果集的列名。</p>
<p>举个例子，这里是一个简单的查询。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$query</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">SELECT current_role, current_time</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$results</span> <span class="o">=</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">query:</span> <span class="nv">$query</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The query </span><span class="p">{</span> <span class="nv">$query</span> <span class="p">}</span><span class="s2"> returned </span><span class="p">{</span> <span class="nv">$results</span><span class="o">.</span><span class="nf">rows</span> <span class="p">}</span><span class="s2"> rows with columns: </span><span class="p">{</span> <span class="nv">$results</span><span class="o">.</span><span class="nf">columns</span><span class="o">.</span><span class="nb">join</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">}&#34;;</span>
<span class="k">for</span> <span class="nv">$results</span><span class="o">.</span><span class="nf">hashes</span> <span class="k">-&gt;</span> <span class="nv">$row</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">$row</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$column</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Column </span><span class="nv">$column</span><span class="s2"> = </span><span class="nv">$value</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上面这段代码提供了一个类似于下面的输出。</p>
<p>查询 <code>SELECT current_role, current_time</code> 返回1行，列数为： current_role, current_time。</p>
<pre><code>Column current_role = luca
Column current_time = 14:48:47.147983+02
</code></pre><h2 id="光标">光标</h2>
<p>默认情况下，<code>.query</code> 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 <code>.cursor</code> 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。</p>
<p>作为一个简单的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">cursor</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">select * from raku</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">fetch</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="p">:</span><span class="s">hash</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">%row</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">====================</span><span class="p">&#34;;</span>
    <span class="k">for</span> <span class="nv">%row</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$column</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Column [ </span><span class="nv">$column</span><span class="s2"> ] = </span><span class="nv">$value</span><span class="p">&#34;;</span>
    <span class="p">}</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">====================</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>产生和输出像这样的东西。</p>
<pre><code>====================
Column [ pk ] = 2
Column [ t ] = This is value 0
====================
====================
Column [ pk ] = 3
Column [ t ] = This is value 1
====================
====================
Column [ t ] = This is value 2
Column [ pk ] = 4
====================
====================
Column [ pk ] = 5
Column [ t ] = This is value 3
====================
...
</code></pre><h2 id="撰写声明">撰写声明</h2>
<p>编写语句可以通过 <code>.execute</code> 方法来执行，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$connection</span><span class="o">.</span><span class="nf">execute:</span> <span class="k">q</span><span class="p">&lt;</span><span class="s"> insert into raku( t ) values( &#39;Hello World&#39; )</span><span class="p">&gt;;</span>
</code></pre></div><h2 id="交易和编制报表">交易和编制报表</h2>
<p>为了处理事务，你需要访问被&quot;屏蔽&quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 <code>.begin</code>、<code>.rollback</code>、<code>.commit</code>等方法。</p>
<p>此外，还可以使用 <code>.prepare</code> 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，<code>.prepare</code> 方法使用了 <code>$1</code>、<code>$2</code> 等参数占位符，当语句接受单个值时，必须在 <code>.execute</code> 中不指定索引。</p>
<p>举个例子</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$database-handler</span> <span class="o">=</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">db</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$statement</span> <span class="o">=</span> <span class="nv">$database-handler</span><span class="o">.</span><span class="nf">prepare:</span> <span class="p">&#39;</span><span class="s1">insert into raku( t ) values( $1 )</span><span class="p">&#39;;</span>

<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">begin</span><span class="p">;</span>
<span class="nv">$statement</span><span class="o">.</span><span class="nf">execute</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">This is value </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">)</span>  <span class="k">for</span> <span class="mi">0</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">commit</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nb">finish</span><span class="p">;</span>
</code></pre></div><p>上述循环相当于一个SQL事务，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">BEGIN</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 0&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 1&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 2&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 10&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">COMMIT</span><span class="p">;</span><span class="w">
</span></code></pre></div><p><code>.finish</code> 方法是必需的，因为 DB::Pg 处理缓存。请注意，<code>.commit</code> 和 <code>.rollback</code> 方法是流畅的，并返回一个对象实例，这样你就可以调用 <code>.commit.finish</code>。</p>
<h2 id="数据库与连接">数据库与连接</h2>
<p>缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 <code>.</code> 完成。</p>
<p>因此，你可以在两个对象上使用相同的 <code>.query</code> 和 <code>.execute</code> 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。</p>
<h2 id="复制">复制</h2>
<p>PostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 <code>.copy-in</code> 可以执行 <code>COPY FROM</code>，而 <code>COPY TO</code> 可以在迭代循环中使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/tmp/raku.csv</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">open</span><span class="o">:</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">query:</span> <span class="p">&#39;</span><span class="s1">COPY raku TO stdout (FORMAT CSV)</span><span class="p">&#39;</span>  <span class="k">-&gt;</span> <span class="nv">$row</span> <span class="p">{</span>
    <span class="nv">$file</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="nv">$row</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>以上将 CSV 结果导出到文本文件上。
如果要读回数据，可以发出 <code>.copy-in</code> 方法，但首先需要发出 <code>SQL COPY</code>。工作流程是</p>
<pre><code>issue a COPY FROM STDIN;
use .copy-data to slurp all the data;
use .copy-end to notify the database that the COPY is concluded.
</code></pre><p>对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$database-handler</span> <span class="o">=</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">db</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">query:</span> <span class="p">&#39;</span><span class="s1">COPY raku FROM STDIN (FORMAT CSV)</span><span class="p">&#39;;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">copy-data:</span>  <span class="p">&#39;</span><span class="s1">/tmp/raku1.csv</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">copy-data:</span>  <span class="p">&#39;</span><span class="s1">/tmp/raku2.csv</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">copy-end</span><span class="p">;</span>
</code></pre></div><h2 id="转换器">转换器</h2>
<p>可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 <code>inflate</code> 和 <code>deflate</code> 选项。
第一步是在 <code>DB::Pg</code> 中给转换器实例添加一个角色，这样的实例必须。</p>
<ul>
<li>增加一个新的类型转换方法。</li>
<li>增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。</li>
</ul>
<p>作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$connection</span><span class="o">.</span><span class="nf">converter</span> <span class="k">does</span> <span class="k">role</span> <span class="nc">fluca-converter</span>
<span class="p">{</span>
    <span class="k">submethod</span> <span class="nb">BUILD</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">add-type</span><span class="p">(</span> <span class="s">text</span> <span class="o">=&gt;</span> <span class="nb">Str</span> <span class="p">)</span> <span class="p">}</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nf">convert</span><span class="p">(</span> <span class="nb">Str:U</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$value</span><span class="o">.</span><span class="nb">flip</span><span class="o">.</span><span class="nb">uc</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">query</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">select * from raku</span><span class="p">&#39;</span> <span class="p">)</span><span class="o">.</span><span class="nf">arrays</span><span class="p">;</span>
</code></pre></div><p>产生类似于的输出。</p>
<pre><code>[442 DLROW OLLEH]
[454 DLROW OLLEH]
[466 DLROW OLLEH]
</code></pre><p>其中字符串 Hello World 被翻转。</p>
<h2 id="listen-和-notify">listen 和 notify</h2>
<p>DB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。
首先，创建一个简单的机制来通知一些事件。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="s">testdb</span><span class="o">=&gt;</span> <span class="n">create</span> <span class="ow">or</span> <span class="n">replace</span> <span class="k">rule</span> <span class="nf">r_raku_insert</span> 
         <span class="n">as</span> <span class="n">on</span> <span class="n">insert</span> <span class="nb">to</span> <span class="nb">raku</span> 
         <span class="nb">do</span> <span class="k">also</span> 
         <span class="n">SELECT</span> <span class="nf">pg_notify</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">insert_event</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">INSERTING ROW(S)</span><span class="p">&#39;</span> <span class="p">);</span>
<span class="nb">CREATE</span> <span class="n">RULE</span>

<span class="s">testdb</span><span class="o">=&gt;</span> <span class="n">create</span> <span class="ow">or</span> <span class="n">replace</span> <span class="k">rule</span> <span class="nf">r_raku_delete</span>
         <span class="n">as</span> <span class="n">on</span> <span class="nb">delete</span> <span class="nb">to</span> <span class="nb">raku</span> 
         <span class="nb">do</span> <span class="k">also</span> 
         <span class="n">SELECT</span> <span class="nf">pg_notify</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">delete_event</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">DELETING ROW(S)</span><span class="p">&#39;</span> <span class="p">);</span>
<span class="nb">CREATE</span> <span class="n">RULE</span>
</code></pre></div><p>现在，可以创建一个等待传入事件的 Raku 脚本。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">react</span> <span class="p">{</span>
    <span class="k">whenever</span> <span class="nv">$connection</span><span class="o">.</span><span class="nb">listen</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">delete_event</span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">whenever</span> <span class="nv">$connection</span><span class="o">.</span><span class="nb">listen</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">insert_event</span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>目的是，每次发出一个事件，<code>.listen</code> 都会将消息有效载荷传递给 react 代码块。因此，发出一些 <code>DELETE</code> 和 <code>INSERT</code> 会导致输出。</p>
<pre><code>DELETING ROW(S)
INSERTING ROW(S)
INSERTING ROW(S)
</code></pre><p>可以通过 <code>.unlisten</code> 方法停止监听反应块。也可以通过 <code>.notify</code> 方法发出事件。</p>
<h2 id="总结">总结</h2>
<p>DB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。</p>
<p>文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。</p>
<p>原文链接: <a href="https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html">https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[争取在 MoarVM 中建立一个新的总调度机制]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="related" type="text/html" title="自定义 when" />
            
                <id>https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-03-15T00:00:00+08:00</published>
            <updated>2021-03-15T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Towards a New General Dispatch Mechanism in Moarvm</blockquote><p>我的天啊，看来我是两年多来第一次写 Raku 内部的博文了。当然，两年前还不叫 Raku。总之，话不多说，继续说说这个共同的脑洞吧。</p>
<h2 id="什么是调度">什么是调度？</h2>
<p>我用 &ldquo;dispatch&rdquo; 来表示我们接受一组参数，最后根据这些参数采取一些行动的过程。一些熟悉的例子包括:</p>
<ul>
<li>
<p>进行一个方法调用，比如 <code>$basket.add($product, $quantity)</code>。传统上，我们可能只调用 <code>$product</code> 和 <code>$qauntity</code> 作为参数，但就我的目的而言，所有的 <code>$basket</code>、方法名  &ldquo;add&rdquo;、<code>$product</code> 和 <code>$quantity</code> 都是 dispatch 的参数：它们是我们需要的东西，以便决定我们要做什么。</p>
</li>
<li>
<p>进行子程序调用，如 <code>uc($youtube-comment)</code>。由于 Raku sub 调用是词法解析的，所以在这种情况下，调度的参数是 <code>&amp;uc</code>（查找子程序的结果）和 <code>$youtube-comment</code>。</p>
</li>
<li>
<p>调用多个调度子程序或方法，根据参数的数量和类型来决定调用一组候选程序中的哪一个。这个过程可以看作是发生在上述两个调度中的一个 &ldquo;内部&rdquo;，因为我们在 Raku 中既有多重调度子程序，也有方法。</p>
</li>
</ul>
<p>乍一看，也许前两个看起来相当简单，第三个就有点手忙脚乱了 - 这也算是事实。然而，Raku 还有一些其他的特性，使得调度变得相当，嗯，有趣。例如：</p>
<ul>
<li>
<p><code>wrap</code> 允许我们包装任何 Routine (sub 或方法); 包装器可以选择用原来的参数或新的参数来服从原来的例程。</p>
</li>
<li>
<p>当进行多重调度时，我们可以写一个原型例程，让它选择何时 - 甚至是否 - 调用合适的候选者。</p>
</li>
<li>
<p>我们可以使用 <code>callsame</code> 这样的例程，以便在调度中推迟到下一个候选者。但这意味着什么呢？如果我们是在一个多重调度中，它意味着下一个最适用的候选者，如果有的话。如果我们是在一个方法调度中，那么它意味着一个基类的方法。(同样的事情也被用来实现去下一个封装者，或者，最终也是去最初封装的例程)。而且这些都可以结合起来：我们可以包装一个 multi 方法，这意味着我们可以有 3 个层次的东西，都有可能贡献下一个要调用的东西!</p>
</li>
</ul>
<p>多亏了这一点，dispatch - 至少在 Raku 中 - 并不总是我们所做的事情并产生一个结果，而是一个可能会被要求继续多次进行的过程!</p>
<p>最后，虽然我上面所写的例子都可以很清楚地看成是调度的例子，但在 Raku 中，其他一些常见的构造也可以表达为一种调度。分配是一个例子：它的语义取决于分配的目标和被分配的值，因此我们需要选择正确的语义。强制类型转换(Coercion)是另一个例子，返回值类型检查又是一个例子。</p>
<h2 id="为什么调度很重要">为什么调度很重要？</h2>
<p>Dispatch 在我们的程序中无处不在，它悄悄地把想做事情的代码和做事情的代码联系在一起。它的无处不在意味着它在程序性能中扮演着重要的角色。在最好的情况下，我们可以将成本降为零。在最坏的情况下，调度的成本高到足以超过作为调度结果的工作的成本。</p>
<p>初步估计，当运行时&quot;理解&quot;调度时，性能至少会有些不错，但当运行时不理解时，很有可能会很糟糕。调度往往涉及到一个可以缓存的工作量，往往会有一些廉价的防护措施来验证缓存结果的有效性。例如，在方法调度中，天真地我们需要走一个线性化的继承图，并询问沿途遇到的每个类是否有指定名称的方法。显然，如果我们在每次方法调用时都这样做，速度不会非常快。然而，特定类型上的特定方法名（精确识别，不考虑子类）每次都会解析到同一个方法。因此，我们可以缓存查找的结果，只要调用者的类型与用于产生缓存结果的类型相匹配，就可以使用它。</p>
<h2 id="语言运行时的专门化与通用化机制">语言运行时的专门化与通用化机制</h2>
<p>当一个人开始构建一个针对特定语言的运行时，并且必须在相当紧张的预算下完成时，要想获得某种可容忍的性能，最明显的方法就是将各种热路径语言语义烘焙到运行时中。这正是 MoarVM 的起步方式。因此，如果我们看看 MoarVM 几年前的样子，我们会发现这样的事情。</p>
<ul>
<li>对方法缓存的一些支持</li>
<li>一个与 Raku 的多重调度语义高度绑定的多重调度缓存，只有在调度都是名义类型的时候才真正能够起到帮助作用（所以使用 <code>where</code> 的代价非常高）。</li>
<li>一种机制，用于指定如何在封装代码对象内部找到实际的代码句柄（例如，<code>Sub</code> 对象有一个私有属性，它持有识别要运行的字节码的低级代码句柄）。</li>
<li>一些有限的尝试，让我们能够在知道一个调度不会继续的情况下正确地进行优化 - 这需要编译器和运行时之间的谨慎合作（或者不那么外交地讲，这都是一个大黑客）。</li>
</ul>
<p>这些今天都还在，然而也都在淘汰的路上。这个榜单最能说明问题的是什么，不包括在内。比如：</p>
<ul>
<li>私有方法调用，需要不同的缓存 但最初的虚拟机设计限制了每一种类型的调用</li>
<li>合格的方法调用(<code>$obj.SomeType::method-name()</code>)</li>
<li>体面优化调度恢复的方法</li>
</ul>
<p>几年前，我开始部分解决这个问题，引入了一种机制，我称之为 &ldquo;specializer 插件&rdquo;。但首先，什么是特化器(specializer)？</p>
<p>MoarVM 刚开始的时候，它是一个比较简单的字节码解释器。它只需要足够快的速度击败 Parrot VM 就可以获得相当的使用量，我认为在继续实现一些更有趣的优化之前，这一点非常重要（当时我们还没有今天这样的发布前自动测试基础设施，因此更多的是依赖于早期采用者的反馈）。总之，在能够像其他后端一样运行 Raku 语言后不久，我就开始了动态优化器的开发。它在程序被解释时收集类型统计，识别热代码，将其放入 <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA 形式</a>，使用类型统计插入防护，将这些与字节码的静态属性一起使用来分析和优化，并为相关函数生成专门的字节码。这个字节码可以省略类型检查和各种查找，也可以使用一系列的内部操作，做出各种假设，由于优化器证明了程序的属性，这些假设是安全的。这被称为专门化的字节码，因为它的很多通用性 - 这将使它能够正确地工作在我们可能遇到的所有类型的值上 - 被删除了，转而工作在运行时实际发生的特殊情况下。(代码，尤其是动态语言中的代码，一般来说，理论上的通用性远远大于实践中的通用性。)</p>
<p>这个组件 - 内部称为 &ldquo;spesh&rdquo; 的 specializer - 为 Raku 程序的性能带来了显著的进一步提升，随着时间的推移，它的复杂程度也在不断提高，并采用了<a href="https://en.wikipedia.org/wiki/Inline_expansion">内联</a>和<a href="https://en.wikipedia.org/wiki/Escape_analysis">带有标量替换的转义分析</a>等优化功能。这些并不是容易构建的东西 - 但一旦运行时拥有了它们，它们就会创造出以前不存在的设计可能性，并使在没有它们的情况下做出的决定看起来是次优的。</p>
<p>值得注意的是，那些特殊情况下的语言特定机制，在早期为了获得一些速度而被嵌入到运行时中，反而成为了一种负担和瓶颈。它们具有复杂的语义，这意味着它们对优化器来说要么是不透明的（所以优化器无法对它们进行推理，意味着优化受到抑制），要么就是需要在优化器中进行特殊的封装（一种负担）。</p>
<p>所以，回到 specializer 插件。我到了一个地步，我想承担像 <code>$obj.?meth(&quot;call me maybe&quot;, dispatch)</code>、<code>$obj.SomeType::meth()</code>(用类开始寻找的调度限定)，以及角色中的私有方法调用(不能静态解析)这样的性能。同时，我还准备实现一定量的转义分析，但意识到它的作用将非常有限，因为赋值在虚拟机中也被特例化了，有一大块不透明的 C 代码在做热路径的事情。</p>
<p>但为什么我们要让 C 代码来做那些热路径的事情呢？嗯，因为让每个赋值都调用一个虚拟机级别的函数，做一堆检查和逻辑，花费太大了。为什么这样做成本很高？因为函数调用的开销和解释的成本。这在以前都是正确的。但是，若干年后的发展。</p>
<ul>
<li>内联被实现了，并且可以消除做一个函数调用的开销。</li>
<li>我们可以编译成机器代码，消除解释开销。</li>
<li>我们当时的处境是，我们手头有 specializer 的类型信息，可以让我们消除 C 代码中的分支，但由于我们调用的只是一个不透明的函数，所以没有办法抓住这个机会</li>
</ul>
<p>我解决了上面提到的分配问题和调度问题，引入了一个新的机制：specializer 插件。它们的工作原理如下。</p>
<ul>
<li>当我们第一次到达字节码中的一个给定的调用点时，我们就会运行这个插件。它产生了一个要调用的代码对象，以及一组守卫（为了使用该代码对象结果而必须满足的条件）。</li>
<li>下一次到达时，我们检查是否满足守卫，如果满足，就用结果</li>
<li>如果没有，我们再运行一次插件，并在 callsite 处堆积一个防护集。</li>
<li>我们统计了一个给定的防护集成功的频率，然后将其用于 specializer</li>
</ul>
<p>绝大多数情况下都是单态的，这意味着只产生一组守卫，而且之后总是成功的。因此，特殊化器可以将这些守卫编译到专门的字节码中，然后假设给定的目标调用者就是将被调用的守卫。(进一步，重复的守卫可以被消除，所以某个插件引入的守卫可能会减少到零)。</p>
<p>Specializer 插件感觉挺好的。一个新机制解决了多个优化头疼的问题。</p>
<p>新的 MoarVM 调度机制是对一个相当简单的问题的回答：如果我们把所有与调度相关的特例机制去掉，而采用有点像 specializer 插件的机制，会怎么样？由此产生的机制需要是一个比 specializer 插件更强大的机制。进一步说，我可以学习特殊器插件的一些缺点。因此，虽然它们会在比较短的寿命后消失，但我认为可以说，如果没有这些经验，我就不会有能力设计新的 MoarVM 调度机制。</p>
<h2 id="调度操作和引导调度器">调度操作和引导调度器</h2>
<p>所有的方法缓存。所有的多重调度缓存。所有的 specializer 插件。所有用于在代码对象中解包字节码句柄的调用协议的东西。这一切都将被取消，取而代之的是一个新的调度指令。它的名字很无聊，叫 <code>dispatch</code>。它看起来像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dispatch_o</span> <span class="nb">result</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-name</span><span class="p">&#39;</span><span class="o">,</span> <span class="n">callsite</span><span class="o">,</span> <span class="n">arg0</span><span class="o">,</span> <span class="n">arg1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">argN</span>
</code></pre></div><p>这意味着：</p>
<ul>
<li>使用名为 dispatcher-name 的调度器。</li>
<li>给它指定的参数寄存器（所引用的调用点表示参数的数量）。</li>
<li>将调度的对象结果放入寄存器结果中。</li>
</ul>
<p>(旁白：这意味着一个新的调用约定，即我们不再将参数复制到参数缓冲区，而是将寄存器集的基数和一个指针传递到找到寄存器参数映射的字节码中，然后做一个查询 <code>registers[map[argument_index]]</code> 来获取一个参数的值。仅此一点，我们在解释时就很省事，因为我们不再需要每个参数绕着解释器循环了）。)</p>
<p>有些参数可能是我们传统上称之为参数的东西。有些则是针对调度过程本身。这其实并不重要 - 但如果我们安排将只针对调度的参数放在前面（例如，方法名），而将针对调度目标的参数放在后面（例如，方法参数），则会更加理想。</p>
<p>新的 bootstrap 机制提供了少量的内置调度器，它们的名字以 &ldquo;boot-&rdquo; 开头。它们是：</p>
<ul>
<li><code>boot-value</code> - 取第一个参数并将其作为结果（身份函数，除了丢弃任何其他参数）。</li>
<li><code>boot-constant</code> - 取第一个参数并将其作为结果，但同时也将其视为一个将始终产生的常量值（因此意味着优化器可以将任何用于计算该值的纯代码视为死值）。</li>
<li><code>boot-code</code> - 取第一个参数（必须是虚拟机字节码句柄），并运行该字节码，将其余参数作为参数传给它；评估为字节码的返回值。</li>
<li><code>boot-syscall</code> - 将第一个参数视为虚拟机提供的内置操作的名称，然后调用它，并将其余参数作为其参数。</li>
<li><code>boot-resume</code> - 恢复正在进行的最上层调度。</li>
</ul>
<p>差不多就是这样。我们构建的每一个调度器，为了教给运行时一些其他的调度行为，最终都会终止于其中一个。</p>
<h2 id="在引导程序的基础上">在引导程序的基础上</h2>
<p>教 MoarVM 了解不同种类的调度，不外乎使用调度机制本身! 在大多数情况下，<code>boot-syscall</code> 被用来注册一个调度器，设置守卫，并提供与它们相匹配的结果。</p>
<p>这里是一个最小的例子，取自 dispatcher 测试套件，展示了一个提供同一性功能的 dispatcher 的样子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">identity</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-value</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
<span class="p">});</span>
<span class="k">sub</span> <span class="nf">identity</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">identity</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$x</span><span class="p">)</span>
<span class="p">}</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">identity</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">==</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can define identity dispatch (1)</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">identity</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can define identity dispatch (2)</span><span class="p">&#39;);</span>
</code></pre></div><p>在第一条语句中，我们调用 dispatcher-register MoarVM 系统调用，传递一个 dispatcher 的名称以及一个闭包，每次我们需要处理调度时，都会调用这个闭包（我倾向于将其称为&quot;调度回调&quot;）。它接收一个单一的参数，这是一个参数的捕获（其实不是 Raku 级别的捕获，但想法 - 一个包含一组调用参数的对象 - 是一样的）。</p>
<p>每一个用户定义的调度器最终都应该使用 dispatcher-delegate，以便确定另一个调度器将控制权传递给它。在这种情况下，它立即委托给 <code>boot-value</code> - 这意味着它除了是 <code>boot-value</code> 内置调度器的包装器外，其实什么都不是。</p>
<p>sub <code>identity</code> 包含一个调度操作的静态出现。鉴于我们两次调用 sub，我们在运行时将两次遇到这个 op，但这两次是非常不同的。</p>
<p>第一次是 &ldquo;记录&rdquo; 阶段。参数形成一个捕获，回调运行，回调又将其传给引导值调度器，产生结果。这样就形成了一个极其简单的调度程序，它说结果应该是捕获中的第一个参数。由于没有守卫，所以这将永远是一个有效的结果。</p>
<p>第二次遇到调度操作时，它那里已经记录了一个调度程序，所以我们处于运行模式。在 MoarVM 源码中开启调试模式，我们可以看到结果的调度程序是这样的。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load argument 0 into temporary 0
    Set result object value from temporary 0
</code></pre><p>也就是说，它将参数 0 读入一个临时位置，然后将其设置为调度的结果。请注意，没有提到我们经过了额外的一层调度，这些在结果调度程序中的成本为零。</p>
<h2 id="捕获操作">捕获操作</h2>
<p>参数捕获是不可改变的。各种虚拟机系统调用的存在，可以通过一些调整将它们转化为新的参数捕获，例如删除或插入参数。这里还有一个测试套件的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">drop-first</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$capture-derived</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-value</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture-derived</span><span class="p">);</span>
<span class="p">});</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">drop-first</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">first</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">second</span><span class="p">&#39;)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">second</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg works</span><span class="p">&#39;);</span>
</code></pre></div><p>这就在将捕获传递给引导值调度器之前丢弃了第一个参数 - 意味着它将返回第二个参数。回头看一下之前的身份函数的调度程序。你能猜到这个程序会是什么样子吗？</p>
<p>好吧，就是这样。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load argument 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>同样，虽然在这样一个调度器的记录阶段，我们确实是创建了捕获对象，并做了一个调度器代理，但由此产生的调度程序要简单得多。</p>
<p>下面是一个稍微复杂一点的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$target</span> <span class="o">:=</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">call-on-target</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$capture-derived</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$target</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">boot-code-constant</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture-derived</span><span class="p">);</span>
<span class="p">});</span>
<span class="k">sub</span> <span class="nf">cot</span><span class="p">()</span> <span class="p">{</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">call-on-target</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">49</span><span class="p">)</span> <span class="p">}</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">cot</span><span class="p">()</span> <span class="o">==</span> <span class="mi">50</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj works at start of capture</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">cot</span><span class="p">()</span> <span class="o">==</span> <span class="mi">50</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj works at start of capture after link too</span><span class="p">&#39;);</span>
</code></pre></div><p>这里，我们有一个存储在变量 <code>$target</code> 中的闭包。我们把它作为捕获的第一个参数插入，然后委托给 <code>boot-code-constant</code>，它将调用那个代码对象，并把其他调度参数传递给它。再次，在记录阶段，我们真正要做的事情是这样的。</p>
<ul>
<li>创建一个新的捕获 在开始的时候插入一个代码对象。</li>
<li>委托给引导代码常量分配器，它&hellip;。</li>
<li>&hellip;在没有原始参数的情况下创建一个新的捕获，并使用这些参数运行字节码。</li>
</ul>
<p>由此产生的调度程序呢？就是这个</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load collectable constant at index 0 into temporary 0
    Skip first 0 args of incoming capture; callsite from 0
    Invoke MVMCode in temporary 0
</code></pre><p>也就是说，加载我们要调用的常量字节码句柄，设置 <code>args</code>（在本例中等于传入捕获的参数），然后用这些参数调用字节码。参数的洗牌，又一次消失了。一般来说，只要我们做最终的字节码调用的参数是初始调度参数的尾巴，参数转换就会变得不过是一个指针的添加。</p>
<h2 id="守卫">守卫</h2>
<p>目前看到的所有调度方案都是无条件的：一旦在某一通话地点记录下来，就应一直使用。要使这样的机制具有实用性，缺少的一大块就是守卫。守卫断言了一些属性，比如参数的类型或者参数是确定的（<code>Int:D</code>）还是不确定的（<code>Int:U</code>）。</p>
<p>下面是一个有点长的测试用例，并在其中放置了一些解释。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># A couple of classes for test purposes</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">C1</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">C2</span> <span class="p">{</span> <span class="p">}</span>
 
<span class="c1"># A counter used to make sure we&#39;re only invokving the dispatch callback as</span>
<span class="c1"># many times as we expect.</span>
<span class="k">my</span> <span class="nv">$count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
 
<span class="c1"># A type-name dispatcher that maps a type into a constant string value that</span>
<span class="c1"># is its name. This isn&#39;t terribly useful, but it is a decent small example.</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">type-name</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="c1"># Bump the counter, just for testing purposes.</span>
    <span class="nv">$count</span><span class="o">++</span><span class="p">;</span>
 
    <span class="c1"># Obtain the value of the argument from the capture (using an existing</span>
    <span class="c1"># MoarVM op, though in the future this may go away in place of a syscall)</span>
    <span class="c1"># and then obtain the string typename also.</span>
    <span class="k">my</span> <span class="nv">$arg-val</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">my</span> <span class="nb">str</span> <span class="nv">$name</span> <span class="o">:=</span> <span class="nv">$arg-val</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="nv">$arg-val</span><span class="p">);</span>
 
    <span class="c1"># This outcome is only going to be valid for a particular type. We track</span>
    <span class="c1"># the argument (which gives us an object back that we can use to guard</span>
    <span class="c1"># it) and then add the type guard.</span>
    <span class="k">my</span> <span class="nv">$arg</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-type</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$arg</span><span class="p">);</span>
 
    <span class="c1"># Finally, insert the type name at the start of the capture and then</span>
    <span class="c1"># delegate to the boot-constant dispatcher.</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-constant</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-str</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$name</span><span class="p">));</span>
<span class="p">});</span>
 
<span class="c1"># A use of the dispatch for the tests. Put into a sub so there&#39;s a single</span>
<span class="c1"># static dispatch op, which all dispatch programs will hang off.</span>
<span class="k">sub</span> <span class="nf">type-name</span><span class="p">(</span><span class="nv">$obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">type-name</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$obj</span><span class="p">)</span>
<span class="p">}</span>
 
<span class="c1"># Check with the first type, making sure the guard matches when it should</span>
<span class="c1"># (although this test would pass if the guard were ignored too).</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C1</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatcher setting guard works</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback ran once</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C1</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can use it another time with the same type</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback was not run again</span><span class="p">&#39;);</span>
 
<span class="c1"># Test it with a second type, both record and run modes. This ensures the</span>
<span class="c1"># guard really is being checked.</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C2</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can handle polymorphic sites when guard fails</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback ran a second time for new type</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C2</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Second call with new type works</span><span class="p">&#39;);</span>
 
<span class="c1"># Check that we can use it with the original type too, and it has stacked</span>
<span class="c1"># the dispatch programs up at the same callsite.</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C1</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Call with original type still works</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback only ran a total of 2 times</span><span class="p">&#39;);</span>
</code></pre></div><p>这个时候就会产生两个调度程序，一个是 C1。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C1)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>另一个是 C2:</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C2)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>再一次，没有捕获操作、跟踪或调度器委托的遗留问题；调度程序对一个参数进行类型防护，然后产生结果字符串。整个对 <code>$arg-val.HOW.name($arg-val)</code> 的调用都被省略了，我们写的调度程序将知识进行了编码 - 以虚拟机能够理解的方式 - 一个类型的名称可以被认为是不可改变的。</p>
<p>这个例子有点造作，但现在考虑一下，我们反而要查找一个方法，并在调用者类型上进行守卫：这就是一个方法缓存! 守护更多参数的类型，我们就有了一个多缓存。两者都做，我们就有了一个多方法缓存。</p>
<p>后者很有意思，因为方法调度和多调度都想对调用者进行守护。事实上，在 MoarVM 中，今天会有两个这样的类型测试，直到我们到了特殊化器做工作并消除这些重复的守卫。然而，新的调度器并没有将调度器 - guard-类型当作一种命令式操作，将守卫写入结果调度程序中。相反，它声明相关的参数必须被防护。如果其他的调度器已经这样做了，那它就是幂等的。一旦我们委派通过的所有调度程序，在通往最终结果的路径上，都有了自己的发言权，就会发出守卫。</p>
<p>有趣的是：特别细心的人会注意到，调度机制也被用作实现新的调度程序的一部分，事实上，这最终也将意味着特殊化者可以将调度程序特殊化，让它们也被 JIT 编译成更高效的东西。毕竟，从 MoarVM 的角度来看，这一切都只是要运行的字节码，只是有些字节码是告诉 VM 如何更高效地执行 Raku 程序的!</p>
<h2 id="恢复调度">恢复调度</h2>
<p>可恢复调度器需要做两件事。</p>
<ul>
<li>在注册调度器的时候，提供一个恢复回调和一个调度回调。</li>
<li>在 dispatch 回调中，指定一个捕获，这将形成恢复初始化状态。</li>
</ul>
<p>当发生恢复时，将调用恢复回调，并提供恢复的任何参数。它还可以获得在 dispatch 回调中设置的 resume 初始化状态。resume 初始化状态包含了第一次恢复调度时继续进行调度所需要的东西。我们先来看看方法调度的工作原理，看一个具体的例子。我也会在此时，切换到看真正的 Rakudo 调度器，而不是简化的测试用例。</p>
<p>Rakudo 调度器利用授权、重复守卫和捕获操作都没有运行时成本的优势，在结果调度程序中，至少在我看来，很好地因素了一个有些复杂的调度过程。方法调度有多个切入点：普通无聊的 <code>$obj.meth()</code>，限定的 <code>$obj.Type::meth()</code>，以及调用我也许 <code>$obj.?meth()</code>。这些都有共同的 resume 语义 - 或者至少，只要我们在 resume 初始化状态中始终携带一个起始类型，也就是我们做方法调度的对象的类型，就可以使它们成为。</p>
<p>这里是普通方法调度的切入点，去掉了报告缺失方法错误的无聊细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># A standard method call of the form $obj.meth($arg); also used for the</span>
<span class="c1"># indirect form $obj.&#34;$name&#34;($arg). It receives the decontainerized invocant,</span>
<span class="c1"># the method name, and the the args (starting with the invocant including any</span>
<span class="c1"># container).</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-meth-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="c1"># Try to resolve the method call using the MOP.</span>
    <span class="k">my</span> <span class="nv">$obj</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">my</span> <span class="nb">str</span> <span class="nv">$name</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg_s</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$meth</span> <span class="o">:=</span> <span class="nv">$obj</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">find_method</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="nv">$name</span><span class="p">);</span>
 
    <span class="c1"># Report an error if there is no such method.</span>
    <span class="k">unless</span> <span class="nf">nqp::isconcrete</span><span class="p">(</span><span class="nv">$meth</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">!!!</span> <span class="p">&#39;</span><span class="s1">Error reporting logic elided for brevity</span><span class="p">&#39;;</span>
    <span class="p">}</span>
 
    <span class="c1"># Establish a guard on the invocant type and method name (however the name</span>
    <span class="c1"># may well be a literal, in which case this is free).</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-type</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">1</span><span class="p">));</span>
 
    <span class="c1"># Add the resolved method and delegate to the resolved method dispatcher.</span>
    <span class="k">my</span> <span class="nv">$capture-delegate</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$meth</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="p">&#39;</span><span class="s1">raku-meth-call-resolved</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture-delegate</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div><p>现在是解析方法 dispatcher，也就是处理恢复的地方。首先，让我们看看正常的 dispatch 回调（恢复回调是包含的，但是是空的，我稍后会展示它）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Resolved method call dispatcher. This is used to call a method, once we have</span>
<span class="c1"># already resolved it to a callee. Its first arg is the callee, the second and</span>
<span class="c1"># third are the type and name (used in deferral), and the rest are the args to</span>
<span class="c1"># the method.</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-meth-call-resolved</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="c1"># Initial dispatch</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="c1"># Save dispatch state for resumption. We don&#39;t need the method that will</span>
        <span class="c1"># be called now, so drop it.</span>
        <span class="k">my</span> <span class="nv">$resume-capture</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-init-args</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$resume-capture</span><span class="p">);</span>
 
        <span class="c1"># Drop the dispatch start type and name, and delegate to multi-dispatch or</span>
        <span class="c1"># just invoke if it&#39;s single dispatch.</span>
        <span class="k">my</span> <span class="nv">$delegate_capture</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$method</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$delegate_capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$method</span><span class="o">,</span> <span class="nb">Routine</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$method</span><span class="o">.</span><span class="nf">is_dispatcher</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$delegate_capture</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-invoke</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$delegate_capture</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="o">,</span>
    <span class="c1"># Resumption</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="o">...</span> <span class="p">&#39;</span><span class="s1">Will be shown later</span><span class="p">&#39;;</span>
    <span class="p">});</span>
</code></pre></div><p>raku-meth-call 中有一个可以论证的欺骗：它实际上并没有插入调用者的类型对象来代替调用者。事实证明，这并不重要。否则，我认为注释（在真正的实现中也可以找到）很好地说明了这个问题。</p>
<p>有一个重要的点可能并不清楚 - 但遵循了一个重复的主题 - 那就是恢复初始化状态的设置也更多的是一种声明式而不是命令式的东西：在调度的时候并没有运行时成本，而是我们在周围保留了足够的信息，以便能够在我们需要的时候重建恢复初始化状态。事实上，当我们处于恢复的运行阶段时，我们甚至不需要在创建捕获对象的意义上重建它）。</p>
<p>现在说说复盘。我将介绍一个严重简化的版本，它只处理 callsame 语义（完整的东西也要处理 lastcall 和 nextcallee 这样的乐趣）。resume 初始化状态的存在是为了给 resumption 过程播种。一旦我们知道我们实际上确实要处理恢复，我们就可以做一些事情，比如计算我们想要走过的继承图中的全部方法列表。每个可恢复的调度器在调用栈上得到一个单一的存储槽，它可以用于它的状态。它可以在恢复的第一步中初始化这个，然后在我们走的时候更新它。或者更准确的说，它可以设置一个调度程序，在运行时就会这样做。</p>
<p>对于我们将要走过的候选链来说，链接列表原来是一个非常方便的数据结构。我们可以通过跟踪当前节点来完成链接列表的工作，也就是说只需要有一个东西发生突变，也就是当前调度的状态。调度程序机制还提供了一种从对象中读取属性的方法，这就足以将遍历链接列表表达到调度程序中。这也意味着零分配。</p>
<p>所以，不多说了，下面是链接列表（在 NQP 这个受限的 Raku 子集中，相当不如在完整的 Raku 中漂亮）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># A linked list is used to model the state of a dispatch that is deferring</span>
<span class="c1"># through a set of methods, multi candidates, or wrappers. The Exhausted class</span>
<span class="c1"># is used as a sentinel for the end of the chain. The current state of the</span>
<span class="c1"># dispatch points into the linked list at the appropriate point; the chain</span>
<span class="c1"># itself is immutable, and shared over (runtime) dispatches.</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">DeferralChain</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!code</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!next</span><span class="p">;</span>
    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$code</span><span class="o">,</span> <span class="nv">$next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$obj</span> <span class="o">:=</span> <span class="nf">nqp::create</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
        <span class="nf">nqp::bindattr</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!code</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$code</span><span class="p">);</span>
        <span class="nf">nqp::bindattr</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!next</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$next</span><span class="p">);</span>
        <span class="nv">$obj</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nb">code</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$!code</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nb">next</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$!next</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">Exhausted</span> <span class="p">{};</span>
</code></pre></div><p>最后是恢复处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-meth-call-resolved</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="c1"># Initial dispatch</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="o">...</span> <span class="p">&#39;</span><span class="s1">Presented earlier;
</span><span class="s1">    },
</span><span class="s1">    # Resumption. The resume init capture</span><span class="p">&#39;</span><span class="k">s</span> <span class="err">first</span> <span class="err">two</span> <span class="err">arguments</span> <span class="err">are</span> <span class="err">the</span> <span class="err">type</span>
    <span class="p">#</span><span class="sr"> that we initially did a method dispatch against and the method name
</span><span class="sr">    </span><span class="p">#</span><span class="s2"> respectively.
</span><span class="s2">    -&gt; </span><span class="nv">$capture</span><span class="s2"> {
</span><span class="s2">        </span><span class="p">#</span> <span class="n">Work</span> <span class="n">out</span> <span class="n">the</span> <span class="nb">next</span> <span class="k">method</span> <span class="nb">to</span> <span class="n">call</span><span class="o">,</span> <span class="k">if</span> <span class="nb">any</span><span class="o">.</span> <span class="n">This</span> <span class="n">depends</span> <span class="n">on</span> <span class="k">if</span> <span class="n">we</span> <span class="n">have</span>
        <span class="c1"># an existing dispatch state (that is, a method deferral is already in</span>
        <span class="c1"># progress).</span>
        <span class="k">my</span> <span class="nv">$init</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-get-resume-init-args</span><span class="p">&#39;);</span>
        <span class="k">my</span> <span class="nv">$state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-get-resume-state</span><span class="p">&#39;);</span>
        <span class="k">my</span> <span class="nv">$next_method</span><span class="p">;</span>
        <span class="k">if</span> <span class="nf">nqp::isnull</span><span class="p">(</span><span class="nv">$state</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1"># No state, so just starting the resumption. Guard on the</span>
            <span class="c1"># invocant type and name.</span>
            <span class="k">my</span> <span class="nv">$track_start_type</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$init</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-type</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_start_type</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">$track_name</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$init</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_name</span><span class="p">);</span>
 
            <span class="c1"># Also guard on there being no dispatch state.</span>
            <span class="k">my</span> <span class="nv">$track_state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-resume-state</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_state</span><span class="p">);</span>
 
            <span class="c1"># Build up the list of methods to defer through.</span>
            <span class="k">my</span> <span class="nv">$start_type</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$init</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">my</span> <span class="nb">str</span> <span class="nv">$name</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg_s</span><span class="p">(</span><span class="nv">$init</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">@mro</span> <span class="o">:=</span> <span class="nf">nqp::can</span><span class="p">(</span><span class="nv">$start_type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">mro_unhidden</span><span class="p">&#39;)</span>
                <span class="o">??</span> <span class="nv">$start_type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nf">mro_unhidden</span><span class="p">(</span><span class="nv">$start_type</span><span class="p">)</span>
                <span class="o">!!</span> <span class="nv">$start_type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">mro</span><span class="p">(</span><span class="nv">$start_type</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">@methods</span><span class="p">;</span>
            <span class="k">for</span> <span class="nv">@mro</span> <span class="p">{</span>
                <span class="k">my</span> <span class="nv">%mt</span> <span class="o">:=</span> <span class="nf">nqp::hllize</span><span class="p">(</span><span class="nv">$_</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">method_table</span><span class="p">(</span><span class="nv">$_</span><span class="p">));</span>
                <span class="k">if</span> <span class="nf">nqp::existskey</span><span class="p">(</span><span class="nv">%mt</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nv">@methods</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">%mt</span><span class="p">{</span><span class="nv">$name</span><span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
 
            <span class="c1"># If there&#39;s nothing to defer to, we&#39;ll evaluate to Nil (just don&#39;t set</span>
            <span class="c1"># the next method, and it happens below).</span>
            <span class="k">if</span> <span class="nf">nqp::elems</span><span class="p">(</span><span class="nv">@methods</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="c1"># We can defer. Populate next method.</span>
                <span class="nv">@methods</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span> <span class="c1"># Discard the first one, which we initially called</span>
                <span class="nv">$next_method</span> <span class="o">:=</span> <span class="nv">@methods</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span> <span class="c1"># The immediate next one</span>
 
                <span class="c1"># Build chain of further methods and set it as the state.</span>
                <span class="k">my</span> <span class="nv">$chain</span> <span class="o">:=</span> <span class="n">Exhausted</span><span class="p">;</span>
                <span class="k">while</span> <span class="nv">@methods</span> <span class="p">{</span>
                    <span class="nv">$chain</span> <span class="o">:=</span> <span class="n">DeferralChain</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">@methods</span><span class="o">.</span><span class="nb">pop</span><span class="o">,</span> <span class="nv">$chain</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-state-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$chain</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">elsif</span> <span class="o">!</span><span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$state</span><span class="o">,</span> <span class="n">Exhausted</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1"># Already working through a chain of method deferrals. Obtain</span>
            <span class="c1"># the tracking object for the dispatch state, and guard against</span>
            <span class="c1"># the next code object to run.</span>
            <span class="k">my</span> <span class="nv">$track_state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-resume-state</span><span class="p">&#39;);</span>
            <span class="k">my</span> <span class="nv">$track_method</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-attr</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nv">$track_state</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!code</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_method</span><span class="p">);</span>
 
            <span class="c1"># Update dispatch state to point to next method.</span>
            <span class="k">my</span> <span class="nv">$track_next</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-attr</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nv">$track_state</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!next</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-state</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_next</span><span class="p">);</span>
 
            <span class="c1"># Set next method, which we shall defer to.</span>
            <span class="nv">$next_method</span> <span class="o">:=</span> <span class="nv">$state</span><span class="o">.</span><span class="nb">code</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1"># Dispatch already exhausted; guard on that and fall through to returning</span>
            <span class="c1"># Nil.</span>
            <span class="k">my</span> <span class="nv">$track_state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-resume-state</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_state</span><span class="p">);</span>
        <span class="p">}</span>
 
        <span class="c1"># If we found a next method...</span>
        <span class="k">if</span> <span class="nf">nqp::isconcrete</span><span class="p">(</span><span class="nv">$next_method</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1"># Call with same (that is, original) arguments. Invoke with those.</span>
            <span class="c1"># We drop the first two arguments (which are only there for the</span>
            <span class="c1"># resumption), add the code object to invoke, and then leave it</span>
            <span class="c1"># to the invoke or multi dispatcher.</span>
            <span class="k">my</span> <span class="nv">$just_args</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$init</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">,</span>
                <span class="mi">0</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">$delegate_capture</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$just_args</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$next_method</span><span class="p">);</span>
            <span class="k">if</span> <span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$next_method</span><span class="o">,</span> <span class="nb">Routine</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$next_method</span><span class="o">.</span><span class="nf">is_dispatcher</span> <span class="p">{</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi</span><span class="p">&#39;</span><span class="o">,</span>
                        <span class="nv">$delegate_capture</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-invoke</span><span class="p">&#39;</span><span class="o">,</span>
                        <span class="nv">$delegate_capture</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1"># No method, so evaluate to Nil (boot-constant disregards all but</span>
            <span class="c1"># the first argument).</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-constant</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span>
                    <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nb">Nil</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">});</span>
</code></pre></div><p>这是相当多的内容，也是相当多的代码。但请记住，这只是运行在调度恢复的记录阶段。它还会在 callsame 的 callsite 产生一个调度程序，并带有通常的守卫和结果。隐式守卫是为我们在该点恢复的调度程序创建的。在最常见的情况下，这最终将是单形或双形的，尽管涉及多个调度或方法调度的嵌套的情况可能会产生一个更有形态的 callsite。</p>
<p>我选取的设计迫使 resume 回调处理两种情况：第一次复用和后一次复用。这在几个方面都不理想。</p>
<p>这对那些编写调度简历回调的人来说有点不方便。然而，这又不是特别常见的活动!</p>
<p>这种差异导致两个调度程序堆积在一个调用点，而在其他情况下，这个调用点可能只得到一个
只有其中第二项真正重要。之所以不统一，是为了确保绝大多数从未恢复调度的电话，不会因其最终从未使用的功能而产生每次调度的费用。如果结果是使用该功能的人多花了一点成本，那就这样吧。事实上，早期的基准测试显示，使用新调度器的 callsame 与 wrap 和方法调用似乎比当前 Rakudo 中的速度快了 10 倍，这还没等专门人员对它有足够的了解，就已经进一步改进了!</p>
<h2 id="目前所做的事情">目前所做的事情</h2>
<p>我上面讨论的所有内容都已经实现了，只是我可能在某个地方给人的印象是，使用新的 dispatcher 已经完全实现了多重调度，而现在还不是这样（没有处理 where 子句，也不支持调度恢复）。</p>
<h2 id="今后的步骤">今后的步骤</h2>
<p>下一步显然是要完全实现多调度的缺失部分。另一个缺失的语义是对 callwith 和 nextwith 的支持，当我们希望改变移动到下一个候选人时使用的参数。抛开其他一些小问题不谈，理论上来说，这至少可以让所有的 Raku 调度语义得到支持。</p>
<p>目前，所有的标准方法调用（$obj.meth()）和其他调用（foo()和$foo()）都会通过现有的调度机制，而不是新的调度器。这些也需要迁移到新的调度器上，而且任何发现的错误都需要修复。这将使事情达到新调度器在语义上已经准备好的程度。</p>
<p>之后是性能工作：确保专用器能够处理调度程序的防护和结果。最初的目标是，让常见调用形式的稳态性能至少与当前乐道主分支中的性能相同。已经很清楚了，对于一些到目前为止还很冰冷的东西来说，会有一些大的胜利，但它不应该以最常见的调度种类的退步为代价，因为这些调度种类之前已经得到了大量的优化努力。</p>
<p>此外，NQP - 乐道编译器和运行时内脏的其他位写的乐的限制形式 - 也需要迁移到使用新的调度器。只有做到这一点，才有可能从 MoarVM 中扯出当前的方法缓存、多调度缓存等。</p>
<p>一个悬而未决的问题是，如何处理 MoarVM 以外的后端。理想情况下，新的调度机制将被移植到这些地方。相当多的内容应该可以用 JVM 的 invokedynamic 来表达（而这一切可能会在基于 Truffle 的 Raku 实现中发挥得相当好，尽管我不确定目前是否有这方面的积极努力）。</p>
<h2 id="未来的机会">未来的机会</h2>
<p>虽然我目前的重点是发布一个使用新调度机制的 Rakudo 和 MoarVM 版本，但这不会是旅程的终点。一些眼前的想法。</p>
<ul>
<li>对角色的方法调用需要把角色打入一个类中， 所以方法查找会返回一个闭包来完成这个任务并替换调用者。这是一个很大的间接性；新的调度者可以获得 pun，并产生一个调度程序，用 punn 化的类类型对象替换角色类型对象，这将使每次调用的成本大大降低。</li>
<li>我期望使用新的 dispatcher 可以使句柄（dlegated）和 fallback（处理缺失的方法调用）机制都能有更好的表现</li>
<li>当前的 assuming - 用于为例程讨价还价或其他首要参数 - 的实现并不理想，利用新调度器的参数重写能力的实现可能会有更好的表现。
在新的调度机制的帮助下，一些新的语言功能也可能以高效的方式提供。例如，目前没有一种可靠的方式来尝试调用一段代码，如果签名绑定了就运行它，如果没有绑定就做其他事情。相反，像 Cro 路由器这样的东西，必须先做签名的试绑定，然后再做调用，这使得路由的成本相当高。还有一个建议已久的想法，就是通过签名与 <code>when</code> 构造提供模式匹配 (例如，<code>when * -&gt; ($x) {}; when * -&gt; ($x, *@tail) { }</code>)，这和需求差不多，只是在一个不太动态的环境下。</li>
</ul>
<h2 id="最后">最后&hellip;</h2>
<p>在新的调度机制上的工作比我最初预期的历程要长。设计的恢复部分特别具有挑战性，而且还有一些重要的细节需要处理。一路走来，大概有四种潜在的方法被抛弃了（虽然其中的元素都影响了我在这篇文章中描述的内容）。能坚持下来的抽象真的非常非常难。</p>
<p>我最终也不得不从根本上离开几个月做 Raku 工作，在其他一些工作中感觉有点被压垮了，并且一直在与同样重要的 RakuAST 项目（它将因为能够承担新的调度器的存在而被简化，并且还为我提供了一系列更柔和的 Raku 黑客任务，而调度器的工作提供了很少的轻松选择）。</p>
<p>鉴于这些，我很高兴终于看到了隧道尽头的光亮。剩下的工作是数不胜数的，而我们使用新的调度器发布 Rakudo 和 MoarVM 的那一天，感觉还需要几个月的时间（我希望写下这句话不是在诱惑命运！）。</p>
<p>新的调度器可能是 MoarVM 自我创建以来最重要的变化，因为它看到我们删除了一堆从一开始就存在的东西。RakuAST 也将为 Rakudo 编译器带来十年来最大的架构变化。两者都是一个机会，将多年来学习的东西硬生生地折合到运行时和编译器中。我希望再过十年，当我回顾这一切的时候，至少会觉得自己这次犯了更多有趣的错误。</p>
<p>原文链接: <a href="https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/">https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[为最年轻的 Raku 贡献力量]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-16T00:00:00+08:00</published>
            <updated>2021-02-16T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Contributing to Raku</blockquote><p>在过去的几周里，我看到了一些<a href="https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/">文章</a>和<a href="https://youtu.be/GAqfMNB-YBU">视频</a>，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文<a href="http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg">Raku 是我的 MMORPG</a>。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 <a href="https://raku.org/">Raku</a> 编程语言的法师。</p>
<h2 id="选择一个任务">选择一个任务</h2>
<p>让我们挑选一些编译器的 bug，并修复它。让我们去 <a href="https://rakudo.org/">Rakudo</a> 编译器 <a href="https://github.com/rakudo/rakudo/issues">issues</a>中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究<a href="https://www.apress.com/gp/book/9781484232279">编译器语法</a>，看了一本这方面的好书。找到了四个问题。</p>
<p><img src="https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png" alt="img"></p>
<ol>
<li>标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。</li>
<li>标签 &ldquo;需要共识&rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。</li>
<li>标签为 &ldquo;grammar and actions&rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。</li>
</ol>
<p>任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。</p>
<h2 id="建立工作环境">建立工作环境</h2>
<p>为源码和我们建立的编译器建立文件夹。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir ~/dev-rakudo <span class="o">&amp;&amp;</span> mkdir ~/dev-rakudo-install
</code></pre></div><p>Rakudo 编译器由三部分组成。</p>
<ol>
<li>虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。</li>
<li>NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &ldquo;子集&rdquo;。虚拟机可以执行用 NQP 编写的代码。</li>
<li>Rakudo 编译器本身，用 NQP 和 Raku 编写。</li>
</ol>
<p>下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:MoarVM/MoarVM.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:Raku/nqp.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> nqp
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:rakudo/rakudo.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> rakudo
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install
</code></pre></div><p>注意参数。<code>--prefix</code> 显示了 <code>make install</code> 命令后可执行文件的复制位置，<code>--backend=moar</code> 表示正在使用的虚拟机，而 <code>-j 4</code> 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 <code>~/dev-rakudo-install/bin/raku</code>。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo/rakudo <span class="o">&amp;&amp;</span> git clone https://github.com/Raku/roast.git t/spec
</code></pre></div><p>我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。</p>
<p>这里和下面我将在 <code>~/dev-rakudo/rakudo</code> 文件夹中工作，除非另有说明。</p>
<pre><code>&gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
</code></pre><p>14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!</p>
<h2 id="让我们来看看问题的陈述">让我们来看看问题的陈述</h2>
<p>问题陈述说，某个元运算符 <code>R</code> 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Output: True</span>
</code></pre></div><p>Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 <code>:foo(42)</code> 是一个名称为 <code>foo</code>、值为 <code>42</code> 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-named-parameter</span><span class="p">(</span><span class="o">:</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Output: 42</span>
</code></pre></div><p>如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 没有冒号</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Unexpected named argument &#39;foo&#39; passed</span>
</code></pre></div><p>如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">((:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)));</span> <span class="c1"># Output: foo =&gt; 42</span>
</code></pre></div><p>在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-capture</span><span class="p">(</span><span class="o">|</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 参数捕获</span>
  <span class="nb">say</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>     <span class="c1"># Output: \(:foo(42))</span>
<span class="nf">sub-with-capture</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>           <span class="c1"># Output: \(42)</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(:foo((1,).Seq))</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(-1)</span>
</code></pre></div><p>倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。</p>
<p>在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。</p>
<h2 id="我们需要一个新的测试">我们需要一个新的测试</h2>
<p>为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（<a href="https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t">S03-metops/reverse.t</a>）。下面我将补充以下测试。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># https://github.com/rakudo/rakudo/issues/1632</span>
<span class="p">{</span>
  <span class="k">sub</span> <span class="nf">subroutine</span><span class="p">(</span><span class="nv">$expected</span><span class="o">,</span> <span class="o">|</span><span class="n">actual</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">is</span> <span class="nc">actual</span><span class="o">.</span><span class="nb">gist</span><span class="o">,</span> <span class="nv">$expected</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Сolonpair exists</span><span class="p">&#34;</span>
  <span class="p">}</span>

  <span class="nf">subroutine</span><span class="p">(&#39;</span><span class="s1">\(:foo(-1))</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p>该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 <code>make</code> 对新构建的编译器进行单独测试。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test 'Colonpair exists'
# at t/spec/S03-metaops/reverse.t line 191
# expected: '\(:foo(-1))'
#      got: '\(-1)'
# You planned 69 tests, but ran 70
# You failed 1 test of 70
</code></pre><p>你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 <code>plan</code> 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。</p>
<h2 id="凝视法">凝视法</h2>
<p>一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：</p>
<ol>
<li>基础解析器代码在文件 <code>rakudo/src/Perl6/Grammar.nqp</code> 中。</li>
<li>这个解析器是从 <code>nqp/src/HLL/Grammar.nqp</code> 文件中的基础解析器继承的。</li>
<li>元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。</li>
</ol>
<p>我在基础解析器代码中找到了对元操作符的引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;R&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">R</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">reverse the args of</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nv">O</span><span class="o">=.</span><span class="nf">revO</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;Z&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">Z</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">zip with</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="sr">O(|</span><span class="nv">%list_infix</span><span class="sr">)</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 <code>my $r = :foo(3 R- 2); say $r; # Output: foo =&gt; -1</code> 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。</p>
<h2 id="编译器将帮助我们">编译器将帮助我们</h2>
<p>颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 <code>--target</code> 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 <code>--target=parse</code>（因为我只知道这一个）。</p>
<p>我从 <code>~/dev-rakudo/rakudo</code> 文件夹中使用 <code>rakumo-m</code>，这样我就不必等待通过 <code>make install</code> 命令将所需文件复制到 <code>~/dev-rakudo-install</code>。简单的脚本可以这样运行。更复杂的脚本必须在 <code>make install</code> 之后从 <code>-install</code> 中运行。</p>
<pre><code>&gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
</code></pre><p>结论：R 和 Z 的解析是一样的。</p>
<h2 id="这不是解析">这不是解析</h2>
<p>所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 <code>rakudo/src/Perl6/Actions.nqp</code> 和 <code>nqp/src/HLL/Actions.nqp</code> 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。</p>
<p>我在主 Actions 中找到了以下代码。</p>
<pre><code>[...]
elsif $&lt;infix_prefix_meta_operator&gt; {
[...]
  if    $metasym eq 'R' { $helper := '&amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }
  elsif $metasym eq 'X' { $helper := '&amp;METAOP_CROSS'; $t := nqp::uc($t); }
  elsif $metasym eq 'Z' { $helper := '&amp;METAOP_ZIP'; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&lt;call&gt;, :name($helper), WANTED($basepast,'infixish') );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&lt;OPER&gt;&lt;O&gt;.made)), :scope&lt;lexical&gt;))
    if $metasym eq 'X' || $metasym eq 'Z';
[...]
</code></pre><p>它说，如果在代码中解析了元操作符 <code>R</code>、<code>Z</code> 或 <code>X</code>，就应该在语法树中添加一些 <code>METAOP_</code> 函数调用。在 <code>Z</code> 和 <code>X</code> 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 <code>rakudo/src/core.c/metaops.pm6</code> 中找到。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">METAOP_ZIP</span><span class="p">(</span>\<span class="n">op</span><span class="o">,</span> <span class="nv">&amp;reduce</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
 <span class="nf">nqp::if</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="nf">prec</span><span class="p">(&#39;</span><span class="s1">thunky</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">starts-with</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$arity</span> <span class="o">=</span> <span class="n">lol</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
    <span class="o">[...]</span>
  <span class="p">}</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">Rakudo::Iterator</span><span class="o">.</span><span class="nf">ZipIterablesOp</span><span class="p">(</span><span class="n">lol</span><span class="o">,</span><span class="n">op</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>给你：</p>
<ol>
<li><code>\op</code> 是由我们的元操作符，即-，在前面的操作。</li>
<li>Trait <code>implementation-detail</code> 只是表明这不是公共代码，是编译器实现的一部分。</li>
<li>由于-操作没有笨重的特性，所以 <code>&amp;reduce</code> 函数不会参与计算，<code>Z</code> 的结果是 <code>Seq.new(...)</code>。</li>
<li><code>R</code> 的结果是一个操作调用 - 参数顺序相反。</li>
</ol>
<p>这时我想起还有一个 - 目标，即星。它将显示行动的结果。</p>
<pre><code>&gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(call &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>一如所料。除了调用不同的 <code>METAOP_</code> 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 <code>Int</code> 和 <code>Seq</code>。众所周知，Raku 对不同类型的对象的上下文相当敏感&hellip;&hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>一切都没有改变。所以，不是返回值&hellip;&hellip;想了想，不知道为什么结果又是 <code>-1</code> 而不是 <code>(-1,).Seq</code>。而且，从代码来看，<code>Seq</code> 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 <code>METAOP_REVERSE</code> 结果只是为了崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>怎么会呢？语法树中包含了对 <code>METAOP_REVERSE</code> 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 <code>-1</code>。</p>
<p>这些都不是《行动》。</p>
<p>这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 <code>--target=mast</code>。</p>
<pre><code>&gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&lt;s&gt;, cuuid&lt;1&gt;
  Local types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;int&gt;, 5&lt;str&gt;, 6&lt;obj&gt;, 7&lt;obj&gt;, 8&lt;obj&gt;,
  Lexical types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;obj&gt;,
  Lexical names: 0&lt;c&gt;, 1&lt;$¢&gt;, 2&lt;$!&gt;, 3&lt;$/&gt;, 4&lt;$*DISPATCHER&gt;,
  Lexical map: $!&lt;2&gt;, c&lt;0&gt;, $*DISPATCHER&lt;4&gt;, $¢&lt;1&gt;, $/&lt;3&gt;,
  Outer: name&lt;&lt;unit&gt;&gt;, cuuid&lt;2&gt;
[...]
</code></pre><p>某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。</p>
<pre><code>&gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(callstatic &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>哈，就是这样。在优化阶段后，行将失踪。</p>
<ul>
<li><code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-.</code>
并将整个 <code>METAOP_REVERSE</code> 调用替换为通常的操作 <code>(&amp;infix:&lt;-&gt;)</code>。所以问题一定在优化器的某个地方。</li>
</ul>
<p>只有在 <code>optim_nameless_call</code> 方法中才会提到 <code>&amp;METAOP_ASSIGN</code>，其中 <code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;)</code>。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 <code>_</code> 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
  }
[...]
</code></pre><p>让我提醒你，优化前的树是这样的。</p>
<pre><code>[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
    - QAST::Want &lt;wanted&gt; 2
[...]
</code></pre><p>而精简之后，是这样的。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>也就是说，优化 <code>_nameless_call</code> 做了以下工作。</p>
<p>如果我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作没有三个参数，如果 <code>METAOP_REVERSE</code> 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作，以相反的顺序调用 <code>&amp;infix:&lt;-&gt;</code> 参数。就是说，把结果打包成一对就没了。</p>
<p>在摸索了一下如何解决这个问题，并阅读了 <code>QAST::SpecialArg</code> 和 <code>QAST::Node</code> 的实现后，我想到了下面的代码。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
</code></pre><p>还有木头。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;infix:&lt;-&gt; :named&lt;foo&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>命名的参数返回到它的位置。测试也开始通过。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
</code></pre><p>我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 <code>self.visit_op: $opt_result;</code>，对产生的非优化操作调用优化器，那么产生的树就会像这样。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&lt;foo&gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&lt;foo&gt;)
    - QAST::IVal(-1)
[...]
</code></pre><p>现在一切都很理想。</p>
<h2 id="分享成果">分享成果</h2>
<p>我们已经到了终点线。现在我们只需要分享我们的经验。</p>
<ol>
<li>重要的是：运行所有的 <code>make spectest</code> 测试，确保没有新的东西被破坏。</li>
<li>在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。</li>
<li>将 fork 仓库添加为新的 git 远程仓库。</li>
<li>cd ~/dev-rakudo/rakudo &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
<li>cd ~/dev-rakudo/t/spec &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
</ol>
<p>重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。</p>
<p>提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。</p>
<p>运行提交。</p>
<pre><code>cd ~/dev-rakudo/rakudo &amp;&amp; git push fork
cd ~/dev-rakudo/t/spec &amp;&amp; git push fork
</code></pre><p>向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。</p>
<h2 id="结论">结论</h2>
<p>对开源软件的贡献是：</p>
<ol>
<li>趣味性和趣味性。</li>
<li>给你的感觉是，你正在做一些有用的事情，你真的是。</li>
<li>让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 <code>#raku IRC</code> 频道中得到回答）。</li>
<li>解决非标准任务，没有截止日期的压力，是一种很好的体验。</li>
</ol>
<p>选择你觉得最舒服的角色等级，去做新的任务吧!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[贪婪 Junction 的奇闻异事]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-10-04T00:00:00+08:00</published>
            <updated>2020-10-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>The Strange Case of the Greedy Junction</blockquote><h2 id="贪婪-junction-的奇闻异事">贪婪 junction 的奇闻异事</h2>
<p>说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。</p>
<p><a href="https://raku.org/">Raku</a> 有一个整洁的功能，叫做 <a href="https://docs.raku.org/type/Junction">Junction</a>。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 <code>pair</code> 数据结构，它可以接受两个不同类型的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">enum</span> <span class="n">RGB</span> <span class="p">&lt;</span><span class="s">R G B</span><span class="p">&gt;;</span>

<span class="c1"># Pair Constructor: the arguments of pair() are captured</span>
<span class="c1"># in a closure that is returned</span>
<span class="k">sub</span> <span class="nb">pair</span><span class="p">(</span>\<span class="nb">x</span><span class="o">,</span> \<span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="p">(</span><span class="nv">&amp;p</span><span class="p">){</span> <span class="nf">p</span><span class="p">(</span><span class="nb">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div><p>所以 <code>pair</code> 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 <code>pair</code> 中的值。我将把这些访问(accessor)函数称为 <code>fst</code> 和 <code>snd</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Accessors to get the values from the closure</span>
<span class="k">my</span> <span class="k">sub</span> <span class="nf">fst</span> <span class="p">(</span><span class="nv">&amp;p</span><span class="p">)</span> <span class="p">{</span><span class="nf">p</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="o">,</span>\<span class="n">y</span><span class="p">){</span><span class="nb">x</span><span class="p">})}</span>
<span class="k">my</span> <span class="k">sub</span> <span class="nf">snd</span> <span class="p">(</span><span class="nv">&amp;p</span><span class="p">)</span> <span class="p">{</span><span class="nf">p</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="o">,</span>\<span class="n">y</span><span class="p">){</span><span class="n">y</span><span class="p">})}</span>
</code></pre></div><p>做实际选择的函数是由 <code>fst</code> 和 <code>snd</code> 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 <code>pair</code>，而不是必须将它们作为参数传递。让我们看一个例子，一个 <code>Int</code> 和一个 <code>RGB</code> 的 pair。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">\p1</span> <span class="o">=</span> <span class="nb">pair</span> <span class="mi">42</span><span class="o">,</span> <span class="ow">R</span><span class="err">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="mi">42</span> <span class="o">==</span> <span class="n">fst</span> <span class="n">p1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="n">snd</span> <span class="n">p1</span><span class="p">;</span>	<span class="k">#=</span><span class="p">&gt;</span><span class="sd"> says &#34;R&#34;
</span><span class="sd">}
</span></code></pre></div><p>所以我们用两个值调用 <code>pair</code> 来创建一个 pair，并使用 <code>fst</code> 和 <code>snd</code> 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。</p>
<p>现在让我们使用 junction 作为其中一个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Example instance with a &#39;one&#39;-type junction</span>
<span class="k">my</span> <span class="nb">Junction</span> \<span class="n">p1j</span> <span class="o">=</span> <span class="nb">pair</span> <span class="p">(</span><span class="mi">42</span><span class="o">^</span><span class="mi">43</span><span class="p">)</span><span class="o">,</span><span class="ow">R</span><span class="err">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="mi">42</span> <span class="o">==</span> <span class="n">fst</span> <span class="n">p1j</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="n">snd</span> <span class="n">p1j</span><span class="p">;</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> one(R, R)
</span><span class="sd">}
</span></code></pre></div><p>这里发生的情况是，原始参数 <code>R</code> 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 <code>R</code> 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章&quot;<a href="https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e">重构 Raku 的 Junction</a>&quot;。</p>
<p><a href="https://docs.raku.org/type/Junction">Raku 关于 junction 的文档</a>中说，你不应该真正尝试从 junction 中获取值。</p>
<p>&ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。&rdquo;</p>
<p>然而，有一个 FAQ <a href="https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)">勉强地告诉你如何做</a>。FAQ 再次警告不要这样做。</p>
<p>&ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。&rdquo;</p>
<p>然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。</p>
<p>因此，我建议增加一个折叠(<code>collapse</code>)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span> <span class="mi">42</span> <span class="o">==</span> <span class="n">fst</span> <span class="n">p1j</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nf">collapse</span><span class="p">(</span><span class="n">snd</span> <span class="n">p1j</span><span class="p">);</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> says &#39;R&#39;
</span><span class="sd">}
</span></code></pre></div><p>该函数的实现取自<a href="https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)">上述常见问题</a>，并增加了一个检查，以确保 junction 上的所有值都相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">collapse</span><span class="p">(</span><span class="nb">Junction</span> \<span class="n">j</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">my</span> <span class="nv">@vvs</span><span class="p">;</span>
    <span class="k">-&gt;</span> <span class="nb">Any</span> \<span class="k">s</span> <span class="p">{</span><span class="sr"> push </span><span class="nv">@vvs</span><span class="sr">, s </span><span class="p">}</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>    
    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span>  <span class="nb">shift</span> <span class="nv">@vvs</span><span class="p">;</span>        
    <span class="k">my</span> <span class="nv">@ts</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span><span class="o">!</span><span class="p">(</span><span class="nv">$_</span> <span class="o">~~</span> <span class="nv">$v</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@vvs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">@ts</span><span class="o">.</span><span class="nb">elems</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
        <span class="nv">$v</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Can&#39;t collapse this Junction: elements are not identical: </span><span class="p">{</span><span class="nv">$v</span><span class="o">,</span><span class="nv">@vvs</span><span class="p">}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果能把这个功能作为一个 <code>collapse</code> 方法添加到 <code>Junction</code> 类中就更好了。</p>
<p>原文链接: <a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/junction" term="junction" label="Junction" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[重构 Raku 的 Junction]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
            
                <id>https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-10-04T00:00:00+08:00</published>
            <updated>2020-10-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Reconstructing Raku&rsquo;s Junctions</blockquote><h2 id="重构-raku-的-junction">重构 Raku 的 Junction</h2>
<p>Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。</p>
<h3 id="raku-中的-junction">Raku 中的 Junction</h3>
<p><a href="https://docs.raku.org/">Raku</a> 有一个整洁的功能叫做 <a href="https://docs.raku.org/type/Junction">Junction</a>。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(<code>&amp;</code>)、any(<code>|</code>)、one(<code>^</code>) 或 <code>none</code> (空结点)。</p>
<p>例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">11</span><span class="o">|</span><span class="mi">22</span><span class="p">;</span> <span class="c1"># short for any(11,22)</span>
<span class="k">if</span> <span class="mi">33</span> <span class="o">==</span> <span class="nv">$j</span> <span class="o">+</span> <span class="mi">11</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">yes</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="mi">3</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="nb">one</span><span class="p">;</span>         <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> True 
</span><span class="sd">say so (&#34;a&#34; ^ &#34;b&#34; ^ &#34;c&#34;) eq &#34;a&#34;; #=</span> <span class="nb">True</span>
</code></pre></div><p>函数 <code>so</code> 强制使用布尔上下文。</p>
<p>Junction 有 <code>Junction</code> 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 <code>sq</code> 从 <code>Int</code> 到 <code>Int</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sq</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="p">}</span>

<span class="k">my</span> <span class="nb">Int</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span> <span class="c1"># OK</span>
<span class="nb">say</span> <span class="nv">$res</span><span class="p">;</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> 121
</span></code></pre></div><p>现在让我们定义一个类型为任何 <code>Int</code> 值的 Junction。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">|</span> <span class="mi">22</span><span class="p">;</span> 
</code></pre></div><p>当我们将 <code>sq</code> 应用于 <code>$j</code> 时，我们没有得到一个类型错误，即使函数的类型是 <code>:(Int --&gt; Int)</code>，Junction 的类型是 <code>Junction</code>。相反，我们得到的是一个结果的 Junction。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nf">sq</span><span class="p">(</span><span class="nv">$j</span><span class="p">);</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> any(121, 484)
</span></code></pre></div><p>如果我们像之前一样将其赋值给一个类型为 <code>Int</code> 的变量，我们会得到一个类型错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="nv">$j</span><span class="p">);</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))
</span></code></pre></div><p>取而代之的是，现在返回值的类型为 <code>Junction</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="mi">11</span><span class="o">|</span><span class="mi">22</span><span class="p">);</span> <span class="c1"># OK</span>
</code></pre></div><p>所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。</p>
<p>另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 <code>Junction</code> 类型。例如，如果我们创建了一个由 <code>Str</code> 值组成的 Junction，并试图将这个 Junction 的值传递到 <code>sq</code> 中，我们会得到一个类型错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sj</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">11</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&#39;</span><span class="s1">22</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">$sj</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd">(Junction)
</span><span class="sd">
</span><span class="sd">my Junction $svj = sq($sj); #=</span> <span class="n">Type</span> <span class="n">check</span> <span class="n">failed</span> <span class="nb">in</span> <span class="n">binding</span> <span class="nb">to</span> <span class="nb">parameter</span> <span class="p">&#39;</span><span class="s1">x</span><span class="p">&#39;;</span> <span class="nb">expected</span> <span class="nb">Int</span> <span class="k">but</span> <span class="nb">got</span> <span class="nb">Str</span> <span class="p">(&#34;</span><span class="s2">11</span><span class="p">&#34;)</span>
</code></pre></div><h3 id="junction-不遵循静态类型规则">Junction 不遵循静态类型规则</h3>
<p>虽然这样做是有道理的(如果原始函数期望使用 <code>Int</code>，我们不希望它与 <code>Str</code> 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 <code>Int</code>，那么可以使用类型图中低于它的任何类型来代替。但是 <code>Int</code> 和 <code>Junction</code> 的简化类型图如下。</p>
<pre><code>Int -&gt; Cool -&gt; Any -&gt; Mu &lt;- Junction
</code></pre>
<p>所以 Junction 永远不是 <code>Any</code> 以下任何东西的子类型。因此，将 Junction 放在类型为 <code>Any</code> 或其子类型的槽中应该是一个类型错误。</p>
<p>此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。</p>
<p>那么这里到底发生了什么？</p>
<h3 id="一个工作假设">一个工作假设</h3>
<p>一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。</p>
<h3 id="重构-junction-的第一部分类型">重构 Junction 的第一部分：类型</h3>
<p>让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。</p>
<h4 id="junction-类型">Junction 类型</h4>
<p>Junction 是一个由 Junction 类型 <code>JType</code> 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">data</span> <span class="n">JType</span> <span class="o">=</span> <span class="n">JAny</span> <span class="o">|</span> <span class="n">JAll</span> <span class="o">|</span> <span class="n">JOne</span> <span class="o">|</span> <span class="n">JNone</span>

<span class="n">data</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">Junction</span> <span class="n">JType</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
</code></pre></div><h4 id="应用结点">应用结点</h4>
<p>对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。</p>
<ul>
<li>将非 Junction 函数应用于 Junction 表达式</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span>•￮<span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="k">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="k">-&gt;</span>  <span class="nb">Junction</span> <span class="n">b</span>
</code></pre></div><ul>
<li>将 Junction 函数应用于非 Junction 表达式。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span>￮•<span class="p">)</span> <span class="o">::</span>  <span class="nb">Junction</span> <span class="p">(</span><span class="n">b</span> <span class="k">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">b</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="n">c</span>
</code></pre></div><ul>
<li>将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span>￮￮<span class="p">)</span> <span class="o">::</span>  <span class="nb">Junction</span> <span class="p">(</span><span class="n">b</span> <span class="k">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="n">b</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="p">(</span><span class="nb">Junction</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div><p>为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">--</span> <span class="ow">and</span> <span class="n">similar</span> <span class="k">for</span> <span class="o">/-,</span> <span class="o">&gt;,</span> <span class="o">&lt;,</span> <span class="p">&lt;</span><span class="s">=,</span><span class="p">&gt;</span><span class="o">=</span>
<span class="p">(</span>￮<span class="o">==</span>•<span class="p">)</span> <span class="o">::</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="k">-&gt;</span> <span class="n">a</span> <span class="k">-&gt;</span> <span class="nb">Bool</span>
</code></pre></div><h4 id="折叠-junction">折叠 Junction</h4>
<p>那么我们就有了 <code>so</code>，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">so</span> <span class="o">::</span> <span class="nb">Junction</span> <span class="nb">Bool</span> <span class="k">-&gt;</span> <span class="nb">Bool</span>
</code></pre></div><p>最后我们有 <code>collapse</code>，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">collapse</span> <span class="o">::</span> <span class="p">(</span><span class="n">Show</span> <span class="n">a</span><span class="o">,</span><span class="n">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="k">-&gt;</span> <span class="n">a</span>
</code></pre></div><p>这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在&quot;<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的奇怪情况</a>&ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。</p>
<h4 id="重新审视贪婪-junction-的奇怪情况">重新审视贪婪 Junction 的奇怪情况</h4>
<p>假设我们有一个两个参数的函数 <code>f :: a -&gt; b -&gt; c</code>，我们对第一个参数应用一个结点 <code>j :: Junction</code> a 应用到第一个参数 <code>f •￮ j</code> 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：<code>fp :: Junction b -&gt; c</code>。如果我们现在想用 <code>fp ￮• v</code> 将这个函数应用于一个非结点的值 <code>v :: b</code>，那么结果就是 <code>Junction c</code> 类型的。</p>
<p>现在，让我们考虑类型 <code>c</code> 是 <code>forall d . (a -&gt; b -&gt; d) -&gt; d</code> 的特殊情况。所以我们有 <code>Junction</code>(<code>forall d . (a-&gt;b-&gt;d) -&gt; d</code>)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 <code>forall</code>，所以 <code>d</code> 可以是任何东西，但在实践中我们希望它是 <code>a</code> 或 <code>b</code>。</p>
<p>假设我们将这个函数(称它为 <code>p</code>)应用于 <code>fst :: a-&gt;b-&gt;a</code>，使用 <code>p ￮• fst</code>，那么我们得到 <code>Junction a</code>。但是如果我们将它应用于 <code>snd :: a-&gt;b-&gt;b</code>，使用 <code>p ￮• snd</code>，那么我们得到 <code>Junction b</code>。</p>
<p>这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在&rdquo;<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的奇怪情况</a>&ldquo;中已经解释过。而这也是我们需要 <code>collapse</code> 函数的原因。</p>
<h4 id="重构-junction-的第2部分raku-的实现">重构 Junction 的第2部分：Raku 的实现。</h4>
<p>我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># The types of Junctions</span>
<span class="k">enum</span> <span class="n">JType</span> <span class="p">&lt;</span><span class="s">JAny  JAll  JOne  JNone </span><span class="p">&gt;;</span>

<span class="c1"># The actual Junction type</span>
<span class="k">role</span> <span class="nb">Junction</span><span class="o">[</span>\<span class="n">jt</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">]</span> <span class="p">{</span>
    <span class="k">has</span> <span class="n">JType</span> <span class="nv">$.junction-type</span><span class="o">=</span><span class="n">jt</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.values</span><span class="o">=</span><span class="nv">@vs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">our</span> <span class="k">sub</span> <span class="nf">all_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JAll</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">our</span> <span class="k">sub</span> <span class="nf">any_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JAny</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">our</span> <span class="k">sub</span> <span class="nf">one_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JOne</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">our</span> <span class="k">sub</span> <span class="nf">none_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JNone</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>将一个（单参数）函数应用于 junction 参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">●○</span><span class="p">&gt;(</span> <span class="nv">&amp;f</span><span class="o">,</span> \<span class="n">j</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jt</span><span class="o">=</span><span class="n">j</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@vs</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
  
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">jt</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">&amp;f</span><span class="p">(</span><span class="nv">$_</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@vs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>要将 Junction 内的函数应用于非 Junction 的参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">○●</span><span class="p">&gt;(</span> \<span class="n">jf</span><span class="o">,</span> \<span class="n">v</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jt</span><span class="o">=</span><span class="n">jf</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@fs</span> <span class="o">=</span> <span class="n">jf</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>

    <span class="nb">Junction</span><span class="o">[</span> <span class="n">jt</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">$_</span><span class="p">(</span> <span class="n">v</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@fs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">○○</span><span class="p">&gt;(</span> \<span class="n">jf</span><span class="o">,</span> \<span class="n">jv</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jft</span><span class="o">=</span> <span class="n">jf</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@fs</span> <span class="o">=</span> <span class="n">jf</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">\jvt</span> <span class="o">=</span> <span class="n">jv</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@vs</span> <span class="o">=</span> <span class="n">jv</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">jvt</span> <span class="o">==</span> <span class="n">JAll</span> <span class="ow">and</span> <span class="n">jft</span> <span class="o">!=</span> <span class="n">JAll</span><span class="p">)</span> <span class="p">{</span>        
        <span class="nb">Junction</span><span class="o">[</span> <span class="n">jvt</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="n">v</span><span class="p">){</span><span class="n">jf</span> ○● <span class="n">v</span><span class="p">}</span><span class="o">,</span> <span class="nv">@vs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>  
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        
        <span class="nb">Junction</span><span class="o">[</span> <span class="n">jft</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">&amp;f</span><span class="p">){</span> <span class="nv">&amp;f</span> ●○ <span class="n">jv</span><span class="p">}</span><span class="o">,</span> <span class="nv">@fs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>为了完整，这里是 <code>○==●</code> 的定义。<code>○!=●</code>、<code>○&gt;●</code> 等的定义是类似的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s"> ○==● </span><span class="p">&gt;(</span> \<span class="n">j</span><span class="o">,</span> \<span class="n">v</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="p">){</span><span class="nb">x</span><span class="o">==</span><span class="n">v</span><span class="p">}</span> ●○ <span class="n">j</span>
<span class="p">}</span>
</code></pre></div><p>接下来我们有 <code>so</code>，它把布尔值的 junction 变成了布尔值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">our</span> <span class="k">sub</span> <span class="nb">so</span> <span class="p">(</span>\<span class="n">jv</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">my</span> <span class="nv">@vs</span> <span class="o">=</span> <span class="n">jv</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">given</span> <span class="n">jv</span><span class="o">.</span><span class="nf">junction-type</span> <span class="p">{</span>
        <span class="k">when</span> <span class="n">JAny</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span>  <span class="nv">@vs</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">}</span>
        <span class="k">when</span> <span class="n">JAll</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="o">!</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span> <span class="nv">@vs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">}</span>
        <span class="k">when</span> <span class="n">JOne</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span>  <span class="nv">@vs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">}</span>
        <span class="k">when</span> <span class="n">JOne</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span>  <span class="nv">@vs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>最后我们有 <code>collapse</code>，正如<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的文章</a>中所定义的那样， <code>collapse</code> 返回 Junction 的值，只要它们都是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">our</span> <span class="k">sub</span> <span class="nf">collapse</span><span class="p">(</span> \<span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jt</span><span class="o">=</span><span class="n">j</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@vvs</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span>  <span class="nb">shift</span> <span class="nv">@vvs</span><span class="p">;</span>        
    <span class="k">my</span> <span class="nv">@ts</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span><span class="o">!</span><span class="p">(</span><span class="nv">$_</span> <span class="o">~~</span> <span class="nv">$v</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@vvs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">@ts</span><span class="o">.</span><span class="nb">elems</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
        <span class="nv">$v</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Can&#39;t collapse this Junction: elements are not identical: </span><span class="p">{</span><span class="nv">$v</span><span class="o">,</span><span class="nv">@vvs</span><span class="p">}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="junction-清理">Junction 清理</h3>
<p>现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sq</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="p">}</span>
<span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">|</span> <span class="mi">22</span><span class="p">;</span> 
<span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="nv">$j</span><span class="p">);</span> 
</code></pre></div><p>去语法塘后这变成了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$j</span> <span class="o">=</span> <span class="n">any_</span> <span class="o">[</span><span class="mi">11</span><span class="o">,</span><span class="mi">22</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nv">&amp;sq</span> ●○ <span class="nv">$j</span><span class="p">;</span>
</code></pre></div><p>类似地,</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span><span class="nv">$j</span> <span class="o">==</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> 
</code></pre></div><p>变成了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span><span class="nb">so</span> <span class="p">(</span><span class="nv">$j</span> ○<span class="o">==</span>● <span class="mi">42</span><span class="p">))</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>和其他布尔上下文类似。</p>
<p>如果我们仔细看<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 文章</a>中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> \<span class="n">p1j</span> <span class="o">=</span> <span class="nb">pair</span> <span class="ow">R</span><span class="o">,</span><span class="err">(42</span><span class="o">^</span><span class="err">43);</span>
</code></pre></div><p>去语法塘后变为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> \<span class="n">p1j</span> <span class="o">=</span> <span class="nv">&amp;pair</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="ow">R</span><span class="err">)</span> ●○ <span class="n">one_</span> <span class="o">[</span><span class="mi">42</span><span class="o">,</span><span class="mi">43</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><p>我们使用 <code>.assuming()</code> 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">\p1jr</span> <span class="o">=</span> <span class="p">(</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$y</span><span class="p">){</span> <span class="nv">&amp;pair</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="o">*,</span><span class="nv">$y</span><span class="p">)</span> <span class="p">}</span> ●○ <span class="n">one_</span> <span class="o">[</span><span class="mi">42</span><span class="o">,</span><span class="mi">43</span><span class="o">]</span> <span class="p">)</span> ○● <span class="ow">R</span><span class="err">;</span>
</code></pre></div><p>最后，举一个两个参数都是 Junction 的例子。由于 <code>○○</code> 的定义，应用的顺序并不重要。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">m</span><span class="p">(</span>\<span class="nb">x</span><span class="o">,</span>\<span class="n">y</span><span class="p">){</span><span class="nb">x</span><span class="o">*</span><span class="n">y</span><span class="p">}</span>

<span class="k">my</span> <span class="nv">\p4</span> <span class="o">=</span> <span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="p">){</span> <span class="nv">&amp;m</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="nb">x</span><span class="p">)</span> <span class="p">}</span> ●○ <span class="n">any_</span> <span class="o">[</span><span class="mi">11</span><span class="o">,</span><span class="mi">22</span><span class="o">]</span> <span class="p">)</span> ○○ <span class="n">all_</span> <span class="o">[</span><span class="mi">33</span><span class="o">,</span><span class="mi">44</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">\p4r</span> <span class="o">=</span> <span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="p">){</span> <span class="nv">&amp;m</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="o">*,</span><span class="nb">x</span><span class="p">)</span> <span class="p">}</span> ●○ <span class="n">all_</span> <span class="o">[</span><span class="mi">33</span><span class="o">,</span><span class="mi">44</span><span class="o">]</span> <span class="p">)</span> ○○ <span class="n">any_</span> <span class="o">[</span><span class="mi">11</span><span class="o">,</span><span class="mi">22</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><h3 id="结论">结论</h3>
<p>从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。</p>
<p>原文链接: <a href="https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e">https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/junction" term="junction" label="Junction" />
                            
                        
                    
                
            
        </entry>
    
</feed>
