<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.85.0">Hugo</generator><title type="html"><![CDATA[rakulang on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/categories/rakulang/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/categories/rakulang/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/categories/rakulang/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/categories/rakulang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-07-13T22:14:20+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/categories/rakulang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Actions 和抽象语法树]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-05-12-actions-and-ast-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-05-12-actions-and-ast-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-13T00:00:00+08:00</published>
            <updated>2021-07-13T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Actions and Ast in Raku</blockquote><p>有一段结构化的文本, 写一个 Grammar 来解析它：</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">name = Animal Facts
author = jnthn

[cat]
desc = The smartest and cutest
cuteness = 100000

[dugong]
desc = The cow of the sea
cuteness = -10

[magpie]
desc = crow; raven; rook; jackdaw; chough; magpie; jay
cuteness = 99
</code></pre></div><p>每一段都是一个章节, 有的章节没有 <code>[cat]</code> 这样的标题, 要求 Grammar 生成一个散列, 散列的键是方括号中的单词, 如果没有就默认为 <code>_</code>, 散列的值是一个散列的数组, 数组里面的每个散列的键为等号左边的单词, 键值为等号右边的字符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">INIFile::Grammar</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="ni">^</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">entries</span><span class="p">&gt;</span><span class="sr">     </span><span class="c1"># 条目
</span><span class="c1"></span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">section</span><span class="p">&gt;</span><span class="o">+</span><span class="sr">    </span><span class="c1"># 章节
</span><span class="c1"></span><span class="sr">        </span><span class="ni">$</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">section</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">entries</span><span class="p">&gt;</span><span class="sr"> </span><span class="c1"># 每个章节含有多个条目 entry
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">entries</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">entry</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="c1"># entry 可以为空
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">entry</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">key</span>     <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                       </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">value</span>   <span class="p">{</span><span class="sr"> </span><span class="se">\N</span><span class="o">+</span><span class="sr">                       </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">INIFileActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">entries</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">%entries</span><span class="p">;</span>
        <span class="k">for</span> <span class="nv">$&lt;entry&gt;</span> <span class="k">-&gt;</span> <span class="nv">$e</span> <span class="p">{</span>
            <span class="nv">%entries</span><span class="p">{</span><span class="nv">$e</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;}</span> <span class="o">:=</span> <span class="o">~</span><span class="nv">$e</span><span class="p">&lt;</span><span class="s">value</span><span class="p">&gt;;</span>
        <span class="p">}</span>
        <span class="k">make</span> <span class="nv">%entries</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">%result</span><span class="p">;</span>
        <span class="nv">%result</span><span class="p">&lt;</span><span class="s">_</span><span class="p">&gt;</span> <span class="o">:=</span> <span class="nv">$&lt;entries&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
        <span class="k">for</span> <span class="nv">$&lt;section&gt;</span> <span class="k">-&gt;</span> <span class="nv">$sec</span> <span class="p">{</span>
            <span class="nv">%result</span><span class="p">{</span><span class="nv">$sec</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;}</span> <span class="o">:=</span> <span class="nv">$sec</span><span class="p">&lt;</span><span class="s">entries</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">make</span> <span class="nv">%result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$m</span> <span class="o">:=</span> <span class="n">INIFile::Grammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="k">Q</span><span class="p">{</span><span class="s">
</span><span class="s">name = Animal Facts
</span><span class="s">author = jnthn
</span><span class="s">
</span><span class="s">[cat]
</span><span class="s">desc = The smartest and cutest
</span><span class="s">cuteness = 100000
</span><span class="s">
</span><span class="s">[dugong]
</span><span class="s">desc = The cow of the sea
</span><span class="s">cuteness = -10
</span><span class="s">
</span><span class="s">[magpie]
</span><span class="s">desc = crow; raven; rook; jackdaw; chough; magpie; jay
</span><span class="s">cuteness = 99
</span><span class="s"></span><span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">INIFileActions</span><span class="p">));</span>

<span class="k">my</span> <span class="nv">%sections</span> <span class="o">:=</span> <span class="nv">$m</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">%sections</span> <span class="k">-&gt;</span> <span class="nv">$sec</span> <span class="p">{</span>
    <span class="nb">say</span><span class="p">(&#34;</span><span class="s2">章节: </span><span class="p">{</span><span class="nv">$sec</span><span class="o">.</span><span class="nb">key</span><span class="p">}&#34;);</span>
    <span class="k">for</span> <span class="nv">$sec</span><span class="o">.</span><span class="nb">value</span> <span class="k">-&gt;</span> <span class="nv">$entry</span> <span class="p">{</span>
        <span class="nb">say</span><span class="p">(&#34;</span><span class="s2">    </span><span class="p">{</span><span class="nv">$entry</span><span class="o">.</span><span class="nb">key</span><span class="p">}</span><span class="s2">: </span><span class="p">{</span><span class="nv">$entry</span><span class="o">.</span><span class="nb">value</span><span class="p">}&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>make</code> 是一个函数, 接收单个参数, <code>make</code> 的作用是, 对于每一个 <code>method</code> 中对应的 <code>$_</code> , 存储生成的抽象语法树(AST)(片段)到 <code>$/</code> 中。<code>.ast</code> 用于从已保存的 AST 抽象语法树中检索提取 AST (片段), <code>»</code> 相当于一个循环, 即检索每一个 <code>$&lt;entry&gt;</code> 之类的语法树。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">INIFile::Grammar</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="ni">^</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">section</span><span class="p">&gt;</span><span class="o">+</span><span class="sr">    </span><span class="c1"># 章节
</span><span class="c1"></span><span class="sr">        </span><span class="ni">$</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">section</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="c1"># [key] 这一行是可选的
</span><span class="c1"></span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">entries</span><span class="p">&gt;</span><span class="sr">                 </span><span class="c1"># 每个章节含有多个条目 entry
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">entries</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">entry</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="c1"># entry 可以为空
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">entry</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">key</span>     <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                       </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">value</span>   <span class="p">{</span><span class="sr"> </span><span class="se">\N</span><span class="o">+</span><span class="sr">                       </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">INIFileActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nb">key</span>    <span class="p">(</span><span class="nv">$/</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span>                                 <span class="p">}</span>
    <span class="k">method</span> <span class="nb">value</span>  <span class="p">(</span><span class="nv">$/</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="o">~</span><span class="nv">$/</span>                                 <span class="p">}</span>
    <span class="k">method</span> <span class="nf">entry</span>  <span class="p">(</span><span class="nv">$/</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;key&gt;</span><span class="o">.</span><span class="s">ast</span> <span class="o">=&gt;</span> <span class="nv">$&lt;value&gt;</span><span class="o">.</span><span class="nb">ast</span>          <span class="p">}</span>
    <span class="k">method</span> <span class="nf">entries</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;entry&gt;</span><span class="o">».</span><span class="nb">ast</span>                       <span class="p">}</span>
    <span class="k">method</span> <span class="nf">section</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;key&gt;</span><span class="o">.</span><span class="nb">ast</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">_</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="nv">$&lt;entries&gt;</span><span class="o">.</span><span class="nb">ast</span> <span class="p">}</span> <span class="c1"># 如果 key 不存在就默认为 `_`</span>

    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;section&gt;</span><span class="o">».</span><span class="nb">ast</span><span class="p">;</span>  <span class="c1"># 等价于 $/.make($&lt;section&gt;».ast);</span>
        <span class="c1"># &#39;-&#39; =&gt; $&lt;entries&gt;.ast    # &#39;_&#39; 没有 ast 方法</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$m</span> <span class="o">=</span> <span class="n">INIFile::Grammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="k">Q</span><span class="p">{</span><span class="s">
</span><span class="s">name = Animal Facts
</span><span class="s">author = jnthn
</span><span class="s">
</span><span class="s">[cat]
</span><span class="s">desc = The smartest and cutest
</span><span class="s">cuteness = 100000
</span><span class="s">
</span><span class="s">[dugong]
</span><span class="s">desc = The cow of the sea
</span><span class="s">cuteness = -10
</span><span class="s">
</span><span class="s">[magpie]
</span><span class="s">desc = crow; raven; rook; jackdaw; chough; magpie; jay
</span><span class="s">cuteness = 99
</span><span class="s"></span><span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="n">INIFileActions</span><span class="p">))</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@$m</span> <span class="k">-&gt;</span> <span class="nv">$sec</span> <span class="p">{</span>
    <span class="nb">say</span><span class="p">(&#34;</span><span class="s2">章节: </span><span class="p">{</span><span class="nv">$sec</span><span class="o">.</span><span class="nb">key</span><span class="p">}&#34;);</span>

    <span class="k">for</span> <span class="nv">$sec</span><span class="o">.</span><span class="nb">value</span> <span class="k">-&gt;</span> <span class="nv">$entry</span> <span class="p">{</span>
        <span class="nb">say</span><span class="p">(&#34;</span><span class="s2">    </span><span class="p">{</span><span class="nv">$entry</span><span class="o">.</span><span class="nb">key</span><span class="p">}</span><span class="s2">: </span><span class="p">{</span><span class="nv">$entry</span><span class="o">.</span><span class="nb">value</span><span class="p">}&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Grammar 的解析是从上至下的, 从 top-level (<code>TOP</code>) 开始, 到分支(branch)。Actions 中的方法是随着解析而执行的, 但是抽象语法树(AST) 的存储和检索是自下而上的, 只有底部的存储完了, 其上层部分才可以使用 <code>.ast</code> 或 <code>.made</code> 方法进行检索, 检索到之后各自进行处理后再次存储, 以供它的上层部分使用, 以此类推。</p>
<p>注意, 第一段代码中 <code>$m</code> 存储的死散列, 而第二段代码中, <code>$m</code> 存储的是数组! 这说明可以返回散列和数组两种形式。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/actions" term="actions" label="actions" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/ast" term="ast" label="ast" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 Subscripts]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-06-01-accessing-data-structure-elements-by-index-or-key/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-06-01-accessing-data-structure-elements-by-index-or-key/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-13T00:00:00+08:00</published>
            <updated>2021-07-13T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Accessing Data Structure Elements by Index or Key</blockquote><h1 id="subscriptshttpsdocsrakuorglanguagesubscripts"><a href="https://docs.raku.org/language/subscripts">Subscripts</a></h1>
<p>通过索引或键访问数据结构中的元素。</p>
<p>通常, 人们需要引用集合或数据结构中的一个特定的元素(或特定的元素切片)。从数学标记法中偷学到的, 向量 <code>v</code> 的组成部分用 <em>v₁, v₂, v₃</em> 来引用, 在 Raku 中这个概念叫做 “下标” (或“索引”)。</p>
<h1 id="basics">Basics</h1>
<p>Raku 提供了两个通用的下标接口：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">elements are identified by</th>
<th style="text-align:left">interface name</th>
<th style="text-align:left">supported by</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">[ ]</td>
<td style="text-align:left">zero-based indices</td>
<td style="text-align:left">Positional</td>
<td style="text-align:left">Array, List, Buf, Match, &hellip;</td>
</tr>
<tr>
<td style="text-align:left">{ }</td>
<td style="text-align:left">string or object keys</td>
<td style="text-align:left">Associative</td>
<td style="text-align:left">Hash, Bag, Mix, Match, &hellip;</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Positional</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_%5B_%5D">postcircumfix <input disabled="" type="checkbox"> </a> 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素, 索引 1 引用第二个元素, 以此类推：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@chores</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">buy groceries</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">feed dog</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">wash car</span><span class="p">&#34;;</span>

<span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># buy groceries</span>
<span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># feed dog</span>
<span class="nb">say</span> <span class="nv">@chores</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># wash car</span>
</code></pre></div><ul>
<li><strong>Associative</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_%7B_%7D">postcircumfix { }</a>), 不要求集合以任何特定的顺序保存元素 - 相反, 它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子, 一个标准的<a href="http://doc.raku.org/type/Hash">散列</a> 使用字符串作为键, 而一个 <a href="http://doc.raku.org/type/Mix">Mix</a> 能使用任意的对象作为键, 等等:</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%grade</span> <span class="o">=</span> <span class="s">Zoe</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">C</span><span class="p">&#34;</span>, <span class="s">Ben</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">B+</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%grade</span><span class="p">{&#34;</span><span class="s2">Zoe</span><span class="p">&#34;};</span>  <span class="c1"># C</span>
<span class="nb">say</span> <span class="nv">%grade</span><span class="p">{&#34;</span><span class="s2">Ben</span><span class="p">&#34;};</span>  <span class="c1"># B+</span>

<span class="k">my</span> <span class="nv">$stats</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">Date</span><span class="o">.</span><span class="s">today</span> <span class="o">=&gt;</span> <span class="mf">4.18</span>, <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mf">17.253</span> <span class="p">)</span><span class="o">.</span><span class="nb">Mix</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$stats</span><span class="p">{</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">};</span>  <span class="c1"># 17.253</span>
</code></pre></div><p>相对于传递单个-单词字符串键给 <code>{ }</code>, 你也可以使用<a href="http://doc.raku.org/language/quoting#Word_quoting:_qw">以尖括号引起单词的结构</a>, 就像它们是后缀操作符一样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Zoe</span><span class="p">&gt;;</span>    <span class="c1"># C</span>
<span class="nb">say</span> <span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Ben</span><span class="p">&gt;;</span>    <span class="c1"># B+</span>
</code></pre></div><p>这实际上仅仅是在编译时被转换为对应 <code>{ }</code> 形式的语法糖：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span><span class="p">&lt;</span><span class="s">foo bar</span><span class="p">&gt;;</span>     <span class="c1"># same as %hash{ &lt;foo bar&gt; }</span>
<span class="nv">%hash</span><span class="p">«</span><span class="s2">foo </span><span class="nv">$var</span><span class="p">»;</span>    <span class="c1"># same as %hash{ «foo $var» }</span>
<span class="nv">%hash</span><span class="p">&lt;&lt;</span><span class="s2">foo </span><span class="nv">$var</span><span class="p">&gt;&gt;;</span>  <span class="c1"># same as %hash{ &lt;&lt;foo $var&gt;&gt; }</span>
</code></pre></div><p>下标能应用到能返回可下标化对象的任何表达式上, 而不仅仅应用到变量上：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">__Hello__</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">__</span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr">__</span><span class="p">/)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># ｢Hello｣</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">__Hello__</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">__</span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr">__</span><span class="p">/)</span><span class="o">.[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># same, in method notation</span>
</code></pre></div><p>Positional 和 associative 下标并不互相排斥 - 举个例子, <code>Match</code> 对象两个都支持(每个访问不同的数据集)。还有, 为了让列表处理更方便, 类 <code>Any</code> 为位置下标提供了备用的实现, 这会把调用者看作含有一个元素的列表。(但是对于关系下标, 没有这样的备用实现, 所以会抛出一个异常, 当下标被应用到没有实现支持的对象上时。)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">42</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 42</span>
<span class="nb">say</span> <span class="mi">42</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1"># ERROR: postcircumfix { } not defined for type Int</span>
</code></pre></div><h1 id="nonexistent-elements">Nonexistent elements</h1>
<p>当通过下标寻址一个不存在的元素所发生的事情取决于正在使用的集合类型。标准的 Array 和 Hash 集合返回它们的<a href="http://doc.raku.org/routine/of">value type constraint</a>  的类型对象(这默认是 <code>Any</code>)。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array1</span><span class="p">;</span>     <span class="nb">say</span> <span class="nv">@array1</span><span class="o">[</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (Any)</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">@array2</span><span class="p">;</span> <span class="nb">say</span> <span class="nv">@array2</span><span class="o">[</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (Int)</span>

<span class="k">my</span> <span class="nv">%hash1</span><span class="p">;</span>      <span class="nb">say</span> <span class="nv">%hash1</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1"># (Any)</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">%hash2</span><span class="p">;</span>  <span class="nb">say</span> <span class="nv">%hash2</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1"># (Int)</span>
</code></pre></div><p>然而, 其它类型的集合可能在寻址不存在的元素的下标时反应也不用：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="p">)</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>       <span class="c1"># Nil</span>
<span class="nb">say</span> <span class="nb">bag</span><span class="p">(&lt;</span><span class="s">a a b b b</span><span class="p">&gt;)&lt;</span><span class="s">c</span><span class="p">&gt;;</span>  <span class="c1"># 0</span>
</code></pre></div><p>为了在下标操作中默默地跳过不存在的元素, 查看 <a href="http://doc.raku.org/language/subscripts#Truncating_slices">#Truncating slices</a>  和 <a href="http://doc.raku.org/language/subscripts#%3Av"><code>#:v</code></a> 副词。</p>
<h1 id="from-the-end">From the end</h1>
<p>Positional 索引是从集合的开头计数的, 但是也有一种标记法用于, 通过相对于末尾的位置来寻址元素：<code>*-1</code> 引用最后一个元素, <code>*-2</code> 引用倒数第二个元素, 以此类推。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Z</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Y</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># X</span>
</code></pre></div><p>注意：星号很重要。在 Raku 中, 如果像在很多其它编程语言中那样传递一个裸的负整数(例如 <code>@alphabet[-1]</code>), 会抛出错误。</p>
<p>这里实际发生的是, <code>*-1</code> 那样的表达式通过 <a href="http://doc.raku.org/type/Whatever">Whatever</a> 柯里化声明了一个代码对象 - <code>[ ]</code> 会把代码对象作为索引, 通过集合的长度作为参数来调用它并使用结果值作为实际的索引。换句话说, <code>@alphabet[*-1]</code> 变成了 <code>@alphabet[@alphabet.elems - 1]</code>。</p>
<p>这意味着你可以使用任何依赖于集合尺寸的表达式：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[*</span> <span class="ow">div</span> <span class="mi">2</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 选择最中间的那个元素</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span><span class="nv">$i</span> <span class="nv">%</span> <span class="o">*]</span><span class="p">;</span>   <span class="c1"># wrap around a given index (&#34;模运算&#34;)</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span> <span class="k">-&gt;</span> <span class="nv">$size</span> <span class="p">{</span> <span class="nv">$i</span> <span class="nv">%</span> <span class="nv">$size</span> <span class="p">}</span> <span class="o">]</span><span class="p">;</span>  <span class="c1"># same as previous</span>
</code></pre></div><h1 id="slices">Slices</h1>
<p>当需要访问集合中的多个元素时, 有一个快捷方式用于处理多个单独的下标操作：仅仅在下标中指定一个索引/键的列表, 来取回一个元素的列表 - 也被叫做&quot;切片&quot; - 以相同的顺序。</p>
<p>对于 positional 切片, 你可以混合普通切片和 <a href="http://doc.raku.org/language/subscripts#From_the_end">from-the-end</a> 切片：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>
<span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">*-</span><span class="mi">9</span><span class="o">,</span> <span class="mi">11</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (&#34;p&#34;, &#34;e&#34;, &#34;r&#34;, &#34;l&#34;)</span>
</code></pre></div><p>对于 associative 切片, 尖括号形式的切片通常会很方便：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>

<span class="n">dd</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;};</span>  <span class="c1"># (&#34;red&#34;, &#34;green&#34;)</span>
<span class="n">dd</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">cherry kiwi</span><span class="p">&gt;;</span>       <span class="c1"># (&#34;red&#34;, &#34;green&#34;)</span>
<span class="n">dd</span> <span class="nv">%color</span><span class="p">{</span><span class="o">*</span><span class="p">};</span>                 <span class="c1"># (&#34;green&#34;, &#34;red&#34;, &#34;yellow&#34;)</span>
</code></pre></div><p>要知道切片是由传入 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">one dimension of</a>)下标的类型控制的, 而非它的长度：</p>
<table>
<thead>
<tr>
<th style="text-align:left">subscript</th>
<th style="text-align:left">result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">any Positional object not covered below</td>
<td style="text-align:left">normal slice</td>
</tr>
<tr>
<td style="text-align:left">a Range or infinite sequence</td>
<td style="text-align:left">truncating slice (only for positional subscripts)</td>
</tr>
<tr>
<td style="text-align:left">* (Whatever-star)</td>
<td style="text-align:left">full slice (as if all keys/indices were specified)</td>
</tr>
<tr>
<td style="text-align:left">any other object</td>
<td style="text-align:left">single-element access rather than a slice</td>
</tr>
<tr>
<td style="text-align:left">empty</td>
<td style="text-align:left">Zen slice</td>
</tr>
</tbody>
</table>
<p>所以, 即使一个单个元素的列表也会返回一个切片, 而一个裸的标量值不会：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">2</span><span class="o">,]</span><span class="p">;</span>  <span class="c1"># (&#34;c&#34;,)</span>
<span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>   <span class="c1"># &#34;c&#34;</span>
</code></pre></div><p>(尖括号形式的 associative 下标也没有问题, 因为 <a href="http://doc.raku.org/language/quoting#Word_quoting:_qw">word quoting</a> 在单个单词的情况下很方便的返回一个 Str。</p>
<p>对于普通的切片, 下标的内容 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">the current dimension of</a>) 在它的元素被解释为索引/键之前会被展平(flattened)：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="p">)))</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;)</span>
</code></pre></div><h2 id="truncating-slices">Truncating slices</h2>
<p>通常, 在切片下标中引用不存在的元素会让输出列表包含未定义的值。然而, 如果传递给位置下标的对象是一个 Range 或使用序列操作符构建的无限序列, 它会被自动截断到集合的实际尺寸：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@letters</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f</span><span class="p">&gt;;</span>
<span class="n">dd</span> <span class="nv">@letters</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (&#34;d&#34;, &#34;e&#34;, &#34;f&#34;, Any, Any)</span>
<span class="n">dd</span> <span class="nv">@letters</span><span class="o">[</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">7</span><span class="o">]</span><span class="p">;</span>         <span class="c1"># (&#34;d&#34;, &#34;e&#34;, &#34;f&#34;)</span>
</code></pre></div><p><a href="http://doc.raku.org/language/subscripts#From_the_end">From-the-end</a> 索引被允许作为范围的端点, 代表无限的范围和序列：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">@array</span><span class="o">[*-</span><span class="mi">3</span> <span class="o">..</span> <span class="o">*]</span><span class="p">;</span>       <span class="c1"># select the last three elements</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*]</span><span class="p">;</span>  <span class="c1"># select all elements with even indices</span>
</code></pre></div><p>如果你不想把你的切片指定为 <code>range/sequence</code> 但仍旧想默默地跳过不存在的元素, 你可以使用 <a href="http://doc.raku.org/language/subscripts#%3Av">#:v</a> 副词。</p>
<h2 id="zen-slices">Zen slices</h2>
<p>如果你写的下标没有指定任何索引/键, 那它就会返回被脚注的对象自身。因为它是空的但是返回了全部东西, 这就是所谓的 &ldquo;Zen slice&rdquo;。</p>
<p>这和传递一个 Whatever-star, 还有传递一个空的列表都不同(它返回一个空的切片)：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%bag</span> <span class="o">:=</span> <span class="p">(&#34;</span><span class="s2">orange</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">apple</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">Bag</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="o">&lt;&gt;</span><span class="p">;</span>    <span class="c1"># (&#34;orange&#34;=&gt;1,&#34;apple&#34;=&gt;3).Bag</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="p">{};</span>    <span class="c1"># (&#34;orange&#34;=&gt;1,&#34;apple&#34;=&gt;3).Bag</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="p">{</span><span class="o">*</span><span class="p">};</span>   <span class="c1"># (1, 3)</span>
<span class="n">dd</span> <span class="nv">%bag</span><span class="p">{()};</span>  <span class="c1"># ()</span>
</code></pre></div><p>这通常被用于把整个数组/散列插值到字符串中：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">cruel</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">world</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, </span><span class="nv">@words</span><span class="o">[]</span><span class="s2">!</span><span class="p">&#34;</span>  <span class="c1"># Hello, cruel world!</span>
</code></pre></div><h1 id="autovivification">Autovivification</h1>
<p>下标参与 &ldquo;autovivification&rdquo;, 这是一种数组和散列在需要时会自动存在的处理, 以至于你没有必要在每一层级预声明集合的类型来构建嵌套的数据结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$beatles</span><span class="p">;</span>
<span class="nv">$beatles</span><span class="p">{&#34;</span><span class="s2">White Album</span><span class="p">&#34;}</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Back in the U.S.S.R.</span><span class="p">&#34;;</span>  <span class="c1"># autovivification!</span>
<span class="nb">say</span> <span class="nv">$beatles</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1"># {&#34;White Album&#34; =&gt; [&#34;Back in the U.S.S.R.&#34;]}</span>
</code></pre></div><p><code>$beatles</code> 从未定义开始, 但是它变成了一个 Hash 对象, 因为它在赋值时用 <code>{ }</code> 标注了。类似地, <code>$beatles{&quot;White Album”}</code> 变成一个 Array 对象, 因为它在赋值时用 <code>[ ]</code> 标注了。</p>
<p>注意下标本身不会引起 autovivification, 它只发生在下标链的结果被赋值时(或变化时)。</p>
<h1 id="binding">Binding</h1>
<p>下标表达式也可以用在绑定语句的左侧。如果被标注的集合的类型支持, 这会使用指定的容器替换集合里的插槽的值:</p>
<p>内置的 Array 和 Hash 类型支持这种绑定, 为了允许构建复杂的联动的数据结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">13</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>  <span class="c1"># binding! (@a[2] and $x refer to the same container now.)</span>

<span class="nv">$x</span><span class="o">++</span><span class="p">;</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">2</span><span class="o">]++</span><span class="p">;</span>

<span class="n">dd</span> <span class="nv">@a</span><span class="p">;</span>  <span class="c1"># [10, 11, 3, 13]&lt;&gt;</span>
<span class="n">dd</span> <span class="nv">$x</span><span class="p">;</span>  <span class="c1"># 3</span>
</code></pre></div><p>查看 <a href="http://doc.raku.org/language/subscripts#method_BIND-POS">#method BIND-POS</a> 和 <a href="http://doc.raku.org/language/subscripts#method_BIND-KEY">#method BIND-KEY</a> 了解底层机制.</p>
<h1 id="adverbs">Adverbs</h1>
<p>下标操作的返回值和可能存在的副作用能够使用副词来控制。</p>
<p>要知道副词操作符的优先级相对宽松, 这可能需要你在合成表达式中添加括号：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$foo</span> <span class="o">||</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>    <span class="c1"># WRONG, tries to adverb the || op</span>
<span class="k">if</span> <span class="nv">$foo</span> <span class="o">||</span> <span class="p">(</span><span class="nv">%hash</span><span class="p">&lt;</span><span class="s">key</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>  <span class="c1"># correct</span>
</code></pre></div><p>支持的副词有:</p>
<h2 id="exists">:exists</h2>
<p>返回请求的元素是否存在, 而不是返回元素实际的值。这能够用于区别未定义值的元素和一点儿也不属于集合部分的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="nb">Any</span><span class="o">,</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">defined</span><span class="p">;</span>    <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>     <span class="c1"># True</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>     <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">@foo</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1"># (True, False)</span>

<span class="k">my</span> <span class="nv">%fruit</span> <span class="o">=</span> <span class="s">apple</span> <span class="o">=&gt;</span> <span class="nb">Any</span>, <span class="s">orange</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>       <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>        <span class="c1"># True</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">banana</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>       <span class="c1"># False</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple banana</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span> <span class="c1"># (True, False)</span>
</code></pre></div><p>也可以对副词取反来测试不存在：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple banana</span><span class="p">&gt;:!</span><span class="s">exists</span><span class="p">;</span> <span class="c1"># (False, True)</span>
</code></pre></div><p>要检查切片的所有元素是否存在, 使用 <a href="http://doc.raku.org/routine/all">all</a> junction:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">all</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple orange banana</span><span class="p">&gt;:</span><span class="s">exists</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p><code>:exists</code> 可以和  <a href="http://doc.raku.org/language/subscripts#%3Adelete">:delete</a> 还有 <code>:p/:kv</code> 副词组合 - 这时表达式的行为就由那些副词决定, 除了使用表明元素存在的对应 Bool 值替换返回的元素值之外。</p>
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-POS">method EXISTS-POS</a> 和 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-KEY">method EXISTS-KEY</a> 了解底层机制.</p>
<h2 id="delete">:delete</h2>
<p>从集合中删除元素, 除了返回它们的值以外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">:</span><span class="s">delete</span><span class="p">;</span>     <span class="c1"># 30</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="p">;</span>               <span class="c1"># [0, 10, 20]&lt;&gt;</span>

<span class="k">my</span> <span class="nv">%fruit</span> <span class="o">=</span> <span class="s">apple</span> <span class="o">=&gt;</span> <span class="mi">5</span>, <span class="s">orange</span> <span class="o">=&gt;</span> <span class="mi">10</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">peach</span> <span class="o">=&gt;</span> <span class="mi">17</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;:</span><span class="s">delete</span><span class="p">;</span>         <span class="c1"># 5</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">peach orange</span><span class="p">&gt;:</span><span class="s">delete</span><span class="p">;</span>  <span class="c1"># (17, 10)</span>
<span class="n">dd</span> <span class="nv">%fruit</span><span class="p">;</span>                       <span class="c1"># {banana =&gt; 4}&lt;&gt;</span>
</code></pre></div><p>使用否定形式的副词, 元素实际上不会被删除。这意味着你可以传递一个标记, 让它变成有条件的删除：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%fruit</span><span class="p">&lt;</span><span class="s">apple</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">delete</span><span class="p">(</span><span class="nv">$flag</span><span class="p">);</span>  <span class="c1"># deletes the element only if $flag is</span>
                                  <span class="c1"># true, but always returns the value.</span>
</code></pre></div><p>能和 <code>:exists</code> 还有 <code>:p/:kv/:k/:v</code> 副词组合 - 这时返回值由那些副词决定, 但是同时元素也会被删除。</p>
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_DELETE-POS">method DELETE-POS</a> and <a href="http://doc.raku.org/language/subscripts#method_DELETE-KEY">method DELETE-KEY</a> 了解底层机制.</p>
<h2 id="p">:p</h2>
<p>以 Pair 的形式, 返回元素的索引/键和元素值, 并默默跳过不存在的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">p</span><span class="p">;</span>        <span class="c1"># 1 =&gt; 10</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">p</span><span class="p">;</span>  <span class="c1"># (0 =&gt; 0, 2 =&gt; 20)</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">p</span><span class="p">;</span>          <span class="c1"># &#34;Feb&#34; =&gt; 2</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">p</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34; =&gt; 1, &#34;Mar&#34; =&gt; 3)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">p</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34; =&gt; 1, &#34;Foo&#34; =&gt; Any, &#34;Mar&#34; =&gt; 3)</span>
</code></pre></div><p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看 <a href="http://doc.raku.org/routine/pairs">pairs</a> 子例程.</p>
<h2 id="kv">:kv</h2>
<p>以列表的形式返回元素的索引/键和值, 并默默地跳过不存在的元素。当作用在切片上时, 返回值是一个展平的键和值交叉着的单个列表：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">kv</span><span class="p">;</span>        <span class="c1"># (1, 10)</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">kv</span><span class="p">;</span>  <span class="c1"># (0, 0, 2, 20)</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">kv</span><span class="p">;</span>          <span class="c1"># (&#34;Feb&#34;, 2)</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">kv</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, 1, &#34;Mar&#34;, 3)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">kv</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, 1, &#34;Foo&#34;, Any, &#34;Mar&#34;, 3)</span>
</code></pre></div><p>这个副词一般用于遍历切片：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb Mar</span><span class="p">&gt;:</span><span class="s">kv</span> <span class="k">-&gt;</span> <span class="nv">$month</span><span class="o">,</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$month</span><span class="s2"> had </span><span class="p">{</span><span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2015</span><span class="o">,</span> <span class="nv">$i</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">days-in-month</span><span class="p">}</span><span class="s2"> days in 2015</span><span class="p">&#34;</span>
<span class="p">}</span>
</code></pre></div><p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
<p>也可以查看  <a href="http://doc.raku.org/routine/kv">kv</a> 子例程.</p>
<h2 id="k">:k</h2>
<p>只返回元素的索引/键, 而不是它们的值, 并默默地跳过不存在的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">k</span><span class="p">;</span>        <span class="c1"># 1</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">k</span><span class="p">;</span>  <span class="c1"># (0, 2)</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">k</span><span class="p">;</span>          <span class="c1"># &#34;Feb&#34;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">k</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, &#34;Mar&#34;)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">k</span><span class="p">;</span>  <span class="c1"># (&#34;Jan&#34;, &#34;Foo&#34;, &#34;Mar&#34;)</span>
</code></pre></div><p>还可以查看 <a href="http://doc.raku.org/routine/keys">keys</a> 子例程.</p>
<h2 id="v">:v</h2>
<p>返回元素的裸值(不是有可能返回一个可变值容器), 并默默跳过不存在的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@tens</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">:</span><span class="s">v</span><span class="p">;</span>        <span class="c1"># 10</span>
<span class="n">dd</span> <span class="nv">@tens</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span><span class="p">:</span><span class="s">v</span><span class="p">;</span>  <span class="c1"># (0, 20)</span>
<span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>        <span class="c1"># OK</span>
<span class="nv">@tens</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">:</span><span class="s">v</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>      <span class="c1"># ERROR, cannot assign to immutable integer value</span>

<span class="k">my</span> <span class="nv">%month</span> <span class="o">=</span> <span class="s">Jan</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">Feb</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">Mar</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Feb</span><span class="p">&gt;:</span><span class="s">v</span><span class="p">;</span>          <span class="c1"># 2</span>
<span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:</span><span class="s">v</span><span class="p">;</span>  <span class="c1"># (1, 3)</span>
</code></pre></div><p>如果你不想跳过不存在的元素, 使用否定形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dd</span> <span class="nv">%month</span><span class="p">&lt;</span><span class="s">Jan Foo Mar</span><span class="p">&gt;:!</span><span class="s">v</span><span class="p">;</span>  <span class="c1"># (1, Any, 3)</span>
</code></pre></div><p>还可以查看  <a href="http://doc.raku.org/routine/values">values</a> 子例程.</p>
<h1 id="custom-types">Custom types</h1>
<p>这页描述的下标接口并不意味着和 Raku 的内置集合类型相排斥 - 你可以(并且应该)为任何想通过索引或键提供数据访问的自定义类型重用它们。</p>
<p>你不必手动重载 <a href="http://doc.raku.org/routine/%5B%20%5D#postcircumfix_%5B_%5D">postcircumfix [ ]</a> 和  <a href="http://doc.raku.org/">postcircumfix { }</a> 操作符并重新实现它们所有的戏法, 为了实现它, 相反, 你可以依赖这个事实, 在幕后, 它们的标准实现分派给了一个定义良好的底层方法集。例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">当你这样写</th>
<th style="text-align:left">这会在幕后调用如下底层方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%foo<!-- raw HTML omitted --></td>
<td style="text-align:left">%foo.AT-KEY(&ldquo;aa&rdquo;)</td>
</tr>
<tr>
<td style="text-align:left">%foo<!-- raw HTML omitted -->:delete</td>
<td style="text-align:left">%foo.DELETE-KEY(&ldquo;aa&rdquo;)</td>
</tr>
<tr>
<td style="text-align:left">@foo[3,4,5]</td>
<td style="text-align:left">@foo.AT-POS(3), @foo.AT-POS(4), @foo.AT-POS(5)</td>
</tr>
<tr>
<td style="text-align:left">@foo[*-1]</td>
<td style="text-align:left">@foo.AT-POS(@foo.elems - 1)</td>
</tr>
</tbody>
</table>
<p>所以, 为了让你的下标工作, 你只需要为你的自定义类型实现或委托那些底层方法(<a href="http://doc.raku.org/language/subscripts#Methods_to_implement_for_positional_subscripting">下面描述详情</a>)。</p>
<p>如果你这样做了, 你还应该让你的类型各自遵守 <a href="http://doc.raku.org/type/Positional">Positional</a> 或 <a href="http://doc.raku.org/type/Associative">Associative</a> role</p>
<h2 id="custom-type-example">Custom type example</h2>
<p>设想一下 <code>HTTP::Header</code> 类型, 尽管它作为一个有特定行为的自定义类, 却能像散列那样索引：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$request</span> <span class="o">=</span> <span class="n">HTTP::Request</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">GET</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">raku.org</span><span class="p">&#34;);</span>
<span class="nb">say</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>  <span class="c1"># (HTTP::Header)</span>

<span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">&lt;</span><span class="s">Accept</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">text/plain</span><span class="p">&#34;;</span>
<span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">{&#39;</span><span class="s1">Accept-</span><span class="p">&#39;</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">Charset Encoding Language</span><span class="p">&gt;}</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">utf-8 gzip en</span><span class="p">&gt;;</span>
<span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">Accept-Language</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">fr</span><span class="p">&#34;);</span>  <span class="c1"># like .push on a Hash</span>

<span class="nb">say</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="p">&lt;</span><span class="s">Accept-Language</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>  <span class="c1"># [&#34;en&#34;, &#34;fr&#34;]</span>

<span class="k">my</span> <span class="nv">$rawheader</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">.</span><span class="nf">header</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>  <span class="c1"># stringify according to HTTP spec</span>
</code></pre></div><p>实现这个类的最简单的方法是, 给它一个 Hash 类型的属性, 并把所有的下标和迭代相关功能性委托给那个属性。(使用一个自定义类型约束来确保使用者不会在里面插入任何不合法的值)：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">HTTP::Header</span> <span class="k">does</span> <span class="nb">Associative</span> <span class="k">is</span> <span class="nb">Iterable</span> <span class="p">{</span>
    <span class="k">subset</span> <span class="nc">StrOrArrayOfStr</span> <span class="k">where</span> <span class="nb">Str</span> <span class="o">|</span> <span class="p">(</span> <span class="nb">Array</span> <span class="o">&amp;</span> <span class="p">{</span><span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="nb">Str</span><span class="p">}</span> <span class="p">);</span>

    <span class="k">has</span> <span class="nv">%!fields</span> <span class="k">of</span> <span class="nc">StrOrArrayOfStr</span>
                 <span class="nb">handles</span> <span class="p">&lt;</span><span class="s">AT-KEY EXISTS-KEY DELETE-KEY push
</span><span class="s">                          iterator list kv keys values</span><span class="p">&gt;;</span>

    <span class="k">method</span> <span class="nb">Str</span> <span class="p">{</span> <span class="cm">#`[not shown, for brevity]</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然而, HTTP header 字段名被认为是大小写无关的(更偏好驼峰法)。我们可以通过把 <code>*-key</code> 和 <code>push</code> 方法拿到 <code>handles</code> 列表的外面来容纳它, 并像这样各自实现它们：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">AT-KEY</span>     <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}</span>        <span class="p">}</span>
<span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">exists</span> <span class="p">}</span>
<span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">delete</span> <span class="p">}</span>
<span class="k">method</span> <span class="nb">push</span> <span class="p">(</span><span class="o">*</span><span class="nv">@_</span><span class="p">)</span> <span class="p">{</span> <span class="cm">#`[not shown, for brevity]</span> <span class="p">}</span>

<span class="k">sub</span> <span class="nf">normalize-key</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$key</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/</span><span class="o">,</span> <span class="o">*.</span><span class="nb">tc</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>注意下标  <code>%!fields</code> 返回一个适当的 rw 容器, 而我们的 <code>AT-KEY</code> 能够简单地传递。</p>
<p>然而, 我们可能倾向于少一点对用户输入的限制, 相反我们自己关心字段值的消毒。那种情况下, 我们可以移除 <code>%!fields</code> 上的 <code>StrOrArrayOfStr</code> 类型约束, 并在赋值时使用返回自定义的关心消毒值的 Proxy 容器来替换我们的 <code>AT-KEY</code> 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$element</span> <span class="o">:=</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">};</span>

    <span class="nb">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
        <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">()</span> <span class="p">{</span> <span class="nv">$element</span> <span class="p">}</span>,

        <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$element</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">given</span> <span class="nv">$value</span><span class="o">».</span><span class="nb">split</span><span class="p">(/&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span>
                <span class="k">when</span> <span class="mi">1</span>  <span class="p">{</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>    <span class="c1"># a single value is stored as a string</span>
                <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Array</span> <span class="p">}</span>  <span class="c1"># multiple values are stored as an array</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>注意把方法声明为 <code>multi</code> 并把它限制为 <code>:D</code> (defined invocants) 确保未定义情况被传递给由 Any 提供的默认实现。</p>
<h2 id="methods-to-implement-for-positional-subscripting">Methods to implement for positional subscripting</h2>
<p>为了通过 <a href="http://doc.raku.org/routine/%5B%20%5D#postcircumfix_%5B_%5D">postcircumfix [ ]</a> 让基于索引的下标在你的自定义类型中工作, 你应该至少实现下面的 <code>elems</code>, <code>AT-POS</code> 和 <code>EXISTS-POS-</code> 还有其它可选项。</p>
<h3 id="elems-方法">elems 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">elems</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>预期返回一个数字, 用于表明对象中有多少个可标注的元素。可能被用户直接调用, 并且当从末尾索引元素的时候, 还会被  <code>postcircumfix [ ]</code> 调用, 就像 <code>@foo[*-1]</code> 中那样。</p>
<p>如果没有实现这个方法, 你的类型会从 Any 继承默认的实现, 对定义过的调用者这总是返回 1 - 这最不可能是你想要的。所以, 如果不能从你的位置类型知晓元素的个数, 那就添加一个 fails 或 dies 实现, 以避免沉默地做了错事。</p>
<h3 id="at-pos-方法">AT-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</code></pre></div><p>期望返回 <code>$index</code> 位置处的元素。这就是 <code>postcircumfix [ ]</code> 通常调用的方法。
如果你想让元素可变(像它们用于 Array 类型那样), 你就必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>rw</code> 子例程 trait 以使它工作。)</p>
<h3 id="exists-pos-方法">EXISTS-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</code></pre></div><p>返回一个布尔值以表明在 <code>$index</code> 位置处是否有元素。这就是引用 <code>@foo[42]:exists</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>元素&quot;存在&quot;意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 对于索引 0 它会返回 True, 对于 其它索引它会返回 <code>false</code> - 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情。</p>
<h3 id="delete-pos-方法">DELETE-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="p">)</span>
</code></pre></div><p>删除 <code>$index</code> 处的元素, 并返回它所删除的这个元素。这就是引用 <code>@foo[42]:delete</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
<p>&ldquo;删除&quot;元素的意思是什么, 取决于你的类型。</p>
<p>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="assign-pos-方法">ASSIGN-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">ASSIGN-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="o">,</span> <span class="nv">$new</span><span class="p">)</span>
</code></pre></div><p>把 <code>$index</code> 位置处的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-POS($index) = $new</code> 代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>@numbers[5] = &quot;five&quot;</code> 的赋值能在不调用 <code>AT-POS</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-POS</code> 不能解除让 <code>AT-POS</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>@numbers[5]++</code> 的不太重要的赋值/修改仍旧会使用 <code>AT-POS</code>。</p>
<h3 id="bind-pos-方法">BIND-POS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">BIND-POS</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$index</span><span class="o">,</span> \<span class="nb">new</span><span class="p">)</span>
</code></pre></div><p>把值或容器 <code>new</code> 绑定给位置 <code>$index</code> 处的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nv">@numbers</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>
</code></pre></div><p>一般的数组类支持这以允许创建复杂的链接数据结构, 但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
<h2 id="methods-to-implement-for-associative-subscripting">Methods to implement for associative subscripting</h2>
<p>为了通过 <code>postcircumfix { }</code> 让基于键的下标能够工作于你的自定义类型中, 你应该至少实现 <code>AT-KEY</code> 和 <code>EXISTS-KEY</code> - 还有可选地实现下面的方法。</p>
<h3 id="at-key-方法">AT-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</code></pre></div><p>返回和 <code>$key</code> 相关联的元素。这正是 <code>postcircumfix { }</code> 通常所调用的方法。</p>
<p>如果你想让元素可变(就像它们是为了内置的 Hash 类型), 你必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>is rw</code> 子例程 trait 以使其有效; 查看例子。)</p>
<p>另一方面, 如果你想让你的集合只读, 请直接返回非容器值。</p>
<h3 id="exists-key-方法">EXISTS-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</code></pre></div><p>返回一个布尔值以表明和 <code>$key</code> 相关联的元素是否存在。这就是引用 <code>%foo&lt;aa&gt;:exists</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>元素&quot;存在&quot;意味着什么, 取决于你的类型。</p>
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 这通常返回 False - 这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情</p>
<h3 id="delete-key-方法">DELETE-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span>
</code></pre></div><p>删除和 <code>$key</code> 相关联的元素, 并返回它所删除的这个元素。这就是引用 <code>%foo&lt;aa&gt;:delete</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
<p>&ldquo;删除&quot;元素的意思是什么, 取决于你的类型 - 尽管它通常让 <code>EXISTS-KEY</code> 因为那个键变为 <code>False</code>。</p>
<p>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</p>
<h3 id="assign-key-方法">ASSIGN-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">ASSIGN-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$new</span><span class="p">)</span>
</code></pre></div><p>把和 <code>$key</code>  相关联的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-KEY($key) = $new</code> 代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>%age&lt;Claire&gt; = 29</code> 的赋值能在不调用 <code>AT-KEY</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
<p>注意, 实现 <code>ASSIGN-KEY</code> 不能解除让 <code>AT-KEY</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>%age&lt;Claire&gt;++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-KEY</code>。</p>
<h3 id="bind-key-方法">BIND-KEY 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">BIND-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="o">,</span> \<span class="nb">new</span><span class="p">)</span>
</code></pre></div><p>把值或容器 <code>new</code> 绑定给跟 <code>$key</code> 相关联的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nv">%age</span><span class="p">&lt;</span><span class="s">Claire</span><span class="p">&gt;</span> <span class="o">:=</span> <span class="nv">$x</span><span class="p">;</span>
</code></pre></div><p>一般的散列类支持这以允许创建复杂的链接数据结构, 但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/subscripts" term="subscripts" label="subscripts" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[买水果]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-04-12-janes-fruit/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-04-12-janes-fruit/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-13T00:00:00+08:00</published>
            <updated>2021-07-13T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Janes Fruit</blockquote><h2 id="问题描述">问题描述</h2>
<p>小詹妮拿着 5 美元去超市买东西,  为新搬来的邻居买水果篮礼物。因为她是个勤奋并缺乏想象力的孩纸, 她打算正好花 5 美元, 不多也不少。</p>
<p>事实上超市里水果的价格并非整数, 正好花光 5 美元并不容易。 - 但是詹妮已经准备好了。她从背包里拿出上网本, 输入她看到过的水果的单价, 并且开启了一个程序为她收集 — 就是这样, 5 美元能买的水果的组合就出现在屏幕上。</p>
<p>挑战: 用你选择的语言展示詹妮的程序是什么样子。</p>
<ul>
<li>目标就是 500 美分 (等于 5 美元)</li>
<li>解决方法可以包含多种同类型的水果 - 假设它们数量没有限制</li>
<li>解决方法没有必要包含所有水果类型</li>
<li>对给定的输入检测所有可能的方法</li>
</ul>
<h2 id="输入描述">输入描述</h2>
<p>每行一种水果 — 规定了水果的名字(不含空格的单词)和水果的单价(单位为美分, 整数)</p>
<h2 id="输出描述">输出描述</h2>
<p>每个解决方法一行 — 用以逗号分割的数量+名字对儿, 描述了那种类型要买的水果数。</p>
<p>不要列出数量为 0 的水果。如果为复数就给名字加 <strong>s</strong>。</p>
<h2 id="输入样本">输入样本</h2>
<pre><code>banana 32
kiwi 41
mango 97
papaya 254
pineapple 399
</code></pre><h2 id="输出样本">输出样本</h2>
<pre><code>6 kiwis, 1 papaya
7 bananas, 2 kiwis, 2 mangos
</code></pre><h2 id="有挑战的输入">有挑战的输入</h2>
<pre><code>apple 59
banana 32
coconut 155
grapefruit 128
jackfruit 1100
kiwi 41
lemon 70
mango 97
orange 73
papaya 254
pear 37
pineapple 399
watermelon 500
</code></pre><p>注意, 这种输入有 180 种解决方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">@names</span><span class="o">,</span> <span class="nv">@prices</span><span class="p">)</span> <span class="o">:=</span> <span class="p">(</span><span class="nv">$_</span><span class="o">»[</span><span class="mi">0</span><span class="o">],</span> <span class="nv">$_</span><span class="o">»[</span><span class="mi">1</span><span class="o">]».</span><span class="nb">Int</span> <span class="k">given</span> <span class="nb">lines</span><span class="o">».</span><span class="nb">words</span><span class="p">);</span>

<span class="k">for</span> <span class="nf">find-coefficients</span><span class="p">(</span><span class="mi">500</span><span class="o">,</span> <span class="nv">@prices</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">@quantities</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">@names</span> <span class="ow">Z</span> <span class="nv">@quantities</span><span class="p">)</span>
        <span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="k">-&gt;</span> <span class="o">[</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">$qty</span><span class="o">]</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$qty</span><span class="s2"> </span><span class="nv">$name</span><span class="p">&#34;</span><span class="o">~</span><span class="p">(&#34;</span><span class="s2">s</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$qty</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$qty</span> <span class="p">})</span>
        <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">, </span><span class="p">&#34;);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">find-coefficients</span> <span class="p">(</span><span class="nv">$goal</span><span class="o">,</span> <span class="nv">@terms</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">gather</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">@coefficients</span><span class="p">;</span>

        <span class="k">loop</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nv">@terms</span><span class="p">;</span> <span class="nv">@coefficients</span><span class="o">[</span><span class="nv">$i</span><span class="o">]++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">given</span> <span class="o">[+]</span><span class="p">(</span><span class="nv">@coefficients</span> <span class="ow">Z</span><span class="o">*</span> <span class="nv">@terms</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="nv">$goal</span> <span class="p">{</span>
                <span class="k">when</span> <span class="nb">Less</span> <span class="p">{</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span>                      <span class="p">}</span>
                <span class="k">when</span> <span class="nb">More</span> <span class="p">{</span> <span class="nv">@coefficients</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span> <span class="p">}</span>
                <span class="k">when</span> <span class="nb">Same</span> <span class="p">{</span> <span class="nb">take</span> <span class="nv">@coefficients</span><span class="o">.</span><span class="nb">values</span>   <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在循环的每一次迭代中，数组 <code>@coefficients</code> 被&quot;增一&quot;，就像它的元素是一个数字的位数一样 - 但不是一个有固定基数的数字：相反，只要超过了搜索条件（sum &gt; goal），它就会溢出&quot;数字&quot;。</p>
<p>同样的事情也可以用递归的方式更优雅地完成。对于那些不喜欢天真的暴力解决方法的人来说，这个挑战也可能是一个尝试一些<a href="https://en.wikipedia.org/wiki/Dynamic_programming">动态编程</a>技术的好机会。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@fruits</span> <span class="o">=</span> <span class="nb">lines</span><span class="o">».</span><span class="nb">split</span><span class="p">(&#34;</span><span class="s2"> </span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*[</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@names</span>  <span class="o">=</span> <span class="nv">@fruits</span><span class="o">»[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@prices</span> <span class="o">=</span> <span class="nv">@fruits</span><span class="o">»[</span><span class="mi">1</span><span class="o">]».</span><span class="nb">Int</span><span class="p">;</span>

<span class="k">for</span> <span class="nf">find-coefficients</span><span class="p">(</span><span class="mi">500</span><span class="o">,</span> <span class="nv">@prices</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">@quantities</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">@names</span> <span class="ow">Z</span> <span class="nv">@quantities</span><span class="p">)</span>
        <span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="k">-&gt;</span> <span class="o">[</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">$qty</span><span class="o">]</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$qty</span><span class="s2"> </span><span class="nv">$name</span><span class="p">&#34;</span><span class="o">~</span><span class="p">(&#34;</span><span class="s2">s</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$qty</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$qty</span> <span class="p">})</span>
        <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">, </span><span class="p">&#34;);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">find-coefficients</span> <span class="p">(</span><span class="nv">$goal</span><span class="o">,</span> <span class="nv">@terms</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">gather</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">@initial</span> <span class="o">=</span> <span class="mi">0</span> <span class="ow">xx</span> <span class="nv">@terms</span><span class="p">;</span>

        <span class="k">my</span> <span class="nv">%partials</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="nv">@initial</span><span class="o">,]</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">@todo</span> <span class="o">=</span> <span class="p">(</span><span class="nv">@initial</span><span class="o">,</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">%seen-partials</span> <span class="o">:=</span> <span class="nb">SetHash</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">%seen-solutions</span> <span class="o">:=</span> <span class="nb">SetHash</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>

        <span class="k">while</span> <span class="nv">@todo</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">@current</span> <span class="o">:=</span> <span class="nv">@todo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>
            <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="o">[+]</span> <span class="nv">@current</span> <span class="ow">Z</span><span class="o">*</span> <span class="nv">@terms</span><span class="p">;</span>

            <span class="nb">next</span> <span class="k">if</span> <span class="nv">$sum</span> <span class="o">&gt;</span> <span class="nv">$goal</span><span class="p">;</span>

            <span class="nv">%partials</span><span class="p">{</span><span class="nv">$sum</span><span class="p">}</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">@current</span><span class="p">;</span>

            <span class="c1"># Find solutions by adding known partials to the current partial</span>
            <span class="k">for</span> <span class="nv">%partials</span><span class="p">{</span><span class="nv">$goal</span> <span class="o">-</span> <span class="nv">$sum</span><span class="p">}</span><span class="o">[*]</span> <span class="k">-&gt;</span> <span class="nv">@known</span> <span class="p">{</span>
                <span class="o">.</span><span class="nb">take</span> <span class="k">if</span> <span class="o">!</span><span class="nv">%seen-solutions</span><span class="p">{</span><span class="o">~</span><span class="nv">$_</span><span class="p">}</span><span class="o">++</span> <span class="k">given</span> <span class="nb">list</span> <span class="nv">@current</span> <span class="ow">Z</span><span class="o">+</span> <span class="nv">@known</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1"># Schedule additional iterations</span>
            <span class="k">if</span> <span class="nv">$sum</span> <span class="o">&lt;=</span> <span class="nv">$goal</span> <span class="ow">div</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">for</span> <span class="nv">@terms</span><span class="o">.</span><span class="nb">keys</span> <span class="p">{</span>
                    <span class="k">my</span> <span class="nv">@next</span> <span class="o">=</span> <span class="nv">@current</span><span class="p">;</span>
                    <span class="nv">@next</span><span class="o">[</span><span class="nv">$_</span><span class="o">]++</span><span class="p">;</span>
                    <span class="nv">@todo</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">@next</span> <span class="k">if</span> <span class="o">!</span><span class="nv">%seen-partials</span><span class="p">{</span><span class="o">~</span><span class="nv">@next</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>注意:</p>
<ul>
<li>对于挑战的输入(解空间=1,127,153,664)，它只需要 4296 次迭代，而每次迭代都要花费几次哈希查询。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/gather" term="gather" label="gather" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[列表解析]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-05-11-list-comprehensions/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-05-11-list-comprehensions/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-13T00:00:00+08:00</published>
            <updated>2021-07-13T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>List Comprehensions</blockquote><h2 id="列表解析">列表解析</h2>
<p>列表解析即 List Comprehensions。</p>
<p>生成 <code>1x1, 2x2, 3x3, ..., 10x10</code> 的列表：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="nv">$_</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div><p><code>for</code> 语句前面还可以添加 if 修饰符，这样我们就可以仅筛选出偶数的平方：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="nv">$_</span><span class="o">**</span><span class="mi">2</span> <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">);</span>
<span class="p">(</span><span class="nv">$_</span><span class="o">**</span><span class="mi">2</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># 同上</span>
</code></pre></div><p>组合多个 if 条件:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$_</span> <span class="k">if</span> <span class="nv">$_</span> <span class="nv">%2</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">6</span> <span class="p">);</span> <span class="c1"># [3 5]   </span>
</code></pre></div><p>还可以生成全排列：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="nv">$_</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">ABC</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&#34;</span><span class="s2">XYZ</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">);</span>
<span class="c1"># (&#34;AX&#34;, &#34;AY&#34;, &#34;AZ&#34;, &#34;BX&#34;, &#34;BY&#34;, &#34;BZ&#34;, &#34;CX&#34;, &#34;CY&#34;, &#34;CZ&#34;)</span>

<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">(</span><span class="nv">@a</span> <span class="ow">X</span> <span class="nv">@b</span><span class="p">);</span> <span class="c1"># 这儿也可以用圆括号, 也可以不用</span>
<span class="c1"># [(1 2) (1 4) (1 6) (3 2) (3 4) (3 6) (4 2) (4 4) (4 6)]</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; <span class="o">(</span><span class="nv">$_</span> when /7$/ <span class="k">for</span> 1..99<span class="o">)</span>
<span class="o">(</span><span class="m">7</span> <span class="m">17</span> <span class="m">27</span> <span class="m">37</span> <span class="m">47</span> <span class="m">57</span> <span class="m">67</span> <span class="m">77</span> <span class="m">87</span> 97<span class="o">)</span>
</code></pre></div><p>大小写转换：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Hello World IBM Apple</span><span class="p">&gt;;</span>
<span class="p">(</span><span class="o">.</span><span class="nb">lc</span> <span class="k">for</span> <span class="nv">@a</span><span class="p">);</span> <span class="c1"># hello world ibm apple</span>
</code></pre></div><p>删除字符串末尾的空白：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@freshfruit</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1"> banana</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> loganberry </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">passion fruit </span><span class="p">&#39;;</span>
<span class="p">(</span><span class="o">.</span><span class="nb">trim</span> <span class="k">for</span> <span class="nv">@freshfruit</span><span class="p">);</span> <span class="c1"># &#34;banana&#34; &#34;loganberry&#34; &#34;passion fruit&#34;</span>
</code></pre></div><p>向量运算：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@vec</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="p">;</span>
<span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nv">$_</span> <span class="k">for</span> <span class="nv">@vec</span><span class="p">);</span>            <span class="c1"># 6 12 18</span>
<span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nv">$_</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="k">for</span> <span class="nv">@vec</span><span class="p">);</span>  <span class="c1"># 12 18</span>
<span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nv">$_</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="nv">@vec</span><span class="p">);</span>  <span class="c1"># ()</span>
</code></pre></div><p>嵌套数组：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@vec</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="p">;</span>
<span class="p">(</span><span class="o">[</span><span class="nv">$_</span><span class="o">,</span> <span class="nv">$_</span><span class="o">**</span><span class="mi">2</span><span class="o">].</span><span class="nb">perl</span> <span class="k">for</span> <span class="nv">@vec</span><span class="p">);</span> <span class="c1"># [2, 4] [4, 16] [6, 36]</span>
<span class="p">(</span><span class="o">[</span><span class="nv">$_</span><span class="o">,</span> <span class="nv">$_</span><span class="o">**</span><span class="mi">2</span><span class="o">].</span><span class="nb">WHAT</span> <span class="k">for</span> <span class="nv">@vec</span><span class="p">);</span> <span class="c1"># (Array) (Array) (Array)</span>
</code></pre></div><p>多个列表之间的列表解析:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@vec1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@vec2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,-</span><span class="mi">9</span><span class="p">;</span>
<span class="p">(</span><span class="nv">$_</span> <span class="k">for</span> <span class="nv">@vec1</span> <span class="ow">X</span><span class="o">*</span> <span class="nv">@vec2</span><span class="p">);</span>     <span class="c1"># 8 6 -18 16 12 -36 24 18 -54</span>
<span class="p">(</span><span class="nv">$_</span> <span class="k">for</span> <span class="nv">@vec1</span> <span class="ow">X</span><span class="o">+</span> <span class="nv">@vec2</span><span class="p">);</span>     <span class="c1"># 5 -7 8 7 -5 10 9 -3</span>
<span class="p">(</span><span class="nv">$_</span> <span class="k">for</span> <span class="nv">@vec1</span> <span class="ow">Z</span><span class="o">*</span> <span class="nv">@vec2</span><span class="p">);</span>     <span class="c1"># 8 12 -54</span>
<span class="p">(</span><span class="nv">$_</span> <span class="k">for</span> <span class="nv">@vec1</span> <span class="o">&gt;&gt;*&lt;&lt;</span> <span class="nv">@vec2</span><span class="p">);</span>  <span class="c1"># 8 12 -54</span>
</code></pre></div><p>使用列表解析处理矩阵:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; my @a <span class="o">=</span> <span class="o">([</span>1,2,3<span class="o">]</span>, <span class="o">[</span>4,5,6<span class="o">]</span>, <span class="o">[</span>7,8,9<span class="o">])</span><span class="p">;</span>
&gt; @a<span class="o">[</span>0<span class="o">]</span>                    <span class="c1"># 1 2 3</span>
&gt; @a<span class="o">[</span>0<span class="o">][</span>1<span class="o">]</span>                 <span class="c1"># 2</span>
&gt; @a<span class="o">[</span>0<span class="o">][</span>2<span class="o">]</span>                 <span class="c1"># 3</span>
&gt; <span class="o">(</span><span class="nv">$_</span><span class="o">[</span>1<span class="o">]</span> <span class="k">for</span> @a<span class="o">)</span>           <span class="c1"># 2 5 8</span>
&gt; <span class="o">(</span><span class="nv">$_</span><span class="o">[</span>2<span class="o">]</span> <span class="k">for</span> @a<span class="o">)</span>           <span class="c1"># 3 6 9</span>
&gt; <span class="o">(</span><span class="nv">$_</span><span class="o">[</span>2<span class="o">]</span>-1 <span class="k">for</span> @a<span class="o">)</span>         <span class="c1"># 2 5 8</span>
&gt; <span class="o">(</span>@a<span class="o">[</span><span class="nv">$_</span><span class="o">][</span><span class="nv">$_</span><span class="o">]</span> <span class="k">for</span> 0..2<span class="o">)</span>    <span class="c1"># 1 5 9</span>
</code></pre></div><p>矩阵转置:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">transpose</span> <span class="p">(</span><span class="nv">@m</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">@m</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">keys</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="o">[</span> <span class="nv">@m</span><span class="o">»[</span><span class="nv">$_</span><span class="o">]</span> <span class="o">]</span><span class="p">};</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="o">[</span><span class="p">&lt;</span><span class="s"> a b c d e </span><span class="p">&gt;</span><span class="o">],</span>
        <span class="o">[</span><span class="p">&lt;</span><span class="s"> f g h i j </span><span class="p">&gt;</span><span class="o">],</span>
        <span class="o">[</span><span class="p">&lt;</span><span class="s"> k l m n o </span><span class="p">&gt;</span><span class="o">],</span>
        <span class="o">[</span><span class="p">&lt;</span><span class="s"> p q r s t </span><span class="p">&gt;</span><span class="o">]</span><span class="p">;</span>

<span class="p">(</span><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.&amp;</span><span class="nf">transpose</span><span class="p">);</span>
</code></pre></div><pre><code>a f k p
b g l q
c h m r
d i n s
e j o t
</code></pre><p>一丢丢解释：<code>@m[0].keys</code> 获取 <code>column index</code>, 根据获取到的列索引, 使用超运算符 <code>»</code> 遍历数组中对应列索引位置的元素。注意 <code>[]</code> 实际上是后缀操作符, 原来使用 <code>».[]</code> 的语法是错误的。</p>
<p>使用 gather 进行列表解析：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@s</span> <span class="o">=</span> <span class="k">gather</span> <span class="p">{</span> <span class="k">for</span> <span class="o">^</span><span class="mi">100</span> <span class="p">{</span> <span class="nb">take</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$_</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 1到20之间哪些数字组成直角？</span>
<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="k">gather</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$n</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">$x</span><span class="o">..</span><span class="nv">$n</span> <span class="k">-&gt;</span> <span class="nv">$y</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nv">$y</span><span class="o">..</span><span class="nv">$n</span> <span class="k">-&gt;</span> <span class="nv">$z</span> <span class="p">{</span>
            <span class="nb">take</span> <span class="nv">$x</span><span class="o">,</span><span class="nv">$y</span><span class="o">,</span><span class="nv">$z</span> <span class="k">if</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="o">+</span> <span class="nv">$y</span><span class="o">*</span><span class="nv">$y</span> <span class="o">==</span> <span class="nv">$z</span><span class="o">*</span><span class="nv">$z</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">@a</span><span class="o">[]</span><span class="p">&#34;;</span>

<span class="c1"># 3 4 5 5 12 13 6 8 10 8 15 17 9 12 15 12 16 20       </span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/list-comprehensions" term="list-comprehensions" label="List Comprehensions" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的动态变量]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-02-29-dynamic-variables-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-02-29-dynamic-variables-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-12T00:00:00+08:00</published>
            <updated>2021-07-12T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Dynamic Variables in Raku</blockquote><p>Raku 中的<a href="http://qiita.com/B73W56H84/items/18053bf37de8bb2bb808#err">动态变量</a></p>
<h2 id="argfiles">$*ARGFILES</h2>
<blockquote>
<p>$*ARGFILES Magic command-line input handle.</p>
</blockquote>
<p><strong><code>argfiles.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="vg">$*ARGFILES</span><span class="o">.</span><span class="nb">raku</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># IO::Handle.new(:path(Any),:chomp)</span>

<span class="c1"># 按行读取</span>
<span class="k">for</span> <span class="vg">$*ARGFILES</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$line</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="c1"># 一次性读取</span>
<span class="c1"># say $*ARGFILES.slurp;</span>
</code></pre></div><p><strong><code>USAGE</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku argfiles.raku file1 file2 file3 ...
</code></pre></div><ul>
<li><a href="http://doc.raku.org/type/IO::Handle">class IO::Handle - Raku Documentation</a></li>
<li><a href="http://doc.raku.org/language/io">Input/Output - Raku Documentation</a></li>
<li><a href="http://qiita.com/syohex/items/0a7782920968ab105ba0">Raku文件操作 - Qiita</a></li>
</ul>
<h2 id="args">@*ARGS</h2>
<blockquote>
<p>@*ARGS - Arguments from the command line. 命令行中的参数。</p>
</blockquote>
<p><strong><code>agrs.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">@*ARGS</span><span class="o">.</span><span class="nf">WAHT</span><span class="p">;</span>    <span class="c1"># (Array)</span>
<span class="nb">say</span> <span class="vg">@*ARGS</span><span class="p">;</span>         <span class="c1"># [a b c d e]</span>
<span class="nb">say</span> <span class="vg">@*ARGS</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>    <span class="c1"># [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;e&#34;]</span>
</code></pre></div><p><strong><code>USAGE</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku args.raku a b c d e
</code></pre></div><ul>
<li><a href="http://doc.raku.org/type/Array">class Array - Raku Documentation</a></li>
</ul>
<h2 id="in">$*IN</h2>
<blockquote>
<p>$*IN - 标准输入文件句柄, 等同于 stdin</p>
</blockquote>
<p><strong><code>in.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*IN</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1"># IO::Handle.new(:path(IO::Special.new(what  &#34;&lt;STDIN&gt;&#34;)),:chomp)</span>
<span class="nb">say</span> <span class="vg">$*IN</span><span class="o">.</span><span class="nb">path</span><span class="p">;</span>   <span class="c1"># IO::Special.new(what  &#34;&lt;STDIN&gt;&#34;)</span>
<span class="nb">say</span> <span class="vg">$*IN</span><span class="o">.</span><span class="nb">chomp</span><span class="p">;</span>  <span class="c1"># True</span>

<span class="k">for</span> <span class="vg">$*IN</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$line</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p><strong><code>USAGE</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku in.raku
人力
...

$ cat somefile.txt <span class="p">|</span> raku in.raku
</code></pre></div><h2 id="out">$*OUT</h2>
<blockquote>
<p>$*OUT - 标准输出文件句柄, 等同于 stdout</p>
</blockquote>
<p><strong><code>out.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*OUT</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1"># IO::Handle.new(:path(IO::Special.new(what  &#34;&lt;STDOUT&gt;&#34;)),:chomp)</span>
<span class="nb">say</span> <span class="vg">$*OUT</span><span class="o">.</span><span class="nb">path</span><span class="p">;</span>   <span class="c1"># IO::Special.new(what  &#34;&lt;STDOUT&gt;&#34;)</span>
<span class="nb">say</span> <span class="vg">$*OUT</span><span class="o">.</span><span class="nb">chomp</span><span class="p">;</span>  <span class="c1"># True</span>

<span class="vg">$*OUT</span><span class="o">.</span><span class="nb">say</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/新年快乐/ </span><span class="s">);
</span><span class="s">    祝你</span><span class="p">新年快乐</span>
    <span class="mf">2016.01.23</span>
    <span class="n">让我再说一次</span>
<span class="n">新年快乐</span>

<span class="c1"># 通常我们会在打印时省略 $*OUT</span>
<span class="c1"># say &#34;哈利路亚&#34;;</span>
</code></pre></div><p>最后一段代码中 <code>//</code> 中间的字符是分割符。这打印出:</p>
<pre><code>祝你新年快乐
2016.01.23
让我再说一次
</code></pre><p><strong><code>USAGE</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku out.raku
$ raku out.raku &gt; result.txt
</code></pre></div><ul>
<li><a href="http://doc.raku.org/type/IO">role IO - Raku Documentation</a></li>
</ul>
<h2 id="err">$*ERR</h2>
<blockquote>
<p>$*ERR - 标准错误文件句柄, 等同于 stderr</p>
</blockquote>
<p><strong><code>err.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1"># IO::Handle.new(:path(IO::Special.new(what  &#34;&lt;STDERR&gt;&#34;)),:chomp)</span>
<span class="nb">say</span> <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">path</span><span class="p">;</span>   <span class="c1"># IO::Special.new(what  &#34;&lt;STDERR&gt;&#34;)</span>
<span class="nb">say</span> <span class="vg">$*ERR</span><span class="o">.</span><span class="nb">chomp</span><span class="p">;</span>  <span class="c1"># True</span>

<span class="vg">$*ERR</span><span class="o">.</span><span class="nb">say</span><span class="p">(&#34;</span><span class="s2">我错了</span><span class="p">&#34;);</span>

<span class="c1"># 平时可以使用 note</span>
<span class="c1"># note &#34;前方高能预警&#34;;</span>
</code></pre></div><p><strong><code>USAGE</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku err.raku &gt; /dev/null
我错了
</code></pre></div><h2 id="repo">$*REPO</h2>
<blockquote>
<p>$*REPO A variable holding information about modules installed/loaded</p>
</blockquote>
<p><strong><code>repo.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*REPO</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*REPO</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*REPO</span><span class="o">.</span><span class="nb">id</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*REPO</span><span class="o">.</span><span class="nf">path-spec</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*REPO</span><span class="o">.</span><span class="nb">loaded</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*REPO</span><span class="o">.</span><span class="nf">repo-chain</span><span class="p">;</span>
</code></pre></div><h2 id="tz">$*TZ</h2>
<blockquote>
<p>$*TZ The system&rsquo;s local timezone.</p>
</blockquote>
<p><strong><code>tz.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*TZ</span><span class="p">;</span>      <span class="c1"># 32400</span>
<span class="nb">say</span> <span class="vg">$*TZ</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="c1"># 32400</span>
<span class="nb">say</span> <span class="vg">$*TZ</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="c1"># (Int)</span>
</code></pre></div><h2 id="cwd">$*CWD</h2>
<blockquote>
<p>$*CWD The Current Working Directory.</p>
</blockquote>
<p><strong><code>cwd.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*CWD</span><span class="p">;</span>       <span class="c1"># &#34;/Users/kujira&#34;.IO</span>
<span class="nb">say</span> <span class="vg">$*CWD</span><span class="o">.</span><span class="nb">path</span><span class="p">;</span>  <span class="c1"># /Users/kujira</span>
<span class="nb">say</span> <span class="vg">$*CWD</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="c1"># &#34;/Users/kujira&#34;.IO(:SPEC(IO::Spec::Unix),:CWD(&#34;/Users/kujira&#34;))</span>
</code></pre></div><h2 id="kernel">$*KERNEL</h2>
<blockquote>
<p>$*KERNEL Which kernel am I compiled for?</p>
</blockquote>
<p><strong><code>kernel.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="p">;</span>            <span class="c1"># darwin (15.2.0)</span>
<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">release</span><span class="p">;</span>    <span class="c1"># Darwin Kernel Version 15.2.0: Fri Nov 13 19:56:56 PST 2015; root:xnu-3248.20.55~2/RELEASE_X86_64</span>
<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>       <span class="c1"># darwin</span>
<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">auth</span><span class="p">;</span>       <span class="c1"># unknown</span>
<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">version</span><span class="p">;</span>    <span class="c1"># v15.2.0</span>
<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">signature</span><span class="p">;</span>  <span class="c1"># (Blob)</span>
<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">desc</span><span class="p">;</span>       <span class="c1"># (Str)</span>

<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>        <span class="c1"># Kernel.new(release  Str, name  &#34;darwin&#34;, auth  &#34;unknown&#34;, version  Version.new(&#39;15.2.0&#39;), signature  Blob, desc  Str)</span>
<span class="nb">say</span> <span class="vg">$*KERNEL</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>        <span class="c1"># (Kernel)</span>
</code></pre></div><h2 id="distro">$*DISTRO</h2>
<blockquote>
<p>$*DISTRO Which OS distribution am I compiling under?</p>
</blockquote>
<p><strong><code>distro.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="p">;</span>           <span class="c1"># macosx (10.11.2)</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>      <span class="c1"># macosx</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">is-win</span><span class="p">;</span>    <span class="c1"># False</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">version</span><span class="p">;</span>   <span class="c1"># v11.4</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">path-sep</span><span class="p">;</span>  <span class="c1"># :</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">auth</span><span class="p">;</span>      <span class="c1"># Apple Computer, Inc.</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">desc</span><span class="p">;</span>      <span class="c1"># unknown</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">release</span><span class="p">;</span>   <span class="c1"># 20F71</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">signature</span><span class="p">;</span> <span class="c1"># (Blob)</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">gist</span><span class="p">;</span>      <span class="c1"># macosx (11.4)</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>       <span class="c1"># macosx</span>
<span class="nb">say</span> <span class="vg">$*DISTRO</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>      <span class="c1"># Distro.new(release  &#34;20F71&#34;, path-sep  &#34;:&#34;, name  &#34;macos&#34;, auth  &#34;Apple Inc.&#34;, version  v11.4, signature  Blob, desc  &#34;unknown&#34;)</span>
</code></pre></div><ul>
<li><a href="http://blog.64p.org/entry/2015/09/05/225701">Raku で windows かどうか判定したい - tokuhirom&rsquo;s blog</a></li>
<li><a href="https://github.com/raku/roast/blob/master/S02-magicals/DISTRO.t">DISTRO.t</a></li>
</ul>
<h2 id="vm">$*VM</h2>
<blockquote>
<p>$*VM Which virtual machine am I compiling under?</p>
</blockquote>
<p><strong><code>vm.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*VM</span><span class="p">;</span>         <span class="c1"># moar (2021.06)</span>
<span class="nb">say</span> <span class="vg">$*VM</span><span class="o">.</span><span class="nb">config</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*VM</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
</code></pre></div><h2 id="raku">$*RAKU</h2>
<blockquote>
<p>$*RAKU Which Raku am I compiled for?</p>
</blockquote>
<p><strong><code>perl.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*RAKU</span><span class="p">;</span>          <span class="c1"># Raku (6.d)</span>
<span class="nb">say</span> <span class="vg">$*RAKU</span><span class="o">.</span><span class="nb">compiler</span><span class="p">;</span> <span class="c1"># rakudo (2021.06)</span>

<span class="nb">say</span> <span class="vg">$*RAKU</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>     <span class="c1"># Raku.new(compiler  Compiler.new(id  &#34;24F69C23F0D9F44910DEB9B097353B0DD30C7E96&#34;, release  &#34;&#34;, codename  &#34;&#34;, name  &#34;rakudo&#34;, auth  &#34;The Perl Foundation&#34;, version  v2021.06, signature  Blob, desc  Str), name  &#34;Raku&#34;, auth  &#34;The Perl Foundation&#34;, version  v6.d, signature  Blob, desc  Str)</span>
</code></pre></div><h2 id="pid">$*PID</h2>
<blockquote>
<p>$*PID Process ID of the current process.</p>
</blockquote>
<p><strong><code>pid.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*PID</span><span class="p">;</span>      <span class="c1"># 35480</span>
<span class="nb">say</span> <span class="vg">$*PID</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="c1"># 35480</span>
<span class="nb">say</span> <span class="vg">$*PID</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="c1"># (Int)</span>
</code></pre></div><h2 id="program-name">$*PROGRAM-NAME</h2>
<blockquote>
<p>$*PROGRAM-NAME Path to the current executable as it was entered on the command line, or C&lt;-e&gt; if perl was invoked with the -e flag.</p>
</blockquote>
<p><strong><code>program-name.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*PROGRAM-NAME</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*PROGRAM-NAME</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="nb">say</span> <span class="vg">$*PROGRAM-NAME</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">basename</span><span class="p">;</span>
</code></pre></div><h2 id="program">$*PROGRAM</h2>
<blockquote>
<p>$*PROGRAM Location (in the form of an C<a href="undefined">IO::Path</a> object) of the Perl program being executed.</p>
</blockquote>
<p><strong><code>program.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*PROGRAM</span><span class="p">;</span>        <span class="c1"># &#34;/Users/kujira/program.raku&#34;.IO</span>
<span class="nb">say</span> <span class="vg">$*PROGRAM</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>    <span class="c1"># program.raku</span>
<span class="nb">say</span> <span class="vg">$*PROGRAM</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1"># &#34;program.raku&#34;.IO(:SPEC(IO::Spec::Unix),:CWD(&#34;/Users/kujira&#34;))</span>
<span class="nb">say</span> <span class="vg">$*PROGRAM</span><span class="o">.</span><span class="nb">SPEC</span><span class="p">;</span>   <span class="c1"># (Unix)</span>
<span class="nb">say</span> <span class="vg">$*PROGRAM</span><span class="o">.</span><span class="nf">CWD</span><span class="p">;</span>    <span class="c1"># /Users/kujira</span>
<span class="nb">say</span> <span class="vg">$*PROGRAM</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>   <span class="c1"># (Path)</span>
</code></pre></div><h2 id="executable">$*EXECUTABLE</h2>
<blockquote>
<p>$*EXECUTABLE Absolute path of the perl executable that is currently running.</p>
</blockquote>
<p><strong><code>executable.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*EXECUTABLE</span><span class="p">;</span>           <span class="c1"># &#34;/usr/local/bin/raku&#34;.IO</span>
<span class="nb">say</span> <span class="vg">$*EXECUTABLE</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>       <span class="c1"># /usr/local/bin/raku</span>
<span class="nb">say</span> <span class="vg">$*EXECUTABLE</span><span class="o">.</span><span class="nb">basename</span><span class="p">;</span>  <span class="c1"># raku</span>
<span class="nb">say</span> <span class="vg">$*EXECUTABLE</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>      <span class="c1"># (Path)</span>
<span class="nb">say</span> <span class="vg">$*EXECUTABLE</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>      <span class="c1"># &#34;/usr/local/bin/raku&#34;.IO(:SPEC(IO::Spec::Unix))</span>
<span class="nb">say</span> <span class="vg">$*EXECUTABLE</span><span class="o">.</span><span class="nb">SPEC</span><span class="p">;</span>      <span class="c1"># (Unix)</span>
</code></pre></div><h2 id="executable-name">$*EXECUTABLE-NAME</h2>
<blockquote>
<p>$*EXECUTABLE-NAME The name of the perl executable that is currently running. (e.g. raku-p, raku-m, Niecza.exe) Favor $*EXECUTABLE because it is not guaranteed that the perl executable is in PATH.</p>
</blockquote>
<p><strong><code>executable-name.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*EXECUTABLE-NAME</span><span class="p">;</span>       <span class="c1"># raku</span>
<span class="nb">say</span> <span class="vg">$*EXECUTABLE-NAME</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>  <span class="c1"># (Str)</span>
</code></pre></div><h2 id="user">$*USER</h2>
<blockquote>
<p>$*USER The user that is running the program. It is an object that evaluates to &ldquo;username (uid)&rdquo;. It will evaluate to the username only if treated as a string and the numeric user id if treated as a number.</p>
</blockquote>
<p><strong><code>user.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*USER</span><span class="p">;</span>      <span class="c1"># kujira (801)</span>
<span class="nb">say</span> <span class="o">+</span><span class="vg">$*USER</span><span class="p">;</span>     <span class="c1"># 801</span>
<span class="nb">say</span> <span class="o">~</span><span class="vg">$*USER</span><span class="p">;</span>     <span class="c1"># kujira</span>
<span class="nb">say</span> <span class="vg">$*USER</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="c1"># IdName.new</span>
</code></pre></div><h2 id="group">$*GROUP</h2>
<blockquote>
<p>$*GROUP The primary group of the user who is running the program. It is an object that evaluates to &ldquo;groupname (gid)&rdquo;. It will evaluate to the groupname only if treated as a string and the numeric group id if treated as a number.</p>
</blockquote>
<p><strong><code>group.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*GROUP</span><span class="p">;</span>       <span class="c1"># whale (0)</span>
<span class="nb">say</span> <span class="o">~</span><span class="vg">$*GROUP</span><span class="p">;</span>      <span class="c1"># whale</span>
<span class="nb">say</span> <span class="o">+</span><span class="vg">$*GROUP</span><span class="p">;</span>      <span class="c1"># 0</span>
<span class="nb">say</span> <span class="vg">$*GROUP</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="c1"># IdName.new</span>
</code></pre></div><h2 id="home">$*HOME</h2>
<blockquote>
<p>$*HOME An L<a href="undefined">IO::Path</a> object representing the &ldquo;home directory&rdquo; of the user that is running the program. If the &ldquo;home directory&rdquo; cannot be determined it will be L</p>
</blockquote>
<p><strong><code>home.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*HOME</span><span class="p">;</span>       <span class="c1"># &#34;/Users/kujira&#34;.IO</span>
<span class="nb">say</span> <span class="vg">$*HOME</span><span class="o">.</span><span class="nf">CWD</span><span class="p">;</span>   <span class="c1"># /Users/kujira</span>
<span class="nb">say</span> <span class="vg">$*HOME</span><span class="o">.</span><span class="nb">SPEC</span><span class="p">;</span>  <span class="c1"># (Unix)</span>
<span class="nb">say</span> <span class="vg">$*HOME</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>  <span class="c1"># (Path)</span>
<span class="nb">say</span> <span class="vg">$*HOME</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="c1"># &#34;/Users/kujira&#34;.IO(:SPEC(IO::Spec::Unix),:CWD(&#34;/Users/kujira&#34;))</span>
</code></pre></div><ul>
<li><a href="http://doc.raku.org/type/IO::Path">class IO::Path - Raku Documentation</a></li>
</ul>
<h2 id="spec">$*SPEC</h2>
<blockquote>
<p>$*SPEC The appropriate IO::Spec sub-class for the platform that the program is running on.</p>
</blockquote>
<p><strong><code>spec.raku</code></strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*SPEC</span><span class="p">;</span>          <span class="c1"># (Unix)</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>     <span class="c1"># IO::Spec::Unix</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">path</span><span class="p">;</span>     <span class="c1"># (/usr/local/Cellar/rakudo-star/2015.12/share/raku/site/bin /usr/local/sbin /usr/local/bin /usr/bin /bin /usr/sbin /sbin)</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">tmpdir</span><span class="p">;</span>   <span class="c1"># &#34;/var/folders/9v/wr31l2zj78x1nw58jgljq_9w0000gn/T&#34;.IO</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">dir-sep</span><span class="p">;</span>  <span class="c1"># /</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">curdir</span><span class="p">;</span>   <span class="c1"># .</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">updir</span><span class="p">;</span>    <span class="c1"># ..</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">curupdir</span><span class="p">;</span> <span class="c1"># none(., ..)</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">rootdir</span><span class="p">;</span>  <span class="c1"># /</span>
<span class="nb">say</span> <span class="vg">$*SPEC</span><span class="o">.</span><span class="nb">devnull</span><span class="p">;</span>  <span class="c1"># /dev/null</span>
</code></pre></div><ul>
<li><a href="http://doc.raku.org/type/IO::Spec">class IO::Spec - Raku Documentation</a></li>
<li><a href="http://doc.raku.org/type/IO::Spec::QNX">class IO::Spec::QNX - Raku Documentation</a></li>
<li><a href="http://doc.raku.org/type/IO::Spec::Unix">class IO::Spec::Unix - Raku Documentation</a></li>
<li><a href="http://doc.raku.org/type/IO::Spec::Win32">class IO::Spec::Win32 - Raku Documentation</a></li>
<li><a href="http://doc.raku.org/type/IO::Spec::Cygwin">class IO::Spec::Cygwin - Raku Documentation</a></li>
</ul>
<p><a href="http://qiita.com/B73W56H84/items/18053bf37de8bb2bb808#%E5%8F%82%E8%80%83%E3%81%A8%E6%B3%A8%E9%87%88">http://qiita.com/B73W56H84/items/18053bf37de8bb2bb808#%E5%8F%82%E8%80%83%E3%81%A8%E6%B3%A8%E9%87%88</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dynamic-variable" term="dynamic-variable" label="dynamic variable" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的术语]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-03-26-terms-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-21-terms-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的项" />
            
                <id>https://ohmyweekly.github.io/notes/2016-03-26-terms-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-12T00:00:00+08:00</published>
            <updated>2021-07-12T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Terms in Raku</blockquote><h2 id="匿名">匿名</h2>
<p>子例程、方法或子方法，当它们不能通过名字调用时，就被称为匿名的</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># named subroutine</span>
<span class="k">sub</span> <span class="nf">double</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
<span class="c1"># 匿名子例程,存储在一个具名的标量里</span>
<span class="k">my</span> <span class="nv">$double</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>
</code></pre></div><p>注意，匿名子例程仍然可以有名字</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 使用 anon 关键字使子例程匿名</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="k">anon</span> <span class="k">sub</span> <span class="nf">triple</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">3</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">}</span>
<span class="nb">say</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>        <span class="c1"># triple</span>
</code></pre></div><h2 id="副词">副词</h2>
<p>通常, 副词是函数的命名参数.  也有一些其它特殊语法形式允许副词出现在某些合适的地方:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">q</span><span class="sa">:w</span><span class="p">&#34;</span><span class="s">foo bar</span>   <span class="c1"># &#34;:w&#34; is a Quotelike form modifier adverb</span>
<span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/</span><span class="sr">a</span><span class="o">|</span><span class="sr">b</span><span class="o">|</span><span class="sr">c</span><span class="p">/</span>     <span class="c1"># &#34;:g&#34; is also</span>
<span class="mi">4</span> <span class="o">+&gt;</span> <span class="mi">5</span> <span class="p">:</span><span class="s">rotate</span> <span class="c1"># &#34;:rotate&#34; is an operator adverb</span>
<span class="nv">@h</span><span class="p">{</span><span class="mi">3</span><span class="p">}:</span><span class="s">exists</span>   <span class="c1"># &#34;:exists&#34; is also, but is known as a subscript adverb</span>
</code></pre></div><p>副词通常使用冒号对儿标记来表示, 因为这个原因, 冒号对儿标记法也以副词对儿形式著称:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">a</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>          <span class="c1"># Same as &#34;a&#34; =&gt; 4</span>
</code></pre></div><h2 id="autothreading">Autothreading</h2>
<p><code>Autothreading</code> 是这样的: 如果你传递一个 <code>junction</code> 给子例程, 该子例程期望的参数类型为 <code>Any</code> 或它的子类型。那么这个子例程调用会被执行多次, 每次使用一个不同的 junction 状态. 这些调用的结果被组合成一个跟原 <code>junction</code> 同类型的 <code>junction</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">};</span>

<span class="k">if</span> <span class="nb">f</span><span class="p">(</span><span class="mi">1</span><span class="o">|</span><span class="mi">2</span><span class="o">|</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">success</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><p>这里 <code>f()</code> 是含有一个参数的子例程，然而因为它没有显式的类型声明，它就被隐式的声明为 <code>Any</code> 型。 Junction 参数使 <code>f(1|2|3)</code> 调用在内部作为 <code>f(1)|f(2)|f(3)</code> 执行, 而结果是跟原 <code>junction</code> 同类型的 <code>junction</code>, 即  <code>2|4|6</code>。这种把一个 <code>Junction</code> 分成对多次函数调用的处理就叫做 <code>autothreading</code>。</p>
<h2 id="colon-pair-和-colon-list">Colon Pair 和 Colon List</h2>
<p>冒号对儿是用于创建或 Pair 对象的便捷语法. 两种最常见的形式是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">a</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>          <span class="c1"># Same as &#34;a&#34; =&gt; 4,   same as Pair.new(:key&lt;a&gt;,:value(5))</span>
<span class="p">:</span><span class="s">a</span><span class="p">&lt;</span><span class="s">4</span><span class="p">&gt;</span>          <span class="c1"># Same as &#34;a&#34; =&gt; &#34;4&#34;, same as Pair.new(:key&lt;a&gt;,:value&lt;5&gt;)</span>
</code></pre></div><p>这也是人们熟知的副词对儿形式。注意, 当冒号后面括号前面的部分不是一个合法的标识符的时候, 会应用其它语义, 不是所有的副词对儿都创建 <code>Pair</code> 对象。
另外两个常见的形式是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">a</span>             <span class="c1"># Same as :a(True)</span>
<span class="p">:!</span><span class="s">a</span>            <span class="c1"># Same as :a(False)</span>
</code></pre></div><p>一个 colon 列表是一个仅包含冒号对儿的列表, 不需要逗号, 甚至不需要空格:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">a</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span><span class="s">c</span><span class="p">:!</span><span class="s">d</span><span class="p">:</span><span class="s">c</span>   <span class="c1"># Same as a =&gt; 4, c =&gt; True, d =&gt; False, c =&gt; True</span>
</code></pre></div><h2 id="constraint">Constraint</h2>
<p>约束是给参数或 subset 类型添加的限制。通过单词 where 引入约束. 在下面的例子中, 约束用于确保, 当调用一个名为 abbreviate 的子例程, 其参数为一个长度小于 10 个字符的字符串时,会抛出一个错误:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">abbreviate</span> <span class="p">(</span><span class="nb">Str</span> <span class="nv">$thing</span> <span class="k">where</span> <span class="p">{</span> <span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="p">})</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>上例中的 Str 也是一个约束, 但是经常作为&quot;类型约束&quot;.</p>
<h2 id="instance">Instance</h2>
<p>类的实例在其它编程语言中也叫对象. 对象存储属性, 通常是 new 方法调用的返回值, 或者是对象字面量.
大部分类型的实例被定义为 True, 例如 <code>defined($instance)</code> 为 True。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Str</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">hello</span><span class="p">&#34;;</span>  <span class="c1">## 这使用内建类型,例如 Str</span>

<span class="k">if</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Oh, yeah. I&#39;m defined.</span><span class="p">&#34;;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No. Something off? </span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="c1">## if you wanted objects...</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="c1"># nothing here for now.</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$an_instance</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$an_instance</span><span class="o">.</span><span class="nb">defined</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span><span class="c1"># defined($an_instance) works too.</span>
</code></pre></div><p>类拥有方法和属性的所有蓝图, 而类的实例把蓝图带到真实世界中。</p>
<h2 id="invocant">Invocant</h2>
<p>在 Raku 中调用方法的对象叫做调用者. 在方法中它就是 <code>self</code> 引用的东西.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">str</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">uc</span><span class="p">;</span>   <span class="c1"># &#39;str&#39; 是 方法 uc 的调用者</span>
</code></pre></div><h2 id="literal">Literal</h2>
<p>字面量是一块直接代表对象的代码, 通常指向对象自身.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>      <span class="c1"># the 2 is a literal</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># $x is not a literal, but a variable</span>
</code></pre></div><h2 id="lvalue">lvalue</h2>
<p>lvalue 或者左值是能出现在赋值操作符左侧的任何东西; 典型的左值有变量, 私有属性和 <code>is rw</code> 属性, 变量列表和左值子例程。</p>
<p>左值的例子:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Declaration</th>
<th style="text-align:left">lvalue</th>
<th style="text-align:left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">my $x;</td>
<td style="text-align:left">$x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">my ($a, $b);</td>
<td style="text-align:left">($a, $b)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">has $!attribute;</td>
<td style="text-align:left">$!attribute</td>
<td style="text-align:left">Only inside classes</td>
</tr>
<tr>
<td style="text-align:left">has $.attrib is rw;</td>
<td style="text-align:left">$.attrib</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">sub a is rw { $x };</td>
<td style="text-align:left">a()</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>不是左值的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">3</span>                        <span class="c1"># literals</span>
<span class="k">constant</span> <span class="nb">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>          <span class="c1"># constants</span>
<span class="k">has</span> <span class="nv">$.attrib</span><span class="p">;</span>            <span class="c1"># attributes; you can only assign to $!attrib</span>
<span class="k">sub</span> <span class="nb">f</span> <span class="p">{</span> <span class="p">};</span> <span class="nb">f</span><span class="p">();</span>          <span class="c1"># &#34;normal&#34; subs are not writable</span>
<span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">};</span>    <span class="c1"># error - parameters are read-only by default</span>
</code></pre></div><h2 id="mainline">Mainline</h2>
<p><code>mainline</code> 是程序中不属于任何 block 的程序文本.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span> <span class="p">{</span>
            <span class="c1"># not in mainline, in sub f</span>
<span class="p">}</span>

<span class="nb">f</span><span class="p">();</span>        <span class="c1"># in mainline again</span>
</code></pre></div><h2 id="slurpy">Slurpy</h2>
<p>子例程或方法中的形参如果能接收任意数量的参数, 那这个形参就会被认为是 <code>slurpy</code> 的。它由参数名字前面的星号标出。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">sum</span> <span class="p">(</span><span class="o">*</span><span class="nv">@numbers</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">[+]</span> <span class="nv">@numbers</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="type-object">Type Object</h2>
<p>类型对象是一个代表类 <code>/role/package/grammar/enum</code> 的对象。它通常和类型名相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="p">};</span>

<span class="nb">say</span> <span class="n">A</span><span class="p">;</span>              <span class="c1"># A is the type object</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>    <span class="c1"># same here</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">class</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">hi</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># $x now holds a type object returned from the</span>
<span class="c1"># anonymous class definition</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/term" term="term" label="term" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的签名]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-04-12-signature-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-08-29-exploring-raku-signatures-part-two/?utm_source=atom_feed" rel="related" type="text/html" title="探索 Raku 中的签名(第二部分)" />
            
                <id>https://ohmyweekly.github.io/notes/2016-04-12-signature-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-12T00:00:00+08:00</published>
            <updated>2021-07-12T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Signature in Raku</blockquote><h2 id="签名httpdocrakuorgtypesignature也是对象"><a href="http://doc.raku.org/type/Signature">签名</a>也是对象</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nb">Signature</span> <span class="p">{}</span>
</code></pre></div><p>签名是代码对象<a href="https://docs.raku.org/type/Parameter">参数</a>列表的静态描述。即, 签名描述了你需要什么参数和多少参数传递给代码或函数以调用它们。</p>
<p>传递参数给签名把包含在 <strong><a href="https://docs.raku.org/type/Capture">Capture</a></strong> 中的参数绑定到了签名上。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; sub a<span class="o">(</span><span class="nv">$a</span>, <span class="nv">$b</span><span class="o">)</span> <span class="o">{}</span><span class="p">;</span>
&gt; <span class="p">&amp;</span>a.signature.perl.say
:<span class="o">(</span><span class="nv">$a</span>, <span class="nv">$b</span><span class="o">)</span>
&gt; my <span class="nv">$b</span> <span class="o">=</span> -&gt; <span class="nv">$a</span>, <span class="nv">$b</span> <span class="o">{}</span><span class="p">;</span>
&gt; <span class="nv">$b</span>.signature.perl.say
:<span class="o">(</span><span class="nv">$a</span>, <span class="nv">$b</span><span class="o">)</span>
</code></pre></div><p>签名是一个对象, 就像 Raku 中的任何其它东西一样。 任何 <strong>Callable</strong> 类型中都有签名, 并且它能使用 <code>.signature</code> 方法获取到。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nb">Signature</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="签名字面量">签名字面量</h2>
<p>签名出现在<a href="https://docs.raku.org/type/Sub">子例程</a>和<a href="https://docs.raku.org/type/Method">方法</a>名后面的圆括号中, 对于 blocks 签名出现在 <code>-&gt;</code> 或 <code>&lt;-&gt;</code> 箭头后面, 或者作为<a href="https://docs.raku.org/language/variables#Variable_Declarators_and_Scope">变量声明符</a>(例如 <a href="https://docs.raku.org/syntax/my">my</a> )的输入, 或者以冒号开头作为单独的项。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">#    ^^^^ sub f 的签名</span>
<span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">#       ^^ 方法 x 的签名</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">(</span><span class="o">*</span><span class="nv">@a</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">#           ^^^^^ 匿名函数的签名</span>

<span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">#              ^^    Block 的签名</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">@b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="o">,</span> <span class="p">(</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="p">);</span>
<span class="c1">#  ^^^^^^^^ 变量声明符的签名</span>

<span class="k">my</span> <span class="nv">$sig</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">);</span>
<span class="c1">#          ^^^^^^^^ 独立的签名对象</span>
</code></pre></div><p>签名字面量可以用于定义回调或闭包的签名。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">&amp;c:</span><span class="p">(</span><span class="nb">Int</span><span class="p">))</span>    <span class="p">{}</span>
<span class="k">sub</span> <span class="nf">will-work</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">sub</span> <span class="nf">won&#39;t-work</span><span class="p">(</span><span class="nb">Str</span><span class="p">){}</span>
<span class="nb">f</span><span class="p">(</span><span class="nv">&amp;will-work</span><span class="p">);</span>

<span class="nb">f</span><span class="p">(</span><span class="nv">&amp;won&#39;t-work</span><span class="p">);</span>
<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1"># OUTPUT: «X::TypeCheck::Binding::Parameter: Constraint type check failed in binding to parameter &#39;&amp;c&#39;␤»</span>

<span class="nb">f</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">this works too</span><span class="p">&#39;</span> <span class="p">}</span> <span class="p">);</span>
</code></pre></div><p>支持签名和列表(List)间的智能匹配。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sig</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$i</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$s</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">answer</span><span class="p">&#39;)</span> <span class="o">~~</span> <span class="nv">$sig</span><span class="p">;</span> <span class="c1"># OUTPUT: «True␤» </span>

<span class="k">my</span> <span class="nv">$sub</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">(</span> <span class="nb">Str</span> <span class="nv">$s</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$i</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$s</span> <span class="ow">xx</span> <span class="nv">$i</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">$sub</span><span class="o">.</span><span class="nb">signature</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span> <span class="nb">Str</span><span class="o">,</span> <span class="nb">Int</span> <span class="p">);</span> <span class="c1"># OUTPUT: «True␤» </span>

<span class="k">given</span> <span class="nv">$sig</span> <span class="p">{</span>
    <span class="k">when</span> <span class="o">:</span><span class="p">(</span><span class="nb">Str</span><span class="o">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mismatch</span><span class="p">&#39;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="o">:</span><span class="p">(</span><span class="nv">$</span><span class="o">,</span> <span class="nv">$</span><span class="p">)</span>     <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">match</span><span class="p">&#39;</span> <span class="p">}</span>
    <span class="k">default</span>          <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">no match</span><span class="p">&#39;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="c1"># OUTPUT: «match␤» </span>
</code></pre></div><p>它匹配第二个 <code>when</code> 从句, 因为 <code>:($, $)</code> 表示带有两个标量, 匿名参数的 <code>Signature</code>, 它是 <code>$sig</code> 的更一版版本。</p>
<p>当和散列智能匹配时, 签名被认为由散列的键组成。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="s">left</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">right</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%h</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="nv">$left</span><span class="o">,</span> <span class="o">:</span><span class="nv">$right</span><span class="p">);</span>
<span class="c1"># OUTPUT</span>
<span class="c1"># True</span>
</code></pre></div><h3 id="参数分隔符">参数分隔符</h3>
<p>签名由逗号分割的 0 个或多个<a href="https://docs.raku.org/type/Parameter">形式参数</a>组成。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sig</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">@b</span><span class="o">,</span> <span class="nv">%c</span><span class="p">)</span>
<span class="k">sub</span> <span class="nb">add</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span>
</code></pre></div><p>作为一个例外, 签名中的第一个参数的后面可以跟着一个冒号而非逗号来标记方法的调用者。调用者是用来调用方法的对象, 其通常绑定到 <a href="https://docs.raku.org/routine/self">self</a>。 通过在签名中指定调用者, 你可以更改它绑定到的变量名称。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="p">(</span><span class="nv">$a:</span> <span class="nv">@b</span><span class="o">,</span> <span class="nv">%c</span><span class="p">){}</span>  <span class="c1"># 第一个参数是调用者</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">whoami</span> <span class="p">(</span><span class="nv">$me:</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">Well I&#39;m class </span><span class="nv">$me</span><span class="o">.</span><span class="nf">^name</span><span class="p">()</span><span class="s2">, of course!</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Foo</span><span class="o">.</span><span class="nf">whoami</span><span class="p">;</span> <span class="c1"># Well I&#39;m class Foo, of course!</span>
</code></pre></div><h3 id="类型约束">类型约束</h3>
<p>参数可以可选地拥有一个类型约束(默认为 <a href="https://docs.raku.org/type/Any">Any</a>)。这些能用于限制函数允许的输入。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sig</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">divisors</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$_</span> <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$n</span> <span class="p">}</span>
<span class="n">divisors</span> <span class="mf">2.5</span><span class="p">;</span> <span class="c1"># !!! Calling &#39;divisors&#39; will never work with argument types (Rat)</span>
<span class="c1"># ===SORRY!=== Error while compiling: </span>
<span class="c1"># Calling divisors(Rat) will never work with declared signature (Int $n) </span>
</code></pre></div><p>匿名参数也行, 如果参数只需要它的类型约束的话。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sig</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$</span><span class="o">,</span> <span class="nv">@</span><span class="o">,</span> <span class="nv">%a</span><span class="p">)</span>         <span class="c1"># 两个匿名参数和一个 &#34;正常的(有名字的)&#34;参数</span>
<span class="nv">$sig</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Positional</span><span class="p">)</span>     <span class="c1"># 只有类型也行(两个参数)</span>
<span class="k">sub</span> <span class="nf">baz</span> <span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="p">{&#34;</span><span class="s2">Got passed a Str</span><span class="p">&#34;}</span>
</code></pre></div><p>类型约束也可以是类型捕获(<a href="http://doc.raku.org/type/Signature#Type_Captures">type captures</a>)。</p>
<p>除了这些名义上的类型之外, 额外的约束可以以代码块的形式加到参数上, 代码块必须返回一个真值以通过类型检测。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">}</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$y</span> <span class="o">&gt;=</span> <span class="nv">$x</span> <span class="p">})</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p><code>where</code> 子句中的代码有一些限制：任何会产生副作用的东西（例如, 打印输出, 从迭代器中拉取或递增状态变量）都不受支持, 如果使用了, 可能会产生令人惊讶的结果。此外, 在某些实现中, <code>where</code> 子句的代码可能会针对单个类型检查运行多次。</p>
<p><code>where</code> 子句不需要是代码块, <code>where</code> 子句右侧的任何内容都将用于和参数<a href="https://docs.raku.org/language/operators#infix_~~">智能匹配</a>。所以你也可以写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">factorial</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">factorial</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">)</span>        <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nf">factorial</span><span class="p">(</span><span class="nv">$x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>第一个还能简化为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre></div><p>你可以直接把字面量用作类型并把值约束到匿名参数上。</p>
<p><strong>提示</strong>：注意不要在你有几个条件时不小心离开区块：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">-&gt;</span> <span class="nv">$y</span> <span class="k">where</span>   <span class="o">.</span><span class="nb">so</span> <span class="o">&amp;&amp;</span> <span class="o">.</span><span class="nb">name</span>    <span class="p">{}(</span> <span class="k">sub</span> <span class="nb">one</span>   <span class="p">{}</span> <span class="p">);</span> <span class="c1"># WRONG!! </span>
<span class="k">-&gt;</span> <span class="nv">$y</span> <span class="k">where</span> <span class="p">{</span> <span class="o">.</span><span class="nb">so</span> <span class="o">&amp;&amp;</span> <span class="o">.</span><span class="nb">name</span> <span class="p">}</span>  <span class="p">{}(</span> <span class="k">sub</span> <span class="nf">two</span>   <span class="p">{}</span> <span class="p">);</span> <span class="c1"># OK! </span>
<span class="k">-&gt;</span> <span class="nv">$y</span> <span class="k">where</span>   <span class="o">.</span><span class="nb">so</span> <span class="o">&amp;</span>  <span class="o">.</span><span class="nb">name</span><span class="o">.</span><span class="nb">so</span> <span class="p">{}(</span> <span class="k">sub</span> <span class="nf">three</span> <span class="p">{}</span> <span class="p">);</span> <span class="c1"># Also good </span>
</code></pre></div><p>第一个版本是错误的, 会发出一个关于 sub 对象强制转换为字符串的警告。原因是表达式相当于 <code>($y ~~ ($y.so &amp;&amp; $y.name));</code> 那就是“调用 <code>.so</code>, 如果它为 <code>True</code>, 调用 <code>.name</code>; 如果这也是 <code>True</code>, 则使用它的值进行smartmatching &hellip;”。这是 <code>(.so &amp;&amp; .name)</code> 的结果将被智能匹配, 但我们要检查 <code>.so</code> 和 <code>.name</code> 是否为真值。这就是为什么明确的 Block 或者 <a href="https://docs.raku.org/type/Junction">Junction</a> 是正确的版本。</p>
<p>在签名中不是子签名(sub-signature)的一部分的所有先前的参数都可以在参数后面的 <code>where</code> 从句中访问。 因此, 最后一个参数的 where 从句可以访问不是子签名一部分的签名的所有参数。 对于子签名, 把 where 从句放在子签名中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">where</span> <span class="o">*</span> <span class="o">==</span> <span class="nv">$a</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$b</span><span class="s2"> is a square of </span><span class="nv">$a</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="n">foo</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="p">;</span> <span class="c1"># OUTPUT: «4 is a square of 2␤»» </span>
<span class="c1"># foo 2, 3; </span>
<span class="c1"># OUTPUT: «Constraint type check failed in binding to parameter &#39;$b&#39;…» </span>

<span class="k">sub</span> <span class="nf">one-of-them</span><span class="p">(</span><span class="o">:</span><span class="nv">$a</span><span class="o">,</span> <span class="o">:</span><span class="nv">$b</span><span class="o">,</span> <span class="o">:</span><span class="nv">$c</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">defined</span> <span class="o">^^</span> <span class="nv">$b</span><span class="o">.</span><span class="nb">defined</span> <span class="o">^^</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">defined</span> <span class="p">})</span> <span class="p">{</span>
    <span class="nv">$a</span> <span class="o">//</span> <span class="nv">$b</span> <span class="o">//</span> <span class="nv">$c</span>
<span class="p">};</span>
<span class="nb">say</span> <span class="nf">one-of-them</span><span class="p">(</span><span class="s">c</span><span class="o">=&gt;</span><span class="mi">42</span><span class="p">);</span>
<span class="c1"># OUTPUT«42␤»</span>
</code></pre></div><h3 id="约束可选参数">约束可选参数</h3>
<p><a href="https://docs.raku.org/type/Signature#Optional_and_Mandatory_Parameters">可选参数</a>也可以拥有约束。任何参数 <code>where</code> 从句都将被执行, 即使它是可选的, 而且不是由调用者提供。在这种情况下, 您可能必须防止 where 从句中的未定义值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">UInt</span> <span class="nv">$i</span><span class="o">?</span> <span class="k">where</span> <span class="p">{</span> <span class="o">!</span><span class="nv">$i</span><span class="o">.</span><span class="nb">defined</span> <span class="ow">or</span> <span class="nv">$i</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h4 id="约束吞噬参数">约束吞噬参数</h4>
<p><a href="https://docs.raku.org/type/Slurpy_(A$FULL_STOPK$FULL_STOPA$FULL_STOP_Variadic)_Parameters">吞噬参数</a>不能拥有类型约束。一个 where 从句连同一个 <a href="https://docs.raku.org/type/Junction">Junction</a>可以达到同样的那个效果。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">*</span><span class="nv">@a</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="nb">Int</span> <span class="p">})</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">@a</span> <span class="p">};</span>
<span class="nb">f</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nb">f</span><span class="p">(&lt;</span><span class="s">a</span><span class="p">&gt;);</span>
<span class="c1"># OUTPUT«[42] Constraint type check failed for parameter &#39;@a&#39;  in sub f at ...»</span>
</code></pre></div><h4 id="约束定义值和未定义值">约束定义值和未定义值</h4>
<p>通常, 类型约束只检查传递的值是否是正确的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">limit-lines</span> <span class="p">(</span><span class="nb">Str</span> <span class="nv">$s</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$limit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
    <span class="nv">@lines</span><span class="o">[</span><span class="mi">0</span> <span class="o">..^</span> <span class="nb">min</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">elems</span><span class="o">,</span> <span class="nv">$limit</span><span class="o">].</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="p">(</span><span class="n">limit-lines</span> <span class="p">&#34;</span><span class="s2">a \n b \n c \n d \n</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># &#34;a \n b \n c &#34;</span>
<span class="nb">say</span> <span class="n">limit-lines</span> <span class="nb">Str</span><span class="o">,</span>      <span class="mi">3</span><span class="p">;</span>  <span class="c1"># Uh-oh. Dies with &#34;Cannot call &#39;lines&#39;;&#34;</span>

<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1"># OUTPUT: «X::Multi::NoMatch: Cannot resolve caller lines(Str: ); none of these signatures match:</span>
<span class="c1">#     (Cool:D $: |c is raw)</span>
<span class="c1">#     (Str:D $: :$count!, *%_)</span>
<span class="c1">#     (Str:D $: $limit, *%_)</span>
<span class="c1">#     (Str:D $: *%_)»</span>

<span class="nb">say</span> <span class="n">limit-lines</span> <span class="p">&#34;</span><span class="s2">a \n b</span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">Int</span> <span class="c1"># Always returns the max number of lines</span>
</code></pre></div><p>这样的情况, 我们其实只想处理定义了的字符串。要这样做, 我们使用 <code>:D</code> 类型约束。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">limit-lines</span> <span class="p">(</span><span class="nb">Str:D</span> <span class="nv">$s</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$limit</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">limit-lines</span> <span class="nb">Str</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1"># OUTPUT«X::AdHocParameter &#39;$s&#39; requires an instance of type Str, but a</span>
<span class="c1"># type object was passed.  Did you forget a .new?»</span>
<span class="c1"># Dies with &#34;参数 &#39;$s&#39; 需要一个实例, 但是函数 limit-lines 中却传递了一个类型对象。</span>
</code></pre></div><p>如果传递一个诸如 <strong>Str</strong> 这样的类型对象进去, 那么就会报错。这样的失败方式比以前更好了, 因为失败的原因更清晰了。</p>
<p>也有可能未定义的类型是子例程唯一有意义的接收值。这可以使用 <code>:U</code> 类型约束来约束它。例如, 我们可以把 <code>&amp;limit-lines</code> 转换成 multi 函数以使用 <code>:U</code> 约束。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span>  <span class="nf">limit-lines</span> <span class="p">(</span><span class="nb">Str</span> <span class="nv">$s</span><span class="o">,</span> <span class="nb">Int:D</span> <span class="nv">$limit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
    <span class="nv">@lines</span><span class="o">[</span><span class="mi">0</span> <span class="o">..^</span> <span class="nb">min</span> <span class="nv">@lines</span><span class="o">.</span><span class="nb">elems</span><span class="o">,</span> <span class="nv">$limit</span><span class="o">].</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nf">limit-lines</span> <span class="p">(</span><span class="nb">Str</span> <span class="nv">$s</span><span class="o">,</span> <span class="nb">Int:U</span> <span class="nv">$</span><span class="p">)</span> <span class="p">{</span><span class="nv">$s</span><span class="p">}</span> <span class="c1"># 如果传递给我一个未定义的类型对象, 就返回整个字符串</span>

<span class="nb">say</span> <span class="n">limit-lines</span> <span class="p">&#34;</span><span class="s2">a \n b \n c</span><span class="p">&#34;</span><span class="o">,</span> <span class="nb">Int</span><span class="p">;</span>      <span class="c1"># &#34;a \n b \n c&#34;</span>
</code></pre></div><p>为了显式地标示常规的行为, 可以使用 <code>:_</code>, 但这不是必须的。 <code>:(Num:_ $)</code> 和 <code>:(Num $)</code> 相同。</p>
<h4 id="约束-callables-的签名">约束 Callables 的签名</h4>
<p>要基于 block和子例程的签名约束 block 和子例程引用, 参数名要写在签名的后面。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">&amp;c:</span><span class="p">(</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="p">))</span>  <span class="p">{</span> <span class="nb">say</span> <span class="nf">c</span><span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">ten</span><span class="p">&#39;)</span> <span class="p">};</span>
<span class="k">sub</span> <span class="nf">g</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$i</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$s</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$s</span> <span class="o">~</span> <span class="nv">$i</span>          <span class="p">};</span>

<span class="nb">f</span><span class="p">(</span><span class="nv">&amp;g</span><span class="p">);</span>

<span class="c1"># OUTPUT: ten10</span>
</code></pre></div><h4 id="约束返回类型">约束返回类型</h4>
<p><code>--&gt;</code> 标记后面跟着一个类型会强制在子例程执行成功时进行类型检测。返回类型箭头必须放在参数列表的后面。跟在签名声明后面的 <code>returns</code> 关键字有同样的功能。<code>Nil</code> 在类型检测中被认为是定义了的。这允许沿着调用链返回和传递 <a href="https://docs.raku.org/type/Failure">Failure</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="p">(</span><span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span>   <span class="p">{</span> <span class="k">my</span> <span class="nb">Int</span> <span class="nv">$i</span><span class="p">;</span> <span class="nv">$i</span><span class="p">};</span>
<span class="k">sub</span> <span class="p">(</span><span class="k">--&gt;</span> <span class="nb">Int:D</span><span class="p">)</span>    <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">sub</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Int</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>

<span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>
<span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">returns</span> <span class="nb">Int</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>        <span class="c1"># 同上</span>
<span class="k">sub</span> <span class="nf">does-not-work</span><span class="p">(</span><span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;&#34;</span> <span class="p">};</span> <span class="c1"># throws X::TypeCheck::Return</span>
</code></pre></div><p>如果类型约束是一个常量表达式, 那么它被用于子例程的返回值。那个子例程中的任何 <strong>return</strong> 语句必须是不含参数的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="k">--&gt;</span> <span class="mi">123</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</code></pre></div><p><code>Nil</code> 和 <code>Failure</code> 总是被允许作为返回类型, 不管类型约束是什么。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nb">Nil</span> <span class="p">};</span>
<span class="nb">say</span> <span class="n">foo</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># Nil</span>
</code></pre></div><p>不支持类型捕获和强制类型。</p>
<h4 id="强制类型">强制类型</h4>
<p>要接受一个类型但是强制它自动地转为另一种类型, 使用接受的类型作为目标类型的参数。如果接受的类型是 Any, 那么它可以被省略。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nb">Int</span><span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="nv">$want-int</span><span class="o">,</span> <span class="nb">Str</span><span class="p">()</span> <span class="nv">$want-str</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$want-int</span><span class="o">.</span><span class="nb">WHAT</span><span class="o">,</span> <span class="nv">$want-str</span><span class="o">.</span><span class="nb">WHAT</span> <span class="p">}</span>
<span class="nb">f</span> <span class="p">&#39;</span><span class="s1">10</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">10</span><span class="p">;</span>

<span class="c1"># OUTPUT</span>
<span class="c1"># (Int)(Str)</span>
</code></pre></div><h3 id="吞噬参数或长度可变参数">吞噬参数(或长度可变参数)</h3>
<p>数组或散列参数可以通过前置一个星号(s)被标记为吞噬参数, 这意味着它可以被绑定给任意数量的参数(0 个或 多个)。</p>
<p>它们被叫做吞噬参数, 因为它们吞完函数中的任何剩余参数, 就像有些人吞吃面条那样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">@b</span><span class="p">)</span>  <span class="c1"># 正好两个参数, 而第二个参数必须是 Positional 的</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="o">*</span><span class="nv">@b</span><span class="p">)</span> <span class="c1"># 至少一个参数, @b 吞噬完任何剩余的参数</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">*</span><span class="nv">%h</span><span class="p">)</span>     <span class="c1"># 没有位置参数, 除了任意数量的具名参数</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">one-arg</span> <span class="p">(</span><span class="nv">@</span><span class="p">)</span>  <span class="p">{</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nb">slurpy</span>  <span class="p">(</span><span class="o">*</span><span class="nv">@</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="n">one-arg</span> <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="p">);</span>   <span class="c1"># ok, same as one-arg((5, 6, 7))</span>
<span class="nb">slurpy</span>  <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="p">);</span>   <span class="c1"># ok</span>
<span class="nb">slurpy</span>   <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span> <span class="p">;</span>   <span class="c1"># ok</span>
<span class="c1"># one-arg(5, 6, 7) ; # X::TypeCheck::Argument</span>
<span class="c1"># one-arg  5, 6, 7 ; # X::TypeCheck::Argument</span>

<span class="k">sub</span> <span class="nf">named-names</span> <span class="p">(</span><span class="o">*</span><span class="nv">%named-args</span><span class="p">)</span> <span class="p">{</span> <span class="nv">%named-args</span><span class="o">.</span><span class="nb">keys</span> <span class="p">};</span>
<span class="nb">say</span> <span class="n">named-names</span> <span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="p">:</span><span class="s">bar</span><span class="p">&lt;</span><span class="s">baz</span><span class="p">&gt;;</span> <span class="c1"># foo bar</span>
</code></pre></div><p>注意位置参数不允许出现在吞噬参数的后面。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">:</span><span class="p">(</span><span class="o">*</span><span class="nv">@args</span><span class="o">,</span> <span class="nv">$last</span><span class="p">);</span>
<span class="k">CATCH</span> <span class="p">{</span> <span class="k">when</span> <span class="ne">X::Parameter::WrongOrder</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">}</span>
<span class="c1"># OUTPUT«X::Parameter::WrongOrder: 不能把必要参数放在可变长度参数的后面»</span>
</code></pre></div><p>带有一个星号的吞噬参数会通过消融一层或多层裸的可迭代对象来展平参数。带有两个星号的吞噬参数不会展平参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">a</span><span class="p">(</span><span class="o">*</span><span class="nv">@a</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">|</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span> <span class="p">};</span>
<span class="k">sub</span> <span class="nf">b</span><span class="p">(</span><span class="o">**</span><span class="nv">@b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@b</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">|</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span> <span class="p">};</span>

<span class="nf">a</span><span class="p">(</span><span class="mi">1</span><span class="o">,[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span><span class="p">(</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span><span class="mi">5</span><span class="p">));</span>    <span class="c1">#  1|1|2|3|4|5</span>
<span class="nf">b</span><span class="p">(</span><span class="mi">1</span><span class="o">,[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],</span><span class="p">(</span><span class="o">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span><span class="mi">5</span><span class="p">));</span>    <span class="c1"># 1|1 2|3 4 5</span>

</code></pre></div><p>通常, 吞噬参数会创建一个数组, 为每个 argument 创建一个标量容器, 并且把每个参数的值赋值给那些标量。如果在该过程中原参数也有一个中间的标量分量, 那么它在调用函数中是访问不到的。</p>
<p>吞噬参数在和某些 <a href="http://doc.raku.org/type/Signature#Parameter_Traits_and_Modifiers">traits and modifiers</a> 组合使用时会有特殊行为, 像下面描述的那样。</p>
<h3 id="single-argument-rule-slurpy">Single Argument Rule Slurpy</h3>
<p>单一参数规则允许根据上下文处理子程序、for-loop 和列表构造函数的参数。许多位置类型的方法可以像处理列表或参数一样处理单个参数。在 Signature 中使用 <code>+@</code> 作为标志, 提供了语法糖, 使这项工作更容易一些。任何非位置类型的单一参数都会被提升为一个具有单一项的列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">+</span><span class="nv">@a</span><span class="p">){</span> <span class="n">dd</span> <span class="nv">@a</span> <span class="p">};</span>
<span class="nb">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="c1"># OUTPUT«[1]␤»</span>
<span class="nb">f</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="c1"># OUTPUT«[1, 2, 3]␤»</span>
<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
<span class="nb">f</span> <span class="nv">@b</span><span class="p">;</span>
<span class="c1"># OUTPUT«[&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]␤»</span>
</code></pre></div><h3 id="类型捕获">类型捕获</h3>
<p>类型捕获允许把类型约束的说明推迟到函数被调用时。它们允许签名和函数体中的类型都可以引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">:</span><span class="p">:</span><span class="s">T</span> <span class="nv">$p1</span><span class="o">,</span> <span class="nb">T</span> <span class="nv">$p2</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">C</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># $p1 和 $p2 的类型都为 T, 但是我们还不知道具体类型是什么</span>
    <span class="c1"># C 将会保存一个源于类型对象或值的类型</span>
    <span class="k">my</span> <span class="n">C</span> <span class="nv">$closure</span> <span class="o">=</span> <span class="nv">$p1</span> <span class="o">/</span> <span class="nv">$p2</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">sub</span> <span class="p">(</span><span class="nb">T</span> <span class="nv">$p1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$closure</span> <span class="o">*</span> <span class="nv">$p1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 第一个参数是 Int 类型, 所以第二个参数也是</span>
<span class="c1"># 我们从调用用于 &amp;f 中的操作符导出第三个类型</span>
<span class="k">my</span> <span class="nv">&amp;s</span> <span class="o">=</span> <span class="nb">f</span><span class="p">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span> <span class="nb">Int</span><span class="o">.</span><span class="nb">new</span> <span class="o">/</span> <span class="nb">Int</span><span class="o">.</span><span class="nb">new</span><span class="p">);</span>
<span class="nb">say</span> <span class="k">s</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c1"># 10 / 2 * 2  == 10</span>
</code></pre></div><h3 id="positional-vs-named">Positional vs. Named</h3>
<p>参数可以是跟位置有关的或者是具名的。所有的参数都是 positional 的, 除了吞噬型散列参数和有前置冒号标记的参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span>   <span class="c1"># 位置参数</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="nv">$a</span><span class="p">)</span>  <span class="c1"># 名字为 a 的具名参数</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">*</span><span class="nv">@a</span><span class="p">)</span>  <span class="c1"># 吞噬型位置参数</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">*</span><span class="nv">%h</span><span class="p">)</span>  <span class="c1"># 吞噬型具名参数</span>
</code></pre></div><p>在调用者这边, 位置参数的传递顺序和它们声明顺序相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">pos</span><span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">x = </span><span class="nv">$x</span><span class="s2"> y = </span><span class="nv">$y</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="nb">pos</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">#  x = 4 y = 5</span>
</code></pre></div><p>对于具名实参和具名形参, 只用名字用于将实参映射到形参上。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">named</span><span class="p">(</span><span class="o">:</span><span class="nv">$x</span><span class="o">,</span> <span class="o">:</span><span class="nv">$y</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">x=</span><span class="nv">$x</span><span class="s2"> y=</span><span class="nv">$y</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="nb">named</span><span class="p">(</span> <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">5</span>, <span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></div><p>具名参数也可以和变量的名字不同:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">named</span><span class="p">(:</span><span class="s">official</span><span class="p">(</span><span class="nv">$private</span><span class="p">))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">公务</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$private</span> <span class="p">}</span>
<span class="nb">named</span> <span class="p">:</span><span class="s">official</span><span class="p">;</span>
</code></pre></div><p>别名也是那样做的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="p">(</span> <span class="p">:</span><span class="s">color</span><span class="p">(:</span><span class="s">colour</span><span class="p">(</span><span class="nv">$c</span><span class="p">))</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># &#39;color&#39; 和 &#39;colour&#39; 都可以</span>
<span class="k">sub</span> <span class="p">(</span> <span class="p">:</span><span class="s">color</span><span class="p">(</span><span class="o">:</span><span class="nv">$colour</span><span class="p">)</span> <span class="p">)</span>    <span class="p">{</span> <span class="p">}</span> <span class="c1"># same API for the caller</span>
</code></pre></div><p>带有具名参数的函数可以被动态地调用, 使用 <code>|</code>非关联化一个 Pair 来把它转换为一个具名参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nb">f</span><span class="p">(</span><span class="o">:</span><span class="nv">$named</span><span class="p">)</span> <span class="p">{</span> <span class="nb">note</span> <span class="nv">&amp;?ROUTINE</span><span class="o">.</span><span class="nb">signature</span> <span class="p">};</span>
<span class="k">multi</span> <span class="nb">f</span><span class="p">(</span><span class="o">:</span><span class="nv">$also-named</span><span class="p">)</span> <span class="p">{</span> <span class="nb">note</span> <span class="nv">&amp;?ROUTINE</span><span class="o">.</span><span class="nb">signature</span> <span class="p">};</span>

<span class="k">for</span> <span class="p">&#39;</span><span class="s1">named</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">also-named</span><span class="p">&#39;</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
    <span class="nb">f</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="nv">$n</span> <span class="o">=&gt;</span> <span class="nb">rand</span><span class="p">))</span>      <span class="c1"># «(:$named)␤(:$also-named)␤»</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$pair</span> <span class="o">=</span> <span class="p">:</span><span class="s">named</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">f</span> <span class="o">|</span><span class="nv">$pair</span><span class="p">;</span> <span class="c1"># «(:$named)␤»</span>
</code></pre></div><p>同样的语法也可以用于将散列转换为具名参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%pairs</span> <span class="o">=</span> <span class="s">also-named</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{};</span>
<span class="nb">f</span> <span class="o">|</span><span class="nv">%pairs</span><span class="p">;</span>        <span class="c1"># (:$also-named)</span>
</code></pre></div><h3 id="可选参数和强制参数">可选参数和强制参数</h3>
<p>Positional 参数默认是强制的, 也可以用默认值或结尾的问号使参数成为可选的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$id</span><span class="p">)</span>         <span class="c1"># 必要参数 required parameter</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$base</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>      <span class="c1"># 可选参数, 默认为 10</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="o">?</span><span class="p">)</span>         <span class="c1"># 可选参数, 默认为 Int 类型的对象</span>
</code></pre></div><p>具名参数默认是可选的, 可以通过在参数末尾加上一个感叹号使它变成强制参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="nv">%config</span><span class="p">)</span>        <span class="c1"># 可选参数</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="nv">$debug</span> <span class="o">=</span> <span class="nb">False</span><span class="p">)</span> <span class="c1"># 可选参数, 默认为 False</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="o">!</span><span class="p">)</span>         <span class="c1"># 名为 name 的强制具名参数</span>
</code></pre></div><p>默认值可以依靠之前的参数, 并且每次调用都会被重新计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="nv">$goal</span><span class="o">,</span> <span class="nv">$accuracy</span> <span class="o">=</span> <span class="nv">$goal</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>
<span class="nv">$</span> <span class="o">=</span> <span class="o">:</span><span class="p">(</span><span class="o">:</span><span class="nv">$excludes</span> <span class="o">=</span> <span class="o">[</span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">..</span><span class="p">&#39;</span><span class="o">]</span><span class="p">);</span> <span class="c1"># a new Array for every call</span>
</code></pre></div><h3 id="解构参数">解构参数</h3>
<p>参数后面可以跟着一个由括号括起来的 <code>sub-signature</code>, 子签名会解构给定的参数。列表解构成它的元素:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">first</span> <span class="p">(</span><span class="nv">@array</span> <span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="o">*</span><span class="nv">@rest</span><span class="p">))</span> <span class="p">{</span> <span class="nv">$first</span> <span class="p">}</span>
</code></pre></div><p>或:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">first</span> <span class="p">(</span><span class="o">[</span><span class="nv">$first</span><span class="o">,</span> <span class="o">*</span><span class="nv">@</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$first</span> <span class="p">}</span>
</code></pre></div><p>而散列解构成它的键值对儿(pairs):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">all-dimensions</span> <span class="p">(</span><span class="nv">%</span> <span class="p">(:</span><span class="s">length</span><span class="p">(</span><span class="o">:</span><span class="nv">$x</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">width</span><span class="p">(</span><span class="o">:</span><span class="nv">$y</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">depth</span><span class="p">(</span><span class="o">:</span><span class="nv">$z</span><span class="p">)))</span> <span class="p">{</span>
    <span class="nv">$x</span> <span class="ow">andthen</span> <span class="nv">$y</span> <span class="ow">andthen</span> <span class="nv">$z</span> <span class="ow">andthen</span> <span class="nb">True</span>
<span class="p">}</span>
</code></pre></div><p><code>andthen</code> 返回第一个未定义的值, 否则返回最后一个元素。短路操作符。<code>andthen</code> 左侧的结果被绑定给 <code>$_</code> 用于右侧, 或者作为参数传递, 如果右侧是一个 <code>block</code> 或 <code>pointy block</code> 的话。</p>
<p>一般地, 对象根据它的属性解构。通用的惯用法是在 <em>for</em> 循环中解包一个 <a href="https://docs.raku.org/type/Pair">Pair</a> 的键和值:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">Peter Paul Merry</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pairs</span> <span class="k">-&gt;</span> <span class="p">(:</span><span class="s">key</span><span class="p">(</span><span class="nv">$index</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">value</span><span class="p">(</span><span class="nv">$guest</span><span class="p">))</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>但是, 将对象解包为属性只是默认行为。要使对象以不同方式解构, 请更改其 <a href="https://docs.raku.org/routine/Capture">Capture</a> 方法。</p>
<h3 id="子签名">子签名</h3>
<p>要匹配复合参数, 请在圆括号中的参数名后面使用子签名。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="o">|</span><span class="nf">c</span><span class="p">(</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="p">)){</span>
   <span class="nb">put</span> <span class="p">&#34;</span><span class="s2">called with </span><span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="nb">perl</span><span class="p">}&#34;</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">(</span><span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">answer</span><span class="p">&#34;);</span>
<span class="c1"># OUTPUT«called with \(42, &#34;answer&#34;)»</span>
</code></pre></div><h3 id="长名字">长名字</h3>
<p>为了在多重分派中排除特定参数, 使用一个双分号来分割它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$i</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$s</span><span class="p">;;</span> <span class="o">:</span><span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="n">dd</span> <span class="nv">$i</span><span class="o">,</span> <span class="nv">$s</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">};</span>
<span class="nb">f</span><span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">answer</span><span class="p">&#39;);</span>
<span class="c1"># OUTPUT«10 &#34;answer&#34;Any $b = Any»</span>
</code></pre></div><h3 id="捕获参数">捕获参数</h3>
<p>在参数前前置一个垂直的 <code>|</code> 会让参数变为 <a href="https://docs.raku.org/type/Capture">Capture</a>, 并使用完所有剩下的位置参数和具名参数。</p>
<p>这常用在 <code>proto</code> 定义中( 像 <code>proto foo (|) {*}</code> ) 来标示例程的 <a href="https://docs.raku.org/routine/multi">multi 定义</a>可以拥有任何<a href="https://docs.raku.org/type/Signature#Type_Constraints">类型约束</a>。</p>
<p>如果绑定到变量参数, 则可以使用 slip 运算符 <code>|</code> 作为整体转发。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">a</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$i</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$s</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">WHAT</span><span class="o">,</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">WHAT</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">b</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="n">c</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="nf">a</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">}</span>
<span class="nf">b</span><span class="p">(</span><span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">answer</span><span class="p">&#34;);</span>
<span class="c1"># OUTPUT«(Capture)␤(Int)(Str)␤»</span>
</code></pre></div><h3 id="参数特性和修饰符">参数特性和修饰符</h3>
<p>默认地, 形式参数被绑定到它们的实参上并且被标记为只读。你可以使用 traits 特性更改参数的只读特性。</p>
<p><code>is copy</code>特性让参数被复制, 并允许在子例程内部修改参数的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">count-up</span> <span class="p">(</span><span class="nv">$x</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$x</span> <span class="o">=</span> <span class="no">Inf</span> <span class="k">if</span> <span class="nv">$x</span> <span class="o">~~</span> <span class="nb">Whatever</span><span class="p">;</span>
    <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>is rw</code> 特性让参数只绑定到变量上(或其它可写的容器)。 赋值给参数会改变调用一侧的变量的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">swap</span><span class="p">(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="o">,</span> <span class="nv">$y</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$y</span><span class="o">,</span> <span class="nv">$x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>对于吞噬参数, <code>is rw</code> 由语言设计者保留做将来之用</p>
<h2 id="方法">方法</h2>
<h3 id="params-方法">params 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">params</span><span class="p">(</span><span class="n">Signature:D:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Positional</span>
</code></pre></div><p>返回 <code>Parameter</code> 对象列表以组成签名。</p>
<h3 id="arity-方法">arity 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">arity</span><span class="p">(</span><span class="n">Signature:D:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回所必须的最小数量的满足签名的位置参数</p>
<h3 id="count-方法">count 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">count</span><span class="p">(</span><span class="n">Signature:D:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Real:D</span>
</code></pre></div><p>返回能被绑定给签名的最大数量的位置参数。如果有吞噬位置参数则返回 <code>Inf</code>。</p>
<h3 id="returns-方法">returns 方法</h3>
<p>签名返回的任意约束是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span><span class="o">.</span><span class="k">returns</span> <span class="c1"># Int</span>
</code></pre></div><h3 id="accepts-方法">ACCEPTS 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">ACCEPTS</span><span class="p">(</span><span class="n">Signature:D:</span> <span class="nb">Capture</span> <span class="nv">$topic</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">ACCEPTS</span><span class="p">(</span><span class="n">Signature:D:</span> <span class="nv">@topic</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">ACCEPTS</span><span class="p">(</span><span class="n">Signature:D:</span> <span class="nv">%topic</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">ACCEPTS</span><span class="p">(</span><span class="n">Signature:D:</span> <span class="nb">Signature</span> <span class="nv">$topic</span><span class="p">)</span>
</code></pre></div><p>前三个方法会看参能否绑定给 capture, 例如, 如果带有那个 Signature 的函数能使用 <code>$topic</code> 调用:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="p">)</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="nv">$bar</span><span class="p">))</span> <span class="c1"># true</span>
<span class="p">&lt;</span><span class="s">a b c d</span><span class="p">&gt;</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$a</span><span class="p">)</span>               <span class="c1"># False</span>
</code></pre></div><p>最后一个会为真如果 <code>$topic</code> 能接收的任何东西也能被 <code>Signature</code> 接收。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">:</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="nv">$foo</span><span class="o">,</span> <span class="nv">$bar</span><span class="o">,</span> <span class="nv">$baz</span><span class="o">?</span><span class="p">)</span>   <span class="c1"># True</span>
<span class="o">:</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="nb">Str</span><span class="p">)</span>                 <span class="c1"># False</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/signature" term="signature" label="signature" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 代码示例]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-02-14-raku-examples/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-02-14-raku-examples/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-12T00:00:00+08:00</published>
            <updated>2021-07-12T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Examples</blockquote><h2 id="用类来排序数组">用类来排序数组</h2>
<p>有多列数据, 序号, 学校, 课程… 年份这几列。要如果学校和课程相同就根据年份倒序排列。</p>
<p>先按学校排序, 再按课程排序, 然后按年份倒序排序。</p>
<p>我定义一个类来进行多列数据的排序, 很方便：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Course</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.numb</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.univ</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.dis</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.paper</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.cited</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.year</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@headers</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">numb univ dis paper cited year</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@courses</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">$=finish</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nb">next</span> <span class="k">if</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr">num</span><span class="p">/;</span>
    <span class="k">my</span> <span class="nv">@words</span>  <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>

    <span class="nv">@words</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="nv">@words</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">]».</span><span class="nb">Int</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">%h</span> <span class="o">=</span> <span class="nv">@headers</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@words</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$course</span> <span class="o">=</span> <span class="n">Course</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">|</span><span class="nv">%h</span><span class="p">);</span>
    <span class="nv">@courses</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$course</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@sorted</span>  <span class="o">=</span> <span class="nv">@courses</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nf">univ</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nf">dis</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">year</span><span class="p">);</span>
<span class="k">for</span> <span class="nv">@sorted</span>  <span class="p">{</span>
    <span class="nb">say</span> <span class="nb">join</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span><span class="o">,</span> <span class="o">.</span><span class="nf">numb</span><span class="o">,</span> <span class="o">.</span><span class="nf">univ</span><span class="o">,</span> <span class="o">.</span><span class="nf">dis</span><span class="o">,</span> <span class="o">.</span><span class="nf">paper</span><span class="o">,</span> <span class="o">.</span><span class="nf">cited</span><span class="o">,</span> <span class="o">.</span><span class="nb">year</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">=finish</span><span class="sd">
</span><span class="sd">num	univ	dis	paper	cited	year
</span><span class="sd">1	Beijing	Physics	193	4555	2005
</span><span class="sd">2	Beijing	Physics	197	2799	2006
</span><span class="sd">3	Beijing	Physics	240	2664	2007
</span><span class="sd">4	Beijing	Physics	200	3191	2008
</span><span class="sd">5	Beijing	Physics	268	2668	2009
</span><span class="sd">6	Beijing	Physics	249	2300	2010
</span><span class="sd">7	Beijing	Physics	262	2080	2011
</span><span class="sd">8	Beijing	Physics	230	2371	2012
</span><span class="sd">9	Beijing	Physics	309	1367	2013
</span><span class="sd">10	Beijing	Physics	284	615	2014
</span><span class="sd">11	Beijing	Chemistry	143	1650	2005
</span><span class="sd">12	Beijing	Chemistry	149	2379	2006
</span><span class="sd">13	Beijing	Chemistry	190	2566	2007
</span><span class="sd">14	Beijing	Chemistry	147	1888	2008
</span><span class="sd">15	Beijing	Chemistry	184	2146	2009
</span><span class="sd">16	Beijing	Chemistry	214	2568	2010
</span><span class="sd">17	Beijing	Chemistry	238	2874	2011
</span><span class="sd">18	Beijing	Chemistry	265	2097	2012
</span><span class="sd">19	Beijing	Chemistry	251	1303	2013
</span><span class="sd">20	Beijing	Chemistry	241	656	2014
</span></code></pre></div><h2 id="斐波拉契数列fibonacci-sequence">斐波拉契数列（Fibonacci Sequence）</h2>
<ul>
<li>analytic</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">0</span><span class="o">..*</span>  <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">constant</span> <span class="no">phi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">sqrt</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span> <span class="n">phi</span><span class="o">**</span><span class="p">(</span><span class="nv">$n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sqrt</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>这种方法计算前1000个斐波拉契数大约为0.746s（2015.7.Rakudo, 以下都是）。</p>
<ul>
<li>迭代</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">state</span> <span class="nv">@sequence</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="nv">@sequence</span><span class="o">.</span><span class="nb">elems</span> <span class="o">&lt;=</span> <span class="nv">$n</span> <span class="p">{</span>
        <span class="nv">@sequence</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span> <span class="nv">@sequence</span><span class="o">[*-</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="nv">@sequence</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">@sequence</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>这种遍历法大概需要 1 秒多。</p>
<ul>
<li>递归</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">0</span><span class="o">..*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>比较慢。第 20 个之后越来越慢。</p>
<ul>
<li>递归 - 超运算符</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">0</span><span class="o">..*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">[+]</span> <span class="p">(</span><span class="nv">$n-1</span><span class="o">,</span> <span class="nv">$n-2</span><span class="p">)</span><span class="o">».</span><span class="nv">&amp;fibonacci</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>和上面差不多。</p>
<ul>
<li>递归 - map</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">0</span><span class="o">..*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">[+]</span> <span class="nb">map</span> <span class="nv">&amp;fibonacci</span><span class="o">,</span> <span class="p">(</span><span class="nv">$n-1</span><span class="o">,</span> <span class="nv">$n-2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>同上。</p>
<ul>
<li>递归 - multi</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>比上一个稍快。</p>
<ul>
<li>递归 - multi_cached</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>

<span class="k">my</span> <span class="nv">%cached</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">%cached</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">//=</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>花费 0.849s 执行完毕。</p>
<ul>
<li>递归 - multi_cached_state</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">state</span> <span class="nv">%cached</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">%cached</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">//=</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>花费了 0.885s。</p>
<ul>
<li>递归 - multi_cached_trait</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="k">is</span> <span class="k">cached</span> <span class="p">{</span>
    <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$n-2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>目前报错。</p>
<ul>
<li>序列</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">constant</span> <span class="nv">@sequence</span> <span class="o">:=</span>  <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">@sequence</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>花费了 1.6s 多。 其中 <code>:=</code> 是惰性赋值。按需求值。</p>
<ul>
<li>序列 - inline</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%3d</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>花费了 133.808s。</p>
<h2 id="排序">排序</h2>
<ul>
<li>bogosort</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">sub</span> <span class="nf">bogosort</span> <span class="p">(</span> <span class="o">*</span><span class="nv">@list</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">until</span> <span class="o">[!</span><span class="nb">after</span><span class="o">]</span> <span class="nv">@list</span> <span class="p">{</span>
        <span class="nv">@list</span> <span class="o">.=</span> <span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nv">@list</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#my @data = 6, 7, 2, 1, 8, 9, 2;</span>
<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span>  <span class="p">&lt;</span><span class="s"> p e r l s i x </span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">input  = </span><span class="p">&#39;</span> <span class="o">~</span>          <span class="nv">@data</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">output = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="n">bogosort</span> <span class="nv">@data</span><span class="p">;</span>
</code></pre></div><p>输出：</p>
<pre><code>input  = p e r l s i x
output = e i l p r s x
[Finished in 1.326s]
</code></pre><ul>
<li>mergesort</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">sub</span> <span class="nb">merge</span> <span class="p">(</span><span class="nv">@a</span><span class="o">,</span> <span class="nv">@b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">gather</span> <span class="k">while</span> <span class="nv">@a</span> <span class="o">&amp;&amp;</span> <span class="nv">@b</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="ow">before</span> <span class="nv">@b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="p">{</span> <span class="nb">take</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">shift</span> <span class="p">}</span>
        <span class="k">else</span>                  <span class="p">{</span> <span class="nb">take</span> <span class="nv">@b</span><span class="o">.</span><span class="nb">shift</span> <span class="p">}</span>
    <span class="p">}</span><span class="o">,</span>
    <span class="nv">@a</span><span class="o">,</span>
    <span class="nv">@b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">mergesort</span> <span class="p">(</span> <span class="o">*</span><span class="nv">@list</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">@list</span> <span class="k">if</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">my</span> <span class="nv">$middle</span> <span class="o">=</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@left</span>   <span class="o">=</span> <span class="n">mergesort</span> <span class="nv">@list</span><span class="o">[</span> <span class="mi">0</span> <span class="o">..^</span> <span class="nv">$middle</span> <span class="o">]</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@right</span>  <span class="o">=</span> <span class="n">mergesort</span> <span class="nv">@list</span><span class="o">[</span> <span class="nv">$middle</span> <span class="o">..</span> <span class="o">*</span>  <span class="o">]</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">merge</span><span class="p">(</span><span class="nv">@left</span><span class="o">,</span> <span class="nv">@right</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1"># my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span>
<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s"> p e r l s i x </span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">input  = </span><span class="p">{</span>           <span class="nv">@data</span>  <span class="p">}&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">output = </span><span class="p">{</span> <span class="nf">mergesort</span><span class="p">(</span><span class="nv">@data</span><span class="p">)</span> <span class="p">}&#34;;</span>
</code></pre></div><p>输出：</p>
<pre><code>input  = p e r l s i x
output = e i l p r s x
[Finished in 0.337s]
</code></pre><ul>
<li>mergesort_functional</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="o">[],</span> <span class="nv">@ys</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@ys</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="nv">@xs</span><span class="o">,</span> <span class="o">[]</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@xs</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="o">[</span><span class="nv">$x</span><span class="o">,</span> <span class="o">*</span><span class="nv">@xs</span><span class="o">],</span> <span class="o">[</span><span class="nv">$y</span><span class="o">,</span> <span class="o">*</span><span class="nv">@ys</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$x</span> <span class="ow">before</span> <span class="nv">$y</span> <span class="o">??</span> <span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="nb">merge</span> <span class="nv">@xs</span><span class="o">,</span> <span class="o">[</span><span class="nv">$y</span><span class="o">,</span> <span class="nv">@ys</span><span class="o">]</span><span class="p">)</span>
                 <span class="o">!!</span> <span class="p">(</span><span class="nv">$y</span><span class="o">,</span> <span class="nb">merge</span> <span class="o">[</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">@xs</span><span class="o">],</span> <span class="nv">@ys</span><span class="p">)</span>
<span class="p">}</span>


<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span> <span class="o">[]</span> <span class="p">)</span> <span class="p">{</span>  <span class="o">[]</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="o">[</span><span class="nv">$x</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span> <span class="o">[</span><span class="nv">$x</span><span class="o">]</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="nv">@xs</span><span class="p">)</span>  <span class="p">{</span>
    <span class="nb">merge</span>
        <span class="nf">mergesort</span><span class="p">(</span> <span class="nv">@xs</span><span class="o">[</span><span class="mi">0</span> <span class="o">..^</span> <span class="nv">@xs</span><span class="o">.</span><span class="nb">elems</span> <span class="ow">div</span> <span class="mi">2</span><span class="o">]</span> <span class="p">)</span><span class="o">,</span>
        <span class="nf">mergesort</span><span class="p">(</span> <span class="nv">@xs</span><span class="o">[</span><span class="nv">@xs</span><span class="o">.</span><span class="nb">elems</span> <span class="ow">div</span> <span class="mi">2</span> <span class="o">..</span> <span class="o">*</span> <span class="o">]</span> <span class="p">)</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">#my @data = &lt; p e r l s i x &gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">input  = </span><span class="p">{</span>           <span class="nv">@data</span>  <span class="p">}&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">output = </span><span class="p">{</span> <span class="nf">mergesort</span><span class="p">(</span><span class="nv">@data</span><span class="p">)</span> <span class="p">}&#34;;</span>
</code></pre></div><p>输出：</p>
<pre><code>input  = 6 7 2 1 8 9 5 3 4
output = 1 2 3 4 5 6 7 8 9
[Finished in 0.373s]
</code></pre><ul>
<li>mergesort_functional_given</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="o">[],</span> <span class="nv">@ys</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@ys</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="nv">@xs</span><span class="o">,</span> <span class="o">[]</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@xs</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="o">[</span><span class="nv">$x</span><span class="o">,</span> <span class="o">*</span><span class="nv">@xs</span><span class="o">],</span> <span class="o">[</span><span class="nv">$y</span><span class="o">,</span> <span class="o">*</span><span class="nv">@ys</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$x</span> <span class="ow">before</span> <span class="nv">$y</span> <span class="o">??</span> <span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="nb">merge</span> <span class="nv">@xs</span><span class="o">,</span> <span class="o">[</span><span class="nv">$y</span><span class="o">,</span> <span class="nv">@ys</span><span class="o">]</span><span class="p">)</span>
                 <span class="o">!!</span> <span class="p">(</span><span class="nv">$y</span><span class="o">,</span> <span class="nb">merge</span> <span class="o">[</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">@xs</span><span class="o">],</span> <span class="nv">@ys</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span> <span class="o">[]</span> <span class="p">)</span> <span class="p">{</span>  <span class="o">[]</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="o">[</span><span class="nv">$x</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span> <span class="o">[</span><span class="nv">$x</span><span class="o">]</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="nv">@xs</span><span class="p">)</span>  <span class="p">{</span>
    <span class="k">given</span> <span class="nv">@xs</span><span class="o">.</span><span class="nb">elems</span> <span class="ow">div</span> <span class="mi">2</span> <span class="k">-&gt;</span> <span class="nv">$middle</span> <span class="p">{</span>
        <span class="nb">merge</span>
            <span class="nf">mergesort</span><span class="p">(</span> <span class="nv">@xs</span><span class="o">[</span> <span class="mi">0</span> <span class="o">..^</span> <span class="nv">$middle</span> <span class="o">]</span> <span class="p">)</span><span class="o">,</span>
            <span class="nf">mergesort</span><span class="p">(</span> <span class="nv">@xs</span><span class="o">[</span> <span class="nv">$middle</span> <span class="o">..</span> <span class="o">*</span>  <span class="o">]</span> <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">#my @data = &lt; p e r l s i x &gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">input  = </span><span class="p">{</span>           <span class="nv">@data</span>  <span class="p">}&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">output = </span><span class="p">{</span> <span class="nf">mergesort</span><span class="p">(</span><span class="nv">@data</span><span class="p">)</span> <span class="p">}&#34;;</span>
</code></pre></div><p>输出：</p>
<pre><code>input  = 6 7 2 1 8 9 5 3 4
output = 1 2 3 4 5 6 7 8 9
[Finished in 0.375s]
</code></pre><ul>
<li>mergesort_functional_interleaved</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="o">[],</span> <span class="nv">@ys</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@ys</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="nv">@xs</span><span class="o">,</span> <span class="o">[]</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@xs</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nb">merge</span> <span class="p">(</span><span class="o">[</span><span class="nv">$x</span><span class="o">,</span> <span class="o">*</span><span class="nv">@xs</span><span class="o">],</span> <span class="o">[</span><span class="nv">$y</span><span class="o">,</span> <span class="o">*</span><span class="nv">@ys</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$x</span> <span class="ow">before</span> <span class="nv">$y</span> <span class="o">??</span> <span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="nb">merge</span> <span class="nv">@xs</span><span class="o">,</span> <span class="o">[</span><span class="nv">$y</span><span class="o">,</span> <span class="nv">@ys</span><span class="o">]</span><span class="p">)</span>
                 <span class="o">!!</span> <span class="p">(</span><span class="nv">$y</span><span class="o">,</span> <span class="nb">merge</span> <span class="o">[</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">@xs</span><span class="o">],</span> <span class="nv">@ys</span><span class="p">)</span>
<span class="p">}</span>


<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span> <span class="o">[]</span> <span class="p">)</span> <span class="p">{</span>  <span class="o">[]</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="o">[</span><span class="nv">$x</span><span class="o">]</span><span class="p">)</span> <span class="p">{</span> <span class="o">[</span><span class="nv">$x</span><span class="o">]</span> <span class="p">}</span>

<span class="k">multi</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="nv">@xs</span><span class="p">)</span>  <span class="p">{</span>
    <span class="nb">merge</span>
        <span class="nf">mergesort</span><span class="p">(</span> <span class="nv">@xs</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">...*]</span> <span class="p">)</span><span class="o">,</span>
        <span class="nf">mergesort</span><span class="p">(</span> <span class="nv">@xs</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">...*]</span> <span class="p">)</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">#my @data = &lt; p e r l s i x &gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">input  = </span><span class="p">{</span>           <span class="nv">@data</span>  <span class="p">}&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">output = </span><span class="p">{</span> <span class="nf">mergesort</span><span class="p">(</span><span class="nv">@data</span><span class="p">)</span> <span class="p">}&#34;;</span>
</code></pre></div><p>输出：</p>
<pre><code>input  = 6 7 2 1 8 9 5 3 4
output = 1 2 3 4 5 6 7 8 9
[Finished in 0.34s]
</code></pre><ul>
<li>quicksort</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">sub</span> <span class="nf">quicksort</span><span class="p">(</span> <span class="o">*</span><span class="nv">@list</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">@list</span> <span class="k">if</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">my</span> <span class="nv">$pivot</span> <span class="o">=</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>
    <span class="c1"># my $pivot = @list.=pick(*).shift;</span>

    <span class="k">my</span> <span class="p">(</span><span class="nv">@before</span><span class="o">,</span> <span class="nv">@after</span><span class="p">);</span>
    <span class="k">for</span> <span class="nv">@list</span> <span class="k">-&gt;</span> <span class="nv">$elem</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$elem</span> <span class="ow">before</span> <span class="nv">$pivot</span> <span class="p">{</span> <span class="nv">@before</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$elem</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">else</span>                   <span class="p">{</span> <span class="nv">@after</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$elem</span><span class="p">);</span>  <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nf">quicksort</span><span class="p">(</span><span class="nv">@before</span><span class="p">)</span><span class="o">,</span>
        <span class="nv">$pivot</span><span class="o">,</span>
        <span class="nf">quicksort</span><span class="p">(</span><span class="nv">@after</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span>
<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s"> p e r l s i x </span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">input  = </span><span class="p">{</span>           <span class="nv">@data</span>  <span class="p">}&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">output = </span><span class="p">{</span> <span class="nf">quicksort</span><span class="p">(</span><span class="nv">@data</span><span class="p">)</span> <span class="p">}&#34;;</span>
</code></pre></div><p>输出：</p>
<pre><code>input  = p e r l s i x
output = e i l p r s x
[Finished in 0.246s]
</code></pre><ul>
<li>quicksort_classify</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">multi</span> <span class="nf">quicksort</span><span class="p">(</span>  <span class="o">[]</span>  <span class="p">)</span> <span class="p">{</span>    <span class="p">};</span>
<span class="k">multi</span> <span class="nf">quicksort</span><span class="p">(</span>  <span class="nb">Mu</span>  <span class="p">)</span> <span class="p">{</span>    <span class="p">};</span>
<span class="k">multi</span> <span class="nf">quicksort</span><span class="p">(</span> <span class="o">[</span><span class="nv">$x</span><span class="o">]</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="p">};</span>

<span class="k">multi</span> <span class="nf">quicksort</span><span class="p">(</span> <span class="o">[</span><span class="nv">$pivot</span><span class="o">,</span> <span class="o">*</span><span class="nv">@xs</span><span class="o">]</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">given</span> <span class="nv">@xs</span><span class="o">.</span><span class="nb">classify</span><span class="o">:</span><span class="p">{</span> <span class="nv">$^elem</span> <span class="ow">before</span> <span class="nv">$pivot</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">pre</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">post</span><span class="p">&#39;}</span> <span class="p">{</span>
        <span class="nf">quicksort</span><span class="p">(</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">pre</span><span class="p">&gt;</span>  <span class="p">)</span><span class="o">,</span>
        <span class="nv">$pivot</span><span class="o">,</span>
        <span class="nf">quicksort</span><span class="p">(</span> <span class="o">.</span><span class="p">&lt;</span><span class="s">post</span><span class="p">&gt;</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span>
<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s"> p e r l s i x </span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">input  = </span><span class="p">{</span>           <span class="nv">@data</span>  <span class="p">}&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">output = </span><span class="p">{</span> <span class="nf">quicksort</span><span class="p">(</span><span class="nv">@data</span><span class="p">)</span> <span class="p">}&#34;;</span>
</code></pre></div><p>输出：</p>
<pre><code>input  = p e r l s i x
output =  e i  l p  r  s x
[Finished in 0.303s]
</code></pre><ul>
<li>quicksort_functional</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">multi</span> <span class="nf">quicksort</span><span class="p">(</span>  <span class="o">[]</span>  <span class="p">)</span> <span class="p">{</span>    <span class="p">};</span>
<span class="k">multi</span> <span class="nf">quicksort</span><span class="p">(</span> <span class="o">[</span><span class="nv">$x</span><span class="o">]</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="p">};</span>

<span class="k">multi</span> <span class="nf">quicksort</span><span class="p">(</span> <span class="o">[</span><span class="nv">$pivot</span><span class="o">,</span> <span class="o">*</span><span class="nv">@xs</span><span class="o">]</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nf">quicksort</span><span class="p">(</span><span class="nv">@xs</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*</span> <span class="ow">before</span> <span class="nv">$pivot</span><span class="p">)</span><span class="o">,</span>
    <span class="nv">$pivot</span><span class="o">,</span>
    <span class="nf">quicksort</span><span class="p">(</span><span class="nv">@xs</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*</span> <span class="o">!</span><span class="ow">before</span> <span class="nv">$pivot</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;</span>
<span class="k">my</span> <span class="nv">@data</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s"> p e r l s i x </span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">input  = </span><span class="p">{</span>           <span class="nv">@data</span>  <span class="p">}&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">output = </span><span class="p">{</span> <span class="nf">quicksort</span><span class="p">(</span><span class="nv">@data</span><span class="p">)</span> <span class="p">}&#34;;</span>
</code></pre></div><p>输出:</p>
<pre><code>input  = p e r l s i x
output =  e i l  p  r  s x
[Finished in 0.27s]
</code></pre><h2 id="pm-模块">pm 模块</h2>
<p>首先把自定义的 Bank.pm 模块复制到 Raku 的 lib 目录下：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">cp</span> <span class="n">Bank</span><span class="o">.</span><span class="nf">pm</span> <span class="o">~/.</span><span class="nf">rakudobrew</span><span class="o">/</span><span class="n">moar-nom</span><span class="o">/</span><span class="nb">install</span><span class="o">/</span><span class="nb">share</span><span class="o">/</span><span class="nb">raku</span><span class="o">/</span><span class="n">site</span><span class="o">/</span><span class="nb">lib</span>
</code></pre></div><p>Bank.pm</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/raku</span>

<span class="k">class</span> <span class="nc">Ident</span> <span class="p">{</span>
    <span class="k">subset</span> <span class="nc">Pattern</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/</span> \<span class="nb">d</span><span class="o">**</span><span class="mi">3</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> \<span class="nb">d</span><span class="o">**</span><span class="mi">3</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> \<span class="nb">d</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span><span class="p">;</span>

    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.name</span>              <span class="o">=</span> <span class="p">&#39;</span><span class="s1">????</span><span class="p">&#39;;</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.ID</span>  <span class="k">where</span> <span class="n">Pattern</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">000-000-000</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">Taxable</span> <span class="o">[:</span><span class="nv">$THRESHOLD</span> <span class="o">=</span> <span class="mi">100_000</span><span class="o">]</span> <span class="p">{</span>
    <span class="k">constant</span> <span class="no">GENERAL_TAX_RATE</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>

    <span class="k">has</span> <span class="nv">%.tax_record</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">tax_credits</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>

    <span class="k">method</span> <span class="nf">calculate_tax</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$tax_payable</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$.balance</span> <span class="nb">min</span> <span class="nv">$THRESHOLD</span><span class="p">)</span> <span class="o">*</span> <span class="n">GENERAL_TAX_RATE</span>
                          <span class="o">-</span> <span class="nv">$.tax_credits</span><span class="p">;</span>

        <span class="nv">%!tax_record</span><span class="p">{</span><span class="nb">now</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$tax_payable</span><span class="p">;</span>

        <span class="k">return</span> <span class="nv">$tax_payable</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Account</span> <span class="k">does</span> <span class="nc">Taxable</span> <span class="p">{</span>
    <span class="k">subset</span> <span class="nc">ID</span> <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">/</span> <span class="p">&lt;</span><span class="s">alpha</span><span class="p">&gt;</span><span class="o">**</span><span class="mi">4</span> <span class="o">&lt;</span><span class="n">digit</span><span class="o">&gt;**</span><span class="mi">5</span> <span class="o">/</span><span class="p">;</span>

    <span class="k">state</span> <span class="n">ID</span> <span class="nv">$next_account_ID</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">AAAA00001</span><span class="p">&#39;;</span>

    <span class="k">has</span> <span class="nb">Str</span>     <span class="nv">$.name</span>        <span class="o">=</span> <span class="nb">die</span> <span class="p">&#39;</span><span class="s1">Must provide account name</span><span class="p">&#39;;</span>
    <span class="k">has</span> <span class="nb">Numeric</span> <span class="nv">$.balance</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">ID</span>      <span class="nv">$.ID</span>          <span class="o">=</span> <span class="nv">$next_account_ID</span><span class="o">++</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">deposit</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$amount</span> <span class="k">where</span> <span class="o">*&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$!balance</span> <span class="o">+=</span> <span class="nv">$amount</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">withdraw</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$amount</span> <span class="k">where</span> <span class="o">*&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">fail</span> <span class="p">&#34;</span><span class="s2">Insufficient funds to withdraw </span><span class="nv">$amount</span><span class="p">&#34;</span>
            <span class="k">if</span> <span class="nv">$.balance</span> <span class="o">&lt;</span> <span class="nv">$amount</span><span class="p">;</span>
        <span class="nv">$!balance</span> <span class="o">-=</span> <span class="nv">$amount</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">description</span> <span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="nv">$.ID</span><span class="s2"> (</span><span class="nv">$.name</span><span class="s2">): balance=</span><span class="nv">$.balance</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">tax_credits</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Bank</span> <span class="p">{</span>
    <span class="k">has</span> <span class="n">Ident</span>   <span class="nv">$!ident</span>     <span class="nb">handles</span><span class="p">&lt;</span><span class="s"> name ID </span><span class="p">&gt;;</span>
    <span class="k">has</span> <span class="n">Account</span> <span class="nv">%!accounts</span><span class="p">;</span>

    <span class="k">submethod</span> <span class="nb">BUILD</span> <span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$!ident</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">add_account</span><span class="p">(</span><span class="n">Account</span> <span class="nv">$account</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">%!accounts</span><span class="p">{</span><span class="nv">$account</span><span class="o">.</span><span class="nf">ID</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$account</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">close_account</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$ID</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">%!accounts</span><span class="p">{</span><span class="nv">$ID</span><span class="p">}</span> <span class="p">:</span><span class="s">delete</span>
            <span class="p">//</span> <span class="nb">fail</span> <span class="p">&#34;</span><span class="s2">No such account</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">multi</span> <span class="k">method</span> <span class="nf">get_account</span><span class="p">(</span><span class="n">Account::ID</span> <span class="nv">$ID</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">%!accounts</span><span class="p">{</span><span class="nv">$ID</span><span class="p">}</span> <span class="o">//</span> <span class="nb">fail</span> <span class="p">&#34;</span><span class="s2">No such account</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">multi</span> <span class="k">method</span> <span class="nf">get_account</span><span class="p">(</span><span class="nb">Any</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1"># return %!accounts.values.grep({.name ~~ $name});</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">for_each_account</span><span class="p">({</span><span class="o">.</span><span class="nb">take</span> <span class="k">if</span> <span class="o">.</span><span class="nb">name</span> <span class="o">~~</span> <span class="nv">$name</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">for_each_account</span> <span class="p">(</span><span class="nv">&amp;action_on</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">gather</span> <span class="k">for</span> <span class="nv">%!accounts</span><span class="o">.</span><span class="nb">values</span> <span class="k">-&gt;</span> <span class="nv">$account</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
            <span class="nf">action_on</span><span class="p">(</span><span class="nv">$account</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">collect_taxes</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">for_each_account:</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">$tax</span> <span class="o">=</span> <span class="o">.</span><span class="nf">calculate_tax</span><span class="p">();</span>
            <span class="o">.</span><span class="nf">withdraw</span><span class="p">(</span><span class="nv">$tax</span><span class="p">);</span>
            <span class="nb">take</span> <span class="o">.</span><span class="s">ID</span> <span class="o">=&gt;</span> <span class="nv">$tax</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">report</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">[ </span><span class="p">{</span><span class="nb">self</span><span class="o">.</span><span class="nf">ID</span><span class="p">}</span><span class="s2"> [</span><span class="p">{</span><span class="nb">self</span><span class="o">.</span><span class="nb">name</span><span class="p">}</span><span class="s2">] ]</span><span class="p">&#34;;</span>         <span class="c1"># Or: say &#34;[ $.ID [$.name] ]&#34;;</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">for_each_account</span><span class="p">(</span><span class="o">*.</span><span class="nf">description</span><span class="o">.</span><span class="nb">say</span><span class="p">);</span>
        <span class="nb">say</span> <span class="p">&#39;&#39;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Account::Corporate</span>
    <span class="k">is</span> <span class="nc">Account</span>
    <span class="k">does</span> <span class="nc">Taxable</span><span class="o">[</span><span class="s">THRESHOLD</span> <span class="o">=&gt;</span> <span class="mi">1_000_000</span><span class="o">]</span>
<span class="p">{</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.company_ID</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">tax_credits</span> <span class="p">{</span> <span class="mi">5_000</span> <span class="p">}</span>

    <span class="k">method</span> <span class="nf">description</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nb">callsame</span><span class="p">()</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">  [</span><span class="nv">$.company_ID</span><span class="s2">]</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>该模块的功能是计算银行存款汇率等。下面使用这个模块：</p>
<ul>
<li>demo</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">use</span> <span class="nn">Bank</span><span class="p">;</span>

<span class="k">my</span> <span class="n">Bank</span> <span class="nv">$bank</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">(:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">123-456-789</span><span class="p">&#39;));</span>

<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Leslie Grace</span><span class="p">&#39;)</span>                  <span class="p">);</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Dana McKenna</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span><span class="mi">10_000</span><span class="p">));</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">AstroDynamic</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span>   <span class="mf">2e7</span><span class="p">));</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Jan van Quod</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span> <span class="mi">9_999</span><span class="p">));</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">OmniCorp LLC</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span>   <span class="mf">1e6</span><span class="p">));</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nb">report</span><span class="p">;</span>

<span class="nv">$bank</span><span class="o">.</span><span class="nf">get_account</span><span class="p">(&#39;</span><span class="s1">AAAA00003</span><span class="p">&#39;)</span><span class="o">.</span><span class="nf">deposit</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">get_account</span><span class="p">(&#39;</span><span class="s1">Jan van Quod</span><span class="p">&#39;)</span><span class="o">».</span><span class="nf">deposit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">get_account</span><span class="p">(/</span><span class="sr">D</span><span class="ni">.</span><span class="sr">na</span><span class="p">/)</span><span class="o">».</span><span class="nf">deposit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">#$bank.get_account(*)».deposit(99);</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nb">report</span><span class="p">;</span>

<span class="k">given</span> <span class="nv">$bank</span><span class="o">.</span><span class="nf">close_account</span><span class="p">(&#39;</span><span class="s1">AAAA00005</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Closed </span><span class="nv">$^account</span><span class="o">.</span><span class="nf">perl</span><span class="p">()</span><span class="s2">\n</span><span class="p">&#34;;</span>
    <span class="nv">$bank</span><span class="o">.</span><span class="nb">report</span><span class="p">;</span>
<span class="p">}</span>

<span class="nv">$bank</span><span class="o">.</span><span class="nf">close_account</span><span class="p">(&#39;</span><span class="s1">ZZZZ99999</span><span class="p">&#39;);</span>

<span class="nv">$bank</span><span class="o">.</span><span class="nf">get_account</span><span class="p">(&#39;</span><span class="s1">AAAA00001</span><span class="p">&#39;)</span><span class="o">.</span><span class="nf">withdraw</span><span class="p">(</span><span class="mi">1001</span><span class="p">);</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nb">report</span><span class="p">;</span>
</code></pre></div><p>输出：</p>
<pre><code>[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=0
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000000

[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=10001
AAAA00001 (Leslie Grace): balance=0
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10002
AAAA00003 (AstroDynamic): balance=20000102

Closed Account.new(name =&gt; &quot;OmniCorp LLC&quot;, balance =&gt; 1000000e0, ID =&gt; &quot;AAAA00005&quot;, tax_record =&gt; {}&lt;&gt;)

[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=10001
AAAA00001 (Leslie Grace): balance=0
AAAA00002 (Dana McKenna): balance=10002
AAAA00003 (AstroDynamic): balance=20000102

No such account
  in method close_account at ~/.rakudobrew/moar-nom/install/share/raku/site/lib/Bank.pm:67

Actually thrown at:
  in block &lt;unit&gt; at ~/04.bank_demo.pl:26
[Finished in 0.768s]
</code></pre><ul>
<li>demo_inheritance</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">sub</span> <span class="nf">show</span> <span class="p">(</span><span class="nv">$text</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;&#39;;</span>
    <span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">____/ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$text</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> \_________________________________________________</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">Bank</span><span class="p">;</span>

<span class="k">my</span> <span class="n">Bank</span> <span class="nv">$bank</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">(:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">123-456-789</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Bank of Evil</span><span class="p">&#39;));</span>

<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Leslie Grace</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span> <span class="mi">1_000</span><span class="p">));</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Dana McKenna</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span><span class="mi">10_000</span><span class="p">));</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Jan van Quod</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span> <span class="mi">9_999</span><span class="p">));</span>

<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account::Corporate</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">AstroDynamic</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span><span class="mf">2e7</span><span class="p">)</span> <span class="p">:</span><span class="s">company_ID</span><span class="p">(&#39;</span><span class="s1">ASDY</span><span class="p">&#39;));</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account::Corporate</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">OmniCorp LLC</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span><span class="mf">1e6</span><span class="p">)</span> <span class="p">:</span><span class="s">company_ID</span><span class="p">(&#39;</span><span class="s1">OMNI</span><span class="p">&#39;));</span>

<span class="n">show</span> <span class="p">&#39;</span><span class="s1">Status</span><span class="p">&#39;;</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nb">report</span><span class="p">;</span>

<span class="n">show</span> <span class="p">&#39;</span><span class="s1">Taxes collected</span><span class="p">&#39;;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$bank</span><span class="o">.</span><span class="nf">collect_taxes</span><span class="p">();</span>

<span class="n">show</span> <span class="p">&#39;</span><span class="s1">Status</span><span class="p">&#39;;</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nb">report</span><span class="p">;</span>

<span class="nv">$bank</span><span class="o">.</span><span class="nf">collect_taxes</span><span class="p">();</span>

<span class="n">show</span> <span class="p">&#39;</span><span class="s1">Tax records</span><span class="p">&#39;;</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nf">for_each_account</span><span class="p">({</span> <span class="nb">say</span> <span class="o">.</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="nf">tax_record</span> <span class="p">});</span>

<span class="n">show</span> <span class="p">&#39;</span><span class="s1">Culling acounts</span><span class="p">&#39;;</span>
<span class="k">given</span> <span class="nv">$bank</span> <span class="p">{</span>
    <span class="o">.</span><span class="nf">for_each_account:</span> <span class="p">{</span>
        <span class="o">.</span><span class="nf">close_account</span><span class="p">(</span><span class="nv">$^account</span><span class="o">.</span><span class="nf">ID</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span>
            <span class="k">if</span> <span class="nv">$^account</span><span class="o">.</span><span class="nf">balance</span> <span class="o">&lt;</span> <span class="mi">10_000</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">show</span> <span class="p">&#39;</span><span class="s1">Status</span><span class="p">&#39;;</span>
<span class="nv">$bank</span><span class="o">.</span><span class="nb">report</span><span class="p">;</span>
</code></pre></div><p>输出：</p>
<pre><code>____/ Status \____________________________________
[ 123-456-789 [Bank of Evil] ]
AAAA00004 (AstroDynamic): balance=20000000  [ASDY]
AAAA00001 (Leslie Grace): balance=1000
AAAA00005 (OmniCorp LLC): balance=1000000  [OMNI]
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (Jan van Quod): balance=9999


____/ Taxes collected \___________________________
AAAA00004 =&gt; 5000
AAAA00001 =&gt; 10
AAAA00005 =&gt; 5000
AAAA00002 =&gt; 100
AAAA00003 =&gt; 99.99

____/ Status \____________________________________
[ 123-456-789 [Bank of Evil] ]
AAAA00004 (AstroDynamic): balance=19995000  [ASDY]
AAAA00001 (Leslie Grace): balance=990
AAAA00005 (OmniCorp LLC): balance=995000  [OMNI]
AAAA00002 (Dana McKenna): balance=9900
AAAA00003 (Jan van Quod): balance=9899.01

____/ Tax records \_______________________________
AstroDynamic: Instant:1440413601.447466 =&gt; 5000, Instant:1440413601.463112 =&gt; 5000
Leslie Grace: Instant:1440413601.450753 =&gt; 10, Instant:1440413601.465823 =&gt; 9.9
OmniCorp LLC: Instant:1440413601.452933 =&gt; 5000, Instant:1440413601.468346 =&gt; 4950
Dana McKenna: Instant:1440413601.454860 =&gt; 100, Instant:1440413601.470238 =&gt; 99
Jan van Quod: Instant:1440413601.457399 =&gt; 99.99, Instant:1440413601.471551 =&gt; 98.9901
____/ Culling acounts \___________________________
Account.new(name =&gt; &quot;Leslie Grace&quot;, balance =&gt; 980.1, ID =&gt; &quot;AAAA00001&quot;, tax_record =&gt; {&quot;Instant:1440413601.450753&quot; =&gt; 10.0, &quot;Instant:1440413601.465823&quot; =&gt; 9.9}&lt;&gt;)
Account.new(name =&gt; &quot;Dana McKenna&quot;, balance =&gt; 9801.0, ID =&gt; &quot;AAAA00002&quot;, tax_record =&gt; {&quot;Instant:1440413601.454860&quot; =&gt; 100.0, &quot;Instant:1440413601.470238&quot; =&gt; 99.0}&lt;&gt;)
Account.new(name =&gt; &quot;Jan van Quod&quot;, balance =&gt; 9800.0199, ID =&gt; &quot;AAAA00003&quot;, tax_record =&gt; {&quot;Instant:1440413601.457399&quot; =&gt; 99.99, &quot;Instant:1440413601.471551&quot; =&gt; 98.9901}&lt;&gt;)

____/ Status \____________________________________
[ 123-456-789 [Bank of Evil] ]
AAAA00004 (AstroDynamic): balance=19990000  [ASDY]
AAAA00005 (OmniCorp LLC): balance=990050  [OMNI]

[Finished in 0.817s]
</code></pre><ul>
<li>demo_unary_dot</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">use</span> <span class="nn">Bank</span><span class="p">;</span>

<span class="k">my</span> <span class="n">Bank</span> <span class="nv">$bank</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">(:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">123-456-789</span><span class="p">&#39;));</span>

<span class="k">given</span> <span class="nv">$bank</span> <span class="p">{</span>
    <span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Leslie Grace</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span> <span class="mi">1_000</span><span class="p">));</span>
    <span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Dana McKenna</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span><span class="mi">10_000</span><span class="p">));</span>
    <span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">AstroDynamic</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span>   <span class="mf">2e7</span><span class="p">));</span>
    <span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">Jan van Quod</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span> <span class="mi">9_999</span><span class="p">));</span>
    <span class="o">.</span><span class="nf">add_account:</span> <span class="n">Account</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">(&#39;</span><span class="s1">OmniCorp LLC</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">balance</span><span class="p">(</span>   <span class="mf">1e6</span><span class="p">));</span>
    <span class="o">.</span><span class="nb">report</span><span class="p">;</span>

    <span class="o">.</span><span class="nf">get_account</span><span class="p">(&#39;</span><span class="s1">AAAA00003</span><span class="p">&#39;)</span><span class="o">.</span><span class="nf">deposit</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="o">.</span><span class="nb">report</span><span class="p">;</span>

    <span class="nb">say</span> <span class="o">.</span><span class="nf">close_account</span><span class="p">(&#39;</span><span class="s1">AAAA00005</span><span class="p">&#39;);</span>
    <span class="o">.</span><span class="nb">report</span><span class="p">;</span>

    <span class="o">.</span><span class="nf">get_account</span><span class="p">(&#39;</span><span class="s1">AAAA00001</span><span class="p">&#39;)</span><span class="o">.</span><span class="nf">withdraw</span><span class="p">(</span><span class="mi">1001</span><span class="p">);</span>
    <span class="o">.</span><span class="nb">report</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=1000
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000000

[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=1000
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000100

Account.new(name =&gt; &quot;OmniCorp LLC&quot;, balance =&gt; 1000000e0, ID =&gt; &quot;AAAA00005&quot;, tax_record =&gt; {}&lt;&gt;)
[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=1000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000100

Insufficient funds to withdraw 1001
  in method withdraw at ~/.rakudobrew/moar-nom/install/share/raku/site/lib/Bank.pm:43
  in block &lt;unit&gt; at ~04.bank_demo_unary_dot.pl:22

[Finished in 0.738s]
</code></pre><h2 id="lzw">LZW</h2>
<p>LZW 算法:</p>
<ul>
<li>demo</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">sub</span> <span class="nf">compress</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$uncompressed</span> <span class="k">--&gt;</span> <span class="nb">List</span><span class="p">)</span>  <span class="p">{</span>
    <span class="c1"># Build a look-up table of encoded representations</span>
    <span class="c1"># (each ASCII char represented by its equivalent codepoint)</span>
    <span class="k">my</span> <span class="nv">%code_for</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$^ASCII</span><span class="o">.</span><span class="s">chr</span> <span class="o">=&gt;</span> <span class="nv">$^ASCII</span> <span class="p">}</span>, <span class="o">^</span><span class="mi">256</span><span class="p">;</span>

    <span class="c1"># Loop and collect each encoding...</span>
    <span class="k">gather</span> <span class="p">{</span>
        <span class="c1"># Track which characters we&#39;ve seen but not yet encoded</span>
        <span class="k">my</span> <span class="nv">$already_seen</span> <span class="o">=</span> <span class="p">&#34;&#34;;</span>

        <span class="c1"># Walk through each single character...</span>
        <span class="k">for</span> <span class="nv">$uncompressed</span><span class="o">.</span><span class="nb">comb</span> <span class="k">-&gt;</span> <span class="nv">$next_char</span> <span class="p">{</span>
            <span class="c1"># Now we&#39;ve seen that next character as well</span>
            <span class="k">my</span> <span class="nv">$now_seen</span> <span class="o">=</span> <span class="nv">$already_seen</span> <span class="o">~</span> <span class="nv">$next_char</span><span class="p">;</span>

            <span class="c1"># If new char sequence is known, keep looking</span>
            <span class="k">if</span> <span class="nv">%code_for</span><span class="p">{</span><span class="nv">$now_seen</span><span class="p">}:</span><span class="s">exists</span> <span class="p">{</span>
                <span class="nv">$already_seen</span> <span class="o">=</span> <span class="nv">$now_seen</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1"># Otherwise, we have an unknown sequence of chars</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="c1"># Emit encoding for what we&#39;ve previously seen</span>
                <span class="nb">take</span> <span class="nv">%code_for</span><span class="p">{</span><span class="nv">$already_seen</span><span class="p">};</span>
                <span class="c1"># Add encoding for new unknown sequence to table</span>
                <span class="nv">%code_for</span><span class="p">{</span><span class="nv">$now_seen</span><span class="p">}</span> <span class="o">=</span> <span class="nv">%code_for</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
                <span class="c1"># Restart the current sequence from this char</span>
                <span class="nv">$already_seen</span> <span class="o">=</span> <span class="nv">$next_char</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1"># Emit the encoding for the final sequence (if any)</span>
        <span class="nb">take</span> <span class="nv">%code_for</span><span class="p">{</span><span class="nv">$already_seen</span><span class="p">}</span> <span class="k">if</span> <span class="nv">$already_seen</span> <span class="ow">ne</span> <span class="p">&#34;&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># Convert to codepoints...</span>
<span class="k">my</span> <span class="nv">@codes</span> <span class="o">=</span> <span class="nf">compress</span><span class="p">(&#39;</span><span class="s1">To be or not to be. That be the question, matey!</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">@codes</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="c1"># Emit as characters...</span>
<span class="nb">say</span> <span class="nv">@codes</span><span class="o">».</span><span class="nb">chr</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="c1"># Convert to a binary sequence...</span>
<span class="k">my</span> <span class="nv">$bits_per_code</span> <span class="o">=</span> <span class="nv">@codes</span><span class="o">.</span><span class="nb">max</span><span class="o">.</span><span class="nb">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">ceiling</span><span class="p">();</span>
<span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%0</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$bits_per_code</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$bits</span> <span class="o">=</span> <span class="nv">@codes</span><span class="o">».</span><span class="nb">fmt</span><span class="p">(</span><span class="nv">$format</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$bits</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">$bits</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="ni">.</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">({:</span><span class="mi">2</span><span class="p">(</span><span class="nv">$^bitpattern</span><span class="p">)</span><span class="o">.</span><span class="nb">chr</span><span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">separator</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">_</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">50</span> <span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>84 111 32 98 101 32 111 114 32 110 111 116 32 116 257 259 46 32 84 104 97 267 259 268 104 260 113 117 101 115 116 105 111 110 44 32 109 276 101 121 33
__________________________________________________
T o   b e   o r   n o t   t ā ă .   T h a ċ ă Č h Ą q u e s t i o n ,   m Ĕ e y !
__________________________________________________
001010100001101111000100000001100010001100101000100000001101111001110010000100000001101110001101111001110100000100000001110100100000001100000011000101110000100000001010100001101000001100001100001011100000011100001100001101000100000100001110001001110101001100101001110011001110100001101001001101111001101110000101100000100000001101101100010100001100101001111001000100001
__________________________________________________
x@1QoB\7NAt@0\
C aBp4 CDu'h4Ms8,l(2O
__________________________________________________
[Finished in 0.429s]
</code></pre><ul>
<li>LZW_functional</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="c1"># To compress a string...</span>
<span class="k">sub</span> <span class="nf">compress</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$uncompressed</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># Encode the character list via a dictionary, from the start</span>
    <span class="nb">encode</span><span class="p">(</span> <span class="nv">$uncompressed</span><span class="o">.</span><span class="nb">comb</span><span class="o">,</span> <span class="s">code</span> <span class="o">=&gt;</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">map</span> <span class="p">{</span><span class="nv">$^ASCII</span><span class="o">.</span><span class="s">chr</span> <span class="o">=&gt;</span> <span class="nv">$^ASCII</span><span class="p">}</span>, <span class="o">^</span><span class="mi">256</span><span class="p">)</span><span class="o">,</span> <span class="s">seen</span> <span class="o">=&gt;</span> <span class="p">&#34;&#34;</span> <span class="p">)</span>
<span class="p">}</span>

<span class="c1"># Encode an empty list where nothing already seen as nothing</span>
<span class="k">multi</span> <span class="nb">encode</span><span class="p">(</span><span class="o">[],</span> <span class="o">:</span><span class="nv">%code</span><span class="o">,</span> <span class="o">:</span><span class="nv">$seen</span> <span class="k">where</span> <span class="p">&#34;&#34;)</span> <span class="p">{}</span>

<span class="c1"># Encode an empty list where something already seen by look-up</span>
<span class="k">multi</span> <span class="nb">encode</span><span class="p">(</span><span class="o">[],</span> <span class="o">:</span><span class="nv">%code</span><span class="o">,</span> <span class="o">:</span><span class="nv">$seen</span><span class="p">)</span>          <span class="p">{</span> <span class="nv">%code</span><span class="p">{</span><span class="nv">$seen</span><span class="p">}</span> <span class="p">}</span>

<span class="c1"># Encode an list of one or more uncompressed characters...</span>
<span class="k">multi</span> <span class="nb">encode</span><span class="p">(</span><span class="o">[</span><span class="nv">$next</span><span class="o">,</span> <span class="o">*</span><span class="nv">@uncompressed</span><span class="o">],</span> <span class="o">:</span><span class="nv">%code</span><span class="o">,</span> <span class="o">:</span><span class="nv">$seen</span><span class="p">)</span>  <span class="p">{</span>
    <span class="c1"># If [already-seen plus next char] is a known sequence...</span>
    <span class="nv">%code</span><span class="p">{</span> <span class="nv">$seen</span><span class="o">~</span><span class="nv">$next</span> <span class="p">}:</span><span class="s">exists</span>
         <span class="c1"># Then encode all of that together</span>
        <span class="o">??</span> <span class="nb">encode</span><span class="p">(</span><span class="nv">@uncompressed</span><span class="o">,</span> <span class="o">:</span><span class="nv">%code</span><span class="o">,</span> <span class="s">seen</span> <span class="o">=&gt;</span> <span class="nv">$seen</span><span class="o">~</span><span class="nv">$next</span><span class="p">)</span>

         <span class="c1"># Else emit encoding for the already-seen sequence</span>
        <span class="o">!!</span> <span class="p">(</span> <span class="nv">%code</span><span class="p">{</span><span class="nv">$seen</span><span class="p">}</span><span class="o">,</span>
             <span class="c1"># Plus the encoding for the rest of the string...</span>
             <span class="nb">encode</span><span class="p">(</span> <span class="nv">@uncompressed</span><span class="o">,</span>
                     <span class="c1"># Add encoding for new sequence to table</span>
                     <span class="s">code</span> <span class="o">=&gt;</span> <span class="nv">%</span><span class="p">(</span> <span class="nv">%code</span>, <span class="nv">$seen</span><span class="o">~</span><span class="nv">$next</span> <span class="o">=&gt;</span> <span class="nv">%code</span><span class="o">.</span><span class="nb">elems</span> <span class="p">)</span><span class="o">,</span>
                     <span class="c1"># Continue encoding from next character</span>
                     <span class="s">seen</span> <span class="o">=&gt;</span> <span class="nv">$next</span>
             <span class="p">)</span>
           <span class="p">)</span>
<span class="p">}</span>

<span class="c1"># Convert to codepoints...</span>
<span class="k">my</span> <span class="nv">@codes</span> <span class="o">=</span> <span class="nf">compress</span><span class="p">(&#39;</span><span class="s1">To be or not to be. That be the question, matey!</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">@codes</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="c1"># Emit as characters...</span>
<span class="nb">say</span> <span class="nv">@codes</span><span class="o">».</span><span class="nb">chr</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="c1"># Convert to a binary sequence...</span>
<span class="k">my</span> <span class="nv">$bits_per_code</span> <span class="o">=</span> <span class="nv">@codes</span><span class="o">.</span><span class="nb">max</span><span class="o">.</span><span class="nb">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">ceiling</span><span class="p">();</span>
<span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%0</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$bits_per_code</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$bits</span> <span class="o">=</span> <span class="nv">@codes</span><span class="o">».</span><span class="nb">fmt</span><span class="p">(</span><span class="nv">$format</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$bits</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">$bits</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="ni">.</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">({:</span><span class="mi">2</span><span class="p">(</span><span class="nv">$^bitpattern</span><span class="p">)</span><span class="o">.</span><span class="nb">chr</span><span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>
<span class="n">separator</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">separator</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">_</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">50</span> <span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>84 111 32 98 101 32 111 114 32 110 111 116 32 116 257 259 46 32 84 104 97 267 259 268 104 260 113 117 101 115 116 105 111 110 44 32 109 276 101 121 33
__________________________________________________
T o   b e   o r   n o t   t ā ă .   T h a ċ ă Č h Ą q u e s t i o n ,   m Ĕ e y !
__________________________________________________
001010100001101111000100000001100010001100101000100000001101111001110010000100000001101110001101111001110100000100000001110100100000001100000011000101110000100000001010100001101000001100001100001011100000011100001100001101000100000100001110001001110101001100101001110011001110100001101001001101111001101110000101100000100000001101101100010100001100101001111001000100001
__________________________________________________
x@1QoB\7NAt@0\
C aBp4 CDu'h4Ms8,l(2O
__________________________________________________
[Finished in 0.658s]
</code></pre><ul>
<li>validation_concurrent</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@records</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Damian Conway</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">00012345</span><span class="p">&#39;)</span>  <span class="p">}</span><span class="o">,</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Leslie Duvall</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">668</span><span class="p">&#39;)</span>       <span class="p">}</span><span class="o">,</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Sam Georgious</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">00000007</span><span class="p">&#39;)</span>  <span class="p">}</span><span class="o">,</span>
<span class="p">);</span>

<span class="k">sub</span> <span class="nf">normalize_data</span> <span class="p">(</span><span class="nb">Hash</span> <span class="nv">$record</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">Name</span><span class="p">&gt;</span>  <span class="o">.=</span> <span class="nb">subst</span><span class="p">(/&lt;</span><span class="nb">lower</span><span class="p">&gt;/</span><span class="o">,</span><span class="p">{</span><span class="nv">$&lt;lower&gt;</span><span class="o">.</span><span class="nb">uc</span><span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">);</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">Age</span><span class="p">&gt;</span> <span class="nb">max</span><span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">ID</span><span class="p">&gt;</span>    <span class="o">.=</span> <span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%08d</span><span class="p">&#39;);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">report</span> <span class="p">(</span><span class="nv">$outcome</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">\tInvalid record (</span><span class="nv">$outcome</span><span class="s2">)</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">invalid_name</span> <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad name: </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">Name</span><span class="p">&gt;</span> <span class="o">!~~</span> <span class="p">/</span><span class="se">\S</span><span class="p">/;</span>        <span class="p">}</span>
<span class="k">sub</span> <span class="nf">invalid_age</span>  <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad age:  </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">Age</span><span class="p">&gt;</span>  <span class="o">&lt;</span> <span class="mi">18</span><span class="p">;</span>            <span class="p">}</span>
<span class="k">sub</span> <span class="nf">invalid_ID</span>   <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad ID:   </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">ID</span><span class="p">&gt;</span>   <span class="o">!~~</span> <span class="p">/</span><span class="ni">^</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">8</span><span class="ni">$</span><span class="p">/;</span> <span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Validating...</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">@invalidations</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nv">@records</span><span class="o">».</span><span class="nv">&amp;invalid_name</span><span class="o">,</span>
    <span class="nv">@records</span><span class="o">».</span><span class="nv">&amp;invalid_age</span><span class="o">,</span>
    <span class="nv">@records</span><span class="o">».</span><span class="nv">&amp;invalid_ID</span><span class="o">,</span>
<span class="p">);</span>

<span class="nv">@invalidations</span><span class="o">».</span><span class="nv">&amp;report</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Normalizing...</span><span class="p">&#39;;</span>
<span class="nv">@records</span><span class="o">».</span><span class="nv">&amp;normalize_data</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Revalidating...</span><span class="p">&#39;;</span>

<span class="nv">@invalidations</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nv">@records</span><span class="o">».</span><span class="nv">&amp;invalid_name</span><span class="o">,</span>
    <span class="nv">@records</span><span class="o">».</span><span class="nv">&amp;invalid_age</span><span class="o">,</span>
    <span class="nv">@records</span><span class="o">».</span><span class="nv">&amp;invalid_ID</span><span class="o">,</span>
<span class="p">);</span>

<span class="nv">@invalidations</span><span class="o">».</span><span class="nv">&amp;report</span><span class="p">;</span>
</code></pre></div><p>输出：</p>
<pre><code>Validating...
postcircumfix:&lt;{ }&gt; not defined for type Str
</code></pre><ul>
<li>validation_imperative</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@records</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Damian Conway</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">00012345</span><span class="p">&#39;)</span>  <span class="p">}</span><span class="o">,</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Leslie Duvall</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">668</span><span class="p">&#39;)</span>       <span class="p">}</span><span class="o">,</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Sam Georgious</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">00000007</span><span class="p">&#39;)</span>  <span class="p">}</span><span class="o">,</span>
<span class="p">);</span>

<span class="k">sub</span> <span class="nf">normalize_data</span> <span class="p">(</span><span class="nb">Hash</span> <span class="nv">$record</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">Name</span><span class="p">&gt;</span>  <span class="o">.=</span> <span class="nb">subst</span><span class="p">(/&lt;</span><span class="nb">lower</span><span class="p">&gt;/</span><span class="o">,</span><span class="p">{</span><span class="nv">$&lt;lower&gt;</span><span class="o">.</span><span class="nb">uc</span><span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">);</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">Age</span><span class="p">&gt;</span> <span class="nb">max</span><span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">ID</span><span class="p">&gt;</span>    <span class="o">.=</span> <span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%08d</span><span class="p">&#39;);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">report</span> <span class="p">(</span><span class="nv">$outcome</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">\tInvalid record (</span><span class="nv">$outcome</span><span class="s2">)</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">invalid_name</span> <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad name: </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">Name</span><span class="p">&gt;</span> <span class="o">!~~</span> <span class="p">/</span><span class="se">\S</span><span class="p">/;</span>        <span class="p">}</span>
<span class="k">sub</span> <span class="nf">invalid_age</span>  <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad age:  </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">Age</span><span class="p">&gt;</span>  <span class="o">&lt;</span> <span class="mi">18</span><span class="p">;</span>            <span class="p">}</span>
<span class="k">sub</span> <span class="nf">invalid_ID</span>   <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad ID:   </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">ID</span><span class="p">&gt;</span>   <span class="o">!~~</span> <span class="p">/</span><span class="ni">^</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">8</span><span class="ni">$</span><span class="p">/;</span> <span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Validating...</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">@invalidations</span> <span class="o">=</span> <span class="k">gather</span> <span class="k">for</span> <span class="nv">@records</span> <span class="k">-&gt;</span> <span class="nv">$record</span> <span class="p">{</span>
    <span class="nb">take</span> <span class="nf">invalid_name</span><span class="p">(</span><span class="nv">$record</span><span class="p">);</span>
    <span class="nb">take</span> <span class="nf">invalid_age</span><span class="p">(</span><span class="nv">$record</span><span class="p">);</span>
    <span class="nb">take</span> <span class="nf">invalid_ID</span><span class="p">(</span><span class="nv">$record</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">@invalidations</span> <span class="k">-&gt;</span> <span class="nv">$errmsg</span> <span class="p">{</span>
    <span class="nb">report</span><span class="p">(</span> <span class="nv">$errmsg</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Normalizing...</span><span class="p">&#39;;</span>
<span class="k">for</span> <span class="nv">@records</span> <span class="k">-&gt;</span> <span class="nv">$record</span> <span class="p">{</span>
    <span class="nf">normalize_data</span><span class="p">(</span><span class="nv">$record</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Revalidating...</span><span class="p">&#39;;</span>

<span class="nv">@invalidations</span> <span class="o">=</span> <span class="k">gather</span> <span class="k">for</span> <span class="nv">@records</span> <span class="k">-&gt;</span> <span class="nv">$record</span> <span class="p">{</span>
    <span class="nb">take</span> <span class="nf">invalid_name</span><span class="p">(</span><span class="nv">$record</span><span class="p">);</span>
    <span class="nb">take</span> <span class="nf">invalid_age</span><span class="p">(</span><span class="nv">$record</span><span class="p">);</span>
    <span class="nb">take</span> <span class="nf">invalid_ID</span><span class="p">(</span><span class="nv">$record</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">@invalidations</span> <span class="k">-&gt;</span> <span class="nv">$errmsg</span> <span class="p">{</span>
    <span class="nb">report</span><span class="p">(</span> <span class="nv">$errmsg</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>Validating...
	Invalid record (Bad ID:   Name	Leslie Duvall Age	29 ID	668)
	Invalid record (Bad age:  Name	Sam Georgious Age	-2 ID	00000007)
Normalizing...
Revalidating...
</code></pre><ul>
<li>validation_junctions</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@records</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Damian Conway</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">00012345</span><span class="p">&#39;)</span>  <span class="p">}</span><span class="o">,</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Leslie Duvall</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">668</span><span class="p">&#39;)</span>       <span class="p">}</span><span class="o">,</span>
    <span class="p">{</span> <span class="p">:</span><span class="s">Name</span><span class="p">&lt;</span><span class="s">Sam Georgious</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">Age</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">ID</span><span class="p">(&#39;</span><span class="s1">00000007</span><span class="p">&#39;)</span>  <span class="p">}</span><span class="o">,</span>
<span class="p">);</span>

<span class="k">sub</span> <span class="nf">normalize_data</span> <span class="p">(</span><span class="nb">Hash</span> <span class="nv">$record</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">Name</span><span class="p">&gt;</span>  <span class="o">.=</span> <span class="nb">subst</span><span class="p">(/&lt;</span><span class="nb">lower</span><span class="p">&gt;/</span><span class="o">,</span><span class="p">{</span><span class="nv">$&lt;lower&gt;</span><span class="o">.</span><span class="nb">uc</span><span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">);</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">Age</span><span class="p">&gt;</span> <span class="nb">max</span><span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="nv">$record</span><span class="p">&lt;</span><span class="s">ID</span><span class="p">&gt;</span>    <span class="o">.=</span> <span class="nb">fmt</span><span class="p">(&#39;</span><span class="s1">%08d</span><span class="p">&#39;);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">report</span> <span class="p">(</span><span class="nv">$outcome</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">\tInvalid record (</span><span class="nv">$outcome</span><span class="s2">)</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">invalid_name</span> <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad name: </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">Name</span><span class="p">&gt;</span> <span class="o">!~~</span> <span class="p">/</span><span class="se">\S</span><span class="p">/;</span>        <span class="p">}</span>
<span class="k">sub</span> <span class="nf">invalid_age</span>  <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad age:  </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">Age</span><span class="p">&gt;</span>  <span class="o">&lt;</span> <span class="mi">18</span><span class="p">;</span>            <span class="p">}</span>
<span class="k">sub</span> <span class="nf">invalid_ID</span>   <span class="p">(</span><span class="nv">$rec</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Bad ID:   </span><span class="nv">$rec</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$rec</span><span class="p">&lt;</span><span class="s">ID</span><span class="p">&gt;</span>   <span class="o">!~~</span> <span class="p">/</span><span class="ni">^</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">8</span><span class="ni">$</span><span class="p">/;</span> <span class="p">}</span>

<span class="k">my</span> <span class="nv">$invalid_record</span> <span class="o">=</span> <span class="nv">&amp;invalid_name</span> <span class="o">|</span> <span class="nv">&amp;invalid_age</span> <span class="o">|</span> <span class="nv">&amp;invalid_ID</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Validating...</span><span class="p">&#39;;</span>
<span class="nb">report</span><span class="p">(</span> <span class="nv">$invalid_record</span><span class="p">(</span><span class="nb">all</span> <span class="nv">@records</span><span class="p">)</span> <span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Normalizing...</span><span class="p">&#39;;</span>
<span class="nf">normalize_data</span><span class="p">(</span><span class="nb">all</span> <span class="nv">@records</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Revalidating...</span><span class="p">&#39;;</span>
<span class="nb">report</span><span class="p">(</span> <span class="nv">$invalid_record</span><span class="p">(</span><span class="nb">all</span> <span class="nv">@records</span><span class="p">)</span> <span class="p">);</span>
</code></pre></div><p>输出：</p>
<pre><code>Validating...
	Invalid record (Bad ID:   Name	Leslie Duvall Age	29 ID	668)
	Invalid record (Bad age:  Name	Sam Georgious Age	-2 ID	00000007)
Normalizing...
Revalidating...
</code></pre><ul>
<li>prime_demo</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">sub</span> <span class="nf">is_prime</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$n</span> <span class="nv">%</span> <span class="nb">all</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="nv">$n</span><span class="o">.</span><span class="nb">sqrt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">1001</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> is prime</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nf">is_prime</span><span class="p">(</span><span class="nv">$n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>1 is prime
3 is prime
5 is prime
7 is prime
11 is prime
...
991 is prime
997 is prime
</code></pre><ul>
<li>统计</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">99</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (a) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_a</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (g) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_g</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">    mode = </span><span class="p">&#39;</span><span class="o">,</span>   <span class="nb">mode</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">  median = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">median</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>

<span class="k">sub</span> <span class="nf">mean_a</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">[+]</span> <span class="nv">@list</span><span class="p">)</span> <span class="o">/</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">mean_g</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">[*]</span> <span class="nv">@list</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">mode</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">given</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">Bag</span> <span class="p">{</span>
        <span class="o">.</span><span class="nb">pairs</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span><span class="nv">$^elem</span><span class="o">.</span><span class="nb">value</span> <span class="o">==</span> <span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">max</span><span class="p">})</span><span class="o">».</span><span class="nb">key</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">median</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">given</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">sort</span> <span class="p">{</span>
        <span class="o">.</span><span class="nb">elems</span> <span class="nv">%%</span> <span class="mi">2</span>
            <span class="o">??</span> <span class="nf">mean_a</span><span class="p">(</span> <span class="o">.[*/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">*/</span><span class="mi">2</span><span class="o">]</span> <span class="p">)</span>
            <span class="o">!!</span>         <span class="o">.[*/</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 7 4
  median = 5
</code></pre><ul>
<li>stats_hybird</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">99</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (a) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_a</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (g) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_g</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">    mode = </span><span class="p">&#39;</span><span class="o">,</span>   <span class="nb">mode</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">  median = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">median</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>

<span class="k">sub</span> <span class="nf">mean_a</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="o">[+]</span> <span class="nv">@list</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$sum</span> <span class="o">/</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">mean_g</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$product</span> <span class="o">=</span> <span class="o">[*]</span> <span class="nv">@list</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$product</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">mode</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$frequencies</span> <span class="o">=</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">Bag</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$list_elems</span>  <span class="o">=</span> <span class="nv">$frequencies</span><span class="o">.</span><span class="nb">pairs</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$max_freq</span>    <span class="o">=</span> <span class="nv">$frequencies</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">max</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@max_vals</span>    <span class="o">=</span> <span class="nv">$list_elems</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span><span class="o">.</span><span class="nb">value</span> <span class="o">==</span> <span class="nv">$max_freq</span><span class="p">});</span>

    <span class="k">return</span> <span class="nv">@max_vals</span><span class="o">».</span><span class="nb">key</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">median</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">@sorted</span><span class="o">.</span><span class="nb">elems</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="o">??</span> <span class="nf">mean_a</span><span class="p">(</span><span class="nv">@sorted</span><span class="o">.[*/</span><span class="mi">2</span><span class="o">,</span> <span class="o">*/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
                              <span class="o">!!</span>        <span class="nv">@sorted</span><span class="o">.[*/</span><span class="mi">2</span><span class="o">]</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 7 4
  median = 5
</code></pre><ul>
<li>stats_imperative</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">99</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (a) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_a</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (g) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_g</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">    mode = </span><span class="p">&#39;</span><span class="o">,</span>   <span class="nb">mode</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">  median = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">median</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>

<span class="k">sub</span> <span class="nf">mean_a</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$sum</span><span class="p">;</span>
    <span class="k">for</span> <span class="nv">@list</span> <span class="k">-&gt;</span> <span class="nv">$elem</span> <span class="p">{</span>
        <span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$elem</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$sum</span> <span class="o">/</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">mean_g</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$product</span><span class="p">;</span>
    <span class="k">for</span> <span class="nv">@list</span> <span class="k">-&gt;</span> <span class="nv">$elem</span> <span class="p">{</span>
        <span class="nv">$product</span> <span class="o">*=</span> <span class="nv">$elem</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$product</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">mode</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">%counts</span><span class="p">;</span>
    <span class="nv">%counts</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">++</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$max</span> <span class="o">=</span> <span class="nv">%counts</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">max</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">%counts</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">value</span> <span class="o">==</span> <span class="nv">$max</span> <span class="p">})</span><span class="o">».</span><span class="nb">key</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">median</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">@list</span><span class="o">.=</span><span class="nb">sort</span><span class="p">();</span>

    <span class="k">return</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span> <span class="nv">%%</span> <span class="mi">2</span>
            <span class="o">??</span> <span class="nf">mean_a</span><span class="p">(</span> <span class="nv">@list</span><span class="o">[*/</span><span class="mi">2</span><span class="o">,</span> <span class="o">*/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="p">)</span>
            <span class="o">!!</span>         <span class="nv">@list</span><span class="o">[*/</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 4 7
  median = 5
</code></pre><ul>
<li>stats_mode_func</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">99</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (a) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_a</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">mean (g) = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">mean_g</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">    mode = </span><span class="p">&#39;</span><span class="o">,</span>   <span class="nb">mode</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">  median = </span><span class="p">&#39;</span><span class="o">,</span> <span class="nf">median</span><span class="p">(</span><span class="nv">@values</span><span class="p">);</span>

<span class="k">sub</span> <span class="nf">mean_a</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nb">sum</span> <span class="p">{</span> <span class="o">[+]</span> <span class="nv">@list</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">mean_g</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">product</span> <span class="p">{</span> <span class="o">[*]</span> <span class="nv">@list</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nf">product</span><span class="p">()</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nv">@list</span><span class="o">.</span><span class="nb">elems</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">mode</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">frequencies</span> <span class="p">{</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">Bag</span>                             <span class="p">}</span>
    <span class="k">sub</span> <span class="nf">list_elems</span>  <span class="p">{</span> <span class="n">frequencies</span><span class="o">.</span><span class="nb">pairs</span>                     <span class="p">}</span>
    <span class="k">sub</span> <span class="nf">max_freq</span>    <span class="p">{</span> <span class="n">frequencies</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">max</span>                <span class="p">}</span>
    <span class="k">sub</span> <span class="nf">max_vals</span>    <span class="p">{</span> <span class="n">list_elems</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="p">{</span><span class="o">.</span><span class="nb">value</span> <span class="o">==</span> <span class="n">max_freq</span><span class="p">}</span> <span class="p">}</span>

    <span class="k">return</span> <span class="n">max_vals</span><span class="o">».</span><span class="nb">keys</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">median</span> <span class="p">(</span><span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">sorted</span> <span class="p">{</span> <span class="nv">@list</span><span class="o">.</span><span class="nb">sort</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">sorted</span><span class="o">.</span><span class="nb">elems</span> <span class="nv">%%</span> <span class="mi">2</span>
                <span class="o">??</span> <span class="nf">mean_a</span><span class="p">(</span><span class="n">sorted</span><span class="o">.[*/</span><span class="mi">2</span><span class="o">,</span> <span class="o">*/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
                <span class="o">!!</span>        <span class="n">sorted</span><span class="o">.[*/</span><span class="mi">2</span><span class="o">]</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<pre><code>mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 7 4
  median = 5
</code></pre><ul>
<li>stats_OO</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">class</span> <span class="nc">StatList</span> <span class="k">is</span> <span class="nb">List</span> <span class="p">{</span>

    <span class="k">method</span> <span class="nf">mean_a</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">sub</span> <span class="nb">sum</span> <span class="p">{</span> <span class="o">[+]</span> <span class="nb">self</span> <span class="p">}</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">()</span> <span class="o">/</span> <span class="nb">self</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">mean_g</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">sub</span> <span class="nf">product</span> <span class="p">{</span> <span class="o">[*]</span> <span class="nb">self</span> <span class="p">}</span>
        <span class="k">return</span> <span class="nf">product</span><span class="p">()</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">self</span><span class="o">.</span><span class="nb">elems</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">median</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">sub</span> <span class="nf">sorted</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">sort</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">sorted</span><span class="o">.</span><span class="nb">elems</span> <span class="nv">%%</span> <span class="mi">2</span>
                    <span class="o">??</span> <span class="n">StatList</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">sorted</span><span class="o">.[*/</span><span class="mi">2</span><span class="o">,</span> <span class="o">*/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="nf">mean_a</span><span class="p">()</span>
                    <span class="o">!!</span>              <span class="n">sorted</span><span class="o">.[*/</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">mode</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">sub</span> <span class="nf">frequencies</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">Bag</span>                              <span class="p">}</span>
        <span class="k">sub</span> <span class="nf">list_elems</span>  <span class="p">{</span> <span class="n">frequencies</span><span class="o">.</span><span class="nb">pairs</span>                     <span class="p">}</span>
        <span class="k">sub</span> <span class="nf">max_freq</span>    <span class="p">{</span> <span class="n">frequencies</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">max</span>                <span class="p">}</span>
        <span class="k">sub</span> <span class="nf">max_vals</span>    <span class="p">{</span> <span class="n">list_elems</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="p">{</span><span class="o">.</span><span class="nb">value</span> <span class="o">==</span> <span class="n">max_freq</span><span class="p">}</span> <span class="p">}</span>

        <span class="k">return</span>  <span class="n">max_vals</span><span class="o">».</span><span class="nb">keys</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$list</span> <span class="o">=</span> <span class="n">StatList</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">11</span><span class="p">);</span>

<span class="nb">say</span> <span class="nv">$list</span><span class="o">.</span><span class="nf">mean_a</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$list</span><span class="o">.</span><span class="nf">mean_g</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$list</span><span class="o">.</span><span class="nf">median</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$list</span><span class="o">.</span><span class="nb">mode</span><span class="p">;</span>
</code></pre></div><p>输出：</p>
<pre><code>6
4.68393277169202
13
8
</code></pre><blockquote>
<p>以上所有文件都可以在<a href="http://www.bit.do/P6TP">这儿</a> 下载到 - a Raku introductory tutorial by Damian Conway</p>
</blockquote>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/example" term="example" label="example" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[token 和 rule 的区别]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-03-11-difference-between-rules-and-tokens/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-03-11-difference-between-rules-and-tokens/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-12T00:00:00+08:00</published>
            <updated>2021-07-12T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Difference Between Rules and Tokens</blockquote><p>在 grammar 中, 有两个 <strong>regex</strong> 的变体, <strong>rule</strong> 和 <strong>token</strong>。<strong>rule</strong> 默认不会回溯。<strong>rule</strong> 与 <strong>token</strong> 的一个重要区别就是, <code>rule</code> 这样的正则采取了 <code>:sigspace</code> 修饰符。 <code>rule</code> 实际上是</p>
<pre><code>regex :ratchet :sigspace { ... }
</code></pre><p>的简写。ratchet 这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的! 而 <code>:sigspace</code> 表明正则中的空白是有意义的, 而 <strong>token</strong> 实际上是</p>
<pre><code>regex :ratchet { ... }
</code></pre><p>的简写。所以在 <strong>token</strong> 中, 若不是显式地写上 <code>\s</code>、<code>\h</code>、<code>\n</code> 等空白符号, 其它情况下就好像空白隐身了一样, 虽然你写了, 但是编译器却视而不见。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Token::Rule::Difference</span> <span class="p">{</span>
    <span class="c1"># 下面三者等价</span>
    <span class="c1"># rule TOP { [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39;   }  等价于</span>
    <span class="c1"># rule TOP { | [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39; }  等价于</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="se">\w</span><span class="o">+</span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">               </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">             </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1"># $=finish.lines 中的每一行末尾都没有换行符</span>
<span class="k">for</span> <span class="nv">$=finish</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nb">print</span><span class="p">(</span><span class="nv">$line</span><span class="p">);</span>
    <span class="nb">say</span> <span class="n">Token::Rule::Difference</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$line</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">=finish</span><span class="sd">
</span><span class="sd">token takes whitespace invisible unless with sigspace
</span><span class="sd">rule is a token without sigspace
</span><span class="sd">2015 12 25
</span><span class="sd">2016 01 07
</span></code></pre></div><p>说明在 <strong>rule</strong> 中, <code>|</code> 左右两边的空格会被忽略, 这通常是为了使格式对齐, 看起来不乱。另外 <strong>rule</strong> 中, 开头和末尾的空白也会被忽略。</p>
<p>如果每一行都带有换行符呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Grammar::Debugger</span><span class="p">;</span>
<span class="k">grammar</span> <span class="nc">Token::Rule::Difference</span> <span class="p">{</span>

    <span class="c1"># token TOP { ^ [&lt;line&gt;\n]+ $ }</span>
    <span class="c1"># token line {</span>
    <span class="c1">#     | [\w+]+ % &#39; &#39;</span>
    <span class="c1">#     | [\d+]+ % &#39; &#39;</span>
    <span class="c1"># }</span>

    <span class="c1"># 等价于</span>

    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">wrap</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">wrap</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">rule</span> <span class="nf">line</span> <span class="p">{</span><span class="sr">
</span><span class="sr">         </span><span class="p">[</span><span class="se">\w</span><span class="o">+</span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">-</span><span class="se">\s</span><span class="sr">:</span><span class="p">]&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOF/;</span><span class="s">
</span><span class="s">token takes whitespace invisible unless with sigspace
</span><span class="s">rule is a token without sigspace
</span><span class="s">2015-12-25 12:23
</span><span class="s">2016-01-07 13:45
</span><span class="s"></span><span class="p">EOF</span>

<span class="k">my</span> <span class="nv">$parse</span> <span class="o">=</span> <span class="n">Token::Rule::Difference</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$str</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$parse</span><span class="p">;</span>
</code></pre></div><h2 id="token-vs-rule">token vs. rule</h2>
<blockquote>
<p>When we use rule in place of token, any whitespace after anatom is turned into a non-capturing call to ws</p>
</blockquote>
<p>这句话是说, 在 <strong>rule</strong> 中, 任何跟在原子(atom)后面的空白会变成非捕获的 <code>ws</code> 调用, 即 <code>&lt;.ws&gt;</code>,</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">rule</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># . 抑制了捕获</span>
</code></pre></div><p>在 grammar 中, 我们继承了默认的 <code>ws</code>, 但是我们也可以提供自己的 <strong>ws</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># 匹配水平空白, 不包括换行</span>
</code></pre></div><p>rule 中空白的使用:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Swift          is hard    to  learn</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">word</span> <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="k">my</span> <span class="k">rule</span>  <span class="nf">line</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">word</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">[&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">}</span>
<span class="nv">$str</span> <span class="o">~~</span> <span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><p>逗号附近的方括号保证了 <code>&lt;.ws&gt;</code> 调用产生的空白作为分割符的一部分。这利用了 <code>&lt;.ws&gt;</code> 的一个特点：</p>
<p>在两个 <code>\w</code> 之间解释为 <code>\s+</code>, 其它地方解释为 <code>\s*</code>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/token" term="token" label="token" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rule" term="rule" label="rule" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[正确地使用 proto]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-02-11-multi-thoughts/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-10-06-proto-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 proto" />
            
                <id>https://ohmyweekly.github.io/notes/2016-02-11-multi-thoughts/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-12T00:00:00+08:00</published>
            <updated>2021-07-12T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Apropos proto: Perl6.c multi thoughts</blockquote><p>Multi 程序相当整洁, 但对于我来说似乎并不完整。一些背景 — 人们可以这样计算阶乘:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="no">Inf</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span> <span class="nv">$n-1</span> <span class="p">)</span> <span class="p">}</span>
<span class="nb">say</span> <span class="nf">fac</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1"># 24</span>
</code></pre></div><p>现在假设我们要把我们的递归 multi-sub 作为一个回调传递会怎样呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="nv">&amp;fac</span> <span class="k">-&gt;</span> <span class="nv">$some_fun</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nf">some_fun</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="s2">=</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$some_fun</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>现在&hellip; 定义一个匿名的 multi-sub 怎么样？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$anon_fac</span> <span class="o">=</span> <span class="nb">do</span> <span class="p">{</span>
    <span class="k">multi</span> <span class="nf">hidden_fac</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="k">multi</span> <span class="nf">hidden_fac</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="no">Inf</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span> <span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">}</span>
    <span class="nv">&amp;hidden_fac</span> <span class="p">};</span>

<span class="nb">say</span> <span class="nv">$anon_fac</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1"># 24</span>
</code></pre></div><p>这也会有作用, 但是有点 hack 的味道, 并且我们的 multi-sub 并不是真正的匿名。它仅仅是被隐藏了。真正匿名的对象不会在任何作用域中安装, 而在这个例子中, &ldquo;hidden_fac&rdquo; 被安装在 &ldquo;do&rdquo; block 中的本地作用域中。</p>
<p>Raku说明书没有排除匿名的 multi 程序, 而且事实上</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$anon_fac</span> <span class="o">=</span> <span class="k">anon</span> <span class="k">multi</span> <span class="k">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
</code></pre></div><p>会报一个错误:</p>
<blockquote>
<p>Cannot use &lsquo;anon&rsquo; with individual multi candidates. Please declare an anon-scoped proto instead</p>
</blockquote>
<p>不能对单独的 multi 候选者使用 <code>anon</code>。请声明一个 anon-scoped 的 <strong>proto</strong> 代替。</p>
<p>让我们回到原先那个以 &ldquo;multi fac(0) { 1 }&rdquo; 开始的例子。当编译器看到它, 就会在同一个作用域中为我们创建一个&quot;proto fac&quot; 作为 <em>multi</em> 定义。<em>proto</em> 的作用就像一个分发器(dispatcher) — 从概念上讲, 当我们调用 fac(4) 的时候, 我们让 <em>proto fac</em> 为我们从 <em>multi facs</em> 中挑选一个出来以调用。</p>
<p>我们可以提前显式地定义一个 <em>proto</em>, 而且我们甚至能通过指定它的所有程序都需要 <strong>Int</strong> 类型的参数来对默认的 &ldquo;proto&rdquo; 加以改良。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">fac_with_proto</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac_with_proto</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac_with_proto</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="no">Inf</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span> <span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">}</span>
<span class="nb">say</span> <span class="nf">fac_with_proto</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1"># 24</span>
</code></pre></div><p>因此, <em>anon muiti sub</em> 抛出的错误 — <em>Please declare an anon-scoped proto instead</em> — 正是告诉我们 &ldquo;没有要安装到的作用域, 我不能为你获取一个 proto。 使用你自己的 <em>anon proto</em>, 并把这个程序附加给它&rdquo;。</p>
<p>好的, 花蝴蝶, 感谢你的提醒! 我试试&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$fac_proto</span> <span class="o">=</span> <span class="k">anon</span> <span class="k">proto</span> <span class="nf">uninstalled-fac</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">$fac_proto</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># uninstalled-fac</span>
</code></pre></div><p>好极了! 现在所有我们要做的就是给那个 <em>proto</em> 添加 <em>multi</em>s。</p>
<p><strong>$fac_proto</strong> 是一个 <strong>Sub</strong> 对象, 它有方法来告诉你候选者, 但是没有办法设置(<strong>set</strong>) 候选者。并且我找不到任何方式在创建时传递一个候选者列表。</p>
<h2 id="适当的修补">适当的修补</h2>
<hr>
<p>什么会让 <em>proto/multi</em> 干净并且正交是一种方式去</p>
<ul>
<li>在编译时指定候选者</li>
<li>在运行时添加候选者</li>
</ul>
<p>这有点像</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$future_fac</span> <span class="o">=</span> <span class="nf">Proto</span><span class="p">(</span> <span class="p">:</span><span class="s">dispatch</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span> <span class="p">)</span><span class="o">,</span>
                        <span class="p">:</span><span class="s">candidates</span><span class="p">(</span> <span class="o">[</span><span class="k">sub</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">]</span> <span class="p">)</span><span class="o">,</span>
                        <span class="p">:</span><span class="s">mutable</span> <span class="p">);</span>

<span class="nv">$future_fac</span><span class="o">.</span><span class="nb">candidates</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span>
    <span class="k">sub</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="no">Inf</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span> <span class="nv">$n-1</span> <span class="p">)</span> <span class="p">}</span>
<span class="p">);</span>

<span class="nv">$future_fac</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1"># 24</span>
</code></pre></div><p>我假定了一个 <strong>Sub</strong> 的子类 <strong>Proto</strong> 以揭露 multi 程序的内部工作原理。这个构造函数会允许定义任何 <em>proto</em> 声明符所做的: 签名 <code>&amp;</code> 默认程序和名字。 还有, 它会允许在初始的候选者列表中传递一个属性。</p>
<p>最后, 那个对象自身会让候选者方法返回一个数组, 而不是一个不可变列表, 如果 <em>Proto</em> 是使用 <em>mutable</em> 属性创建的话。不指定 <em>mutable</em> 将意味着所有的 <em>multi</em>s 需要在编译时添加, 而不允许在运行时添加。</p>
<p><a href="http://blogs.perl.org/users/yary/2016/02/apropos-proto-perl6c-multi-thoughts.html">http://blogs.perl.org/users/yary/2016/02/apropos-proto-perl6c-multi-thoughts.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/proto" term="proto" label="proto" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[A Mutable Grammar for Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Grammar 解析文本: 一个例子" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>A Mutable Grammar for Raku</blockquote><p>## A Mutable Grammar For Raku</p>
<h3 id="rules">Rules</h3>
<p><code>Rules</code> 就像 perl5的 <code>regexes</code>, 并且更好。它们像子例程和方法那样申明, 并且还能调用其它 rules</p>
<p>下面是一个解析 Raku 基本变量名的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nb">Raku</span> <span class="p">{</span>  
    <span class="c1"># token alpha 是一个预定义好的 rule</span>
    <span class="nf">token</span> identifier <span class="p">{</span><span class="sr">           
</span><span class="sr">       </span><span class="p">&lt;</span><span class="nb">alpha</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">     
</span><span class="sr">    </span><span class="p">}</span>    
    
   <span class="c1"># 匹配一个全限定名标识符</span>
    <span class="c1"># [ ... ]  是非捕获组</span>
    <span class="k">token</span> <span class="nf">name</span> <span class="p">{</span><span class="sr">        
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr">         
</span><span class="sr">        </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="o">*</span><span class="sr">     
</span><span class="sr">    </span><span class="p">}</span>
     <span class="c1"># .. | .. 是分支. 最长匹配胜出.</span>
    <span class="k">token</span> <span class="nf">sigil</span> <span class="p">{</span><span class="sr">        
</span><span class="sr">       </span><span class="p">&#39;</span><span class="s1">$</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">@</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;</span><span class="sr">    
</span><span class="sr">    </span><span class="p">}</span>    
    <span class="c1"># &lt;rule&gt; 调用命名 rule, 隐式地锚定在当前位置</span>
    <span class="k">token</span> <span class="nf">variable</span> <span class="p">{</span><span class="sr">      
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">sigil</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">name</span><span class="p">&gt;</span><span class="sr">  
</span><span class="sr">    </span><span class="p">}</span>

<span class="p">}</span> 
</code></pre></div><h3 id="grammars">Grammars</h3>
<p><code>Grammar</code> 跟类很像, 含有 <code>rules</code> 而不是 methods。Grammars 是 <code>rules</code> 的集合并支持<code>继承</code>。</p>
<p>如果要求 Raku 中变量的名字必须大写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 我们继承原来那个 grammar</span>
<span class="k">grammar</span> <span class="nc">PERL6</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>    
    <span class="c1"># ... 重写我们想改变的解析规则</span>
    <span class="k">token</span> <span class="nf">identifier</span> <span class="p">{</span><span class="sr">        
</span><span class="sr">   </span><span class="c1"># Raku 中的字符类现在写作 &lt;[ ... ]&gt;         
</span><span class="c1"></span><span class="sr">       </span><span class="p">&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">Z</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">Z</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="sr">_</span><span class="p">]&gt;</span><span class="o">*</span><span class="sr">   </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在我们只需告诉编译器使用 <code>PERL6</code> 这个 grammar 而非默认 grammar 。还记得类中的方法调用顺序吗？ 先从本类开始, 沿着继承树从下而上到父类。Grammar 与之类似。</p>
<p>然而有一个缺陷。假设你想更改一个符号, 例如把 <code>$</code> 更改 为 <code>¢</code>（因为你没有足够的 <code>$$$</code> 来买下所有的变量, 不是吗？）看起来很简单：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">LowBudgetRaku</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>
    <span class="c1"># token 就像类中的方法一样, 继承后可以修改</span>
    <span class="k">token</span> <span class="nf">sigil</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">¢</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">@</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>新的 grammar 解析工作的很好,  但是那之后的所有东西肯定会失败。当编译器在解析树里看见 <code>sigil</code> 匹配时, 它得找出到底是哪一个 - 这意味着它必须要检查匹配文本的字面值,  而它并不知道怎么处理 <code>¢</code>。</p>
<p>所以, 我们需要更多的技能&hellip;</p>
<h2 id="proto-regexes">Proto Regexes</h2>
<p> <code>proto regex</code> 是一套有着相同名字的 regexes/rules, 当前的 <a href="http://svn.pugscode.org/pugs/src/raku/STD.pm">Raku grammar</a> 使用这个结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">token</span> <span class="nf">sigil</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
<span class="c1"># ...</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;$&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;@&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;%&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;&amp;&gt;  <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">token</span> <span class="nf">sigil:sym</span>&lt;::&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>这创建了一个叫做 <code>sigil</code> 的组(<code>proto</code>), 组里面有使用 <code>sym</code> 标识符参数化的 5 个规则(rules)（它们属于这个组因为它们跟组的名字相同）。 第一个把 <code>sym</code> 设置为 <code>$</code> 然后匹配这个符号(使用<code>&lt;sym&gt;</code>). 第二个匹配 <code>@</code> 等等。现在如果调用规则 <code>&lt;sigil&gt;</code>, 你会得到一个含有上述所有 5 个规则的列表, 列表元素之间是或的关系。所以它依然跟正则 <code>'$' | '@' | '%' | '&amp;' | '::'</code> 匹配相同的东西, 但是更容易扩展。</p>
<p>如果你想添加一个新的符号, Grammar 中唯一要修改的就是添加另外一个 <code>sigil</code> 规则： </p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">SigilRichP6</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">sigil:sym</span>&lt;ħ&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># 物理学家会很爱你</span>
<span class="p">}</span>
</code></pre></div><p>回到原来那个例子,  你可以重写已存在的规则：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">LowBudgetRaku</span> <span class="k">is</span> <span class="nb">Raku</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">sigil:sym</span>&lt;$&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">¢</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在这个 grammar 为标量使用了一个不同的符号,  但是它和原来的 grammar 有着相同的规则和相同的参数(<code>sigil:sym&lt;$&gt;</code>), 编译器仍然知道怎么处理它。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[comb - 操作字符串的利器]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-02-03-comb-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-02-03-comb-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Comb in Raku</blockquote><p>comb - 操作字符串的利器</p>
<h2 id="comb-子例程">comb 子例程</h2>
<p>comb 子例程的定义为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">comb</span><span class="p">(</span><span class="nb">Regex</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="nb">Str</span><span class="p">(</span><span class="nb">Cool</span><span class="p">)</span> <span class="nv">$input</span><span class="o">,</span> <span class="nv">$limit</span> <span class="o">=</span> <span class="o">*</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">comb</span><span class="p">(</span><span class="nb">Regex</span> <span class="nv">$matcher</span><span class="o">,</span>                   <span class="nv">$limit</span> <span class="o">=</span> <span class="o">*</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">comb</span> <span class="o">/</span><span class="n">PATTERN</span><span class="o">/,</span> <span class="n">STRING</span><span class="o">,</span> <span class="n">LIMIT</span><span class="o">?</span>  <span class="c1"># 子例程形式</span>
<span class="n">STRING</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="sr">PATTERN</span><span class="p">/</span><span class="o">,</span> <span class="n">LIMIT</span><span class="o">?</span><span class="p">)</span>  <span class="c1"># 方法形式</span>
</code></pre></div><p>返回调用者（方法形式）的所有（或者至多 $limit 个，如果提供了的话）匹配，或者返回第二个参数（sub 形式）与 Regex 相匹配的字符串列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">6 or 12</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\d</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">, </span><span class="p">&#34;);</span> <span class="c1"># 6, 12</span>
</code></pre></div><h2 id="str-类中的-comb">Str 类中的 comb</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">comb</span><span class="p">(</span><span class="nb">Str:D</span>   <span class="nv">$matcher</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="nv">$input</span><span class="o">,</span> <span class="nv">$limit</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">comb</span><span class="p">(</span><span class="nb">Regex:D</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="nv">$input</span><span class="o">,</span> <span class="nv">$limit</span> <span class="o">=</span> <span class="no">Inf</span><span class="o">,</span> <span class="nb">Bool</span> <span class="o">:</span><span class="nv">$match</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">comb</span><span class="p">(</span><span class="nb">Int:D</span> <span class="nv">$size</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="nv">$input</span><span class="o">,</span> <span class="nv">$limit</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">)</span>

<span class="k">multi</span> <span class="k">method</span> <span class="nb">comb</span><span class="p">(</span><span class="nb">Str:D</span> <span class="nv">$input:</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">comb</span><span class="p">(</span><span class="nb">Str:D</span> <span class="nv">$input:</span> <span class="nb">Str:D</span>   <span class="nv">$matcher</span><span class="o">,</span> <span class="nv">$limit</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">comb</span><span class="p">(</span><span class="nb">Str:D</span> <span class="nv">$input:</span> <span class="nb">Regex:D</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="nv">$limit</span> <span class="o">=</span> <span class="no">Inf</span><span class="o">,</span> <span class="nb">Bool</span> <span class="o">:</span><span class="nv">$match</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">comb</span><span class="p">(</span><span class="nb">Str:D</span> <span class="nv">$input:</span> <span class="nb">Int:D</span> <span class="nv">$size</span><span class="o">,</span> <span class="nv">$limit</span> <span class="o">=</span> <span class="no">Inf</span><span class="p">)</span>
</code></pre></div><p>在 <code>$input</code> 中搜索 <code>$matcher</code> 并返回所有匹配（默认是 Str，或者是 Match 对象，如果 <code>$match</code> 为真的话）的一个列表。<code>$limit</code> 表示至多返回 <code>$limit</code> 个匹配。</p>
<p>如果没有提供 <code>$matcher</code>(匹配器)， 那么会返回字符串中的所有字符的列表。等价于使用了 <code>$matcher = rx/./</code>。</p>
<p>例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="p">/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">a;b;c</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>        <span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c&#34;).list</span>
<span class="nb">comb</span><span class="p">(/</span><span class="se">\N</span><span class="p">/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">a;b;c</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>        <span class="c1"># (&#34;a&#34;, &#34;;&#34;, &#34;b&#34;, &#34;;&#34;, &#34;c&#34;).list</span>
<span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="p">/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">a;b;c</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>     <span class="c1"># (&#34;a&#34;, &#34;b&#34;).list</span>
<span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="sr">\;</span><span class="se">\w</span><span class="p">/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">a;b;c</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># (&#34;a;b&#34;,).list</span>

<span class="p">&#34;</span><span class="s2">123abc456def</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>           <span class="c1"># (123 abc 456 def)</span>
<span class="p">&#34;</span><span class="s2">123abc456def</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="p">);</span>        <span class="c1"># (123 abc)</span>
</code></pre></div><p>如果匹配器（matcher）是一个整数值，那么它被认为和 <code>/. ** matcher/</code> 类似，但是这个快了 30 倍。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/comb" term="comb" label="comb" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Guess Who]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-20-guess-who/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Guess Who</blockquote><p>你是一个刚成立的小公司里的一名软件工程师, 有天晚上你收到了一封来自 CEO 的电子邮件:</p>
<blockquote>
<p>亲爱的工程师,</p>
<p>​    好新闻！看起来我们的网站越来越受欢迎。我们要变的有钱了! 每秒钟有成千上万的人在同时访问我们的网站, 而且还在快速增长。</p>
<p>我们必须立即识别出谁的通信量最大。幸运的是我的朋友给我发送了一份巨大的 IP 地址和名字的列表。很酷不是吗？你能写一段程序接收我们大量的访问者, 把它和地址/名字列表相比, 并创建一些统计吗？我的意思是, 生成一个国家的名字列表。</p>
<p>做好了的话我给你们开个披萨聚会。</p>
</blockquote>
<blockquote>
<p>邮件的附件文件包含了一个 IP 地址和名字的列表。写一个程序来统计下有多少 IP 访问了你的网站。</p>
</blockquote>
<h2 id="输入描述">输入描述</h2>
<p>输入来自两部分。第一个是一个文本文件, 包含 IP 地址范围。每行一项,使用两个空格分割 IP 和名字。</p>
<p>第二个文件是一个 IP 地址的列表, 每行一个, 它们是必须被查询的IP。</p>
<h2 id="ip-输入样本">IP 输入样本</h2>
<p>输入是有包含两个 IP 地址和一个跟 IP 范围关联的名字的大量行组成。</p>
<pre><code>123.45.17.8 123.45.123.45 University of Vestige
123.50.1.1 123.50.10.1 National Center for Pointlessness
188.0.0.3 200.0.0.250 Mayo Tarkington
200.0.0.251 200.0.0.255 Daubs Haywire Committee
200.0.1.1 200.255.255.255 Geopolitical Encyclopedia
222.222.222.222 233.233.233.233 SAP Rostov
250.1.2.3 250.4.5.6 Shavian Refillable Committee
123.45.100.0 123.60.32.1 United Adverbs
190.0.0.1 201.1.1.1 Shavian Refillable Committee
238.0.0.1 254.1.2.3 National Center for Pointlessness
</code></pre><p>注意: 这些 IP 范围不能保证是 IPv4 &ldquo;子网&rdquo;。这意味着它们可能不能精确地由基于前缀的 CIDR 块来表示。</p>
<p>范围可以重叠。可能多余2层深。</p>
<p>可可有多个范围关联同一个名字。</p>
<h2 id="查询输入样本">查询输入样本</h2>
<pre><code>250.1.3.4
123.50.1.20
189.133.73.57
123.50.1.21
250.1.2.4
123.50.1.21
250.1.3.100
250.1.3.5
188.0.0.5
123.50.1.100
123.50.2.34
123.50.1.100
123.51.100.52
127.0.0.1
123.50.1.22
123.50.1.21
188.0.0.5
123.45.101.100
123.45.31.52
230.230.230.230
</code></pre><h2 id="输出格式化">输出格式化</h2>
<p>倒序输出访问次数。</p>
<pre><code>8 - National Center for Pointlessness
4 - Shavian Refillable Committee
3 - Mayo Tarkington
2 - University of Vestige
1 - SAP Rostov
1 - United Adverbs
1 - &lt;unknown&gt;
</code></pre><h2 id="解释">解释</h2>
<p>这儿是一个输入 IP 和它的名字的映射:</p>
<pre><code>National Center for Pointlessness
123.50.1.20
123.50.1.21
123.50.1.22
123.50.1.21
123.50.1.21
123.50.1.100
123.50.1.100
123.50.2.34

Shavian Refillable Committee
250.1.2.4
250.1.3.4
250.1.3.5
250.1.3.100

Mayo Tarkington
188.0.0.5
188.0.0.5
189.133.73.57

University of Vestige
123.45.101.100
123.45.31.52

SAP Rostov
230.230.230.230

United Adverbs
123.51.100.52

&lt;unknown&gt;
127.0.0.1
</code></pre><p>smls 的解决方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">ip-to-number</span> <span class="p">(</span><span class="nv">$ip</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">do</span> <span class="k">given</span> <span class="nv">$ip</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span> <span class="p">{</span>
        <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+&lt;</span> <span class="mi">24</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+&lt;</span> <span class="mi">16</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+&lt;</span>  <span class="mi">8</span> <span class="o">+</span>
        <span class="o">.[</span><span class="mi">3</span><span class="o">]</span> <span class="o">+&lt;</span>  <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">IntervalTree</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.min</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.max</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!center</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$!min</span> <span class="o">+</span> <span class="nv">$!max</span><span class="p">)</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@!intervals</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">IntervalTree</span> <span class="nv">$!left</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">IntervalTree</span> <span class="nv">$!right</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">new</span> <span class="p">(</span><span class="nv">$min</span><span class="o">,</span> <span class="nv">$max</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">$min</span><span class="o">,</span> <span class="o">:</span><span class="nv">$max</span><span class="p">)</span> <span class="p">}</span>

    <span class="k">method</span> <span class="nf">insert</span> <span class="p">(</span><span class="o">|</span><span class="n">c</span> <span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$end</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="ow">and</span> <span class="nv">$!min</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$!left</span> <span class="o">//=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$!min</span><span class="o">,</span> <span class="nv">$!center</span><span class="p">))</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">elsif</span> <span class="nv">$start</span> <span class="o">&gt;</span> <span class="nv">$!center</span> <span class="ow">and</span> <span class="nv">$!max</span> <span class="o">&gt;</span> <span class="nv">$!center</span> <span class="p">{</span>
            <span class="p">(</span><span class="nv">$!right</span> <span class="o">//=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$!center</span><span class="o">,</span> <span class="nv">$!max</span><span class="p">))</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="o">[</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">$end-$start</span><span class="o">]</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">prepare</span> <span class="p">{</span>
        <span class="nv">@!intervals</span><span class="o">.=</span><span class="nb">sort</span><span class="p">(</span><span class="o">*[</span><span class="mi">3</span><span class="o">]</span><span class="p">);</span>
        <span class="nv">$!left</span> <span class="o">.</span><span class="nf">prepare</span> <span class="k">if</span> <span class="nv">$!left</span><span class="p">;</span>
        <span class="nv">$!right</span><span class="o">.</span><span class="nf">prepare</span> <span class="k">if</span> <span class="nv">$!right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">lookup</span> <span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$best</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$n</span> <span class="o">&lt;</span> <span class="nv">$!center</span> <span class="o">??</span> <span class="p">(</span><span class="nv">$!left</span> <span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$!left</span><span class="p">)</span>
                                  <span class="o">!!</span> <span class="p">(</span><span class="nv">$!right</span><span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="k">if</span> <span class="nv">$!right</span><span class="p">));</span>
        <span class="nv">$best</span> <span class="o">??</span> <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span> <span class="k">return</span> <span class="nv">$best</span> <span class="k">if</span> <span class="o">.[</span><span class="mi">3</span><span class="o">]</span> <span class="o">&gt;</span> <span class="nv">$best</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="p">;</span>
                                     <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="p">})</span> <span class="o">//</span> <span class="nv">$best</span>
              <span class="o">!!</span> <span class="nv">@!intervals</span><span class="o">.</span><span class="nb">first</span><span class="p">({</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="o">.[</span><span class="mi">1</span><span class="o">]</span> <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span><span class="nv">$ip-file</span><span class="o">,</span> <span class="nv">$query-file</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$index</span> <span class="o">=</span> <span class="n">IntervalTree</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">ip-to-number</span> <span class="p">&#39;</span><span class="s1">255.255.255.255</span><span class="p">&#39;);</span>

    <span class="k">for</span> <span class="nv">$ip-file</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$end</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="nv">$index</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="nf">ip-to-number</span><span class="p">(</span><span class="nv">$start</span><span class="p">)</span><span class="o">,</span> <span class="nf">ip-to-number</span><span class="p">(</span><span class="nv">$end</span><span class="p">)</span><span class="o">,</span> <span class="nv">$name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nv">$index</span><span class="o">.</span><span class="nf">prepare</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="nv">$query-file</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$ip</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$index</span><span class="o">.</span><span class="nb">lookup</span><span class="p">(</span><span class="n">ip-to-number</span> <span class="nv">$ip</span><span class="p">)</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$ip</span><span class="s2"> </span><span class="p">{</span><span class="nv">$name</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">&lt;unknown&gt;</span><span class="p">&#39;}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[List in Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>List in Raku</blockquote><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">class</span> <span class="nb">List</span> <span class="k">is</span> <span class="nb">Iterable</span> <span class="k">does</span> <span class="nb">Positional</span> <span class="p">{</span> <span class="o">..</span> <span class="p">}</span>
</code></pre></div><p><strong>List</strong> 以序列化的方式存储 items并且潜在是惰性的。</p>
<p>默认列表和数组的索引从 0 开始。</p>
<p>你可以给列表中的元素赋值如果它们是容器的话。使用数组以使列表中的每个元素存储在容器中。</p>
<h2 id="itemsflattening-和-sigils">Items、Flattening 和 Sigils</h2>
<p>在 Raku 中, 把 <strong>List</strong> 赋值给一个标量变量不会丢失信息。不同之处在于迭代通常会把标量中的列表当作单个元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 三次迭代</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$s</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 一次迭代</span>
<span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># 一次迭代</span>
<span class="k">for</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">list</span> <span class="p">{</span> <span class="p">}</span> <span class="c1"># 三次迭代</span>
</code></pre></div><p><strong>Lists</strong> 通常会插值(展开)除非它们通过一个 item(scalar)容器访问:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@flat</span>   <span class="o">=</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>           <span class="c1"># two elements</span>
<span class="k">my</span> <span class="nv">@nested</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="o">,</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="p">;</span> <span class="c1"># two elements</span>
</code></pre></div><p><code>.item</code> 通常能被写为 <code>$( ... )</code>, 而在数组变量上甚至写为 <code>$@a</code>。</p>
<h2 id="methods">Methods</h2>
<h3 id="elems">elems</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">elems</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">Int:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中元素的个数。</p>
<h3 id="end">end</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">end</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">Int:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">end</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中最后一个元素的索引</p>
<h3 id="keys">keys</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">keys</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">keys</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个索引列表( 例如 <code>0..(@list.elems-1)</code> )</p>
<h3 id="values">values</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">values</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">values</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回列表的一份拷贝。</p>
<h3 id="kv">kv</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">kv</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>  <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">kv</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回索引和值的交替的列表。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">kv</span>
</code></pre></div><p>返回:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span>
</code></pre></div><h3 id="pairs">pairs</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pairs</span><span class="p">(</span><span class="nv">$list</span><span class="p">)</span>   <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pairs</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个 pairs 的列表, 使用索引作为键, 列表值作为键值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pairs</span>   <span class="c1"># 0 =&gt; &#39;a&#39;, 1 =&gt; &#39;b&#39;, 2 =&gt; &#39;c&#39;</span>
</code></pre></div><h3 id="join">join</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">join</span><span class="p">(</span><span class="nv">$separator</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">join</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$separator</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>把列表中元素当作字符串, 在元素之间插入 <code>$separator</code> 并把所有东西连接成单个字符串。</p>
<p>例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">join</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>     <span class="c1"># &#39;a, b, c&#39;</span>
</code></pre></div><h3 id="map">map</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">map</span><span class="p">(</span><span class="nv">&amp;code</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">map</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;code</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>对每个元素调用 <code>&amp;code</code> 并且把值收集到另外一个列表中并返回它。这个过程是惰性的。<code>&amp;code</code>只在返回值被访问的时候调用。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">WHAT</span><span class="o">.</span><span class="nb">raku</span> <span class="p">};</span> <span class="c1"># Str Int Rat Int Str</span>
<span class="nb">map</span> <span class="o">*.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span>      <span class="c1"># 5 1 8 2 5</span>
</code></pre></div><h3 id="grep">grep</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">grep</span><span class="p">(</span><span class="nb">Mu</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">grep</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span>  <span class="nb">Mu</span> <span class="nv">$matcher</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一个使用 <code>$matcher</code> 智能匹配的惰性列表。元素是以出现在原列表中的顺序返回的。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="nb">Int</span><span class="p">;</span>              <span class="c1"># 1 42</span>
<span class="nb">grep</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">}</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;;</span> <span class="c1"># hello 3.142857 world</span>
</code></pre></div><h3 id="first">first</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">first</span><span class="p">(</span><span class="nb">Mu</span> <span class="nv">$matcher</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">first</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span>  <span class="nb">Mu</span> <span class="nv">$matcher</span><span class="p">)</span>
</code></pre></div><p>返回列表中第一个匹配 <code>$matcher</code> 的元素, 当没有匹配值时, 失败。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">;</span> <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$f</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="nb">Complex</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;</span><span class="o">,</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">)</span><span class="o">.</span><span class="nb">first</span><span class="o">:</span> <span class="nb">Complex</span><span class="p">;</span> <span class="c1"># 1+2i</span>
<span class="nb">say</span> <span class="nv">$f</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> 
<span class="c1"># Failure.new(exception =&gt; X::AdHoc.new(payload =&gt; &#34;No values matched&#34;))</span>
</code></pre></div><h3 id="classify">classify</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">classify</span><span class="p">(</span><span class="nv">&amp;mapper</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Hash:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">classify</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;mapper</span><span class="p">)</span>   <span class="k">returns</span> <span class="nb">Hash:D</span>
</code></pre></div><p>根据映射器把一列值转换成代表那些值的类别的散列; 散列的每个键代表着将要归入列表的一个或多个值的类别。比如字符个数,  元素多少, 键值就是根据 mapper 得到的这个类别下的元素,  它来自于原始列表：</p>
<p>例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">classify</span> <span class="p">{</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">even</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">odd</span><span class="p">&#39;</span> <span class="p">}</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1"># (&#34;odd&#34; =&gt; [1, 7, 3], &#34;even&#34; =&gt; [6, 2]).hash;</span>

<span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">hello</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">22</span><span class="o">/</span><span class="mi">7</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">world</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">classify</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>
<span class="c1"># (&#34;5&#34; =&gt; [&#34;hello&#34;, &#34;world&#34;], &#34;1&#34; =&gt; [1], &#34;8&#34; =&gt; [22/7], &#34;2&#34; =&gt; [42]).hash</span>
</code></pre></div><h3 id="bool">Bool</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Bool</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>如果列表至少含有一个元素则返回 True, 如果列表为空则返回 False。</p>
<h3 id="str">Str</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Str</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>字符串化列表中的元素并使用空格把这些元素连接起来。( 和 <code>.join(' ')</code> 一样)。</p>
<h3 id="int">Int</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">Int</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">return</span> <span class="nb">Int:D</span>
</code></pre></div><p>返回列表中元素的数量(和 <code>.elems</code> 一样)</p>
<h3 id="pick">pick</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pick</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pick</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>从调用者身上随机返回 <code>$count</code> 个不重复的元素。 如果 <code>*</code> 作为 <code>$count</code> 传递进来或 <code>$count</code> 大于或等于列表的大小, 那么就以随机序列的方式返回列表中的所有元素。</p>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="p">;</span>     <span class="c1"># b</span>
<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="o">:</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1"># c a e</span>
<span class="nb">say</span>  <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="o">:</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># e d a b c</span>
</code></pre></div><h3 id="roll">roll</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">roll</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">*</span><span class="nv">@list</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">roll</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div><p>返回一个 <code>$count</code> 个元素的惰性列表, 每个元素都从列表中随机选择。每个随机选择都是独立的.</p>
<p>如果给 <code>$count</code> 传递了 <code>*</code> 号, 则返回一个惰性的, 从原列表中随机选取元素的无限列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">;</span>       <span class="c1"># b</span>
<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="o">:</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1"># c c e</span>
<span class="nb">say</span> <span class="nb">roll</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;;</span>    <span class="c1"># b a e d a e b c</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$random_digits</span> <span class="o">:=</span> <span class="p">(</span><span class="o">^</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="o">*</span><span class="p">);</span><span class="mi">1</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$random_digits</span><span class="o">[^</span><span class="mi">15</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 3 8 7 6 0 1 3 2 0 8 8 5 8 0 5</span>
</code></pre></div><h3 id="eager">eager</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">eager</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>急切地计算列表中的所有元素, 并返回调用者。如果列表标示它是 &ldquo;konw inifinite&rdquo; 的, 急切求值可以停止在探测到的无限的点上。</p>
<h3 id="reverse">reverse</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">reverse</span><span class="p">(</span><span class="o">*</span><span class="nv">@list</span> <span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">reverse</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>以相反的顺序返回一个含有相同元素的列表。
注意 <code>reverse</code> 总是指反转列表中的元素, 如果你想反转字符串中的字符, 那么使用 flip。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">hello world!</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">reverse</span>      <span class="c1">#  world! hello</span>
<span class="nb">say</span> <span class="nb">reverse</span> <span class="o">^</span><span class="mi">10</span>                 <span class="c1"># 9 8 7 6 5 4 3 2 1 0</span>
</code></pre></div><h3 id="rotate">rotate</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">rotate</span><span class="p">(</span><span class="nv">@list</span><span class="o">,</span>  <span class="nb">Int:D</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">rotate</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Int:D</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>以 <code>$n</code> 个元素旋转列表, 这把原列表分成两部分, 旋转中心就是在这两部分之间:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>   <span class="c1"># &lt;c d e a b&gt;</span>
<span class="p">&lt;</span><span class="s">a b c d e</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1"># &lt;e a b c d&gt;</span>
</code></pre></div><h3 id="sort">sort</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">sort</span><span class="p">(</span><span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">sort</span><span class="p">(</span><span class="nv">&amp;by</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">sort</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:,</span> <span class="nv">&amp;by</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>列表排序, 最小的元素首先。默认使用 <code>infix:&lt;cmp&gt;</code> 排序列表中的元素。</p>
<p>如果提供了 <code>&amp;by</code>, 那么它接收两个参数, 它由列表元素对儿调用, 并且应该返回 <code>Order::Increase</code>, <code>Order::Same</code> 或 <code>Order::Decrease</code>。</p>
<p>如果 <code>&amp;by</code> 只接受一个参数, 那么列表元素是通过 <code>by($a) cmp by($b)</code> 来排序的。<code>&amp;by</code> 的返回值被缓存起来, 以使每个列表元素只调用一次 <code>&amp;by</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>                  <span class="c1"># -4 -1 0 2 3 7</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="o">*.</span><span class="nb">abs</span><span class="p">;</span>           <span class="c1"># 0 -1 2 3 -4 7</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^b</span> <span class="ow">leg</span> <span class="nv">$^a</span> <span class="p">};</span> <span class="c1"># 7 3 2 0 -4 -1</span>
</code></pre></div><h3 id="reduce">reduce</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">reduce</span><span class="p">(</span><span class="nv">&amp;with</span><span class="o">,</span> <span class="o">*</span><span class="nv">@elems</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">&amp;with</span><span class="p">)</span>
</code></pre></div><p>把 <code>&amp;with</code> 应用到列表中的第一个和第二个值上, 然后把 <code>&amp;with</code> 应用到那个计算的结果值和第三个值上, 以此类推。按照那种方式生成单个项。</p>
<p>注意 <code>reduce</code> 是一个隐式的循环。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">reduce</span><span class="o">:</span> <span class="o">*</span> <span class="o">-</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># -4</span>
</code></pre></div><h3 id="splice">splice</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">splice</span><span class="p">(</span><span class="nv">@list</span><span class="o">,</span>  <span class="nv">$start</span><span class="o">,</span> <span class="nv">$elems</span><span class="o">?,</span> <span class="o">*</span><span class="nv">@replacement</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">splice</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$elems</span><span class="o">?,</span> <span class="o">*</span><span class="nv">@replacement</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>从列表中删除从 <code>$start</code> 索引开始的 <code>$elems</code> 个元素, 返回删除的元素并用 <code>@replacement</code> 来代替它。如果省略了 <code>$elems</code>, 所有从 <code>$index</code> 开始的元素都被删除。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c d e f g</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">splice</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">M N O P</span><span class="p">&gt;);</span> <span class="c1"># c d e</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span>                         <span class="c1"># a b M N O P f g</span>
</code></pre></div><h3 id="pop">pop</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">pop</span><span class="p">(</span><span class="nb">List:D</span> <span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">pop</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>从列表中移除并返回最后一项。如果列表为空则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="o">&gt;</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">pop</span><span class="p">;</span>  <span class="c1"># b</span>
<span class="o">&gt;</span> <span class="nb">pop</span> <span class="nv">@foo</span>   <span class="c1"># a</span>
<span class="o">&gt;</span> <span class="nb">pop</span> <span class="nv">@foo</span>   <span class="c1"># Element popped from empty list</span>
</code></pre></div><h3 id="push">push</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">push</span><span class="p">(</span><span class="nb">List:D</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">push</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>把 <code>@values</code> 添加到列表的末尾, 并返回修改后的列表。 如果列表是无限列表则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
<span class="nv">@foo</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="mi">11</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span>                   <span class="c1"># a b c 1 3 5 7 9 11</span>
</code></pre></div><h3 id="shift">shift</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">shift</span><span class="p">(</span><span class="nb">List:D</span> <span class="p">)</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">shift</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span>
</code></pre></div><p>从列表中移除并返回第一项元素。如果列表为空则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># a</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># b</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>     <span class="c1"># Element shifted from empty list</span>
</code></pre></div><h3 id="unshift">unshift</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span>    <span class="nb">unshift</span><span class="p">(</span><span class="nb">List:D</span><span class="o">,</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">unshift</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="o">*</span><span class="nv">@values</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>添加 <code>@values</code> 到列表的开头, 并返回修改后的列表。如果列表是无限列表则失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@foo</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>
<span class="nv">@foo</span><span class="o">.</span><span class="nb">unshift</span><span class="o">:</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="mi">11</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="p">;</span> <span class="c1"># 1 3 5 7 9 11 a b c</span>
</code></pre></div><h5 id="combinations">combinations</h5>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">combinations</span> <span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Int:D</span> <span class="nv">$of</span><span class="p">)</span>          <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">method</span> <span class="nb">combinations</span> <span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span> <span class="nb">Range:D</span> <span class="nv">$of</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..*</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">combinations</span> <span class="p">(</span><span class="nv">$n</span><span class="o">,</span> <span class="nv">$k</span><span class="p">)</span>                     <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>Int 变体返回调用者列表所有的 <code>$of-combinations</code> 组合。例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">combinations</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div><p>打印</p>
<pre><code>a|b
a|c
b|c
</code></pre><p>因为  &lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo; 的所有 2-combinations 是  [&lsquo;a&rsquo;, &lsquo;b&rsquo;], [&lsquo;a&rsquo;, &lsquo;c&rsquo;], [&lsquo;b&rsquo;, &lsquo;c&rsquo;].</p>
<p>Range 变体把所有单独的组合组合到单个列表中, 所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">combinations</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div><p>打印：</p>
<pre><code>a|b
a|c
b|c
a|b|c
</code></pre><p>因为那是一个所有 2-和3-combinations 组合的列表。</p>
<p>子例程 <code>combinations($n, $k)</code> 等价于 <code>(^$n).combinations($k)</code>, 所以：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">combinations</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><p>打印：</p>
<pre><code>0 1
0 2
0 3
1 2
1 3
2 3
</code></pre><h3 id="permutations">permutations</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">method</span> <span class="nb">permutations</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
<span class="k">multi</span> <span class="k">sub</span>    <span class="nb">permutations</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span>      <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回列表所有可能的组合作为数组的列表。所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">permutations</span>
</code></pre></div><p>打印：</p>
<pre><code>a|b|c
a|c|b
b|a|c
b|c|a
c|a|b
c|b|a
</code></pre><p><code>permutations</code> 把所有列表元素当作可区别的, 所以 <code>(1, 1, 2).permutations</code> 仍旧返回 6 个元素的列表, 即使只有 3 个不同的排列。</p>
<p><code>permutations($n)</code> 等价于 <code>(^$n).permutations</code>, 所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">permutations</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div><p>打印：</p>
<pre><code>1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Blogs]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-blogs/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2016-01-01-raku-blogs/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Blogs</blockquote><p>收集 Raku 方面的博文如下:</p>
<ul>
<li><a href="https://my.oschina.net/u/563463/blog/293900">Raku 的 Grammar 学习总结</a></li>
<li><a href="https://my.oschina.net/u/563463/blog/293590">Raku 的正则表达式</a></li>
<li><a href="https://my.oschina.net/u/563463/blog/371597">Raku 的正则表达式</a></li>
<li><a href="https://my.oschina.net/u/563463/blog/392467">Perl  6 的列表</a></li>
<li><a href="https://my.oschina.net/u/563463/blog/391975">Raku 的字符串</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_53480">Raku URB 解析</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_53641">Raku 格式化帮助信息</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_53146">Raku 解决 24 Game</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_53623">Raku 神的90亿名字整数版</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_52457">Raku 计算矩阵占比</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_52932">Raku 24游戏</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_53446">Raku temporary</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_52338">Raku 括号匹配</a></li>
<li><a href="https://www.oschina.net/code/snippet_2531803_52655">Raku 上传文件</a></li>
<li><a href="https://segmentfault.com/a/1190000004679283">译 Raku Object Orientation</a></li>
<li><a href="https://segmentfault.com/a/1190000004864391">译 Native Calling Interface</a></li>
<li><a href="https://segmentfault.com/a/1190000004957515">译 Raku 5to6-nutshell</a></li>
<li><a href="https://segmentfault.com/n/1330000004436212">Raku 括号的匹配</a></li>
<li><a href="https://segmentfault.com/n/1330000004493136">神的90亿名字整数版</a></li>
<li><a href="https://segmentfault.com/n/1330000004541894">Raku 正则替换</a></li>
<li><a href="https://segmentfault.com/n/1330000004616224">Raku 累加器工厂</a></li>
<li><a href="https://segmentfault.com/n/1330000004897576">Raku IEEE754</a></li>
<li><a href="https://segmentfault.com/n/1330000004929301">Raku usbip 自动 bind</a></li>
<li><a href="https://segmentfault.com/n/1330000004957503">Raku 5to6-perlfunc</a></li>
<li><a href="https://segmentfault.com/n/1330000004975097">Raku GetOption</a></li>
<li><a href="https://segmentfault.com/n/1330000005053516">Raku Search Binary-Tree node</a></li>
<li><a href="https://segmentfault.com/n/1330000005053546">Raku Getopt::Kinoko</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/blog" term="blog" label="blog" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Grammars]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Grammar 解析文本: 一个例子" />
            
                <id>https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Grammars</blockquote><h1 id="grammarshttpdocrakuorglanguagegrammars"><a href="http://doc.raku.org/language/grammars">Grammars</a></h1>
<p>Grammars - 一组具名 regexes 组成正式的 grammar</p>
<p>Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。</p>
<p>例如, Raku 是使用 Raku 风格 grammar 解析并执行的。</p>
<p>对普通 Raku 使用者更实用的一个例子是 <a href="https://github.com/moritz/json">JSON::Tiny</a>模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。</p>
<p>Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。</p>
<h2 id="具名正则-named-regexes">具名正则 (Named Regexes)</h2>
<p>　
grammars 的主要组成部分是 <a href="http://doc.raku.org/language/regexes">regexes</a>。 而 Raku 的 <a href="http://doc.raku.org/language/regexes">regexes</a>语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">number</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">[</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">}</span>   <span class="c1"># 普通 regex 中空格被忽略, [] 是非捕获组</span>
</code></pre></div><p>上面的代码使用 <code>my</code> 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</p>
<p>正则有名字了就方便我们在任何地方重用那个正则了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">32.51</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="nv">&amp;number</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">15 + 4.5</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr">  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="p">/</span>
<span class="nv">&amp;number</span>           <span class="c1"># my regex number { \d+ [ \. \d+ ]?   }  </span>
</code></pre></div><p>为什么用 <code>&amp;number</code>, 对比具名子例程你就知道了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="k">sub</span> <span class="nf">number</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">i am a subroutine</span><span class="p">&#34;</span> <span class="p">}</span>  <span class="c1"># 具名子例程</span>
<span class="o">&gt;</span> <span class="nv">&amp;number</span>                                 <span class="c1"># sub number () { #`(Sub|140651249646256) ... }</span>
</code></pre></div><p><code>&amp;number</code> 就是直接引用了具名的 regex 或 子例程。而在 <code>/ /</code> 或 grammars 里面, 引用一个具名正则的语法也很特殊, 就是给名字包裹上 <code>&lt; &gt;</code>。<code>&lt;&gt;</code> 就像引号那样, 当用它引起某个具名正则后, 引用这个 <code>&lt;&gt;</code> 就会把该具名正则插入(带入)到整个正则之中, 就像字符串插值那样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 具名正则的声明</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">number</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">[</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>  
<span class="k">my</span> <span class="k">token</span> <span class="nf">ident</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">            }
</span><span class="sr">my rule  alpha  </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">[A..Za..z]</span><span class="p">&gt;</span>   <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr"></span><span class="c1"># 1.0 通过 &amp; 来引用
</span><span class="c1"></span><span class="sr">say so </span><span class="p">&#34;</span><span class="s2">12.34</span><span class="p">&#34;</span><span class="sr"> </span><span class="o">~~</span><span class="sr"> </span><span class="nv">&amp;number</span><span class="sr">; </span><span class="c1"># true
</span><span class="c1"></span><span class="sr">
</span><span class="sr"></span><span class="c1"># 2.0 在正则构造 // 里使用
</span><span class="c1"></span><span class="sr">say so </span><span class="p">&#34;</span><span class="s2">12.88 + 0.12</span><span class="p">&#34;</span><span class="sr"> </span><span class="o">~~</span><span class="sr"> /  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  /; </span><span class="c1"># true
</span><span class="c1"># say so &#34;12.88 + 0.12&#34; ~~ /  \s* &#39;+&#39; \s*  /;
</span><span class="c1"># wrong, method &#39;number&#39; not found for invocant of class &#39;Cursor&#39;
</span><span class="c1"></span><span class="sr">
</span><span class="sr"></span><span class="c1"># 3.0 在 grammar 里面使用
</span><span class="c1"></span><span class="sr">grammar EquationParse </span><span class="p">{</span>
    <span class="c1"># 这里也不能给 number 起别名, 除非 number 是在 grammar 内部声明的</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr">  </span><span class="p">}</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="c1"># 等式解析</span>
<span class="k">my</span> <span class="nv">$expr</span> <span class="o">=</span> <span class="n">EquationParse</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#34;</span><span class="s2">12.88 + 0.12 = 13.00</span><span class="p">&#34;);</span>
<span class="nb">say</span> <span class="nv">$expr</span><span class="p">;</span>
</code></pre></div><p>声明具名正则不是只有一个 <code>regex</code> 声明符, 实际上 , regex 声明符用的最少, 大多数时候, 都是使用 <code>token</code> 或 <code>rule</code> 声明符。token 和 rule 这两个都是 <code>ratcheing</code> (棘轮)的, 这意味着如果匹配失败, 那么匹配引擎就不会回并尝试匹配了。这通常会是你想要的, 但不适用于所有情况:</p>
<blockquote>
<p>棘轮用于单向驱动, 防止逆转。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">works-but-slow</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span> <span class="c1"># 可能会回溯</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">fails-but-fast</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span> <span class="c1"># 不回溯</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Tokens and rules won\&#39;t backtrack, which makes them fail quicker!</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;works-but-slow</span><span class="p">;</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;fails-but-fast</span><span class="p">;</span> <span class="c1"># False, .+ 得到了整个字符串但不回溯</span>
</code></pre></div><p><code>token</code> 和 <code>rule</code> 的唯一区别就是 <code>rule</code> 声明符会让正则中的 <code>:sigspace</code> 修饰符起效:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">token</span> <span class="nf">non-space-y</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">once</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">upon</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">time</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">space-y</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">once</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">upon</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">time</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">onceuponatime</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="nv">&amp;non-space-y</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">once upon a time</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="nv">&amp;space-y</span><span class="p">;</span>
</code></pre></div><h2 id="创建-grammar">创建 Grammar</h2>
<p>　
当使用 grammar 关键字而非 class 关键字声明来声明一个类时, 会自动得到以 <a href="https://docs.raku.org/type/Grammar">Grammar</a> 的父类。Grammars 应该只用于解析文本; 如果你想提取复杂的数据, 推荐 <a href="http://doc.raku.org/language/grammars#Action_Objects">action object</a>和 grammar 一块使用。</p>
<h3 id="proto-regexes">Proto regexes</h3>
<p><a href="https://docs.raku.org/type/Grammar">Grammars</a> 由 rules，token 和 regexes 组成; 他们实际上是方法，因为 grammars 是类。这些方法可以共享一个共同的名称和功能，因此可以使用 <a href="https://docs.raku.org/syntax/proto">proto</a>。</p>
<p>如果你有很多备选分支(alternations), 那么生成可读性好的代码或子类化(subclass)你的 grammar 可能会变得很困难。在下面的 <code>Actions</code> 类中, <code>TOP</code> 方法中的三元操作符并不理想, 并且当我们添加的操作越多, 它就变得越糟糕:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Calculator</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">add</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sub</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> }
</span><span class="sr">    rule  add </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">num</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">num</span><span class="p">&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    rule  sub </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">num</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">num</span><span class="p">&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    token num </span><span class="p">{</span> \<span class="nb">d</span><span class="o">+</span> <span class="p">}</span><span class="sr">
</span><span class="sr">}
</span><span class="sr">
</span><span class="sr">class Calculations </span><span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;add&gt;</span> <span class="o">??</span> <span class="nv">$&lt;add&gt;</span><span class="o">.</span><span class="k">made</span> <span class="o">!!</span> <span class="nv">$&lt;sub&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    method add </span><span class="p">(</span><span class="ni">$</span><span class="p">/)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[+]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[-]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Calculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 + 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Calculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 5</span>
</code></pre></div><p>为了让事情变得更好, 我们可以在 tokens 身上使用看起来像 <code>:sym&lt;...&gt;</code> 那样的副词来使用正则表达式原型(protoregexes):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Calculator</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">calc-op</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">proto</span> <span class="k">rule</span> <span class="nf">calc-op</span>          <span class="p">{</span><span class="o">*</span><span class="p">}</span>
          <span class="k">rule</span> <span class="nf">calc-op:sym</span>&lt;add&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
          <span class="k">rule</span> <span class="nf">calc-op:sym</span>&lt;sub&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">num</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Calculations</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span>              <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;calc-op&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">calc-op:sym</span><span class="p">&lt;</span><span class="s">add</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[+]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">calc-op:sym</span><span class="p">&lt;</span><span class="s">sub</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[-]</span> <span class="nv">$&lt;num&gt;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Calculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 + 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Calculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 5</span>
</code></pre></div><p>在这个 grammar 中, 备选分支(alternation)已经被 <code>&lt;calc-op&gt;</code> 替换掉了, 它实质上是我们将要创建的一组值的名字。我们通过使用 <code>proto rule calc-op</code> 定义了一个 rule 原型类型(prototype) 来达成。我们之前的每一个备选分支已经被新的 rule <code>calc-op</code> 替换掉了并且备选分支的名字被附加上了 <code>:sym&lt;&gt;</code> 副词。</p>
<p>在 actions 类中, 我们现在摆脱了三目操作符, 仅仅只在 <code>$&lt;calc-op&gt;</code> 匹配对象上接收 <code>.made</code> 值。并且单独备选分支的 actions 现在和 grammar 遵守相同的命名模式:  <code>method calc-op:sym&lt;add&gt;</code> 和 <code>method calc-op:sym&lt;sub&gt;</code>。</p>
<p>当你子类化(subclass)那个 grammar 和 actions 类的时候才能看到这个方法的真正魅力。假设我们想为 calculator 增加一个乘法功能:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">BetterCalculator</span> <span class="k">is</span> <span class="nc">Calculator</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">calc-op:sym</span>&lt;mult&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">*</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">num</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">BetterCalculations</span> <span class="k">is</span> <span class="nc">Calculations</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">calc-op:sym</span><span class="p">&lt;</span><span class="s">mult</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">[*]</span> <span class="nv">$&lt;num&gt;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">BetterCalculator</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">2 * 3</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">BetterCalculations</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 6</span>
</code></pre></div><p>所有我们需要添加的就是为 <code>calc-op</code> 组添加额外的 rule 和 action, 感谢正则表达式原型(protoregexes), 所有的东西都能正常工作。</p>
<h2 id="特殊的-tokens">特殊的 Tokens</h2>
<h3 id="top">TOP</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>TOP</code> token 是默认的第一个尝试去匹配的 token , 当解析一个 grammar 的时候 - 那颗树的根。注意如果你正使用 <code>.parse</code> 方法进行解析, 那么 token TOP 被自动地锚定到字符串的开头和结尾(再看看 <code>.subparse</code>)。</p>
<p>使用 <code>rule TOP</code> 或 <code>regex TOP</code> 也是可以接受的。</p>
<p>在 <code>.parse</code>、<code>.subparse</code> 或 <code>.parsefile</code> Grammar 方法中使用 <code>:rule</code> 命名参数可以选择一个不同的 token 来进行首次匹配。</p>
<h3 id="ws">ws</h3>
<p>当使用 <code>rule</code> 而非 <code>token</code> 时, 原子(atom)后面的任何空白(whitespace)被转换为一个对 <code>ws</code> 的非捕获调用。即:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">rule</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">entry</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">key</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># . = non-capturing</span>
</code></pre></div><p>默认的 <code>ws</code> 匹配&quot;空白&quot;(whitespace), 例如空格序列(不管什么类型)、换行符、unspaces、或 heredocs。</p>
<p>提供你自己的 <code>ws</code> token 是极好的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">4   \n\n 5</span><span class="p">&#34;;</span> <span class="c1"># Succeeds</span>

<span class="k">grammar</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="se">\d</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr">   </span><span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">4   \n\n 5</span><span class="p">&#34;;</span> <span class="c1"># Fails</span>
</code></pre></div><p>上面的例子中, 在 Bar Gramamr 中重写了自己的 <code>ws</code>, 只匹配水平空白符, 所以 <code>\n\n</code> 匹配失败。</p>
<h3 id="sym">sym</h3>
<p><code>&lt;sym&gt;</code> token 可以在原型正则表达式(proto regex) 中使用，以匹配那个特定正则表达式的 <code>:sym</code> 副词的字符串值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">letter</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">proto</span> <span class="k">token</span> <span class="nf">letter</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;P&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;e&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;r&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;l&gt; <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">letter:sym</span>&lt;*&gt; <span class="p">{</span><span class="sr">   </span><span class="ni">.</span><span class="sr">   </span><span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#34;</span><span class="s2">I ♥ Perl</span><span class="p">&#34;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="k">class</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;letter&gt;</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="p">&lt;</span><span class="s">sym</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">join</span> <span class="p">}</span>
<span class="p">})</span><span class="o">.</span><span class="k">made</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># OUTPUT: «Perl␤»</span>
</code></pre></div><p>当你已经将原型正则表达式与要匹配的字符串区分开来时，这很方便，因为使用 <code>&lt;sym&gt;</code> token 可防止重复这些字符串。</p>
<h3 id="总是成功断言">总是成功断言</h3>
<p><code>&lt;?&gt;</code> is the always succeed assertion(总是匹配成功). 当它用作 grammar 中的 token 时, 它可以被用于触发一个 Action 类方法。在下面的 grammar 中, 我们查找阿拉伯数字并且使用 <code>always succeed assertion</code> 定义一个 succ token。</p>
<p>在 action 类中, 我们使用对 succ 方法的调用来设置(在这个例子中, 我们在 @!numbers 中准备了一个新元素)。在 <code>digit</code> 方法中, 我们把阿拉伯数字转换为梵文数字并且把它添加到 @!numbers 数组的最后一个元素中。多亏了 <code>succ</code>, 最后一个元素总是当前正被解析的 <code>digit</code> 数字的数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Digifier</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">succ</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nb">digit</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">succ</span>   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">digit</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Devanagari</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">@!numbers</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">digit</span> <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@!numbers</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span> <span class="o">~=</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">ord</span><span class="o">.&amp;[+]</span><span class="p">(</span><span class="mi">2358</span><span class="p">)</span><span class="o">.</span><span class="nb">chr</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nb">succ</span>  <span class="p">(</span><span class="nv">$</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">@!numbers</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="p">&#39;&#39;</span>     <span class="p">}</span>
    <span class="k">method</span> <span class="nf">TOP</span>   <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">@!numbers</span><span class="o">[^</span><span class="p">(</span><span class="o">*-</span><span class="mi">1</span><span class="p">)</span><span class="o">]</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Digifier</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">255 435 777</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">actions</span> <span class="o">=&gt;</span> <span class="n">Devanagari</span><span class="o">.</span><span class="nb">new</span><span class="p">)</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># (२५५ ४३५ ७७७)</span>
</code></pre></div><h2 id="grammar-中的方法">Grammar 中的方法</h2>
<p>在 grammar 中使用 <code>method</code> 代替 <code>rule</code> 或 <code>token</code> 也是可以的, 只要它们返回一个 <a href="https://docs.raku.org/type/Cursor">Cursor</a> 类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">DigitMatcher</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="o">:</span><span class="nv">$full-unicode</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$full-unicode</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">num-full</span> <span class="o">!!</span> <span class="nb">self</span><span class="o">.</span><span class="nf">num-basic</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">token</span> <span class="nf">num-full</span>  <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">num-basic</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上面的 grammar 会根据 parse 方法提供的参数尝试不同的匹配:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">+</span><span class="n">DigitMatcher</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">12७१७९०९</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">args</span> <span class="o">=&gt;</span> \<span class="p">(:</span><span class="s">full-unicode</span><span class="p">);</span>
<span class="c1"># OUTPUT:</span>
<span class="c1"># 12717909</span>

<span class="nb">say</span> <span class="o">+</span><span class="n">DigitMatcher</span><span class="o">.</span><span class="nb">subparse</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">12७१७९०९</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">args</span> <span class="o">=&gt;</span> \<span class="p">(:!</span><span class="s">full-unicode</span><span class="p">);</span>
<span class="c1"># OUTPUT:</span>
<span class="c1"># 12</span>
</code></pre></div><h2 id="action-object">Action Object</h2>
<p>　
一个成功的 grammar 匹配会给你一棵匹配对象(Match objects)的解析树, 匹配树(match tree)到达的越深, 则 grammar 中的分支越多, 那么在匹配树中航行以获取你真正感兴趣的东西就变的越来越困难。</p>
<p>为了避免你在匹配树(match tree)中迷失, 你可以提供一个 action object。grammar 中每次解析成功一个具名规则(named rule)之后, 它就会尝试调用一个和该 grammar rule 同名的方法, 并传递给这个方法一个<code>Match</code> 对象作为位置参数。如果不存在这样的同名方法, 就跳过。</p>
<p>这儿有一个例子来说明 grammar 和 action：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">TestGrammar</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TestActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$/</span><span class="o">.</span><span class="k">make</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="nv">$/</span><span class="p">);</span>  <span class="c1"># 等价于 $/.make: 2 + $/</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">TestActions</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span> <span class="c1"># 创建 Action 实例</span>
<span class="k">my</span> <span class="nv">$match</span>   <span class="o">=</span> <span class="n">TestGrammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">40</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$actions</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$match</span><span class="p">;</span>       <span class="c1"># ｢40｣</span>
<span class="nb">say</span> <span class="nv">$match</span><span class="o">.</span><span class="k">made</span><span class="p">;</span>  <span class="c1"># 42</span>
</code></pre></div><p><code>TestActions</code> 的一个实例变量作为具名参数 <code>actions</code> 被传递给 <code>parse</code> 调用, 然后当 token <code>TOP</code> 匹配成功之后, 就会自动调用方法 <code>TOP</code>, 并传递匹配对象(match object) 作为方法的参数。</p>
<p>为了让参数是匹配对象更清楚, 上面的例子使用 <code>$/</code> 作为 action 方法的参数名, 尽管那仅仅是一个方便的约定, 跟内在无关。<code>$match</code> 也可以。(尽管使用 <code>$/</code> 可以提供把 <code>$</code> 作为 <code>$/</code> 的缩写的优势。)</p>
<p>下面是一个更有说服力的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">KeyValuePairs</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[&lt;</span><span class="nf">pair</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">+</span><span class="p">]</span><span class="o">*</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="se">\h</span><span class="o">*</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">rule</span> <span class="nf">pair</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nv">key</span><span class="o">=.</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">value</span><span class="o">=.</span><span class="nf">identifier</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">identifier</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="se">\w</span><span class="o">+</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">KeyValuePairsActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nb">pair</span>      <span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$/</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$&lt;key&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="nv">$&lt;value&gt;</span><span class="o">.</span><span class="k">made</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">identifier</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1"># 子例程 `make` 和在 $/ 上调用 .make 相同</span>
        <span class="k">make</span> <span class="o">~</span><span class="nv">$/</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span> <span class="p">(</span><span class="nv">$match</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1"># TOP 方法的参数可以使用任意变量名, 而不仅仅是 $/</span>
        <span class="nv">$match</span><span class="o">.</span><span class="nb">make</span><span class="o">:</span> <span class="nv">$match</span><span class="p">&lt;</span><span class="s">pair</span><span class="p">&gt;</span><span class="o">».</span><span class="k">made</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="n">KeyValuePairs</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="k">q</span><span class="sa">:to</span><span class="p">/EOI/,</span><span class="s"> :actions(KeyValuePairsActions)).made;
</span><span class="s">    second=b
</span><span class="s">    hits=42
</span><span class="s">    perl=6
</span><span class="s">    </span><span class="p">EOI</span>

<span class="k">for</span> <span class="nv">@$res</span> <span class="k">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Key: </span><span class="nv">$p</span><span class="o">.</span><span class="nf">key</span><span class="p">()</span><span class="s2">\tValue: </span><span class="nv">$p</span><span class="o">.</span><span class="nf">value</span><span class="p">()&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>这会输出:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Key:</span> <span class="nb">second</span>     <span class="n">Value:</span> <span class="nf">b</span>
<span class="n">Key:</span> <span class="nf">hits</span>       <span class="n">Value:</span> <span class="mi">42</span>
<span class="n">Key:</span> <span class="nb">perl</span>       <span class="n">Value:</span> <span class="mi">6</span>
</code></pre></div><p><code>pair</code> 这个 rule, 解析一对由等号分割的 pair, 并且给 <code>identifier</code> 这个 token 各自起了别名。对应的 action 方法构建了一个 <code>Pair</code> 对象, 并使用子匹配对象(sub match objects)的 <code>.made</code> 属性。这也暴露了一个事实: submatches 的 action 方法在那些调用正则/外部正则之前就被调用。所以 action 方法是按后续调用的。</p>
<p>名为 <code>TOP</code> 的 action 方法仅仅把由 <code>pair</code> 这个 rule 的多重匹配组成的所有对象收集到一块, 然后以一个列表的方式返回。</p>
<p>注意 <code>KeyValuePairsActions</code> 是作为一个类型对象(type object)传递给方法 <code>parse</code>的, 这是因为 action 方法中没有一个使用属性(属性只能通过实例来访问)。</p>
<p>其它情况下, action 方法可能会在属性中保存状态。 那么这当然需要你传递一个实例给 <code>parse</code> 方法。</p>
<p>注意, <code>token ws</code> 有点特殊: 当 <code>:sigspace</code> 开启的时候(就是我们使用 <code>rule</code>的时候), 我们覆写的 <code>ws</code> 会替换某些空白序列。这就是为什么 <code>rule pair</code> 中等号两边的空格解析没有问题并且闭合 <code>}</code> 之前的空白不会狼吞虎咽地吃下换行符, 因为换行符在 <code>TOP</code> token 已经占位置了, 并且 token 不会回溯。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># ws 的内置定义</span>
<span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span>                <span class="c1"># match &#34;whitespace&#34;:</span>
                         <span class="c1">#   \s+ if it&#39;s between two \w characters,</span>
                         <span class="c1">#   \s* otherwise</span>

<span class="k">my</span> <span class="k">token</span> <span class="nf">ws</span> <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>      <span class="c1"># 重写 ws 这个内置的 token</span>
<span class="o">&gt;</span><span class="nb">say</span> <span class="nb">so</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="nv">&amp;ws</span>      <span class="c1"># True</span>
</code></pre></div><p>所以 <code>&lt;.ws&gt;</code> 内置的定义是：如果空白在两个 <code>\w</code> 单词字符之间, 则意思为 <code>\s+</code>, 否则为 <code>\s*</code>。 我们可以重写 <code>ws</code> 关于空白的定义, 重新定义我们需要的空白。比如把 <code>ws</code> 定义为 <code>{ \h* }</code> 就是所有水平空白符, 甚至可以将<code>ws</code> 定义为非空白字符。例如: <code>token ws { 'x' }</code></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Weekly Notes]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-08-22-raku-weekly-notes/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-08-22-raku-weekly-notes/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Weekly Notes</blockquote><h2 id="my-foo-的作用域和用途"><code>:my $foo</code> 的作用域和用途</h2>
<p>在 <em>regex</em>、<em>token</em> 或 <em>rule</em> 中, 定义像下面这样的变量是可能的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">directive</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">in command</span><span class="p">&#34;;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="nf">command</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">subject</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="o">?</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>在中提到了一点有关该变量的东西, 我引用过来:</p>
<blockquote>
<p>任何 grammar regex 实际上是一种<code>方法</code>, 并且你可以在这样一个子例程中使用一个冒号跟着任何作用域声明符来声明一个变量, 这些声明符包括 <code>my</code>, <code>our</code>, <code>state</code> 和 <code>constant</code> (作为类似的声明符, temp 和 let 也能被识别). 单个语句(直到结尾的分号或行末尾的闭括号为止) 被解析为普通的 Raku 代码:</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">prove-nondeterministic-parsing</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$threshold</span> <span class="o">=</span> <span class="nb">rand</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">maybe</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">it</span><span class="p">(</span><span class="nv">$threshold</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>有谁能解释下这段代码的应用场景吗？</p>
<h3 id="what-scope-does-my-foo-have">what scope does <code>:my $foo;</code> have?</h3>
<p><code>:my $foo</code> 在它所出现的 rule/token/regex 中拥有词法作用域(lexical scope)。你所得到的作用域要么很大要么很小:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">g</span> <span class="p">{</span>
    <span class="k">regex</span> <span class="nf">r1</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">{</span> <span class="k">my</span> <span class="nv">$foo</span><span class="p">;</span> <span class="o">...</span><span class="p">}</span><span class="sr"> </span><span class="c1"># `$foo` 在该 block 的结尾超出作用域。
</span><span class="c1"></span><span class="sr">        </span><span class="o">..</span><span class="ni">.</span><span class="sr">
</span><span class="sr">        </span><span class="p">{</span> <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>   <span class="p">}</span><span class="sr"> </span><span class="c1"># `$foo` 不在作用域中。
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">grammar</span> <span class="nc">i</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$foo</span><span class="p">;</span>
    <span class="k">regex</span> <span class="nf">r1</span>   <span class="p">{</span><span class="sr"> </span><span class="o">..</span><span class="ni">.</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># 在 `r1` 内部, `$foo` 被识别出。</span>
    <span class="o">...</span>
    <span class="k">regex</span> <span class="nf">r999</span> <span class="p">{</span><span class="sr"> </span><span class="o">..</span><span class="ni">.</span><span class="sr"> </span><span class="p">}</span> <span class="c1"># 但是在 r999 中也是。</span>
<span class="p">}</span>
</code></pre></div><h3 id="它的用途">它的用途?</h3>
<p>使用 <code>:my $foo;</code> 形式的变量声明以在 rule/token/regex 中声明本地作用域的变量, 如果没有进一步的声明, 那么这些变量能在 rule/token/regex 中的任何地方通过所声明的名字来引用。举个例子, 你可以看看 Rakudo 的 Grammar.nqp 源代码中的 <a href="http://github.com/rakudo/rakudo/blob/nom/src/Raku/Grammar.nqp#L108"><code>token babble</code></a> 中声明的 <code>@extra_tweaks</code> 变量的用法。</p>
<p>使用 <code>:my $*foo;</code> 形式的变量声明来声明动态的词法变量。动态变量能够, 在没有进一步声明的情况下, 在闭合词法作用域和闭合动态作用域中通过它们声明的名字来引用。作为说明, 请查看 <a href="http://github.com/rakudo/rakudo/blob/nom/src/Raku/Grammar.nqp#L4861">the declaration of <code>@*nibbles</code> in Rakudo&rsquo;s Grammar module</a> 和 <a href="http://github.com/rakudo/rakudo/blob/nom/src/Raku/Actions.nqp#L8943">its use in Rakudo&rsquo;s Actions module</a> 。</p>
<h3 id="一般的使用场景">一般的使用场景</h3>
<p>在 <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a> 中一般不使用 <code>:…</code> 风格的声明。<code>:...;</code> 结构通常用在特别复杂和庞大的 grammars 中。对于这些使用场景, 依靠 Raku 的正则表达式和闭包的一致性是合适的。正是这使得 rule/token/regex 级别的 <code>:...;</code> 变量声明变得正当。</p>
<h3 id="regexes-和-closures-的一致性">Regexes 和 closures 的一致性</h3>
<p>很多 grammars 都是<a href="http://trevorjim.com/python-is-not-context-free/">上下文有关的</a>.</p>
<p>Raku 使 regexes 和 closures 统一了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">Regex</span><span class="o">.^</span><span class="nb">mro</span><span class="p">;</span> <span class="p">(</span><span class="nb">Regex</span><span class="p">)</span> <span class="p">(</span><span class="nb">Method</span><span class="p">)</span> <span class="p">(</span><span class="nb">Routine</span><span class="p">)</span> <span class="p">(</span><span class="nb">Block</span><span class="p">)</span> <span class="p">(</span><span class="nb">Code</span><span class="p">)</span> <span class="o">...</span>
</code></pre></div><p>mro 是方法解析顺序, 这足以说明 regex 实际上是一种特殊类型的方法(就像方法是一种特殊类型的子例程一样)。</p>
<h2 id="raku-is-there-a-phaser-that-runs-only-when-you-fall-out-of-a-loophttpstackoverflowcomquestions36117329raku-is-there-a-phaser-that-runs-only-when-you-fall-out-of-a-loop"><a href="http://stackoverflow.com/questions/36117329/raku-is-there-a-phaser-that-runs-only-when-you-fall-out-of-a-loop">Raku: is there a phaser that runs only when you fall out of a loop?</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="nl">ROLL</span><span class="o">:</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="k">-&gt;</span> <span class="nv">$r</span> <span class="p">{</span>
    <span class="k">given</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span> <span class="p">{</span>
        <span class="k">when</span> <span class="mi">6</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Roll </span><span class="nv">$r:</span><span class="s2"> you win!</span><span class="p">&#34;;</span>
            <span class="nb">last</span> <span class="n">ROLL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">default</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Roll </span><span class="nv">$r:</span><span class="s2"> sorry...</span><span class="p">&#34;;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">LAST</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You either won or lost - this runs either way</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>更优雅的写法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">for</span> <span class="nb">flat</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span> <span class="ow">xx</span> <span class="o">*</span> <span class="ow">Z</span> <span class="mi">1</span><span class="o">..</span><span class="n">N</span> <span class="k">-&gt;</span> <span class="nv">$_</span><span class="o">,</span> <span class="nv">$n</span> <span class="p">{</span>
    <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">roll </span><span class="nv">$n:</span><span class="s2"> </span><span class="nv">$_</span><span class="s2"> </span><span class="p">&#34;;</span>

    <span class="k">when</span> <span class="mi">6</span> <span class="p">{</span>
        <span class="nb">put</span> <span class="p">&#34;</span><span class="s2">(won)</span><span class="p">&#34;;</span>
        <span class="nb">last</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">default</span> <span class="p">{</span>
        <span class="nb">put</span> <span class="p">&#34;</span><span class="s2">(lost)</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">LAST</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">result: </span><span class="p">&#34;;</span>
        <span class="k">when</span> <span class="mi">6</span> <span class="p">{</span> <span class="nb">put</span> <span class="p">&#34;</span><span class="s2">winner :)</span><span class="p">&#34;</span> <span class="p">}</span>
        <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="p">&#34;</span><span class="s2">loser :(</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="怎么从命令行传递一个复数给-sub-mainhttpstackoverflowcomquestions35872082how-do-i-pass-a-complex-number-from-the-command-line-to-sub-main"><a href="http://stackoverflow.com/questions/35872082/how-do-i-pass-a-complex-number-from-the-command-line-to-sub-main">怎么从命令行传递一个复数给 sub MAIN?</a></h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>


<span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$x</span><span class="s2"> squared is </span><span class="p">{</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="p">}&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>我要在命令行中传递一个复数给 MAIN:</p>
<blockquote>
<pre><code>% ./square i
</code></pre></blockquote>
<pre><code>Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏i' (indicated by ⏏)
  in sub MAIN at ./square line 7
  in block &lt;unit&gt; at ./square line 5

Actually thrown at:
  in sub MAIN at ./square line 7
  in block &lt;unit&gt; at ./square line 5
</code></pre><p>当我把脚本变为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nb">Complex</span> <span class="nv">$x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$x</span><span class="s2"> squared is </span><span class="p">{</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="p">}&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>它竟然彻底罢工了:</p>
<pre><code>% ./square i
Usage:
  square &lt;x&gt;

% ./square 1
Usage:
  square &lt;x&gt;
</code></pre><p>一种方法是使用 <a href="http://design.raku.org/S02.html#Coercive_type_declarations">Coercive type declaration</a> (强制类型声明), 从 Str 到 Complex:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nb">Complex</span><span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$x</span><span class="s2"> 的平方为 </span><span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">}&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>那么:</p>
<pre><code>% ./squared.pl 1
1+0i 的平方为 1+0i
% ./squared.pl 1+2i
1+2i 的平方为 -3+4i
</code></pre><p>但是:</p>
<pre><code>$ ./test.pl6 2
Usage:
  ./test.p6 &lt;x&gt;
</code></pre><p>所以你真正需要的是把其它 Numeric 类型强转为 Complex 类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">(</span> <span class="nb">Complex</span><span class="p">(</span><span class="nb">Real</span><span class="p">)</span> <span class="nv">$x</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$x</span><span class="s2"> squared is </span><span class="p">{</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="p">}&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>我使用 Real 而非 Numeric, 因为 Complex 已经涵盖了其它的了。</p>
<h2 id="blessing-a-hash-into-an-objecthttpswwwredditcomrrakucomments4aoi82blessing_a_hash_into_an_object"><a href="https://www.reddit.com/r/raku/comments/4aoi82/blessing_a_hash_into_an_object/">Blessing a Hash into an object</a></h2>
<p>为什么我写的这段代码不对呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">WordCount</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">%!words</span><span class="p">;</span> <span class="c1"># Tried with both . and !</span>

    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">%words</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">@sentence</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(/</span><span class="se">\s</span><span class="o">+</span><span class="p">/</span><span class="o">,</span> <span class="nv">$string</span><span class="p">);</span>
    
        <span class="k">for</span> <span class="nv">@sentence</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
            <span class="nv">%words</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">%words</span><span class="p">);</span>
  <span class="p">}</span>

    <span class="k">method</span> <span class="nf">sayCounts</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">@keys</span> <span class="o">=</span> <span class="nb">keys</span><span class="p">(</span><span class="nv">%!words</span><span class="p">);</span>
        <span class="k">for</span> <span class="nv">@keys</span> <span class="k">-&gt;</span> <span class="nv">$key</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="nv">$key</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">%!words</span><span class="p">{</span><span class="nv">$key</span><span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">MAIN</span> <span class="p">{</span>
  <span class="k">my</span> <span class="nv">$sentence</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">the boy jumped over the dog</span><span class="p">&#34;;</span>
  <span class="k">my</span> <span class="nv">$wordCount</span> <span class="o">=</span> <span class="n">WordCount</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$sentence</span><span class="p">);</span>
  <span class="nv">$wordCount</span><span class="o">.</span><span class="nf">sayCounts</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div><p>Raku-ify:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">WordCount</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">%.words</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nb">Int</span> <span class="nv">%words</span><span class="p">;</span>

        <span class="k">for</span> <span class="nv">$string</span><span class="o">.</span><span class="nb">split</span><span class="p">(/</span><span class="se">\s</span><span class="o">+</span><span class="p">/)</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
            <span class="nv">%words</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">%words</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">gist</span> <span class="p">{</span>
        <span class="nv">%.words</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span><span class="o">.</span><span class="nb">value</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">key</span><span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$word-count</span> <span class="o">=</span> <span class="n">WordCount</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">the boy jumped over the dog</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">$word-count</span><span class="p">;</span>
</code></pre></div><p>散列中的每一项都是一个 <strong>Pair</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%w</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="nv">%w</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nb">say</span> <span class="nv">$_</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span> <span class="c1"># OUTPUT«Pair␤»</span>
</code></pre></div><p>所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%.words</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span><span class="o">.</span><span class="nb">value</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">key</span><span class="p">})</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%.words</span><span class="o">.</span><span class="nb">kv</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="nv">$word</span><span class="o">,</span> <span class="nv">$count</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$word</span><span class="s2"> </span><span class="nv">$count</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span>
</code></pre></div><p>你还可以使用 sub-signature(子签名)来解构 <code>.map</code> 提供的 <code>Pair</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%.words</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="k">-&gt;</span> <span class="p">(:</span><span class="s">key</span><span class="p">(</span><span class="nv">$word</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">value</span><span class="p">(</span><span class="nv">$count</span><span class="p">))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$word</span><span class="s2"> </span><span class="nv">$count</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span>
</code></pre></div><h3 id="字符串处理">字符串处理</h3>
<blockquote>
<p>将每行从第二列到最后一列数值为0的且数目多于6个的行删除</p>
</blockquote>
<p>数据：</p>
<pre><code>OG004240:    1       3     1       1       9     0       4       5       1     1       6    1     2
OG004241:    1       2     1       4       7     2       1       3       1     2       9    1     1
OG004242:    1       2     1       2       4     1       3       9       2     2       4    2     2
OG004243:    0       4     1       2       9     2       4       5       1     2       3    1     1
OG004244:    0       2     1       3       8     3       3       2       2     3       4    2     2
OG004245:    0       3     1       2       7     3       3       0       3     2       7    2     2
OG004246:    0       0     2       0       1     15      0       15      0     0       1    0     1
</code></pre><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">a.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">@lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(/</span><span class="se">\s</span><span class="o">+</span><span class="p">/);</span>
    <span class="nb">say</span> <span class="nv">$line</span> <span class="k">unless</span> <span class="nv">@words</span><span class="o">[</span><span class="mi">1</span><span class="o">..*].</span><span class="nb">grep</span><span class="p">(</span><span class="o">*</span> <span class="ow">eq</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nb">elems</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>使用 <code>rakudoc -f Str.split</code> 查看 split 的帮助文档。</p>
<p>合并相同行：</p>
<p>文件一：</p>
<pre><code>1###ENSMMUP00000017866###-###27582-27683
1###ENSMMUP00000017866###-###27508-27576
1###ENSMMUP00000017866###-###27290-27503
1###ENSMMUP00000040736###-###199515-200498
1###ENSMMUP00000040736###-###198582-198818
1###ENSMMUP00000030409###+###395728-395934
1###ENSMMUP00000030409###+###403004-403148
</code></pre><p>想合并相同的，生成文件格式如下：</p>
<pre><code>1###ENSMMUP00000017866###-###27582-27683  27508-27576  27290-27503  
1###ENSMMUP00000040736###-###199515-200498  198582-198818
1###ENSMMUP00000030409###+###395728-395934  403004-403148
</code></pre><p>一种方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">a.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%hash</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nv">$line</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="ni">^</span><span class="p">(</span><span class="ni">.</span><span class="o">*?</span><span class="p">)(</span><span class="se">\d</span><span class="o">+</span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="se">\d</span><span class="o">+</span><span class="p">)/);</span>
    <span class="nv">%hash</span><span class="p">{</span><span class="nv">$0</span><span class="p">}</span> <span class="o">~=</span> <span class="nv">$1</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>如下数据，想去掉第3列重复的行且保留的行要使第四列最小, 原始数据：</p>
<pre><code>326        0.00        0.00        ( 0 )
63        0.00        2.43        ( 0.0082 )
64        0.00        2.43        ( 0.0082 )
120        0.00        2.43        ( 0 )
340        0.00        4.03        ( 0 )
99        0.00        9.14        ( 0.0229 )
441        0.00        9.14        ( 0.0232 )
142        0.00        10.77        ( 0.0569 )
292        0.00        10.77        ( 0.0393 )
266        0.00        10.77        ( 0.0233 )
</code></pre><p>想要的结果：</p>
<pre><code>326        0.00        0.00        ( 0 )
120        0.00        2.43        ( 0 )
340        0.00        4.03        ( 0 )
99        0.00        9.14        ( 0.0229 )
266        0.00        10.77        ( 0.0233 )
</code></pre><p>一种方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@lines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">a.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%hash</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nv">$line</span><span class="o">.</span><span class="nb">match</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="sr">\</span><span class="ni">.</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\s</span><span class="o">+</span><span class="sr">\(</span><span class="se">\s</span><span class="o">+</span><span class="p">(</span><span class="se">\S</span><span class="o">+</span><span class="p">)/);</span>
    <span class="nv">%hash</span><span class="p">{</span><span class="nv">$0</span><span class="p">}</span> <span class="o">~=</span> <span class="nv">$1</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">@lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nv">$line</span><span class="o">.</span><span class="nb">match</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="sr">\</span><span class="ni">.</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\s</span><span class="o">+</span><span class="sr">\(</span><span class="se">\s</span><span class="o">+</span><span class="p">(</span><span class="se">\S</span><span class="o">+</span><span class="p">)/);</span>

    <span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">$line</span> <span class="k">if</span> <span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$key</span> <span class="o">&amp;&amp;</span> <span class="nv">$1</span> <span class="o">~~</span> <span class="nv">$value</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">min</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>有 gene.txt 和 in.txt 两个文件, 文件内容如下:</p>
<p>gene.txt:（2000多行)</p>
<pre><code>chr1        ABCA4        94458582        94586799
chr1        ACADM        76190031        76229363
chr16        BBS2        56518258        56554008
chr17        G6PC        41052813        41066450
chr17        GAA        78078244        78093271
</code></pre><p>in.txt:(5万多行)</p>
<pre><code>1        94505603        rs368951547        C        T        NA        NA
1        94505604        rs61750126         A        C        0.02066    NA
1        94505611        rs137853898        G        A        NA        not-provided
1        94505620        rs370967816        T        A        NA        NA
1        94505621        rs149503495        T        C        NA        NA
1        94505627        rs374610040        A        G        NA        NA
22        18901263        rs377148163       C        A        NA        NA
22        18901290        rs381848          G        A        0.07989   NA
22        18901322        rs62232347        C        A        NA        NA
22        18901326        rs201353896       TCC      T        0.05005   NA
22        18901327        rs10537001        CCT      C        0.0528    NA
16        18901326        rs201353896       TCC      T        0.05005   NA
17        18901327        rs10537001        CCT      C        0.0528    NA
</code></pre><p>gene.txt 和 in.txt 的第一列的数字部分相同，并且 In 的第二列在gene 的三四列范围之间，就输出 in.txt 中的那一行。</p>
<p>解决方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@lines</span>   <span class="o">=</span> <span class="p">&#34;</span><span class="s2">a.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@inlines</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">in.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%hash</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nv">$line</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="ni">^</span><span class="sr">chr</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\s</span><span class="o">+</span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="se">\s</span><span class="o">+</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\s</span><span class="o">+</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/);</span>
    <span class="nv">%hash</span><span class="p">{</span><span class="nv">$0</span><span class="o">~</span><span class="nv">$1</span><span class="o">~</span><span class="nv">$2</span><span class="o">~</span><span class="nv">$3</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$0</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$2</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$3</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">@inlines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nv">$line</span><span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="ni">^</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)</span><span class="se">\s</span><span class="o">+</span><span class="p">(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/);</span>

    <span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">values</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">$line</span>
        <span class="k">if</span> <span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$value</span><span class="o">.</span><span class="nb">words</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
        <span class="o">&amp;&amp;</span> <span class="nv">$1</span> <span class="o">&lt;=</span> <span class="nv">$value</span><span class="o">.</span><span class="nb">words</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="nb">Num</span>
        <span class="o">&amp;&amp;</span> <span class="nv">$1</span> <span class="o">&lt;=</span> <span class="nv">$value</span><span class="o">.</span><span class="nb">words</span><span class="o">[</span><span class="mi">2</span><span class="o">].</span><span class="nb">Num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>例如我现在数组中的值是 <code>@project = ('NX11','NX12','NX13’)</code>。</p>
<p>另外一个数组是 <code>@get = ('ss','ssfd','NX12','sed','NX11’)</code>。</p>
<p>现在把第一个数组中出现过的值，如果第二个数组中也有的话删除掉，然后保留第二个数组剩下的值。</p>
<p>使用差集：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@get</span> <span class="ow">(-)</span> <span class="nv">@project</span>
</code></pre></div><p>有如下数据：</p>
<pre><code>PL -0.00 5.50
PL -0.25 3.50
PL -0.50 0.00
PL -0.75 4.50
-0.25 -0.00 1.00
-0.25 -0.25 4.50
-0.25 -0.50 1.00
-0.75 -0.75 1.00
-0.75 -1.00 0.00
-1.00 -0.25 3.50
-1.00 -0.50 0.00
-1.00 -1.25 3.40
-1.00 -1.75 4.00
</code></pre><p>将第一列值相同的行合并， 分使合并第二列和第三列：</p>
<p>结果如下：</p>
<pre><code>PL -0.00 -0.25 -0.50 -0.75
PL 5.50 3.50 0.00 4.50
...
</code></pre><h3 id="面向对象">面向对象</h3>
<p>Fluent interface (流接口)</p>
<p>在软件工程中，一个流接口（fluent Interface）是指实现一种实现面向对象的能提高代码可读性的API的方法。
在 Raku 中有很多种方法, 但是最简单的一种是声明属性为可读写并使用 <code>given</code> 关键字。类型注释是可选的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Employee</span> <span class="p">{</span>
    <span class="k">subset</span> <span class="nc">Salary</span>         <span class="k">of</span> <span class="nb">Real</span> <span class="k">where</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">subset</span> <span class="nc">NonEmptyString</span> <span class="k">of</span> <span class="nb">Str</span>  <span class="k">where</span> <span class="o">*</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\S</span><span class="p">/;</span> <span class="c1"># 至少一个非空白符号</span>

    <span class="k">has</span> <span class="n">NonEmptyString</span> <span class="nv">$.name</span>    <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">NonEmptyString</span> <span class="nv">$.surname</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">Salary</span>         <span class="nv">$.salary</span>  <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">gist</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">qq</span><span class="sa">:to</span><span class="p">[END];</span><span class="s2">
</span><span class="s2">        Name:    </span><span class="nv">$.name</span><span class="s2">
</span><span class="s2">        Surname: </span><span class="nv">$.surname</span><span class="s2">
</span><span class="s2">        Salary:  </span><span class="nv">$.salary</span><span class="s2">
</span><span class="s2">        </span><span class="p">END</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">my</span> <span class="nv">$employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>

<span class="k">given</span> <span class="nv">$employee</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">name</span>    <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Sally</span><span class="p">&#39;;</span>
    <span class="o">.</span><span class="nf">surname</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ride</span><span class="p">&#39;;</span>
    <span class="o">.</span><span class="nf">salary</span>  <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$employee</span><span class="p">;</span>

<span class="c1"># Output:</span>
<span class="c1"># Name:    Sally</span>
<span class="c1"># Surname: Ride</span>
<span class="c1"># Salary:  200</span>
</code></pre></div><ol>
<li><a href="http://stackoverflow.com/questions/30264548/how-do-i-check-file-timestamp-attributes-in-perl-6">在 Raku 中怎样检查文件的时间戳属性</a></li>
</ol>
<p>在 Raku 中怎样检查文件的时间戳属性？ 在 Perl 5 中是使用文件测试操作符  <a href="http://perldoc.raku.org/functions/-X.html">file test operators </a>, 在 Raku 中是使用来自于 <a href="http://doc.raku.org/type/IO::FileTestable"><code>IO::FileTestable</code> role</a> 的方法 (e.g. <code>.modified</code>, <code>.accessed</code> and <code>.changed</code>) 。</p>
<p>例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$filename</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">sample.txt</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$seconds_since_epoch</span> <span class="o">=</span> <span class="nv">$filename</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">accessed</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$readable_timestamp</span>  <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$filename</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">accessed</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">File &#39;</span><span class="nv">$filename&#39;</span><span class="s2"> was last accessed at &#39;</span><span class="nv">$readable_timestamp&#39;</span><span class="s2">, which is </span><span class="p">{</span><span class="nv">$seconds_since_epoch</span><span class="o">.</span><span class="nb">Num</span><span class="p">}</span><span class="s2"> seconds since the epoch</span><span class="p">&#34;;</span>
</code></pre></div><p>2、我正尝试生成包含 10 个随机随机序列的 <a href="https://en.wikipedia.org/wiki/FASTQ_format">FASTQ 文件</a>，序列由随机品质分数构成。我原来是使用下面的代码，它工作良好:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@seq</span>  <span class="o">=</span> <span class="p">(</span><span class="nf">rand_fa_seq</span><span class="p">()</span> <span class="k">for</span> <span class="o">^</span><span class="mi">10</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@qual</span> <span class="o">=</span> <span class="p">(</span><span class="nf">rand_qual</span><span class="p">()</span>   <span class="k">for</span> <span class="o">^</span><span class="mi">10</span><span class="p">);</span>

<span class="nv">@seq</span><span class="o">.</span><span class="nb">raku</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
<span class="nv">@qual</span><span class="o">.</span><span class="nb">raku</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">rand_fa_seq</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">join</span><span class="p">(&#34;&#34;</span><span class="o">,</span> <span class="nb">roll</span><span class="p">(</span><span class="mi">20</span><span class="o">,</span><span class="p">&#34;</span><span class="s2">ACGT</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">rand_qual</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">join</span><span class="p">(&#34;&#34;</span><span class="o">,</span> <span class="nb">roll</span><span class="p">(</span><span class="mi">20</span><span class="o">,</span><span class="p">&#34;</span><span class="s2">EFGHIJ</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>等价于：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">rand-fa-seq</span><span class="p">(</span><span class="nv">$n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span> <span class="p">&lt;</span><span class="s">A C G T</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">rand-qual</span><span class="p">(</span><span class="nv">$n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>   <span class="p">{</span> <span class="p">&lt;</span><span class="s">E F G H I J</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span> <span class="p">}</span>

<span class="k">my</span> <span class="nv">@seq</span>  <span class="o">=</span> <span class="nf">rand-fa-seq</span><span class="p">()</span> <span class="ow">xx</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@qual</span> <span class="o">=</span> <span class="nf">rand-qual</span><span class="p">()</span> <span class="ow">xx</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div><p>3、<a href="http://stackoverflow.com/questions/30414206/list-of-non-squares-using-list-comprehension-in-perl-6">在 Raku 中使用 &ldquo;列表解析&rdquo; 生成非平方数列表</a></p>
<p>在 Raku 中我怎样使用 &ldquo;列表解析&rdquo; 创建一组非平方数? 我在  <a href="http://rosettacode.org/wiki/Sequence_of_Non-squares#Perl_6">Rosetta Code</a>  那儿看到了如何打印一组非平方数的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">nth_term</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">+</span> <span class="nb">round</span> <span class="nb">sqrt</span> <span class="nv">$n</span> <span class="p">}</span>

<span class="nb">say</span> <span class="n">nth_term</span> <span class="nv">$_</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">22</span><span class="p">;</span>
</code></pre></div><p>目前为止我看到的最接近的东西是使用  <code>for</code> 关键字。 但是因为这实际上仅仅是一个内联（inline）循环，我认为这从技术上来讲并不是列表解析，尽管它看起来相似：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@y</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$_</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div><p>但是，我真正想知道是否有一种 “列表解析 “ 的方法来创建可在数学上描述的诸如非平方数的列表。这儿有一个我用来创建一组非平方数的方法（直到 30）：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@non_squares</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span><span class="nb">sqrt</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">floor</span><span class="p">(</span><span class="nb">sqrt</span><span class="p">(</span><span class="nv">$_</span><span class="p">))}</span><span class="o">,</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">30</span><span class="p">;</span>
</code></pre></div><p>我怎样用列表解析来实现它呢？</p>
<p>实际上， 你的例子  <code>my @y = ($_**2 + 1 for 1 .. 10);</code>  是 Raku 方式写成的列表解析。你还可以添加一个条件测试， 就像 <a href="http://design.raku.org/S04.html#Loop_statements">Raku design document S04</a> 中建议的那样：</p>
<blockquote>
<p>为了轻松地书写列表解析， 循环语句修饰符允许包含单个条件语句修饰符：</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">odd</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nv">$n</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">}</span>
<span class="nv">@evens</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">if</span> <span class="o">.&amp;</span><span class="nf">odd</span> <span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">100</span><span class="p">);</span>
</code></pre></div><p>这个就是怎样写一个 Raku 列表解析的非平方数（直到 30）：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@non_squares</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$_</span> <span class="k">if</span> <span class="o">.</span><span class="nb">sqrt</span> <span class="o">!=</span> <span class="o">.</span><span class="nb">sqrt</span><span class="o">.</span><span class="nb">Int</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">30</span><span class="p">);</span>
</code></pre></div><p>一丢丢解释：在每次 for 循环迭代中， 从 1 到 30 这个范围中的当前数字会被赋值给默认变量 <code>$_</code>（等价于 it）。没有调用者的方法调用会默认在 “it&quot; 身上调用（例如 <code>.sqrt</code> 等价于 <code>$_.sqrt</code>）。 所以，对于 1到30中的每一个数字，它的平方根被检查以查看它是否有非整数平方根。 如果是真， 那它就被包含在列表中。</p>
<p>4、<a href="http://stackoverflow.com/questions/30982697/print-and-colon-in-perl-6">Raku 中的 Print 函数和冒号</a></p>
<p>我想知道在 Raku 中冒号与方法和函数调用有什么关系。</p>
<p>我在 <a href="https://github.com/raku/roast/blob/master/S32-io/copy.t">Raku spec test (S32-io)</a> 中看到了这个(我添加了注释):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">0123456789A</span><span class="p">&#34;;</span>   <span class="c1"># prints &#39;0123456789A&#39; to the file</span>
</code></pre></div><p>据我所知，这等价于：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(&#34;</span><span class="s2">0123456789A</span><span class="p">&#34;);</span>   <span class="c1"># prints &#39;0123456789A&#39; to the file</span>
</code></pre></div><p>这两种方式看起来都接收多个参数而且展平列表也没问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">012</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">345</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">6789A</span><span class="p">&#34;;</span>   <span class="c1"># prints &#39;0123456789A&#39; to the file</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(&#34;</span><span class="s2">012</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">345</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">6789A</span><span class="p">&#34;);</span>   <span class="c1"># prints &#39;0123456789A&#39; to the file</span>

<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">012 345 6789A</span><span class="p">&gt;;</span>

<span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>   <span class="c1"># prints &#39;0123456789A&#39; to the file</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="nv">@a</span><span class="p">;</span>   <span class="c1"># prints &#39;0123456789A&#39; to the file</span>
</code></pre></div><p>存在这两种语法一定有某种原因。 使用这种或另一种语法有某种理由吗？</p>
<p>我还注意到，当作为方法使用时， 我们不得不使用带有 <code>:</code> 或 <code>()</code>的 print：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>   <span class="c1"># Works</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="nv">@a</span><span class="p">;</span>   <span class="c1"># Works!</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span> <span class="nv">@a</span><span class="p">;</span>    <span class="c1"># ERROR!</span>
</code></pre></div><p>当使用带冒号的 print 函数时，还有一些有意思的行为。 在这种情况下, ： 和 () 不等价：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span> <span class="nv">@a</span><span class="p">;</span>  <span class="c1"># Prints &#39;0123456789A&#39; (no newline, just like Perl 5)</span>
<span class="nb">print</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span> <span class="c1"># Ditto</span>
<span class="nb">print</span><span class="o">:</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># Prints &#39;012 345 6789A&#39; followed by a newline (at least in REPL)</span>

<span class="nb">print</span>  <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># Error (Two terms in a row)</span>
<span class="nb">print</span><span class="o">:</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># Prints &#39;012 345 6789A 012 345 6789A&#39; followed by a newline (in REPL)</span>
</code></pre></div><p>然后我尝试在脚本文件中使用print。这对于打印到标准输出有效：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span> <span class="nv">@a</span><span class="p">;</span>
</code></pre></div><p>然而， 这不会打印到标准输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span><span class="o">:</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span>
</code></pre></div><p>但是方法版本的工作良好：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="nv">@a</span><span class="o">,</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># Prints &#39;0123456789A0123456789A&#39; to the file</span>
</code></pre></div><p>我感觉我已经理解了这个， 但是不能用语言表达出来。有人可以解释下使用 print 的这些变化吗。 还有， 这些行为会因为  Great List Refactor 而改变吗？</p>
<p>Answer：</p>
<p>使用冒号代替圆括号的一个主要原因是通过移除一组圆括号，它能使代码更清晰。在其它方面它们真的一样。</p>
<p>当你使用 <code>print: @a</code> ， 那你真正在做的就是在行上放置一个标签， 并让 @a 落进去（fall-through）。这在 REPL 中会调用带有值的 say 方法。</p>
<p>如果你没有在方法调用中使用括号或冒号，， 那么方法会以无参数方式调用。</p>
<p>你可以交换方法的顺序，还有调用者，如果你使用冒号的话。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="vg">$*ERR:</span> <span class="p">&#39;</span><span class="s1">hello world</span><span class="p">&#39;;</span> <span class="c1"># $*ERR.say(&#39;hello world&#39;)</span>
</code></pre></div><table>
<thead>
<tr>
<th>我刚刚确认了， 就像你说的， <code>print: @a</code> 就是 <code>label: @a</code>,   <code>label</code> 可以是任何东西. – <a href="http://stackoverflow.com/users/215487/christopher-bottoms">Christopher Bottoms</a> <a href="http://stackoverflow.com/questions/30982697/print-and-colon-in-perl-6#comment50169331_30988281">Jun 26 at 14:12</a></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>换句话说，冒号能代替方法调用的圆括号，但不能代替子例程调用。 – <a href="http://stackoverflow.com/users/215487/christopher-bottoms">Christopher Bottoms</a> <a href="http://stackoverflow.com/questions/30982697/print-and-colon-in-perl-6#comment50169347_30988281">Jun 26 at 14:12</a></td>
</tr>
</tbody>
</table>
<p>5、<a href="http://stackoverflow.com/questions/31745631/sorting-hash-kv-pairs">排序散列键值对儿</a></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span>
    <span class="s">two</span>   <span class="o">=&gt;</span> <span class="mi">2</span>,
    <span class="s">three</span> <span class="o">=&gt;</span> <span class="mi">3</span>,
    <span class="s">one</span>   <span class="o">=&gt;</span> <span class="mi">1</span>,
<span class="p">;</span>

<span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nb">key</span><span class="p">)</span><span class="o">».</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">&#39;</span><span class="nv">$key&#39;</span><span class="s2"> =&gt; &#39;</span><span class="nv">$value&#39;</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p> <code>%hash.sort({.key})».kv</code> 和上面的  <code>sort</code> 等价吗?</p>
<p>为什么这个 sort 没有 hyper <code>»</code>  提示就不会工作?</p>
<p>这个 <a href="http://doc.raku.org/routine/sort"><code>sort</code></a>方法返回一个 <a href="http://doc.raku.org/type/Pair">Pairs</a> 的列表。</p>
<p>因为在列表身上调用  <a href="http://doc.raku.org/routine/kv"><code>.kv</code></a> 会返回一个索引, Pair 列表, 这不是你想要的; 你不能单单在列表身上调用   <a href="http://doc.raku.org/routine/kv"><code>.kv</code></a> 。所以你必须通过在每个 Pair 身上调用 .kv 方法分别从列表中的   <a href="http://doc.raku.org/type/Pair">Pair</a> 中取出键和值, 这正是 ».kv 所做的。</p>
<p>你还可以使用 <a href="http://doc.raku.org/routine/map"><code>.map(*.kv)</code></a> 代替。</p>
<p><code>».kv</code> 语法允许把工作展开到多个线程中执行, 如果那样做有意义的话。</p>
<p>(当前的 Rakudo仅以半随机的顺序工， 以防止人们错误地使用该特性 )</p>
<p>通过在签名中使用副词以提取属性， 这是另一种 loop 写法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">sort</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="o">,</span> <span class="o">:</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">&#39;</span><span class="nv">$key&#39;</span><span class="s2"> =&gt; &#39;</span><span class="nv">$value&#39;</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">sort</span> <span class="k">-&gt;</span> <span class="nv">$pair</span> <span class="p">(</span><span class="o">:</span><span class="nv">$key</span><span class="o">,</span> <span class="o">:</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$pair</span><span class="p">;</span>
    <span class="nb">say</span> <span class="nv">$key</span> <span class="o">===</span> <span class="nv">$pair</span><span class="o">.</span><span class="nb">key</span> <span class="ow">and</span> <span class="nv">$value</span> <span class="o">===</span> <span class="nv">$pair</span><span class="o">.</span><span class="nb">value</span><span class="p">;</span> <span class="c1"># True␤</span>
<span class="p">}</span>

<span class="c1"># :$key is short for :key($key)</span>
<span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">sort</span> <span class="k">-&gt;</span> <span class="p">(:</span><span class="s">key</span><span class="p">(</span><span class="nv">$k</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">value</span><span class="p">(</span><span class="nv">$v</span><span class="p">))</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">&#39;</span><span class="nv">$k&#39;</span><span class="s2"> =&gt; &#39;</span><span class="nv">$v&#39;</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>这对其它没有方法创建一组它们公用属性的对象有用：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span> <span class="k">has</span> <span class="nv">$.b</span><span class="p">;</span> <span class="k">has</span> <span class="nv">$.c</span><span class="p">;</span> <span class="k">has</span> <span class="nv">$!private-value</span> <span class="p">}</span>
<span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$obj</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">a</span><span class="p">&lt;</span><span class="s">A</span><span class="p">&gt;</span><span class="o">,</span><span class="p">:</span><span class="s">b</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">,:</span><span class="nv">$c</span><span class="p">);</span>

<span class="k">given</span> <span class="nv">$obj</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="o">:</span><span class="nv">$a</span><span class="o">,</span> <span class="p">:</span><span class="s">b</span><span class="p">(</span><span class="nv">$b</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">$c</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$a</span><span class="s2"> </span><span class="nv">$b</span><span class="s2"> </span><span class="nv">$c</span><span class="p">&#34;;</span>   <span class="c1"># A 1 5</span>
<span class="p">}</span>

<span class="c1"># ignore $.a by using an unnamed scalar</span>
<span class="k">given</span> <span class="nv">$obj</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="p">:</span><span class="s">a</span><span class="p">(</span><span class="nv">$</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">$b</span><span class="o">,</span> <span class="o">:</span><span class="nv">$c</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1"># places any unspecified public attributes in %others</span>
<span class="k">given</span> <span class="nv">$obj</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="o">:</span><span class="nv">$a</span><span class="o">,</span> <span class="o">:</span><span class="nv">$b</span><span class="o">,</span> <span class="o">*</span><span class="nv">%others</span> <span class="p">)</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">keys</span> <span class="nv">%others</span><span class="p">;</span> <span class="c1"># c␤</span>
<span class="p">}</span>

<span class="c1"># 忽略任何未指定的属性</span>
<span class="c1"># useful to allow subclasses to add more attributes</span>
<span class="c1"># 或仅仅丢弃掉任何你不关心的值</span>
<span class="k">given</span> <span class="nv">$obj</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="o">:</span><span class="nv">$a</span><span class="o">,</span> <span class="o">:</span><span class="nv">$b</span><span class="o">,</span> <span class="o">*</span><span class="nv">%</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1"># 失败，因为它没有处理公用的 c 属性</span>
<span class="c1"># in the sub-signature</span>
<span class="k">given</span> <span class="nv">$obj</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="o">:</span><span class="nv">$a</span><span class="o">,</span> <span class="o">:</span><span class="nv">$b</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>关于签名能做什么，那只是开始。</p>
<p>所有下面的，在子例程和方法签名中都是被允许的，非强制性的， 对于这个例子杀伤力过大。这在 multi subs 和 multi methods 中对于限制可能的候选者真的很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="k">-&gt;</span>
  <span class="c1"># Type is an alias to the object type</span>
  <span class="o">:</span><span class="p">:</span><span class="s">Type</span> <span class="nb">Any</span> <span class="nv">$_</span> <span class="c1"># Any is the default type requirement</span>

  <span class="c1"># the public attributes of the object</span>
  <span class="p">(</span>
    <span class="o">:</span><span class="p">:</span><span class="s">A-Type</span> <span class="nb">Any</span> <span class="p">:</span><span class="s">key</span><span class="p">(</span>   <span class="p">:</span><span class="s">numerator</span><span class="p">(</span>   <span class="nv">$a</span> <span class="p">)</span> <span class="p">)</span><span class="o">,</span>
    <span class="o">:</span><span class="p">:</span><span class="s">B-Type</span> <span class="nb">Any</span> <span class="p">:</span><span class="s">value</span><span class="p">(</span> <span class="p">:</span><span class="s">denominator</span><span class="p">(</span> <span class="nv">$b</span> <span class="p">)</span> <span class="p">)</span> <span class="k">where</span> <span class="nv">$b</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">,</span>
  <span class="p">)</span>
<span class="p">{</span>
  <span class="k">my</span> <span class="n">Type</span> <span class="nv">$obj</span> <span class="o">=</span> <span class="nv">$_</span><span class="p">;</span> <span class="c1"># new variable declared as having the same type</span>
  <span class="k">my</span> <span class="n">A-Type</span> <span class="nv">$new-a</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
  <span class="k">my</span> <span class="n">B-Type</span> <span class="nv">$new-b</span> <span class="o">=</span> <span class="nv">$b</span><span class="p">;</span>

  <span class="c1"># could have used $_.^name or .^name instead of Type.^name</span>
  <span class="c1"># so you don&#39;t actually have to add the alias to the signature</span>
  <span class="c1"># to get the name of the arguments type</span>
  <span class="nb">say</span> <span class="n">Type</span><span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$_</span><span class="p">;</span>
  <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">  </span><span class="p">&#39;</span><span class="o">,</span> <span class="n">A-Type</span><span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$a</span><span class="p">;</span>
  <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">  </span><span class="p">&#39;</span><span class="o">,</span> <span class="n">B-Type</span><span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">Pair</span> <span class="s">one</span> <span class="o">=&gt;</span> <span class="mi">1</span>
  <span class="nb">Str</span> <span class="nb">one</span>
  <span class="nb">Int</span> <span class="mi">1</span>
<span class="nb">Rat</span> <span class="mf">0.333333</span>
  <span class="nb">Int</span> <span class="mi">1</span>
  <span class="nb">Int</span> <span class="mi">3</span>
</code></pre></div><p>至于使用 <a href="http://doc.raku.org/routine/sort"><code>.sort({.key})</code></a>, 恩, 那从根本上来说是同一个东西, 因为 <a href="http://doc.raku.org/routine/sort"><code>sort</code></a>  在那儿接受任何 <a href="http://doc.raku.org/type/Callable">Callable</a> </p>
<p>我要指出, 你甚至不需要为 <a href="http://doc.raku.org/routine/sort"><code>sort</code></a> 提供参数, 因为它默认比你给它的东西智能。</p>
<p>Raku 有很多创建和访问 <a href="http://doc.raku.org/type/Callable">Callable</a> 东西的方式。所以任何下面一种都可以工作：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">*.</span><span class="nb">key</span>
<span class="p">{</span> <span class="o">.</span><span class="nb">key</span> <span class="p">}</span> <span class="c1"># { $_.key }</span>
<span class="k">-&gt;</span> <span class="nv">$_</span> <span class="p">{</span> <span class="o">.</span><span class="nb">key</span> <span class="p">}</span> <span class="c1"># basically what the previous line turns into</span>
<span class="p">{</span> <span class="nv">$^placeholder-var</span><span class="o">.</span><span class="nb">key</span> <span class="p">}</span>
<span class="k">sub</span> <span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">key</span> <span class="p">}</span>
<span class="nv">&amp;a-subroutine-reference</span> <span class="c1"># you would have to create the subroutine though</span>
</code></pre></div><p>还有， 因为所有普通的操作符实际上都是子例程，你可以在需要  <a href="http://doc.raku.org/type/Callable">Callable</a> 的其它地方使用它们：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">&amp;infix:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;</span> <span class="c1"># the subroutines responsible for the numeric addition operator</span>
<span class="o">&amp;[+]</span> <span class="c1"># ditto</span>

<span class="nv">&amp;prefix:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;</span>
<span class="nv">&amp;postfix:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;</span>

<span class="c1"># etc</span>
</code></pre></div><ul>
<li><input disabled="" type="checkbox"> 和 ( ) 的区别</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 无法正常排序</span>
<span class="k">my</span>  <span class="nv">@s</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2443</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">33</span><span class="o">,</span> <span class="mi">90</span><span class="o">,</span> <span class="o">-</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">764</span><span class="o">]</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@s</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>     <span class="c1"># 2443 5 33 90 -9 2 764</span>
<span class="nb">say</span> <span class="nv">@s</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>     <span class="c1"># (Array)</span>
<span class="nb">say</span> <span class="nv">@s</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>     <span class="c1"># [[2443, 5, 33, 90, -9, 2, 764]]&lt;&gt;</span>

<span class="c1"># 正常排序</span>
<span class="k">my</span>  <span class="nv">$array</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2443</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">33</span><span class="o">,</span> <span class="mi">90</span><span class="o">,</span> <span class="o">-</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">764</span><span class="o">]</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$array</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span> <span class="c1">#  -9 2 5 33 90 764 2443</span>
<span class="nb">say</span> <span class="nv">$array</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="c1"># (Array)</span>
<span class="nb">say</span> <span class="nv">$array</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="c1"># [2443, 5, 33, 90, -9, 2, 764]</span>

<span class="k">my</span>  <span class="nv">@s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2443</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">33</span><span class="o">,</span><span class="mi">90</span><span class="o">,-</span><span class="mi">9</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">764</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">@s</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>     <span class="c1"># -9 2 5 33 90 764 2443</span>
<span class="nb">say</span> <span class="nv">$array</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="c1"># (Array)</span>
<span class="nb">say</span> <span class="nv">@s</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>     <span class="c1"># [2443, 5, 33, 90, -9, 2, 764]&lt;&gt;</span>
</code></pre></div><p>可见, 使用 <code>[ ]</code> 和 <code>( )</code> 创建数组是不一样的.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@s</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2443</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">33</span><span class="o">,</span> <span class="mi">90</span><span class="o">,</span> <span class="o">-</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">764</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><p>这创建了一个数组, 并把该数组赋值给 <code>@s[0]</code>, 所以 <code>@s</code> 只有一个元素, 所以对 <code>@s</code> 进行排序是没有意义的. 然而你可以使用:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@s</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">sort</span><span class="o">.</span><span class="nb">say</span>
</code></pre></div><p>来实现你要求的排序。</p>
<ul>
<li><a href="http://stackoverflow.com/questions/37979519/how-do-i-chain-to-an-inline-block-in-perl-6">How do I chain to an inline block in Raku?</a></li>
</ul>
<p>我想修改一个数组(我在这个例子中使用了 <code>splice</code>, 但是它也可能是修改数组的任何操作)并返回修改后的数组 - 和 <code>slice</code> 不一样, slice 返回的是从数组中抠出的项。我可以很容易地通过在数组中存储一个 block 来做到, 就像下面这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$1</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nb">splice</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span><span class="p">);</span> <span class="nv">$a</span> <span class="p">};</span>
<span class="nb">say</span> <span class="p">(</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">??</span> <span class="mi">0</span> <span class="o">!!</span> <span class="nv">$_</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">Array</span><span class="p">;</span>
<span class="c1"># [0 0 0 0 4 5]</span>
<span class="nb">say</span> <span class="p">(</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">??</span> <span class="mi">0</span> <span class="o">!!</span> <span class="nv">$_</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">Array</span><span class="o">.</span><span class="nv">$1</span><span class="p">;</span>
<span class="c1"># [0 1 2 3 4 5]</span>
</code></pre></div><p>我怎么把由 <code>$1</code> 代表的 block 内联到单个表达式中呢？ 下面的解决方法不正确:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">??</span> <span class="mi">0</span> <span class="o">!!</span> <span class="nv">$_</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">Array</span><span class="o">.</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nb">splice</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span><span class="p">);</span> <span class="nv">$a</span> <span class="p">})</span>
<span class="n">Invocant</span> <span class="n">requires</span> <span class="n">a</span> <span class="nb">type</span> <span class="n">object</span> <span class="k">of</span> <span class="nb">type</span> <span class="nb">Array</span><span class="o">,</span> <span class="k">but</span> <span class="nc">an</span> <span class="n">object</span> <span class="n">instance</span> <span class="n">was</span> <span class="n">passed</span><span class="o">.</span>  <span class="n">Did</span> <span class="n">you</span> <span class="n">forget</span> <span class="n">a</span> <span class="p">&#39;</span><span class="s1">multi</span><span class="p">&#39;</span><span class="o">?</span>
</code></pre></div><p>解决方法是添加一个 <code>&amp;</code> 符号:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">??</span> <span class="mi">0</span> <span class="o">!!</span> <span class="nv">$_</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">Array</span><span class="o">.&amp;</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nb">splice</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span><span class="p">);</span> <span class="nv">$a</span> <span class="p">})</span>
<span class="c1"># 输出 [0 1 2 3 4 5]</span>
</code></pre></div><ul>
<li><a href="http://stackoverflow.com/questions/38535690/getting-a-positional-slice-using-a-range-variable-as-a-subscript">Getting a positional slice using a Range variable as a subscript</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@numbers</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">4 8 16 16 23 42</span><span class="p">&gt;;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span> <span class="c1"># this works</span>
<span class="c1"># 4</span>
<span class="c1"># 8</span>
<span class="c1"># 15</span>

<span class="c1"># but this doesn&#39;t</span>
<span class="k">my</span> <span class="nv">$range</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="o">[</span><span class="nv">$range</span><span class="o">]</span><span class="p">;</span>
<span class="c1"># 16</span>
</code></pre></div><p>最后的那个下标看起来好像把 <code>$range</code> 解释为 range 中元素的个数(3)。怎么回事?</p>
<p><strong>解决方法</strong></p>
<p>使用 <code>@numbers[|$range]</code> 把 range 对象展平到列表中。或者在 <strong>Range</strong> 对象上使用绑定来传递它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># On Fri Jul 2016, gfldex wrote:</span>
<span class="k">my</span> <span class="nv">@numbers</span> <span class="o">=</span>  <span class="p">&lt;</span><span class="s">4 8 15 16 23 42</span><span class="p">&gt;;</span> <span class="k">my</span> <span class="nv">$range</span> <span class="o">=</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">;</span> <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="o">[</span><span class="nv">$range</span><span class="o">]</span><span class="p">;</span>

<span class="c1"># OUTPUT«16»</span>
<span class="c1"># expected:</span>
<span class="c1"># OUTPUT«4\n 8\n 15»</span>


<span class="c1"># 这是对的, 并且还跟 &#34;Scalar container implies item&#34; 规则有关.</span>
<span class="c1"># Changing it would break things like the second evaluation here:</span>

<span class="k">my</span> <span class="nv">@x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span> <span class="k">my</span> <span class="nv">@y</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">;</span> <span class="nv">@x</span><span class="o">[</span><span class="nv">@y</span><span class="o">]</span>
<span class="c1"># (2 3 4)</span>

<span class="nv">@x</span><span class="o">[</span><span class="nb">item</span> <span class="nv">@y</span><span class="o">]</span>
<span class="c1"># 4</span>

<span class="c1"># 注意在签名中 range 可以被绑定给 @y, 而特殊的 Range 可以生成一个像 @x[$(@arr-param)] 的表达式</span>
<span class="c1"># 这在它的语义中是不可预期的。</span>

<span class="c1"># 同样, 绑定给 $range 也能提供预期的结果</span>
<span class="k">my</span> <span class="nv">@numbers</span> <span class="o">=</span>  <span class="p">&lt;</span><span class="s">4 8 15 16 23 42</span><span class="p">&gt;;</span> <span class="k">my</span> <span class="nv">$range</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">;</span> <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="o">[</span><span class="nv">$range</span><span class="o">]</span><span class="p">;</span>
<span class="c1"># OUTPUT«4␤8␤15␤»</span>

<span class="c1"># 这也是预期的结果, 因为使用绑定就没有标量容器来强制被当成一个 item 了。</span>
<span class="c1"># So, all here is working as designed.</span>
</code></pre></div><p>或者：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="o">[</span><span class="nv">@</span><span class="p">(</span><span class="nv">$range</span><span class="p">)</span><span class="o">]</span>
<span class="c1"># 4</span>
<span class="c1"># 8</span>
<span class="c1"># 15</span>
</code></pre></div><p>绑定到标量容器的符号输出一个东西, 可以达到你想要的选择包含：</p>
<p>前置一个 <code>@</code> 符号来得到单个东西的复数形式：<code>numbers[@$range];</code> 或者以不同的形式来声明 ragne 变量, 以使它直接工作。
对于后者, 考虑下面的形式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Bind the symbol `numbers` to the value 1..10:</span>
<span class="k">my</span> <span class="nv">\numbers</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>

<span class="c1"># Bind the symbol `rangeA` to the value 1..10:</span>
<span class="k">my</span> <span class="nv">\rangeA</span>  <span class="o">:=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>
<span class="c1"># Bind the symbol `rangeB` to the value 1..10:</span>
<span class="k">my</span> <span class="nv">\rangeB</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>

<span class="c1"># Bind the symbol `$rangeC` to the value 1..10:</span>
<span class="k">my</span> <span class="nv">$rangeC</span>  <span class="o">:=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>

<span class="c1"># Bind the symbol `$rangeD` to a Scalar container</span>
<span class="c1"># and then store the value 1..10 in it:`</span>
<span class="k">my</span> <span class="nv">$rangeD</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>

<span class="c1"># Bind the symbol `@rangeE` to the value 1..10:</span>
<span class="k">my</span> <span class="nv">@rangeE</span>  <span class="o">:=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>

<span class="c1"># Bind the symbol `@rangeF` to an Array container and then</span>
<span class="c1"># store 1 thru 10 in the Scalar containers 1 thru 10 inside the Array</span>
<span class="k">my</span> <span class="nv">@rangeF</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>

<span class="nb">say</span> <span class="n">numbers</span><span class="o">[</span><span class="n">rangeA</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (1 2 3 4 5 6 7 8 9 10)</span>
<span class="nb">say</span> <span class="n">numbers</span><span class="o">[</span><span class="n">rangeB</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># (1 2 3 4 5 6 7 8 9 10)</span>
<span class="nb">say</span> <span class="n">numbers</span><span class="o">[</span><span class="nv">$rangeC</span><span class="o">]</span><span class="p">;</span> <span class="c1"># (1 2 3 4 5 6 7 8 9 10)</span>
<span class="nb">say</span> <span class="n">numbers</span><span class="o">[</span><span class="nv">$rangeD</span><span class="o">]</span><span class="p">;</span> <span class="c1"># 10</span>
<span class="nb">say</span> <span class="n">numbers</span><span class="o">[</span><span class="nv">@rangeE</span><span class="o">]</span><span class="p">;</span> <span class="c1"># (1 2 3 4 5 6 7 8 9 10)</span>
<span class="nb">say</span> <span class="n">numbers</span><span class="o">[</span><span class="nv">@rangeF</span><span class="o">]</span><span class="p">;</span> <span class="c1"># (1 2 3 4 5 6 7 8 9 10)</span>
</code></pre></div><p>绑定到标量容器(<code>$rangeD</code>)上的符号总是产生单个值。在 <code>[...]</code> 下标中单个值必须是数字。
对于 range, 被当作单个数字时, 产生的是 range 的长度。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/notes" term="notes" label="notes" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 given/when 模式匹配]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-02-06-given-when-pattern-match-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-03-15-when-and-where/?utm_source=atom_feed" rel="related" type="text/html" title="When and Where" />
            
                <id>https://ohmyweekly.github.io/notes/2016-02-06-given-when-pattern-match-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Given When Pattern Match in Raku</blockquote><h3 id="模式匹配">模式匹配</h3>
<p>匹配单个字符串:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">twostraws</span><span class="p">&#34;;</span>

<span class="k">given</span> <span class="nv">$name</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">&#34;</span><span class="s2">bilbo</span><span class="p">&#34;</span>      <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Bilbo Baggins!</span><span class="p">&#34;}</span>
    <span class="k">when</span> <span class="p">&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Paul Hudson!</span><span class="p">&#34;</span>  <span class="p">}</span>
    <span class="k">default</span>           <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">身份验证失败</span><span class="p">&#34;</span>           <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>匹配元组:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$bool1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$bool2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">given</span> <span class="p">(</span><span class="nv">$bool1</span><span class="o">,</span> <span class="nv">$bool2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">0, 0</span><span class="p">&#34;}</span>
    <span class="k">when</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">0, 1</span><span class="p">&#34;}</span>
    <span class="k">when</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1, 0</span><span class="p">&#34;}</span>
    <span class="k">when</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1, 1</span><span class="p">&#34;}</span>
<span class="p">}</span>

<span class="k">given</span> <span class="p">(&#34;</span><span class="s2">15</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">example</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">3.14</span><span class="p">&#34;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
    <span class="k">when</span> <span class="p">(</span><span class="nv">$</span><span class="o">,</span> <span class="nv">$</span><span class="o">,</span> <span class="nb">Str</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I got a String of </span><span class="nv">$_</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">given</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(</span> <span class="nv">$</span><span class="o">,</span>  <span class="nv">$</span><span class="p">)</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Ok</span><span class="p">&#34;}</span>
<span class="p">}</span>

<span class="k">given</span> <span class="p">(&#34;</span><span class="s2">fly.mp3</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">It&#39;s funny</span><span class="p">&#34;)</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(/</span><span class="ni">.</span><span class="sr">mp</span><span class="mi">3</span><span class="ni">$</span><span class="p">/</span><span class="o">,</span> <span class="p">/</span><span class="mi">4</span><span class="ni">$</span><span class="p">/</span><span class="o">,</span> <span class="o">*.</span><span class="nb">chars</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Perfact</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">given</span> <span class="mi">5</span> <span class="p">{</span>
    <span class="k">when</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1..10 contains 5</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="同时检查名字和密码">同时检查名字和密码</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$name</span>     <span class="o">=</span> <span class="p">&#34;</span><span class="s2">twostraws</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$password</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;;</span>

<span class="k">given</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">$password</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">bilbo</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">bagg1n5</span><span class="p">&#34;)</span>      <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Bilbo Baggins!</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Paul Hudson!</span><span class="p">&#34;</span>   <span class="p">}</span>
    <span class="k">default</span>                        <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你是谁?</span><span class="p">&#34;</span>                <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="使用单个元组">使用单个元组</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$authentication</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;);</span>

<span class="k">given</span> <span class="nv">$authentication</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">bilbo</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">bagg1n5</span><span class="p">&#34;)</span>      <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Bilbo Baggins!</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Paul Hudson!</span><span class="p">&#34;</span>   <span class="p">}</span>
    <span class="k">default</span>                        <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你是谁?</span><span class="p">&#34;</span>                <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="部分匹配">部分匹配</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 你只关心某些感兴趣的值，不关心其它值，使用 `*` 号或 `$` 来代表 &#34;any value is fine&#34;</span>
<span class="k">my</span> <span class="nv">$authentication</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">127.0.0.1</span><span class="p">&#34;);</span>

<span class="k">given</span> <span class="nv">$authentication</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">bilbo</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">bagg1n5</span><span class="p">&#34;</span><span class="o">,</span> <span class="o">*</span><span class="p">)</span>      <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Bilbo Baggins!</span><span class="p">&#34;}</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Paul Hudson!</span><span class="p">&#34;</span>  <span class="p">}</span>
    <span class="k">default</span>                           <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Who are you?</span><span class="p">&#34;</span>         <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="只匹配元组的一部分">只匹配元组的一部分</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 但仍然想知道其它部分是什么</span>
<span class="k">my</span> <span class="nv">$authentication</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;);</span>

<span class="k">given</span> <span class="nv">$authentication</span> <span class="p">{</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">bilbo</span><span class="p">&#34;</span><span class="o">,</span> <span class="o">*</span><span class="p">)</span>     <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Bilbo Baggins!</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, Paul Hudson: your password was </span><span class="nv">$_</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="k">default</span>               <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Who are you?</span><span class="p">&#34;</span>         <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="匹配计算型元组">匹配计算型元组</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$number</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str</span> <span class="p">{</span>
    <span class="k">given</span> <span class="p">(</span><span class="nv">$number</span> <span class="nv">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$number</span> <span class="nv">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">when</span> <span class="p">(</span><span class="nb">True</span><span class="o">,</span> <span class="nb">False</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="p">&#34;</span><span class="s2">Fizz</span><span class="p">&#34;</span>     <span class="p">}</span>
        <span class="k">when</span> <span class="p">(</span><span class="nb">False</span><span class="o">,</span> <span class="nb">True</span><span class="p">)</span>  <span class="p">{</span> <span class="k">return</span> <span class="p">&#34;</span><span class="s2">Buzz</span><span class="p">&#34;</span>     <span class="p">}</span>
        <span class="k">when</span> <span class="p">(</span><span class="nb">True</span><span class="o">,</span> <span class="nb">True</span><span class="p">)</span>   <span class="p">{</span> <span class="k">return</span> <span class="p">&#34;</span><span class="s2">FizzBuzz</span><span class="p">&#34;</span> <span class="p">}</span>
        <span class="k">when</span> <span class="p">(</span><span class="nb">False</span><span class="o">,</span> <span class="nb">False</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$number</span><span class="o">.</span><span class="nb">Str</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
</code></pre></div><h3 id="遍历元组">遍历元组</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$twostraws</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;);</span>
<span class="k">my</span> <span class="nv">$bilbo</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">bilbo</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">bagg1n5</span><span class="p">&#34;);</span>
<span class="k">my</span> <span class="nv">$taylor</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">taylor</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;);</span>
<span class="k">my</span> <span class="nv">@users</span> <span class="o">=</span> <span class="nv">$twostraws</span><span class="o">,</span> <span class="nv">$bilbo</span><span class="o">,</span> <span class="nv">$taylor</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@users</span> <span class="k">-&gt;</span> <span class="nv">$user</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$user</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="使用-when-匹配元组中的指定值">使用 when 匹配元组中的指定值</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$twostraws</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;);</span>
<span class="k">my</span> <span class="nv">$bilbo</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">bilbo</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">bagg1n5</span><span class="p">&#34;);</span>
<span class="k">my</span> <span class="nv">$taylor</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">taylor</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;);</span>
<span class="k">my</span> <span class="nv">@users</span> <span class="o">=</span> <span class="nv">$twostraws</span><span class="o">,</span> <span class="nv">$bilbo</span><span class="o">,</span> <span class="nv">$taylor</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">User twostraws has the password fr0st1es</span><span class="p">&#34;</span> <span class="k">when</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;)</span> <span class="k">for</span> <span class="nv">@users</span><span class="p">;</span>

<span class="c1"># 打印秘密为指定值的用户</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">User </span><span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="s2"> has password \&#34;fr0st1es\&#34;</span><span class="p">&#34;</span> <span class="k">when</span> <span class="p">(</span><span class="o">*,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;)</span> <span class="k">for</span> <span class="nv">@users</span><span class="p">;</span>
</code></pre></div><h3 id="匹配范围">匹配范围</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$age</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>

<span class="k">given</span> <span class="nv">$age</span> <span class="p">{</span>
    <span class="k">when</span> <span class="mi">0</span> <span class="o">..^</span> <span class="mi">18</span>   <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有活力有时间，但是没钱</span><span class="p">&#34;</span>  <span class="p">}</span>
    <span class="k">when</span> <span class="mi">18</span> <span class="o">..^</span> <span class="mi">70</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有活力有钱，但是没时间</span><span class="p">&#34;</span>  <span class="p">}</span>
    <span class="k">default</span>         <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有时间和金钱，但是没活力</span><span class="p">&#34;}</span>
<span class="p">}</span>
</code></pre></div><h3 id="when-可以配合智能匹配操作符--单独使用">when 可以配合智能匹配操作符 ~~ 单独使用</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$age</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
<span class="k">when</span> <span class="nv">$age</span> <span class="o">~~</span> <span class="mi">0</span> <span class="o">..^</span> <span class="mi">18</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有活力有时间，但是没钱</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">when</span> <span class="nv">$age</span> <span class="o">~~</span> <span class="mi">18</span> <span class="o">..^</span> <span class="mi">70</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有活力有钱，但是没时间</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">default</span>                <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有时间和金钱，但是没活力</span><span class="p">&#34;}</span>
</code></pre></div><h3 id="使用-contains-方法">使用 contains 方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$age</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>
<span class="k">when</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..^</span> <span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="nb">contains</span><span class="p">(</span><span class="nv">$age</span><span class="p">)</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有活力有时间，但是没钱</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">when</span> <span class="p">(</span><span class="mi">18</span> <span class="o">..^</span> <span class="mi">70</span><span class="p">)</span><span class="o">.</span><span class="nb">contains</span><span class="p">(</span><span class="nv">$age</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有活力有钱，但是没时间</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">default</span>                         <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">你有时间和金钱，但是没活力</span><span class="p">&#34;}</span>
</code></pre></div><h3 id="匹配元组中的范围">匹配元组中的范围</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$user</span> <span class="o">=</span> <span class="p">(&#34;</span><span class="s2">twostraws</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">fr0st1es</span><span class="p">&#34;</span><span class="o">,</span> <span class="mi">36</span><span class="p">);</span>

<span class="k">given</span> <span class="nv">$user</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$user</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
    <span class="k">when</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="o">*,</span> <span class="mi">0</span> <span class="o">..^</span> <span class="mi">18</span><span class="p">)</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="s2"> 有活力有时间，但是没钱</span><span class="p">&#34;</span>  <span class="p">}</span>
    <span class="k">when</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="o">*,</span> <span class="mi">18</span> <span class="o">..^</span> <span class="mi">70</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="s2"> 有活力有钱，但是没时间</span><span class="p">&#34;</span>  <span class="p">}</span>
    <span class="k">when</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="o">*,</span> <span class="o">*</span><span class="p">)</span>         <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="s2"> 有时间和金钱,但是没活力</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="枚举">枚举</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">enum</span> <span class="n">WeatherType</span> <span class="p">&lt;</span><span class="s">Cloudy Sunny Windy</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$today</span> <span class="o">=</span> <span class="n">WeatherType::Cloudy</span><span class="p">;</span>

<span class="k">given</span> <span class="nv">$today</span> <span class="p">{</span>
    <span class="k">when</span> <span class="n">WeatherType::Cloudy</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">多云</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="n">WeatherType::Sunny</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">晴天</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="n">WeatherType::Windy</span>  <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">有风</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 使用 if 语句</span>
<span class="k">if</span> <span class="nv">$today</span> <span class="o">~~</span> <span class="n">WeatherType::Cloudy</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">多云</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><h3 id="关联值">关联值</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">enum</span> <span class="n">WeatherType</span>  <span class="p">(</span>
    <span class="s">Cloudy</span> <span class="o">=&gt;</span> <span class="mi">100</span>,
    <span class="s">Sunny</span>  <span class="o">=&gt;</span> <span class="mi">50</span>,
    <span class="s">Windy</span>  <span class="o">=&gt;</span> <span class="mi">30</span>
<span class="p">);</span>

<span class="k">my</span> <span class="nv">$today</span> <span class="o">=</span> <span class="n">WeatherType::Windy</span><span class="p">;</span>
<span class="k">given</span> <span class="nv">$today</span> <span class="p">{</span>
    <span class="k">when</span> <span class="n">WeatherType::Cloudy</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">20</span><span class="o">*</span><span class="n">Cloudy</span> <span class="p">}</span>
    <span class="k">when</span> <span class="n">WeatherType::Sunny</span>  <span class="p">{</span> <span class="nb">say</span> <span class="mi">10</span><span class="o">*</span><span class="n">Sunny</span>  <span class="p">}</span>
    <span class="k">when</span> <span class="n">WeatherType::Windy</span>  <span class="p">{</span> <span class="nb">say</span> <span class="mi">12</span><span class="o">*</span><span class="n">Windy</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="when-从句">when 从句</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@numbers</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@celebrities</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Michael Jackson</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Taylor Swift</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">MichaelCaine</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Adele Adkins</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Michael Jordan</span><span class="p">&#34;;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="o">/^</span><span class="n">Michael</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@celebrities</span><span class="p">;</span>     <span class="c1"># 使用正则表达式</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;</span> <span class="mi">12</span> <span class="k">for</span> <span class="nv">@celebrities</span><span class="p">;</span>  <span class="c1"># 调用方法</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="o">/^</span><span class="n">Michael</span><span class="o">/</span> <span class="ow">and</span> <span class="nv">$_</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&gt;</span><span class="mi">12</span> <span class="k">for</span> <span class="nv">@celebrities</span><span class="p">;</span> <span class="c1"># 复合条件</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/given" term="given" label="given" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/when" term="when" label="when" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 IO 操作]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-10-11-io-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-10-11-io-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Io in Raku</blockquote><p>文件存在、文件的时间戳、文件的修改时间等等</p>
<h3 id="批量插入文本">批量插入文本</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@filenames</span> <span class="o">=</span> <span class="nb">dir</span> <span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="o">,</span>  <span class="s">test</span> <span class="o">=&gt;</span> <span class="nb">any</span><span class="p">(/</span><span class="sr">\</span><span class="ni">.</span><span class="sr">md</span><span class="ni">$</span><span class="p">/</span>, <span class="p">/</span><span class="sr">\</span><span class="ni">.</span><span class="sr">markdown</span><span class="p">/);</span>

<span class="k">for</span> <span class="nv">@filenames</span> <span class="k">-&gt;</span> <span class="nv">$filePath</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$path</span> <span class="o">=</span> <span class="nv">$filePath</span><span class="o">.</span><span class="nb">path</span><span class="p">();</span>
    <span class="nv">$path</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="ni">.</span><span class="sr">md</span><span class="p">//;</span>
    <span class="nv">$path</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/</span><span class="ni">.</span><span class="sr">markdown</span><span class="p">//;</span>

    <span class="k">my</span> <span class="nv">$date</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">now</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$head</span> <span class="o">=</span>
<span class="k">qq</span><span class="sa">:heredoc</span> <span class="p">&#39;EOT&#39;;</span><span class="s2">
</span><span class="s2">title:  </span><span class="nv">$path</span><span class="o">.</span><span class="nf">IO.basename</span><span class="p">()</span><span class="s2">
</span><span class="s2">date: </span><span class="nv">$date</span><span class="s2">
</span><span class="s2">tags: Raku
</span><span class="s2">categories: Raku
</span><span class="s2">
</span><span class="s2">---
</span><span class="s2">
</span><span class="s2">&lt;blockquote class=&#34;blockquote-center&#34;&gt;这城市有太多风景都在提醒那过去！&lt;/blockquote&gt;
</span><span class="s2">
</span><span class="s2">[TOC]
</span><span class="s2">
</span><span class="s2"></span><span class="p">EOT</span>

   <span class="k">my</span> <span class="nv">@content</span>   <span class="o">=</span> <span class="nb">slurp</span> <span class="nv">$filePath</span><span class="p">;</span>
   <span class="nb">spurt</span><span class="p">(</span><span class="nv">$filePath</span><span class="o">.</span><span class="nb">path</span><span class="o">,</span> <span class="p">&#34;</span><span class="nv">$head</span><span class="s2">\n</span><span class="nv">@content</span><span class="o">[]</span><span class="p">&#34;);</span>
<span class="p">}</span>

</code></pre></div><p>在当前目录中查找所有以 <code>.md</code> (.markdown)结尾的文件（即markdown文件）, 并在文件最前面插入一段文本， 形如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">title:</span>  <span class="nb">Raku</span>
<span class="n">date:</span> <span class="mi">2015</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">20</span><span class="nf">T23:19:13Z</span>
<span class="n">tags:</span> <span class="nb">Raku</span>
<span class="n">categories:</span> <span class="nb">Raku</span>

<span class="o">---</span>

<span class="p">&lt;</span><span class="s">blockquote class=&#34;blockquote-center&#34;</span><span class="p">&gt;</span><span class="n">我站在天桥上念你</span><span class="o">,</span> <span class="n">有点狼狈</span><span class="p">&lt;</span><span class="s">/blockquote</span><span class="p">&gt;</span>

</code></pre></div><p>类 <code>IO::Path</code> 提供了 <code>basename</code>, <code>path</code>, <code>parts</code>, 等方法供使用, 具体用法请看文档:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">rakudoc IO::Path
</code></pre></div><p>一些例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">IO::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">/etc/passwd</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">basename</span><span class="p">;</span>   <span class="c1"># passwd</span>
<span class="nb">say</span> <span class="nb">IO::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">docs/README.pod</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">extension</span><span class="p">;</span>   <span class="c1"># pod</span>
<span class="nb">say</span> <span class="nb">IO::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">/etc/passwd</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">dirname</span><span class="p">;</span>    <span class="c1"># /etc</span>
<span class="nb">say</span> <span class="nb">IO::Path::Win32</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">C:\\Windows\\registry.ini</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">volume</span><span class="p">;</span>    <span class="c1"># C:</span>
<span class="nb">say</span> <span class="nb">IO::Path</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">/etc/passwd</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">parts</span><span class="o">.</span><span class="nb">perl</span> <span class="c1"># (&#34;dirname&#34; =&gt; &#34;/etc&#34;, &#34;volume&#34;  =&gt; &#34;&#34;, &#34;basename&#34; =&gt; &#34;passwd&#34;).hash</span>
</code></pre></div><p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># To iterate over the contents of the current directory: for dir() -&gt; $file</span>
<span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$file</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># As before, but include even &#39;.&#39; and &#39;..&#39; which are filtered out by # the</span>
<span class="k">default</span> <span class="p">:</span><span class="s">test</span> <span class="n">matcher:</span> <span class="k">for</span> <span class="nb">dir</span><span class="p">(</span><span class="s">test</span> <span class="o">=&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$file</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$file</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># To get the names of all .jpg and .jpeg files in ~/Downloads: my @jpegs =</span>
<span class="p">&#34;</span><span class="nv">%*ENV</span><span class="p">&lt;</span><span class="s">HOME</span><span class="p">&gt;</span><span class="s2">/Downloads</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">dir</span><span class="p">(</span><span class="s">test</span> <span class="o">=&gt;</span> <span class="p">/:</span><span class="na">i</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> jpe</span><span class="o">?</span><span class="sr">g </span><span class="ni">$</span><span class="p">/)</span><span class="o">».</span><span class="nb">Str</span><span class="p">;</span>

<span class="c1"># An example program that lists all files and directories recursively:</span>

<span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$dir</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@todo</span> <span class="o">=</span> <span class="nv">$dir</span><span class="o">.</span><span class="nb">IO</span><span class="p">;</span> <span class="k">while</span> <span class="nv">@todo</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nv">@todo</span><span class="o">.</span><span class="nb">pop</span><span class="o">.</span><span class="nb">dir</span> <span class="k">-&gt;</span> <span class="nv">$path</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="nv">$path</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span> <span class="nv">@todo</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">$path</span> <span class="k">if</span> <span class="nv">$path</span><span class="o">.</span><span class="nb">d</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="文件测试操作符">文件测试操作符</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># If you have a string - a path to something in the filesystem:</span>

<span class="k">if</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">e</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">file exists</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;;</span> <span class="k">if</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">e</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">file exists</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="c1"># Instead of the colonpair syntax, you can use method calls too:</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">path/to/file</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">e</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">file exists</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="c1"># If you already have an IO object in $file, either by creating one yourself, or</span>
<span class="c1"># by getting it from another subroutine, such as dir, you can write this:</span>

<span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="p">;</span> <span class="k">if</span> <span class="nv">$file</span> <span class="o">~~</span> <span class="p">:</span><span class="s">e</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">file exists</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><h3 id="文件时间戳">文件时间戳</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">modified</span><span class="p">;</span>                <span class="c1"># e.g. Instant:1424089165</span>
<span class="nb">say</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">modified</span><span class="p">);</span>  <span class="c1"># e.g. 2015-02-16T12:18:50Z</span>

<span class="k">my</span> <span class="nv">$modification_instant</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">modified</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$modification_time</span>    <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$modification_instant</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$modification_time</span><span class="p">;</span>  <span class="c1"># e.g. 2015-02-16T12:18:50Z</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">accessed</span><span class="p">;</span>                <span class="c1"># e.g. Instant:1424353577</span>
<span class="nb">say</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">accessed</span><span class="p">);</span>  <span class="c1"># e.g. 2015-02-19T13:45:42Z</span>

<span class="k">my</span> <span class="nv">$access_instant</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">accessed</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$access_time</span>    <span class="o">=</span>  <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$access_instant</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$access_time</span><span class="p">;</span>  <span class="c1"># e.g. 2015-02-19T13:45:42Z</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">changed</span><span class="p">;</span>                <span class="c1"># e.g. Instant:1424089165</span>
<span class="nb">say</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">changed</span><span class="p">);</span>  <span class="c1"># e.g. 2015-02-16T12:18:50Z</span>

<span class="k">my</span> <span class="nv">$change_instant</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">path/to/file</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">changed</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$change_time</span>    <span class="o">=</span>  <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">$chnge_instant</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$change_time</span><span class="p">;</span>  <span class="c1"># e.g. 2015-02-16T12:18:50Z</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/io" term="io" label="io" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 polymod 方法]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-09-17-polymod-method-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-09-17-polymod-method-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Polymod Method in Raku</blockquote><blockquote>
<p>Raku 中的 .polymod 方法 - 把数字分解成分母</p>
</blockquote>
<h2 id="命名">命名</h2>
<p><code>.polymod</code> 方法接受几个除数并把它的调用者分解成一份一份的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$seconds</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">24</span> <span class="c1"># days</span>
            <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span>    <span class="c1"># hours</span>
            <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">60</span>       <span class="c1"># minutes</span>
            <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>           <span class="c1"># seconds</span>

<span class="nb">say</span> <span class="nv">$seconds</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">60</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$seconds</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">24</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># (5 4 27)</span>
<span class="c1"># (5 4 3 1)</span>
</code></pre></div><p>这种情况下我们作为参数传递的除数是和时间相关的: 60(每分钟有多少秒)， 60(每小时有多少分钟)，和24(每天有多少小时)。从最小的单位开始， 我们一直前进到最大的单位。</p>
<p>输出和输入的除数是相匹配的 - 从最小的单位到最大的单位： 5 秒，4 分钟，3 小时和 1 天。</p>
<h2 id="手工制作">手工制作</h2>
<p>不使用 <code>.polymod</code> 而使用一个循环来展示怎么之前的计算:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$seconds</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">24</span> <span class="c1"># days</span>
            <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span>    <span class="c1"># hours</span>
            <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">60</span>       <span class="c1"># minutes</span>
            <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>           <span class="c1"># seconds</span>

<span class="k">my</span> <span class="nv">@pieces</span><span class="p">;</span>

<span class="k">for</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">24</span> <span class="k">-&gt;</span> <span class="nv">$divisor</span> <span class="p">{</span>
    <span class="nv">@pieces</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">$seconds</span> <span class="ow">mod</span> <span class="nv">$divisor</span><span class="p">;</span>
    <span class="nv">$seconds</span> <span class="ow">div</span><span class="o">=</span> <span class="nv">$divisor</span>
<span class="p">}</span>

<span class="nv">@pieces</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">$seconds</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@pieces</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># [5 4 3 2]</span>
</code></pre></div><h2 id="超越无限">超越无限</h2>
<p>当除数是以惰性列表的形式传递给 <code>.polymod</code> 方法时，它会一直运行直到余数为零并不会遍历整个列表:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">120</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span>      <span class="mi">10</span>¹<span class="o">,</span> <span class="mi">10</span>²<span class="o">,</span> <span class="mi">10</span>³<span class="o">,</span> <span class="mi">10</span>⁴<span class="o">,</span> <span class="mi">10</span>⁵<span class="p">;</span>
<span class="nb">say</span> <span class="mi">120</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> <span class="nb">lazy</span> <span class="mi">10</span>¹<span class="o">,</span> <span class="mi">10</span>²<span class="o">,</span> <span class="mi">10</span>³<span class="o">,</span> <span class="mi">10</span>⁴<span class="o">,</span> <span class="mi">10</span>⁵<span class="p">;</span>
<span class="nb">say</span> <span class="mi">120</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span>      <span class="mi">10</span>¹<span class="o">,</span> <span class="mi">10</span>²<span class="o">,</span> <span class="mi">10</span>³ <span class="o">…</span> <span class="no">∞</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># (0 12 0 0 0 0)</span>
<span class="c1"># (0 12)</span>
<span class="c1"># (0 12)</span>
</code></pre></div><p>在第一个调用中， 我们让一系列数字按 10 的幂增长。该调用的输出包含了 4 个尾部的零，因为 <code>.polymod</code> 方法计算了每个除数。在第二个调用中，我们使用 <code>lazy</code> 关键字显式地创建了一个惰性列表， 而现在我们在返回的列表中只有 2 个条目。</p>
<p>第一个除数(10)结果余数为 0，这是返回列表中的第一个条目，对于下一个除数，整除把我们的 120 变成了 12。12 除以 100 的余数为 12， 它是返回列表中的第二个条目。 现在， 12 整除 100 为 0， 它终止了 <code>.polymod</code> 的执行并给了我们两个 条目的结果。</p>
<p>在最后一个调用中，我们使用了省略号，它是一个序列操作符，用来创建一系列按 10 的幂增长的数字，但是这一次序列是无限的。因为它是惰性的，结果再一次只有 2 个元素。</p>
<h2 id="zip-it-lock-it-put-it-in-the-pocket">Zip It, Lock It, Put It In The Pocket</h2>
<p>单独的数字很好但是对于它们所代表的单位不够具有描述性。我们来使用 Zip 元操作符:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@units</span>  <span class="o">=</span> <span class="p">&lt;</span><span class="s">ng μg mg g kg</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@pieces</span> <span class="o">=</span> <span class="mi">42_666_555_444_333</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> <span class="mi">10</span>³ <span class="ow">xx</span> <span class="no">∞</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">@pieces</span> <span class="ow">Z</span><span class="o">~</span> <span class="nv">@units</span><span class="p">;</span>
<span class="c1"># OUTPUT:</span>
<span class="c1"># (333ng 444μg 555mg 666g 42kg)</span>
</code></pre></div><h2 id="快速命名">快速命名</h2>
<p>对于被调用者和除数，你不仅仅限于使用 Ints，也可以使用其它类型的数字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> ⅔<span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> ⅓<span class="p">;</span>

<span class="nb">say</span> <span class="mi">5</span><span class="o">.</span><span class="nb">Rat</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> <span class="mf">.3</span><span class="o">,</span> <span class="mf">.2</span><span class="p">;</span>
<span class="nb">say</span> <span class="mi">3</span><span class="o">.</span><span class="nb">Rat</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> ⅔<span class="o">,</span> ⅓<span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># (0 2)</span>
<span class="c1"># (0.2 0 80)</span>
<span class="c1"># (0.333333 0 12)</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">5</span><span class="o">.</span><span class="nb">Num</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> <span class="mf">.3</span><span class="o">,</span> <span class="mf">.2</span><span class="p">;</span>
<span class="nb">say</span> <span class="mi">3</span><span class="o">.</span><span class="nb">Num</span><span class="o">.</span><span class="nb">polymod</span><span class="o">:</span> ⅔<span class="o">,</span> ⅓<span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># (0.2 0.199999999999999 79)</span>
<span class="c1"># (0.333333333333333 2.22044604925031e-16 12)</span>
</code></pre></div><h2 id="使用-numberdenominatehttpmodulesrakuorgreponumberdenominate-模块">使用 <a href="http://modules.raku.org/repo/Number::Denominate">Number::Denominate</a> 模块</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Number::Denominate</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$seconds</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">24</span> <span class="c1"># days</span>
            <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">60</span><span class="o">*</span><span class="mi">60</span>    <span class="c1"># hours</span>
            <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">60</span>       <span class="c1"># minutes</span>
            <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>           <span class="c1"># seconds</span>

<span class="nb">say</span> <span class="n">denominate</span> <span class="nv">$seconds</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">denominate</span> <span class="nv">$seconds</span><span class="o">,</span> <span class="p">:</span><span class="s">set</span><span class="p">&lt;</span><span class="s">weight</span><span class="p">&gt;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 1 day, 3 hours, 4 minutes, and 5 seconds</span>
<span class="c1"># 97 kilograms and 445 grams</span>
</code></pre></div><p>你还可以定义自己的单位:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">denominate</span> <span class="mi">449</span><span class="o">,</span> <span class="p">:</span><span class="s">units</span><span class="p">(</span> <span class="s">foo</span> <span class="o">=&gt;</span> <span class="mi">3</span>, <span class="p">&lt;</span><span class="s">bar boors</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="mi">32</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">ber</span><span class="p">&#39;</span> <span class="p">);</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 4 foos, 2 boors, and 1 ber</span>
</code></pre></div><p><a href="http://raku.party/post/Raku-.polymod-break-up-a-number-into-denominations">http://raku.party/post/Raku-.polymod-break-up-a-number-into-denominations</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/polymod" term="polymod" label="polymod" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 proto]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-10-06-proto-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-10-06-proto-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Proto in Raku</blockquote><h2 id="proto">proto</h2>
<p>proto 意思为原型。proto 从形式上声明了 <code>multi</code> 候选者之间的<code>共性</code>。 proto 充当作能检查但不会修改参数的包裹。看看这个基本的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$reason</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$name</span><span class="o">,</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>

<span class="k">multi</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nv">$reason</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hooray for your </span><span class="nv">$reason</span><span class="s2">, </span><span class="nv">$name</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nf">congratulate</span><span class="p">(</span><span class="nv">$reason</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$rank</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hooray for your </span><span class="nv">$reason</span><span class="s2">, </span><span class="nv">$name</span><span class="s2"> -- you got rank </span><span class="nv">$rank</span><span class="s2">!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">being a cool number</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Fred</span><span class="p">&#39;);</span>     <span class="c1"># OK</span>
<span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">being a cool number</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Fred</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1"># OK</span>
<span class="nf">congratulate</span><span class="p">(&#39;</span><span class="s1">being a cool number</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">42</span><span class="p">);</span>         <span class="c1"># Proto match error</span>
</code></pre></div><p>所有的 <code>multi congratulate</code> 会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 <code>|</code> 是一个未命名的 <code>Capture</code> 形参, 这允许 <code>multi</code> 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 <code>Str</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">&amp;congratulate</span><span class="o">.</span><span class="nb">signature</span> <span class="c1">#-&gt; (Str $reason, Str $name, | is raw)</span>
</code></pre></div><p>你可以给 <code>proto</code> 一个函数体, 并且在你想执行 dispatch 的地方放上一个 <code>{*}</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># attempts to notify someone -- returns False if unsuccessful</span>
<span class="k">proto</span> <span class="nf">notify</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$user</span><span class="o">,</span><span class="nb">Str</span> <span class="nv">$msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\hour</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="o">.</span><span class="nb">hour</span><span class="p">;</span>
    <span class="k">if</span> <span class="nb">hour</span> <span class="o">&gt;</span> <span class="mi">8</span> <span class="ow">or</span> <span class="nb">hour</span> <span class="o">&lt;</span> <span class="mi">22</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">*</span><span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1"># we can&#39;t notify someone when they might be sleeping</span>
        <span class="k">return</span> <span class="nb">False</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>{*}</code> 总是分派给带有参数的候选者。默认参数和类型强制转换会起作用单不会传递。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">mistake-proto</span><span class="p">(</span><span class="nb">Str</span><span class="p">()</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
<span class="k">multi</span> <span class="nf">mistake-proto</span><span class="p">(</span><span class="nv">$str</span><span class="o">,</span><span class="nv">$number</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">WHAT</span> <span class="p">}</span>
<span class="nf">mistake-proto</span><span class="p">(</span><span class="mi">7</span><span class="o">,</span><span class="mi">42</span><span class="p">);</span>   <span class="c1">#-&gt; (Int) -- coercions not passed on</span>
<span class="nf">mistake-proto</span><span class="p">(&#39;</span><span class="s1">test</span><span class="p">&#39;);</span> <span class="c1">#!&gt; fails -- defaults not passed on</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/proto" term="proto" label="proto" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 Role]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-07-15-roles-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-07-15-roles-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Roles in Raku</blockquote><ul>
<li>Composition and mix-ins</li>
<li>Sigils</li>
<li>Typed data structures</li>
<li>Traits</li>
</ul>
<p>所以到底什么是 <code>role</code> 呢？ role 是零个或多个方法和属性的集合。</p>
<p>role 不像 class，它不能被实例化（如果你尝试了，会生成一个 class）。Raku 中 Classes 是可变的，而 roles 是不可变的。</p>
<h2 id="申明-roles-就像申明-class-一样">申明 Roles 就像申明 Class 一样</h2>
<p>使用关键字 <code>role</code> 来引入 role, 在 role 中声明属性和方法就像在 Raku 的类中声明属性和方法那样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">DebugLog</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">@.log_lines</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.log_size</span> <span class="k">is</span> <span class="k">rw</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">log_message</span><span class="p">(</span><span class="nv">$message</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">@!log_lines</span><span class="o">.</span><span class="nb">shift</span> <span class="k">if</span>
        <span class="nv">@!log_lines</span><span class="o">.</span><span class="nb">elems</span> <span class="o">&gt;=</span> <span class="nv">$!log_size</span><span class="p">;</span>
        <span class="nv">@!log_lines</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$message</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="role-composition">Role Composition</h2>
<ul>
<li>使用 <code>does</code> trait 将 role 组合到 Class 中：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">WebCrawler</span> <span class="k">does</span> <span class="nc">DebugLog</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>这会把方法和属性添加到 class WebCrawler 里面去。</li>
<li>结果就像它们起初被写到 class 中一样。</li>
</ul>
<h2 id="mix-ins">Mix-ins</h2>
<ul>
<li>允许 role 的功能被添加到每个对象的根上</li>
<li>不影响其它的类实例</li>
<li>role 中的方法总是覆盖对象中已经存在的方法</li>
</ul>
<h2 id="mix-ins-example">Mix-ins Example</h2>
<ul>
<li>假设我们想跟踪某个对象发生了什么</li>
<li>Mix in the DebugLog role</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$acount</span> <span class="k">does</span> <span class="nc">DebugLog</span><span class="p">;</span>
</code></pre></div><ul>
<li>然后, 我们可以输出被登记的行</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$account</span><span class="o">.</span><span class="nf">log_lines</span><span class="o">».</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><ul>
<li>现在我们只需给 <code>log_message</code> 方法添加调用</li>
<li>我们可以使用 <code>.?</code> 操作符, 这会调用某个方法, 如果方法存在的话</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Account</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">change_password</span><span class="p">(</span><span class="nv">$new</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.?</span><span class="nf">log_message</span><span class="p">(</span>
            <span class="p">&#34;</span><span class="s2">changing password to </span><span class="nv">$new</span><span class="p">&#34;;</span>
        <span class="p">)</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="sigil--接口协定">Sigil = 接口协定</h2>
<ul>
<li>在 Raku 中, 符号表明接口协定</li>
<li>这个接口协定由 role 定义</li>
<li>你可以只把东西放在带有符号的变量中, 如果该变量遵守(<code>does</code>)了要求的 role 的话</li>
<li>例外: 带有 <code>$</code> 的变量可以存储任何东西(如果没有使用类型约束的话)</li>
</ul>
<h2 id="--positional">@ = Positional</h2>
<ul>
<li><code>@</code> 符号表明它是一个 <code>Positional</code> role</li>
<li>保证会有一个方法后环缀让你能调用</li>
<li>This is that gets called when you do an index positionally into something</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">@fact</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@fact</span><span class="o">.</span><span class="nf">postcircumfix:</span><span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div><ul>
<li>注意: 优化器(如果有的话)可能发出更轻量级的东西</li>
</ul>
<h2 id="--associative">% = Associative</h2>
<ul>
<li><code>%</code> 表明它是一个关联型(Associative)的 role</li>
<li>要有一个方法后环缀 <code>postcircumfix:&lt;{}&gt;</code> 让你调用</li>
<li>This is that gets called when you do an index associatively into something</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">%price</span><span class="p">&lt;</span><span class="s">Cheese</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">%price</span><span class="o">.</span><span class="nf">postcircumfix:</span><span class="p">&lt;</span><span class="s">{ }</span><span class="p">&gt;(&#39;</span><span class="s1">Cheese</span><span class="p">&#39;);</span>
</code></pre></div><h2 id="--callable">&amp; = Callable</h2>
<ul>
<li><code>&amp;</code> 表明它是一个 Callable 的 role</li>
<li>东西要能被调用</li>
<li>这个 role 被诸如 <code>Block</code>、<code>Sub</code>、<code>Method</code>之类的东西遵守</li>
<li>要求实现后环缀 <code>postcircumfix:&lt;()&gt;</code></li>
</ul>
<p>使用带有 block 的 class 关键字引入一个类：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Puppy</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>或使用</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Puppy</span><span class="p">;</span>
<span class="o">...</span>

<span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>把类相关的东西单独写进一个文件</p>
<h2 id="role-也可以被初始化">Role 也可以被初始化</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">BarChart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.b</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$chart</span> <span class="o">=</span> <span class="n">BarChart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span>,<span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="s">b</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Camelia</span><span class="p">&#34;);</span>

<span class="nb">say</span> <span class="nv">$chart</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$chart</span><span class="o">.</span><span class="nf">bar-values</span><span class="p">;</span>
<span class="nv">$chart</span><span class="o">.</span><span class="nf">b</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Rakudo</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">$chart</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">BarChart</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>
</code></pre></div><p>如果你初始化了 role, 那么它就变为类了。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/role" term="role" label="role" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 S/// 操作符]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>The S Operator in Raku</blockquote><h1 id="raku-s-操作符httpblogsperlorguserszoffix_znet201604perl-6-the-s-operatorhtml"><a href="http://blogs.perl.org/users/zoffix_znet/2016/04/perl-6-the-s-operator.html">Raku: S/// 操作符</a></h1>
<p>By <a href="http://blogs.perl.org/users/zoffix_znet/">Zoffix Znet</a></p>
<p>来自 Perl 5 背景的我, 第一次使用 Raku 的非破坏性替换操作符 <code>S///</code> 的经历就像下面这样:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/326727-3a07abee4665adaf.gif?imageMogr2/auto-orient/strip" alt="img"></p>
<p>进展会更好的。我不但会改善错误信息, 而且会解释当前的所有事情。</p>
<h2 id="智能匹配">智能匹配</h2>
<p>我有问题的原因是因为, 看到外形相似的操作符, 我就简单地把 Perl 5 中的绑定操作符(<code>=~</code>)转换为 Raku 中的智能匹配操作符(<code>~~</code>) 还期望它能正常工作。事实上我是异想天开。<code>S///</code> 操作符没有文档, 并且结合令人困惑的(那个时候)警告信息, 这就是我痛苦的根源：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$orig</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$new</span>  <span class="o">=</span> <span class="nv">$orig</span> <span class="o">~~</span> <span class="k">S</span><span class="p">/</span><span class="sr">me</span><span class="p">/</span><span class="s2">c</span><span class="p">/;</span>
<span class="nb">say</span> <span class="nv">$new</span><span class="p">;</span>

<span class="c1"># OUTPUT warning:</span>
<span class="c1"># Smartmatch with S/// can never succeed</span>
</code></pre></div><p>这个丑陋的警告说这儿的 <code>~~</code> 操作符是个错误的选择并且确实如此。<code>~~</code> 操作符不是 Perl 5 的 <code>=~</code> 操作符的等价物。<code>~~</code> 智能操作符把它左边的东西起了个叫做 <code>$_</code> 的别名, 然后 <code>~~</code> 计算它右侧的东西, 然后在右侧这个东西身上调用 <code>.ACCEPTS($_)</code> 方法。这就是所有的魔法。</p>
<p>所以上面的例子实际上发生了:</p>
<ul>
<li>我们到达 <code>S///</code> 的时候, <code>$orig</code> 被起了个叫做 <code>$_</code> 的别名。</li>
<li><code>S///</code> 非破坏性地在 <code>$_</code> 身上执行了替换并返回那个结果字符串。这是智能匹配将要操作的东西。</li>
<li>智能匹配, 按照 Str 与 Str 相匹配的规则, 会根据替换是否发生来给出 True 或 False（令人困惑的是, True 意味着没发生）</li>
</ul>
<p>结果一路下来, 我们并没有得到我们想要的：替换过的字符串。</p>
<h2 id="使用-given">使用 Given</h2>
<p>既然我们知道了 <code>S///</code> 总是作用在 <code>$_</code> 上并且返回替换后的结果, 很容易就想到几种方法把 <code>$_</code> 设置为我们原来的字符串并把 <code>S///</code> 的返回值收集回来, 我们来看几个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$orig</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$new</span>  <span class="o">=</span> <span class="k">S</span><span class="p">/</span><span class="sr">me</span><span class="p">/</span><span class="s2">c</span><span class="p">/</span> <span class="k">given</span> <span class="nv">$orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$new</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@orig</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">meow cow sow vow</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@new</span>  <span class="o">=</span> <span class="nb">do</span> <span class="k">for</span> <span class="nv">@orig</span> <span class="p">{</span> <span class="k">S</span><span class="p">/</span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">ow</span><span class="p">&#39;&gt;/</span><span class="s2">w</span><span class="p">/</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">@orig</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@new</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># meowmix</span>
<span class="c1"># cowmix</span>
<span class="c1"># [meow cow sow vow]</span>
<span class="c1"># [wow wow wow wow]</span>
</code></pre></div><p>第一个作用在单个值上。我们使用后置形式的 <em>given</em> 块儿, 这让我们避免了花括号（你可以使用 <em>with</em> 代替 <em>given</em> 得到同样的结果）。<code>given $orig</code> 会给 <code>$orig</code> 起个叫做 <code>$_</code> 的别名。从输出来看, 原字符串没有被更改。</p>
<p>第二个例子作用在数组中的一堆字符串身上并且我们使用 <em>do</em> 关键字来执行常规的 <em>for</em> 循环(那种情况下, 它把循环变量别名给 <code>$_</code> 了)并把结果赋值给 <code>@new</code> 数组。再次, 输出显示原来的数组并没有发生改变。</p>
<h2 id="副词">副词</h2>
<p><code>S///</code> 操作符 - 就像 <code>s///</code> 操作符和某些方法一样 - 允许你使用正则表达式副词：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">Lörem Ipsum Dolor Sit Amet</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">g</span>      <span class="p">/</span><span class="sr">m</span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span>  <span class="c1"># Löreg Ipsug Dolor Sit Aget</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">i</span>      <span class="p">/</span><span class="sr">l</span><span class="p">/</span><span class="s2">b</span><span class="p">/;</span>  <span class="c1"># börem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">ii</span>     <span class="p">/</span><span class="sr">l</span><span class="p">/</span><span class="s2">b</span><span class="p">/;</span>  <span class="c1"># Börem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">mm</span>     <span class="p">/</span><span class="sr">o</span><span class="p">/</span><span class="s2">u</span><span class="p">/;</span>  <span class="c1"># Lürem Ipsum Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">/</span><span class="sr">m </span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span> <span class="c1"># Lörem Ipsug Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="p">/</span><span class="sr">m </span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span> <span class="c1"># Löreg Ipsug Dolor Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">ss</span><span class="p">/</span><span class="sr">Ipsum Dolor</span><span class="p">/</span><span class="s2">Gipsum\nColor</span><span class="p">/;</span> <span class="c1"># Lörem Gipsum Color Sit Amet</span>
    <span class="nb">say</span> <span class="k">S</span><span class="p">:</span><span class="na">g</span><span class="p">:</span><span class="na">ii</span><span class="p">:</span><span class="na">nth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">/</span><span class="sr">m</span><span class="p">/</span><span class="s2">g</span><span class="p">/;</span>             <span class="c1"># Lörem Ipsug Dolor Sit Amet</span>
<span class="p">}</span>
</code></pre></div><p>如你所见, 它们以 <em>:foo</em> 的形式添加在操作符 <strong>S</strong> 这个部件的后面。你可以大大方方地使用空白符号并且几个副词可以同时使用。下面是它们的意义：</p>
<ul>
<li>:g —(长形式：<code>:global</code>)全局匹配：替换掉所有的出现</li>
<li>:i —不区分大小写的匹配</li>
<li>:ii —(长形式： <code>:samecase</code>) 保留大小写：不管用作替换字母的大小写, 使用原来被替换的字母的大小写</li>
<li>:mm —(长形式：<code>:samemark</code>) 保留重音符号：在上面的例子中, 字母 o 上的分音符号被保留并被应用到替换字母 u 上</li>
<li>:nth(n) —只替换第 n 次出现的</li>
<li>:x(n) —至多替换 n 次（助记符: &lsquo;x&rsquo; 作为及时）</li>
<li>:ss —(长形式：<code>samespace</code>)保留空白类型：空白字符的类型被保留, 而不管替换字符串中使用的是什么空白字符。在上面的例子中, 我们使用换行作为替换, 但是原来的空白被保留了。</li>
</ul>
<h2 id="方法形式">方法形式</h2>
<p><code>S///</code> 操作符很好, 但是有时候有点笨拙。不要害怕, Raku 提供了 <code>.subst</code> 方法能满足你所有的替换需求并且消除你对 <code>.subst/.substr</code> 的困惑。下面来看例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">me</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">m</span><span class="ni">.</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># cowmix</span>
<span class="c1"># cowmix</span>
</code></pre></div><p>这个方法要么接收一个正则表达式要么接收一个普通的字符串作为它的第一个位置参数, 它是要在调用者里面(&ldquo;meowmix&rdquo;)查找的东西。第二个参数是替换字符串。</p>
<p>通过简单地把它们列为具名 Bool 参数, 你也可以使用副词。在 <code>S///</code> 形式中, 副词 <code>:ss</code> 和 <code>:ii</code> 分别表明 <code>:s</code>(使空白有意义) 的出现和  <code>:i</code>(不区分大小写的匹配) 的出现。在方法形式中, 你必须把这些副词应用到正则表达式自身身上：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="p">&#39;</span><span class="s1">Lorem Ipsum Dolor Sit Amet</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/:</span><span class="na">i</span><span class="sr"> l</span><span class="p">/</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">ii</span><span class="p">;</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/:</span><span class="na">s</span><span class="sr"> Ipsum Dolor</span><span class="p">/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Gipsum\nColor</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">:</span><span class="s">ss</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># Borem Ipsum Dolor Sit Amet</span>
<span class="c1"># Lorem Gipsum Color Sit Amet</span>
</code></pre></div><h2 id="方法形式的捕获">方法形式的捕获</h2>
<p>捕获对于替换操作来说不陌生, 所以我们来尝试捕获下方法调用形式的替换：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">me </span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="nv">$0</span><span class="p">&#34;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># Use of Nil in string context  in block &lt;unit&gt; at test.p6 line 1</span>
<span class="c1"># c</span>
</code></pre></div><p>不是我们要找的。我们的替换字符串构建在达到 <code>.subst</code> 方法之前, 并且里面的 <code>$0</code> 变量实际上指向任何这个方法调用之前的东西, 而不是 <code>.subst</code> 正则表达式中的捕获。所以我们怎么来修正它呢？</p>
<p><code>.subst</code> 方法的第二个参数也可以接受一个 <a href="http://docs.raku.org/type/Callable">Callable</a>。在它里面, 你可以使用 <code>$0, $1, ... $n</code> 变量, 直到你想要的编号, 并从捕获中得到正确的值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">meowmix</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">/</span><span class="sr">me </span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">c</span><span class="nv">$0</span><span class="p">&#34;</span> <span class="p">};</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># cowmix</span>
</code></pre></div><p>这里, 我们为我们的 <strong>Callable</strong> 使用了尖号块儿, 但是 <strong>WhateverCode</strong> 和子例程也有效。每次替换都会调用这个 Callable, 并且把 <a href="http://docs.raku.org/type/Match">Match</a> 对象作为第一个位置参数传递给 Callable, 如果你需要访问它的话。</p>
<h2 id="结论">结论</h2>
<p><code>S///</code> 操作符在 Raku 中是 <code>s///</code> 操作符的战友, 它不是修改原来的字符串, 而是拷贝原来的字符串, 修改, 然后返回修改过的版本。这个操作符的使用方式跟 Perl 5 中的非破坏性替换操作符的使用方式不同。作为备选, 方法版本的 <code>.subst</code> 也能使用。 方法形式和操作符形式的替换都能接收一组副词以修改它们的行为, 来满足你的需求。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 Slip]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-05-19-an-example-of-slip/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-05-19-an-example-of-slip/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>An Example of Slip</blockquote><h2 id="描述">描述</h2>
<p>有 7 块板子放在一个&quot;袋子&quot;中, 随机从袋子中移除一个板子展示到玩家面前直到袋子变空。当袋子变空时, 它会被重新装填, 如果需要额外的板子, 则重复前面那个过程。</p>
<h2 id="输出">输出</h2>
<p>使用随机 bag 系统随机输出 50 块板子。</p>
<p>板子如下:</p>
<ul>
<li>O</li>
<li>I</li>
<li>S</li>
<li>Z</li>
<li>L</li>
<li>J</li>
<li>T</li>
</ul>
<h2 id="输出样本">输出样本</h2>
<ul>
<li><code>LJOZISTTLOSZIJOSTJZILLTZISJOOJSIZLTZISOJTLIOJLTSZO</code></li>
<li><code>OTJZSILILTZJOSOSIZTJLITZOJLSLZISTOJZTSIOJLZOSILJTS</code></li>
<li><code>ITJLZOSILJZSOTTJLOSIZIOLTZSJOLSJZITOZTLJISTLSZOIJO</code></li>
</ul>
<p>在 Raku 中我会这样写 (smls):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="o">|</span><span class="p">&lt;</span><span class="s">O I S Z L J T</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="ow">xx</span> <span class="o">*</span><span class="p">)</span><span class="o">.[^</span><span class="mi">50</span><span class="o">].</span><span class="nb">join</span><span class="p">;</span>
</code></pre></div><p>注意:</p>
<ul>
<li><code>|</code> 操作符把每次迭代的项展开进外部的列表中, 以使你不必在结果上显式地调用 <code>.flat</code> 方法</li>
<li>使用 <code>&lt; &gt;</code> 字符串列表字面量看起来比在字符串字面量上使用 <code>.comb</code> 方法更合适</li>
<li><code>xx</code> 操作符每次都会重新计算它左侧的表达式</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/slip" term="slip" label="slip" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 Smile 类型]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-05-smile-type-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-11-05-smile-type-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Smile Type in Raku</blockquote><p>一个裸的 <strong>:D</strong>、<strong>:U</strong>、<strong>:T</strong> 或 <strong>:_</strong> 是限制默认类型为定义、未定义、类型对象或任何对象的类型约束。所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Con</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">man</span><span class="p">(:</span><span class="s">U</span><span class="o">:</span> <span class="p">:</span><span class="s">D</span> <span class="nv">$x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>其签名等价于 <code>(Con:U: Any:D $x)</code>。</p>
<p><code>Con:U</code> 是调用者, 在调用者后面加上一个冒号。要标记一个显式的调用者, 在它后面放上一个冒号就好了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">doit</span> <span class="p">(</span><span class="nv">$x:</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="nv">$c</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h3 id="abstract-vs-concrete-types">Abstract vs Concrete types</h3>
<p>　
对于任何有名字的类型, 某些其它子集类型可以自动地通过在类型的名字后面追加一个合适的状语来派生出来：</p>
<pre><code>Int:_       允许定义或未定的 Int 值
Int:D       只允许有定义的(强制的)Int 值
Int:U       只允许未定义值(抽象或失败)Int 值
Int:T       允许Int只作为类型对象
</code></pre><p>即, 它们的意思有点像:</p>
<pre><code>Int:D       Int:_ where DEFINITE($_)
Int:U       Int:_ where not(DEFINITE($_))
Int:T       Int:U where none(Failure)
</code></pre><p><code>where DEFINITE</code> 是一个布尔宏, 它说正处理的对象是否有一个合法的强制表示。(查看下面的自省) .</p>
<p>在 Raku 中, <strong>Int</strong> 通常假定意为 <code>Int:_</code>, 除了调用者, 其中默认为 <code>Int:D</code>。（默认的 new 方法有一个原型, 它的调用者是 <code>:T</code>, 所以所有的 new 方法都默认允许类型对象。）</p>
<p>这些默认可以通过各种编译指令在词法作用域中更改。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">parameters</span> <span class="p">:</span><span class="s">D</span><span class="p">;</span>
</code></pre></div><p>会让非调用者的参数默认为 <code>:D</code>。</p>
<p>作为对比,</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">variables</span> <span class="p">:</span><span class="s">D</span><span class="p">;</span>
</code></pre></div><p>会对用于变量声明中的类型做同样的事情。
在这样的词法作用域中, 你可以使用 <code>:_</code> 形式回到标准的行为。特别地, 因为调用者默认为定义的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">invocant</span> <span class="p">:</span><span class="s">_</span><span class="p">;</span>
</code></pre></div><p>会让调用者允许任何类型的有定义的和未定义的调用者。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/smile" term="smile" label="smile" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 twigil]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Twigils in Raku</blockquote><h2 id="raku-中的--和--twigil-是什么">Raku 中的 <code>.</code> 和 <code>!</code> <strong>twigil</strong> 是什么？</h2>
<p><code>.</code> <strong>twigil</strong> 的意思是&quot;这是类公用的&quot;, <code>!</code> <strong>twigil</strong> 的意思是“这是类私有的”, 只能用在类的内部。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">ScoreKeeper</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">@.options</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">%!player-points</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>普通的符号表明了词法作用域或包作用域, 但是 <strong>twigils</strong> 就像是 <strong>sigils</strong> 的兄弟, 表明了不同的作用域, 它影响了变量的作用域。<code>.</code> 和 <code>!</code> 是二级 <strong>sigils</strong>。</p>
<p>属性存在于每个类的实例中, 在类的内部, 可以直接使用 <code>!</code> 访问到实例的属性:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">(</span><span class="nv">$!x</span><span class="s2">, </span><span class="nv">$!y</span><span class="s2">)</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>那么 <code>.</code> <strong>twigil</strong> 和 <code>!</code> <strong>twigil</strong> 之间有什么关系呢？下面看一个例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1"># 注意这次我们使用 . 而非 !</span>
        <span class="p">&#34;</span><span class="s2">\$.x 等价于 self.x()</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>  <span class="k">if</span> <span class="nv">$.x</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span>
        <span class="p">&#34;</span><span class="s2">\$.y 等价于 self.y()</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span>  <span class="k">if</span> <span class="nv">$.y</span> <span class="o">==</span> <span class="nb">self</span><span class="o">.</span><span class="nf">y</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span> <span class="c1"># 调用实例的名为 x 的方法</span>
        <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nf">y</span><span class="p">();</span> <span class="c1"># 调用实例的名为 y 的方法</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$point</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">10</span>, <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="p">);</span>
<span class="nv">$point</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>   
<span class="nv">$point</span><span class="o">.</span><span class="nb">print</span><span class="p">;</span>
</code></pre></div><p>会输出:</p>
<pre><code>$.x 等价于 self.x()
$.y 等价于 self.y()
10
20
</code></pre><p>注意到, 属性被声明为 <code>$.x</code> 和 <code>$.y</code>, 但是在类的内部仍旧能通过 <code>$!x</code> 和 <code>$!y</code> 来访问属性。这是因为在 Raku 中所有的属性都是私有的并且在类中可以通过 <code>$!attribute-name</code> 直接访问这些属性。Raku 可以为你自动生成存取方法。</p>
<p>公共属性拥有 <code>.</code> twigil, 私有属性拥有 <code>!</code> twigil。</p>
<p><code>has $.x</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter</code>方法, 即 <code>method x() { ... }</code>。</p>
<p><code>has $.x is rw</code> 就是私有属性 <code>has $!x</code> 加上一个<code>getter/setter</code>方法。</p>
<h2 id="-twigil-就是调用了与属性同名的方法">. <strong>twigil</strong> 就是调用了与属性同名的方法</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">SaySomething</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>  <span class="p">}</span>
    <span class="k">method</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$.a</span><span class="p">;</span>      <span class="p">}</span>
    <span class="k">method</span> <span class="nf">c</span><span class="p">()</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">a</span><span class="p">();</span> <span class="p">}</span> <span class="c1"># 这证明了 $.a 的 . twigil 做了一次隐式的实例方法调用。</span>
<span class="p">}</span>

<span class="n">SaySomething</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span> <span class="c1"># 打印 &#34;a&#34;</span>
<span class="n">SaySomething</span><span class="o">.</span><span class="nf">c</span><span class="p">;</span> <span class="c1"># 打印 &#34;a&#34;</span>
</code></pre></div><h2 id="-twigil-中自动生成的方法可以被子类重写">. <strong>twigil</strong> 中自动生成的方法可以被子类重写</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="k">is</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!radius</span><span class="p">;</span>

    <span class="c1"># 重写父类中的 x() 方法和 y() 方法</span>
    <span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">I am x point in a Circle</span><span class="p">&#34;;</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">y</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">I am y point in a Circle</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$circle</span> <span class="o">=</span> <span class="n">Circle</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">radius</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="nv">$circle</span><span class="o">.</span><span class="nb">x</span><span class="p">()</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># I am x point in a Circle</span>
<span class="nv">$circle</span><span class="o">.</span><span class="nf">y</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># I am y point in a Circle</span>
</code></pre></div><p>如果不想子类重写父类中的方法, 那么在父类中声明属性的时候, 使用 <code>!</code> <strong>twigil</strong> 替代 <code>.</code> <strong>twigil</strong>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的 unspace]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-09-18-unspace-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-09-18-unspace-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Unspace in Raku</blockquote><h2 id="空格最少化">空格最少化</h2>
<p>在数组或散列的开括号(即下标左边的那个括号)之前不允许有空格, 参数列表的圆开括号前面也是不能有空格的。即:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@deadbeef</span><span class="o">[</span><span class="nv">$x</span><span class="o">]</span>         <span class="c1"># okay</span>
<span class="nv">%monsters</span><span class="p">{&#39;</span><span class="s1">cookie</span><span class="p">&#39;}</span>   <span class="c1"># okay</span>
<span class="nf">saymewant</span><span class="p">(&#39;</span><span class="s1">cookie</span><span class="p">&#39;)</span>   <span class="c1"># okay</span>

<span class="nv">@a</span>       <span class="o">[</span><span class="nv">$b</span><span class="o">]</span>         <span class="c1"># WRONG</span>
<span class="nv">%people</span>  <span class="p">{&#39;</span><span class="s1">john</span><span class="p">&#39;}</span>     <span class="c1"># WRONG</span>
<span class="n">mewant</span>   <span class="p">(&#39;</span><span class="s1">cookie</span><span class="p">&#39;)</span>   <span class="c1"># WRONG</span>
</code></pre></div><p>这种限制的的几个副作用之一就是条件控制结构的周围不再需要圆括号了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$value</span> <span class="ow">eq</span> <span class="nv">$target</span> <span class="p">{</span>
    <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">Bullseye!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">while</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">{</span> <span class="nv">$i</span><span class="o">++</span> <span class="p">}</span>
</code></pre></div><p>然而, 显式的使用 <code>unspace</code> 语法仍然能够让你对齐下标和后缀操作符:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%squirrels</span><span class="p">{&#39;</span><span class="s1">fluffy</span><span class="p">&#39;}</span> <span class="o">=</span> <span class="n">Squirrel</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nv">%monsters</span><span class="o">.</span><span class="p">{&#39;</span><span class="s1">cookie</span><span class="p">&#39;}</span> <span class="o">=</span> <span class="n">Monster</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nv">%beatles</span>\<span class="o">.</span><span class="p">{&#39;</span><span class="s1">ringo</span><span class="p">&#39;}</span>  <span class="o">=</span> <span class="n">Beatle</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nv">%people</span>\ <span class="o">.</span><span class="p">{&#39;</span><span class="s1">john</span><span class="p">&#39;}</span>   <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/unspace" term="unspace" label="unspace" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的元对象]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-07-16-metaobject-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-07-16-metaobject-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Metaobject in Raku</blockquote><h1 id="自省和-raku-的对象系统">自省和 Raku 的对象系统</h1>
<p>Raku 是构建在元对象层上面的。那意味着有些对象(元对象)控制着各种面向对象结构(例如类、roles、方法、属性、枚举…)怎样去表现。</p>
<p>要感受类的元对象, 这儿有一个同样的例子出现2次: 一次一种 Raku中的普通声明, 一次通过元模型来表达:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">A</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span> <span class="c1"># 42</span>
</code></pre></div><p>对应于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">A</span> <span class="o">:=</span> <span class="nb">Metamodel::ClassHOW</span><span class="o">.</span><span class="nb">new_type</span><span class="p">(</span> <span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="p">);</span>  <span class="c1"># class A {</span>
<span class="n">A</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">x</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">my</span> <span class="k">method</span> <span class="nb">x</span><span class="p">(</span><span class="n">A:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="mi">42</span> <span class="p">});</span>             <span class="c1"># method x() .. .</span>
<span class="n">A</span><span class="o">.^</span><span class="nb">compose</span><span class="p">;</span>                                                 <span class="c1"># }</span>

<span class="n">A</span><span class="o">.</span><span class="nb">x</span><span class="p">();</span> <span class="c1"># 42</span>
</code></pre></div><p>(除了声明形式的运行在编译时, 后面这种形式不是)</p>
<p>对象后面的元对象能使用 <code>$obj.HOW</code> 获取, 这儿的 HOW 代表着 <strong>Higher Order Workings</strong>(或者 HOW the <code>*%@$</code> does this work?)。</p>
<p>这儿, 带有 <code>.^</code> 的调用是元对象的调用, 所以 <code>A.^compose</code> 是 <code>A.HOW.compose(A)</code> 的简写。调用者也被传递到参数列表中, 以使它能够支持原型类型风格的类型系统, 那儿只有一个元对象。</p>
<p>就像上面的例子展示的那样, 所有的面向对象特性对使用者都是可获得的, 而不仅仅是编译器。实际上编译器就是使用元对象的这样的调用的。</p>
<h2 id="元对象metaobjects">元对象(MetaObjects)</h2>
<p>这些是内省的宏, 类似于方法调用。</p>
<p>元对象通常以 ALLCAPS(全大写)命名, 并且避免使用你自己的带有全大写名字的方法被认为是一个好的风格。这会避免和可能出现在未来版本中的任何元对象发生冲突。注意, 如果你必须使用带有全大写名字的方法的话, 把你的这个方法名字用引号引起来来间接安全地调用:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">#| </span><span class="sd">THIS IS A CLASS FOR SHOUTING THINGS
</span><span class="sd"></span><span class="k">class</span> <span class="nc">MY-CLASSES-ARE-ALL-CAPS</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nb">WHY</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">I DON&#39;T KNOW</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="n">MY-CLASSES-ARE-ALL-CAPS</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">WHY</span>      <span class="c1"># &#34;THIS IS A CLASS FOR SHOUTING THINGS&#34;? 显示这？你在逗我!</span>
<span class="nb">say</span> <span class="nv">$c</span><span class="o">.</span><span class="p">&#34;</span><span class="s2">WHY</span><span class="p">&#34;()</span>  <span class="c1"># &#34;I DON&#39;T KNOW&#34;</span>
</code></pre></div><h2 id="what">WHAT</h2>
<p>类型的类型对象。例如 <code>42.WHAT</code> 返回 <code>Int</code> 类型对象。</p>
<h2 id="which">WHICH</h2>
<p>对象的同一值。这能用于哈希和同一比较, 并且这是 <code>===</code> 中缀操作符的实现方式。</p>
<pre><code>&gt; &quot;a&quot;.WHICH
Str|a
</code></pre><h2 id="who">WHO</h2>
<p>支持对象的包</p>
<pre><code>&gt; &quot;a&quot;.WHO
Str
</code></pre><h2 id="where">WHERE</h2>
<p>对象的内存地址。注意这在移动的/紧凑的垃圾回收实现中是不稳定的。 在稳定的同一指示器中使用 <code>WHERE</code>。</p>
<h2 id="how">HOW</h2>
<p>元类对象(the metaclass object)：“Higher Order Workings”。</p>
<h2 id="why">WHY</h2>
<p>附加的 Pod 值。</p>
<h2 id="definite">DEFINITE</h2>
<p>对象有一个有效的强制表现。</p>
<p>对于实例返回 <code>True</code>, 对于类型对象返回 <code>False</code>。</p>
<pre><code>&gt; 42.DEFINITE
True
&gt; Int.DEFINITE
False
</code></pre><h2 id="var">VAR</h2>
<p>返回底层的 Scalar 对象, 如果有的话。</p>
<h2 id="元对象系统的结构">元对象系统的结构</h2>
<p>对于每个类型声明符关键字, 例如 <code>class</code>、<code>role</code> 、<code>enum</code>、<code>module</code>、<code>package</code>、<code>grammar</code> 或 <code>subset</code>, 就有一个独立的元类在 <code>Matamodel::</code> 命名空间中。(Rakudo 在 <code>Raku::Metamodel::</code> 命名空间中实现了它们, 然后把 <code>Raku::Metamodel</code> 映射到 <code>Metamodel</code>)。</p>
<p>这些元类(meta classes)中的很多都共享公共的功能。例如 roles、grammars 和 classes(类)都能包括方法和属性, 还能遵守 roles。这个共享的功能是在 roles 中实现的, 它被组合进合适的元类中。例如 <a href="http://doc.raku.org/type/Metamodel::RoleContainer">role Metamodel::RoleContainer</a>实现了类型能处理 roles 和 <code>Metamodel::ClassHOW</code> 的功能, 它是在 <code>class</code> 关键字后面的元类, 遵守了这个 role。</p>
<h2 id="bootstrapping-concernshttpdocrakuorglanguagemop___top"><a href="http://doc.raku.org/language/mop#___top">Bootstrapping concerns</a></h2>
<p>你可能想知道为什么 <code>Metamodel::ClassHOW</code> 可以是一个类, 当按照 <code>Metamodel::ClassHOW</code> 作为一个类被定义时, 或者 roles 负责 role 处理的怎么能是 roles。答案是通过魔法。</p>
<p>开玩笑啦。自举是特别实现的。Rakudo 使用语言的对象系统来实现自举, 它恰好(几乎)就是 Raku 的一个子集: NQP, Not Quite Perl。 NQP 有原始的, class-like 叫做 <code>konwhow</code> 的性质, 它用于自举它自己的类和 roles 实现。<code>konwhow</code> 建立在NQP 提供的虚拟机的原始基础上。</p>
<p>因为元对象是根据低级(low-level)类型引导的, 自省有时能返回低级(low-level)类型而非你期望的那个类型, 例如返回一个 NQP-level 的子例程而非普通的 <code>Routine</code> 对象, 或返回一个引导的属性而非<a href="http://doc.raku.org/type/Attribute">Attribute</a>。</p>
<h2 id="组合和静态推理">组合和静态推理</h2>
<p>在 Raku中, 类型是在解析时被构造的, 所以在开始, 它必须是可变的。然而, 如果所有类型一直是可变的, 那么关于类型的所有推断会在任何类型的修改时变得无效。例如父类的列表因此类型检测的结果能在那个时候改变。</p>
<p>所以为了获得这两个世界中最好的东西, 当类型从可变转为不可变时是好时机。这就叫做组合, 并且对于从句法构成上声明的类型, 它发生在类型声明被完全解析时(所以总是在闭合花括号被解析时)。</p>
<p>如果你通过元对象系统直接创建类型, 你必须要在它们身上调用 <code>.^compose</code>, 在它们变得完全起作用之前。</p>
<p>很多元类也使用组合时来计算一些诸如方法解析顺序这样的属性, 发布一个方法缓存, 和其它清扫任务。在它们被组合之后干预类型有时是可能的, 但通常是造成灾难的因素。 不要那样做。</p>
<h2 id="能力和责任">能力和责任</h2>
<p>元对象协议提供了很多常规 Raku 代码故意限制了的能力, 例如调用类中不信任你的私有方法, 窥探私有属性, 和其它通常不能完成的东西。</p>
<p>常规的 Raku 代码有很多就地的安全检测; 元模型中不是这样，它靠近底层的虚拟机, 违反和虚拟机的约定可以导致所有奇怪的行为, 而在正常代码中, 显而易见的会是 bugs。</p>
<p>所以, 在写元类型的时候要格外小心和思考。</p>
<h2 id="能力便利和陷阱">能力、便利和陷阱</h2>
<p>元对象协议被设计的强大到实现 Raku 的对象系统。这种能力间或花费了便利的代价。</p>
<p>例如, 当你写了 <code>my $x = 42</code> 并在 <code>$x</code>上调用方法时, 大部分方法会在整数 42 上起作用, 而不是在存储 42 的标量容器上。这是 Raku中设立的一块便利。元对象协议中的大部分不能提供自动忽略标量容器的便利性, 因为它们也用于实现那些标量容器。 所以, 如果你写了 <code>my $t = MyType; ... $t.^compose</code>, 那么你正组合那个 <code>$</code> 变量表明的标量, 而不是 <code>MyType</code>。</p>
<p>结果就是你需要很详尽的理解 Raku 的底层以避免陷阱, 当使用 MOP 时, 并且不能期望得到和普通 Raku 代码提供的 &ldquo;do what I mean&rdquo; 的便利。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/meta-object" term="meta-object" label="meta object" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的单行程序]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-08-25-one-liners-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-08-25-one-liners-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>One Liners in Raku</blockquote><h1 id="raku-单行程序httpsgithubcomdnmfarrellraku-one-liners"><a href="https://github.com/dnmfarrell/Raku-One-Liners">Raku 单行程序</a></h1>
<p>这本书在进行之中。我希望你能觉得它有趣，甚至可能有用！如果你想贡献反馈的话，那么很欢迎提问题还有新的或有提升的正则表达式。</p>
<h2 id="作者">作者</h2>
<p>戴维法瑞尔 <a href="PerlTricks.com">PerlTricks.com</a></p>
<h2 id="版本">版本</h2>
<p>版本 0.01</p>
<h2 id="许可">许可</h2>
<p>FreeBSD</p>
<h2 id="贡献者">贡献者</h2>
<ul>
<li>Alexander Moquin</li>
<li>Bruce Gray</li>
<li>Carl Mäsak</li>
<li>David H. Adler</li>
<li>FROGGS</li>
<li>Helmut Wollmersdorfer</li>
<li>japhb</li>
<li>Larry Wall</li>
<li>Matt Oates</li>
<li>Moritz Lenz</li>
<li>Mouq</li>
<li>Salve J Nilsen</li>
<li>Sam S</li>
<li>Skids</li>
<li>timotimo</li>
</ul>
<h2 id="致谢">致谢</h2>
<p>启发于 Peteris Krumins 的 Perl 5 example <a href="http://www.catonmat.net/download/perl1line.txt">文件</a>。他逐字逐句地写了一本关于 Perl 5 单行 的<a href="http://www.nostarch.com/perloneliners">书</a>。</p>
<p><a href="http://webchat.freenode.net/?channels=raku&amp;nick=">irc</a>上有很好地 folks。</p>
<h2 id="内容">内容</h2>
<ol>
<li>介绍</li>
<li>教程</li>
<li>文件间距</li>
<li>行号</li>
<li>计算</li>
<li>创建字符串和创建数组</li>
<li>文本转换和替换</li>
<li>文本分析</li>
<li>选择性的行打印</li>
<li>使用管道转换数据(进行中)</li>
<li>WWW(进行中)</li>
<li>转换到 Windows</li>
</ol>
<h3 id="介绍">介绍</h3>
<p>把 Perl 和其它语言区别开的一件事情是在单行代码中写小程序的能力，即人们所熟知的&quot;单行&quot;。在终端里直接键入一个程序比写一个废弃的脚本往往更快。并且单行程序也很强大；它们是羽翼丰满的程序，能够加载外部库，但是也能集成到终端中。你可以在单行程序中输入或输出数据。</p>
<p>像 Perl 5 一样， Raku支持单行程序。还有就像 Raku 到处清理着 Perl 5 的毒瘤一样，Raku 的单行语法也更好了。它拥有更少的特殊变量和选项因此更容易记忆。这本书提供了很多有用的 Raku 单行例子，从找出文件中得重复行到运行一个 web 服务器，它几乎能做所有事情。尽管 Raku 拥有更少的特殊变量，但是由于它高级的面向对象的语法，Raku 中的大部分单行程序比等价的 Perl 5 单行程序更短。</p>
<p>这本书可以以多种方式阅读。如果你是单行程序的新手，从教程开始。它带领你掌握单行程序的核心概念；不要担心，一旦你理解了它会很容易。如果你精通 Perl，Bash，或 Sed/Awk，你可以立马开始工作。随意跳过和浏览你所感兴趣的东西。如果有些代码你不理解，那么在终端中试试！这个仓库中包含的无处不在的文件是 example.txt，它会在很多单行程序中用到。</p>
<p>使用单行编程仅仅是 Raku 擅长的一个范例。这样的代码小而美，但是同时你正学习的是一种生产力技能，记住你正在学的是一种新的编程语言。检查 <a href="raku.org">raku.org</a> 网站获取官方文档。</p>
<h3 id="教程">教程</h3>
<p>要开始单行程序，所有你要掌握的是 <strong>-e</strong> 选项。这告诉 Perl 把它后面所跟的东西作为一个程序去执行。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say &#34;Hello, World!&#34;</span><span class="p">&#39;</span>
</code></pre></div><p>我们来一步步剖析这段代码。 <code>raku</code> 引用了 Raku 程序， <code>-e</code> 告诉 Raku 去执行，而 <code>'say &quot;Hello, World!&quot;'</code>是要执行的程序。每个程序都必须被包围在单引号中（除了在 Windows 上，查看 <a href="https://github.com/dnmfarrell/Raku-One-Liners#converting-for-windows">转换到 Windows</a>）。要运行单行程序，就把它键入到终端中好了：</p>
<pre><code class="language-ba" data-lang="ba">&gt; raku -e 'say &quot;Hello, World!&quot;'
Hello, World!
</code></pre><p>如果你想加载一个文件，就把文件路径添加到程序代码的后面：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;for (lines) {say $_}&#39;</span> /path/to/file.txt
</code></pre></div><p>这个程序打印出了 <code>path/to/file.txt</code> 的每一行。你可能知道 <code>$_</code> 是默认变量，它在这儿是指正被循环的当前行。<code>lines</code> 是一个列表，当你传递一个文件路径给单行程序的时候会自动为你创建这个列表。现在我们来重写那个单行程序，一步一步。它们都是等价的：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;for (lines) { say $_ }&#39;</span> /path/to/file.txt
raku -e <span class="s1">&#39;for (lines) { $_.say }&#39;</span> /path/to/file.txt
raku -e <span class="s1">&#39;for (lines) { .say }&#39;</span> /path/to/file.txt
raku -e <span class="s1">&#39;.say for (lines)&#39;</span> /path/to/file.txt
raku -e <span class="s1">&#39;.say for lines&#39;</span> /path/to/file.txt
</code></pre></div><p>就像 <code>$_</code> 是默认变量一样，在默认变量身上调用的方法可以省略掉变量引用。它们变成了默认方法。所以 <code>$_.say</code> 变成 <code>.say</code>。回报给写单行程序的人的东西是 - 更少的键入！</p>
<p><code>-n</code> 选项改变了程序的行为：它为文件中的每一行执行一次代码。所以，大写并打印 <code>path/to/file.txt</code> 的每一行你会键入：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.uc.say&#39;</span> /path/to/file.txt
</code></pre></div><p><code>-p</code> 选项就像 <code>-n</code>, 除了它会自动打印 <code>$_</code> 之外。所以大写文件中的所有行的另外一种方法是：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;$_ = .uc&#39;</span> /path/to/file.txt
</code></pre></div><p>或者两个做同样事情的更短的版本：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;.=uc&#39;</span> /path/to/file.txt
raku -pe .<span class="o">=</span>uc   /path/to/file.txt
</code></pre></div><p>在第二个例子中，我们可以完全移除周围的单引号。这种场景很少遇到，但是如果你的单行程序中没有空格并且没有符号或引号，那么你通常可以移除外部的引号。</p>
<p><code>-n</code> 和 <code>-p</code> 选项真的很有用。本书中也有很多使用它们的单行例子。</p>
<p>最后一件你要知道的事情是怎么加载模块。 <code>-M</code> 开关代表着加载模块：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -M URI::Encode -e <span class="s1">&#39;say encode_uri(&#34;example.com/10 ways to crush it with Raku&#34;)&#39;</span>
</code></pre></div><p><code>-M URI::Encode</code> 加载了 <code>URI::Encode</code> 模块，它导入了 <em>encode_uri</em> 子例程。 你可以多次使用 <code>-M</code> 来加载多个模块：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -M URI::Encode -M URI -e <span class="s1">&#39;&lt;your code here&gt;&#39;</span>
</code></pre></div><p>如果你有一个还没有安装的本地模块呢？ 简单， 仅仅传递一个 <code>-I</code> 开关来包含那个目录好了：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -I lib -M URI::Encode -e <span class="s1">&#39;&lt;your code here&gt;&#39;</span>
</code></pre></div><p>现在 Raku 会在 <code>lib</code> 目录中搜索 <code>URI::Encode</code> 模块，和标准的安装位置一样。</p>
<p>要查看 Raku 命令行开关有哪些， 使用 <code>-h</code> 选项查看帮助：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -h
</code></pre></div><p>这打印可获得的不错的统计。</p>
<h3 id="文件间距">文件间距</h3>
<p>Double space a file</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;$_ ~= &#34;\n&#34;&#39;</span> example.txt
</code></pre></div><p>N-space a file (例如. 4倍空白)</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;$_ ~= &#34;\n&#34; x 4&#39;</span> example.txt
</code></pre></div><p>在每一行前面添加一个空行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;say &#34;&#34;&#39;</span> example.txt
</code></pre></div><p>移除所有空行：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">raku</span> <span class="o">-</span><span class="ow">ne</span> <span class="p">&#39;</span><span class="s1">.say if /\S/</span><span class="p">&#39;</span>   <span class="n">example</span><span class="o">.</span><span class="nf">txt</span>
<span class="nb">raku</span> <span class="o">-</span><span class="ow">ne</span> <span class="p">&#39;</span><span class="s1">.say if .chars</span><span class="p">&#39;</span> <span class="n">example</span><span class="o">.</span><span class="nf">txt</span>
</code></pre></div><p>移除所有的连续空白行，只保留一行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;$*ARGFILES.slurp.subst(/\n+/, &#34;\n\n&#34;, :g).say&#39;</span> example.txt
</code></pre></div><h3 id="行号">行号</h3>
<p>给文件中的所有行编号：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say &#34;{++$} $_&#34;&#39;</span> example.txt
raku -ne <span class="s1">&#39;say $*ARGFILES.ins ~ &#34; $_ &#34;&#39;</span> example.txt
</code></pre></div><p>只给文件中得非空行编号：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;$_ = &#34;{++$} $_&#34; if /\S/&#39;</span> example.txt
</code></pre></div><p>给所有行编号但是只打印非空行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;$_ = $*ARGFILES.ins ~ &#34; $_ &#34; if /\S/&#39;</span> example.txt
</code></pre></div><p>打印文件中行数的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say lines.elems&#39;</span> example.txt
raku -e <span class="s1">&#39;say lines.Int&#39;</span>   example.txt
raku -e <span class="s1">&#39;lines.Int.say&#39;</span>   example.txt
</code></pre></div><p>打印出文件中非空行的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;lines.grep(/\S/.elems.say)&#39;</span> example.txt
</code></pre></div><p>打印文件中空行的数量：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;lines.grep(/^\s*$/).elems.say&#39;</span> example.txt
</code></pre></div><h3 id="计算">计算</h3>
<p>检查一个数是否是质数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say &#34;7 is prime&#34; if 7.is-prime&#39;</span>
</code></pre></div><p>打印一行中所有字段的和：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say [+] .split(&#34;\t&#34;)&#39;</span>
</code></pre></div><p>打印所有行的所有字段的和：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say [+] lines.split(&#34;\t&#34;)&#39;</span>
</code></pre></div><p>打乱行中的所有字段：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.split(&#34;\t&#34;).pick(*).join(&#34;\t&#34;).say&#39;</span>
</code></pre></div><p>找出一行中最小的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.split(&#34;\t&#34;).min.say&#39;</span>
</code></pre></div><p>找出所有行的最小的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;lines.split(&#34;\t&#34;).min.say&#39;</span>
</code></pre></div><p>找出一行中最大的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.split(&#34;\t&#34;).max.say&#39;</span>
</code></pre></div><p>找出所有行的最大的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;lines.split(&#34;\t&#34;).max.say&#39;</span>
</code></pre></div><p>找出一行中得数值化最小元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.split(&#34;\t&#34;)».Numeric.min.say&#39;</span>
</code></pre></div><p>找出一行中得数值化最大元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.split(&#34;\t&#34;)».Numeric.max.say&#39;</span>
</code></pre></div><p>使用字段的绝对值替换每个字段：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.split(&#34;\t&#34;).map(*.abs).join(&#34;\t&#34;)&#39;</span>
</code></pre></div><p>找出每行中字符的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.chars.say&#39;</span> example.txt
</code></pre></div><p>找出每行中单词的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.words.elems.say&#39;</span> example.txt
</code></pre></div><p>找出每行中由逗号分隔的元素的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.split(&#34;,&#34;).elems.say&#39;</span> example.txt
</code></pre></div><p>找出所有行的字段（单词）的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say lines.split(&#34;\t&#34;).elems&#39;</span> example.txt  <span class="c1"># fields</span>
raku -e <span class="s1">&#39;say lines.words.elems&#39;</span> example.txt        <span class="c1"># words</span>
</code></pre></div><p>打印匹配某个模式的字段的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say lines.split(&#34;\t&#34;).comb(/pattern/).elems&#39;</span> example.txt <span class="c1"># fields</span>
raku -e <span class="s1">&#39;say lines.words.comb(/pattern/).elems&#39;</span> example.txt       <span class="c1"># words</span>
</code></pre></div><p>打印匹配某个模式的行的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say lines.grep(/in/.elems)&#39;</span> example.txt
</code></pre></div><p>打印数字 PI 到 n 位小数点(例如. 10位)：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say pi.fmt(&#34;%.10f&#34;);&#39;</span>
</code></pre></div><p>打印数字 PI 到 15 位小数点：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say π&#39;</span>
</code></pre></div><p>打印数字 E 到 n 位小数点(例如. 10位)：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say e.fmt(&#34;%.10f&#34;);&#39;</span>
</code></pre></div><p>打印数字 E 到 15 位小数点：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say e&#39;</span>
</code></pre></div><p>打印 UNIX 时间 (seconds since Jan 1, 1970, 00:00:00 UTC)</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say time&#39;</span>
</code></pre></div><p>打印 GMT (格林威治标准时间)和地方计算机时间：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -MDateTime::TimeZone -e <span class="s1">&#39;say to-timezone(&#34;GMT&#34;,DateTime.now)&#39;</span>
raku -e <span class="s1">&#39;say DateTime.now&#39;</span>
</code></pre></div><p>以 H:M:S 格式打印当地计算机时间：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say DateTime.now.map({$_.hour, $_.minute, $_.second.round}).join(&#34;:&#34;)&#39;</span>
</code></pre></div><p>打印昨天的日期：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say DateTime.now.earlier(:1day)&#39;</span>
</code></pre></div><p>打印日期： 14 个月, 9 天，和 7 秒之前</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say DateTime.now.earlier(:14months).earlier(:9days).earlier(:7seconds)&#39;</span>
</code></pre></div><p>在标准输出前加上时间戳（GMT，地方时间）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">tail -f logfile <span class="p">|</span> raku -MDateTime::TimeZone -ne <span class="s1">&#39;say to-timezone(&#34;GMT&#34;,DateTime.now) ~ &#34;\t$_&#34;&#39;</span>
tail -f logfile <span class="p">|</span> raku -ne <span class="s1">&#39;say DateTime.now ~ &#34;\t$_&#34;&#39;</span>
</code></pre></div><p>计算 5 的阶乘：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say [*] 1..5&#39;</span>
</code></pre></div><p>计算最大公约数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say [gcd] @list_of_numbers&#39;</span>
</code></pre></div><p>使用欧几里得算法计算数字 20 和 35 的最大公约数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say (20, 35, *%* ... 0)[*-2]&#39;</span>
</code></pre></div><p>计算 20 和 35 的最小公倍数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say 20 lcm 35&#39;</span>
</code></pre></div><p>使用欧几里得算法: n*m/gcd(n,m) 计算数字 20 和 35 的最小公倍数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say 20 * 35 / (20 gcd 35)&#39;</span>
</code></pre></div><p>生成 10 个 5 到 15（不包括 15）之间的随机数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;.say for (5..^15).roll(10)&#39;</span>
</code></pre></div><p>找出并打印列表的全排列：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say .join for [1..5].permutations&#39;</span>
</code></pre></div><p>生成幂集</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;.say for &lt;1 2 3&gt;.combinations&#39;</span>
</code></pre></div><p>把 IP 地址转换为无符号整数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say :256[&#34;127.0.0.1&#34;.comb(/\d+/)]&#39;</span>
raku -e <span class="s1">&#39;say +&#34;:256[{q/127.0.0.1/.subst(:g,/\./,q/,/)}]&#34;&#39;</span>
raku -e <span class="s1">&#39;say Buf.new(+«&#34;127.0.0.1&#34;.split(&#34;.&#34;)).unpack(&#34;N&#34;)&#39;</span>
</code></pre></div><p>把无符号整数转换为 IP 地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say join &#34;.&#34;, @(pack &#34;N&#34;, 2130706433)&#39;</span>
raku -e <span class="s1">&#39;say join &#34;.&#34;, map { ((2130706433+&gt;(8*$_))+&amp;0xFF) }, (3...0)&#39;</span>
</code></pre></div><h3 id="创建字符串和创建数组">创建字符串和创建数组</h3>
<p>生成并打印字母表：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;.say for &#34;a&#34;..&#34;z&#34;&#39;</span>
</code></pre></div><p>生成并打印所有从 &ldquo;a&rdquo; 到 &ldquo;zz&rdquo; 的字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;.say for &#34;a&#34;..&#34;zz&#34;&#39;</span>
</code></pre></div><p>把整数转换为十六进制：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say 255.base(16)&#39;</span>
raku -e <span class="s1">&#39;say sprintf(&#34;%x&#34;, 255)&#39;</span>
</code></pre></div><p>把整数打印为十六进制转换表：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say sprintf(&#34;%3i =&gt; %2x&#34;, $_, $_) for 0..255&#39;</span>
</code></pre></div><p>把整数编码为百分数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say sprintf(&#34;%%%x&#34;, 255)&#39;</span>
</code></pre></div><p>生成一个随机的 10 个 a-z 字符长度的字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;print roll 10, &#34;a&#34;..&#34;z&#34;&#39;</span>
raku -e <span class="s1">&#39;print roll &#34;a&#34;..&#34;z&#34;: 10&#39;</span>
</code></pre></div><p>生成一个随机的 15 个 ASCII 字符长度的密码：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;print roll 15, &#34;0&#34;..&#34;z&#34;&#39;</span>
raku -e <span class="s1">&#39;print roll &#34;0&#34;..&#34;z&#34;: 15&#39;</span>
</code></pre></div><p>创建一个指定长度的字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;print &#34;a&#34; x 50&#39;</span>
</code></pre></div><p>生成并打印从 1 到 100 数字为偶数的数组：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;(1..100).grep(* %% 2).say&#39;</span>
</code></pre></div><p>找出字符串的长度：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;&#34;storm in a teacup&#34;.chars.say&#39;</span>
</code></pre></div><p>找出数组的元素个数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;my @letters = &#34;a&#34;..&#34;z&#34;; @letters.Int.say&#39;</span>
</code></pre></div><h3 id="文本转换和替换">文本转换和替换</h3>
<p>对文件进行 ROT 13 加密：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;tr/A..Za..z/N..ZA..Mn..za..m/&#39;</span> example.txt
</code></pre></div><p>对字符串进行 Base64 编码：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -MMIME::Base64 -ne <span class="s1">&#39;print MIME::Base64.encode-str($_)&#39;</span> example.txt
</code></pre></div><p>对字符串进行 Base64 解码：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -MMIME::Base64 -ne <span class="s1">&#39;print MIME::Base64.decode-str($_)&#39;</span> base64.txt
</code></pre></div><p>对字符串进行 URL 转义：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -MURI::Encode -le <span class="s1">&#39;say uri_encode($string)&#39;</span>
</code></pre></div><p>URL-unescape a string</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -MURI::Encode -le <span class="s1">&#39;say uri_decode($string)&#39;</span>
</code></pre></div><p>HTML-encode a string</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -MHTML::Entity -e <span class="s1">&#39;print encode-entities($string)&#39;</span>
</code></pre></div><p>HTML-decode a string</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -MHTML::Entity -e <span class="s1">&#39;print decode-entities($string)&#39;</span>
</code></pre></div><p>把所有文本转换为大写：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;.=uc&#39;</span>    example.txt
raku -ne <span class="s1">&#39;say .uc&#39;</span> example.txt
</code></pre></div><p>把所有文本转换为小写：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;.=lc&#39;</span>    example.txt
raku -ne <span class="s1">&#39;say .lc&#39;</span> example.txt
</code></pre></div><p>只把每行的第一个单词转换为大写：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say s/(\w+){}/{$0.uc}/&#39;</span> example.txt
</code></pre></div><p>颠倒字母的大小写：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;tr/a..zA..Z/A..Za..z/&#39;</span>           example.txt
raku -ne <span class="s1">&#39;say tr/a..zA..Z/A..Za..z/.after&#39;</span> example.txt
</code></pre></div><p>对每行进行驼峰式大小写：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say .wordcase&#39;</span> example.txt
</code></pre></div><p>在每行的开头去掉前置空白（空格、tabs）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say .trim-leading&#39;</span> example.txt
</code></pre></div><p>从每行的末尾去掉结尾的空白（空格、tabs）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say .trim-trailing&#39;</span> example.txt
</code></pre></div><p>从每行中去除行首和行尾的空白：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say .trim&#39;</span> example.txt
</code></pre></div><p>把 UNIX 换行符转换为 DOS/Windows 换行符：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;print .subst(/\n/, &#34;\r\n&#34;)&#39;</span> example.txt
</code></pre></div><p>把 DOS/Windows  换行符转换为 UNIX 换行符：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;print .subst(/\r\n/, &#34;\n&#34;)&#39;</span> example.txt
</code></pre></div><p>把每行中所有的 &ldquo;ut&rdquo; 实体用 &ldquo;foo&rdquo; 替换掉：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;s:g/ut/foo/&#39;</span> example.txt
</code></pre></div><p>把包含 &ldquo;lorem&rdquo; 的每行中所有的 &ldquo;ut&rdquo; 实体用 &ldquo;foo&rdquo; 替换掉：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;s:g/ut/foo/ if /Lorem/&#39;</span> example.txt
</code></pre></div><p>把文件转换为 JSON 格式：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -M JSON::Tiny -e <span class="s1">&#39;say to-json(lines)&#39;</span> example.txt
</code></pre></div><p>从文件的每一行中随机挑选 5 个单词：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;say .words.pick(5)&#39;</span> example.txt
</code></pre></div><h3 id="文本分析">文本分析</h3>
<p>Print n-grams of a string</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;my $n=2; say &#34;banana&#34;.comb.rotor($n,$n-1).map({[~] @$_})&#39;</span>

打印唯一的 n-grams

<span class="sb">```</span>bash
raku -e <span class="s1">&#39;my $n=2; say &#34;banana&#34;.comb.rotor($n,$n-1).map({[~] @$_}).Set.sort&#39;</span>
</code></pre></div><p>打印 n-grams 的出现次数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;my $n=2; say &#34;banana&#34;.comb.rotor($n,$n-1).map({[~] @$_}).Bag.sort.join(&#34;\n&#34;)&#39;</span>
</code></pre></div><p>打印单词的出现次数(1-grams)：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say lines[0].words.map({[~] @$_}).Bag.sort.join(&#34;\n&#34;)&#39;</span> example.txt
</code></pre></div><p>基于一组 1-grams 打印 Dice 相似系数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;my $a=&#34;banana&#34;.comb;my $b=&#34;anna&#34;.comb;say ($a (&amp;) $b)/($a.Set + $b.Set)&#39;</span>
</code></pre></div><p>基于 1-grams 打印卡得杰相似系数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;my $a=&#34;banana&#34;.comb;my $b=&#34;anna&#34;.comb;say ($a (&amp;) $b) / ($a (|) $b)&#39;</span>
</code></pre></div><p>基于 1-grams 打印重叠系数：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;my $a=&#34;banana&#34;.comb;my $b=&#34;anna&#34;.comb;say ($a (&amp;) $b)/($a.Set.elems,$b.Set.elems).min&#39;</span>
</code></pre></div><p>基于 1-grams 打印类似的余弦：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;my $a=&#34;banana&#34;.comb;my $b=&#34;anna&#34;.comb;say ($a (&amp;) $b)/($a.Set.elems.sqrt*$b.Set.elems.sqrt)&#39;</span>

<span class="c1"># 上面的命令提示 Seq 已经被消费</span>
raku -e <span class="s1">&#39;my $a=&#34;banana&#34;.comb;my $b=&#34;anna&#34;.comb;say ($a.cache (&amp;) $b.cache)/($a.cache.Set.elems.sqrt*$b.cache.Set.elems.sqrt)&#39;</span>
</code></pre></div><p>创建字符串中字符的索引并打印出来：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say {}.push: %(&#34;banana&#34;.comb.pairs).invert&#39;</span>
</code></pre></div><p>创建一行中单词的所以并打印出来：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;({}.push: %(lines[0].words.pairs).invert).sort.join(&#34;\n&#34;).say&#39;</span> example.txt
</code></pre></div><h3 id="选择性的行打印">选择性的行打印</h3>
<p>打印文件的第一行（模仿 head -1）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.say;exit&#39;</span>      example.txt
raku -e <span class="s1">&#39;lines[0].say&#39;</span>    example.txt
raku -e <span class="s1">&#39;lines.shift.say&#39;</span> example.txt
</code></pre></div><p>打印文件的前 10 行（模仿 head -10）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;exit if ++$ &gt; 10&#39;</span> example.txt
raku -ne <span class="s1">&#39;.say if ++$ &lt; 11&#39;</span> example.txt
</code></pre></div><p>打印文件的最后一行（模仿 tail -1）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;lines.pop.say&#39;</span> example.txt
</code></pre></div><p>打印文件的最后 5 行（模仿 tail -5）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;.say for lines[*-5..*]&#39;</span> example.txt
</code></pre></div><p>只打印包含元音的行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;/&lt;[aeiou]&gt;/ &amp;&amp; .print&#39;</span> example.txt
</code></pre></div><p>打印包含所有元音的行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.say if .comb (&gt;=) &lt;a e i o u&gt;&#39;</span> example.txt
raku -ne <span class="s1">&#39;.say if .comb ⊇ &lt;a e i o u&gt;&#39;</span>    example.txt
</code></pre></div><p>打印字符数大于或等于 80 的行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.print if .chars &gt;= 80&#39;</span> example.txt
raku -ne <span class="s1">&#39;.chars &gt;= 80 &amp;&amp; .print&#39;</span> example.txt
</code></pre></div><p>只打印第二行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.print if ++$ == 2&#39;</span> example.txt
</code></pre></div><p>打印除了第二行的所有行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;next if ++$ == 2&#39;</span> example.txt
</code></pre></div><p>打印第一行到第三行之间的所有行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.print if (1..3).any == ++$&#39;</span> example.txt
</code></pre></div><p>打印两个正则表达式之间（包含匹配那个正则表达式的行）的所有行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.print if /^Lorem/../laborum\.$/&#39;</span> example.txt
</code></pre></div><p>打印最长的行的长度：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say lines.max.chars&#39;</span> example.txt
raku -ne <span class="s1">&#39;state $l=0; $l = .chars if .chars &gt; $l;END { $l.say }&#39;</span> example.txt
</code></pre></div><p>打印长度最长的行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say lines.max&#39;</span> example.txt
raku -e <span class="s1">&#39;my $l=&#34;&#34;; for (lines) {$l = $_ if .chars &gt; $l.chars};END { $l.say }&#39;</span> example.txt
</code></pre></div><p>打印包含数字的所有行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.say if /\d/&#39;</span>             example.txt
raku -e <span class="s1">&#39;.say for lines.grep(/\d/)&#39;</span> example.txt
raku -ne <span class="s1">&#39;/\d/ &amp;&amp; .say&#39;</span>             example.txt
raku -pe <span class="s1">&#39;next if ! $_.match(/\d/)&#39;</span> example.txt
</code></pre></div><p>打印只包含数字的所有行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.say if /^\d+$/&#39;</span>             example.txt
raku -e <span class="s1">&#39;.say for lines.grep(/^\d+$/)&#39;</span> example.txt
raku -ne <span class="s1">&#39;/^\d+$/ &amp;&amp; .say&#39;</span>             example.txt
raku -pe <span class="s1">&#39;next if ! $_.match(/^\d+$/)&#39;</span> example.txt
</code></pre></div><p>打印每个奇数行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.say if ++$ % 2&#39;</span> example.txt
</code></pre></div><p>打印每个偶数行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.say if ! (++$ % 2)&#39;</span> example.txt
</code></pre></div><p>打印所有重复的行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;state %l;.say if ++%l{$_}==2&#39;</span> example.txt
</code></pre></div><p>打印唯一的行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;state %l;.say if ++%l{$_}==1&#39;</span> example.txt
</code></pre></div><p>打印每一行中的第一个字段（单词）（模仿 cut -f 1 -d ' &lsquo;）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.words[0].say&#39;</span> example.txt
</code></pre></div><h3 id="使用管道转换数据">使用管道转换数据</h3>
<p>Raku程序直接集成到了命令行中。你可以使用 <code>|</code> 管道符号从单行程序中输出数据和输入数据到单行程序中。为了 从管道中输入数据， Raku 自动地把 STDIN 设置为 <code>$*IN</code>。就像对文件那样，从管道输入的数据在单行中也能使用 <code>-n</code> 来进行循环迭代。从单行程序中输出数据就使用 print 或 say 好了。</p>
<p>在当前目录中对所有文件进行 JSON 编码：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">ls <span class="p">|</span> raku -M JSON::Tiny -e <span class="s1">&#39;say to-json(lines)&#39;</span>
</code></pre></div><p>打印文件中的大约 5% 的随机样本行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -ne <span class="s1">&#39;.say if 1.rand &lt;= 0.05&#39;</span> /usr/share/dict/words
</code></pre></div><p>颜色转换， 从 HTML 到 RGB</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&#34;#ffff00&#34;</span> <span class="p">|</span> raku -ne <span class="s1">&#39;.comb(/\w\w/).map({:16($_)}).say&#39;</span>
</code></pre></div><p>颜色转换， 从 RGB 到 HTML</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s2">&#34;#ffff00&#34;</span> <span class="p">|</span> raku -ne <span class="s1">&#39;.comb(/\w\w/).map({:16($_)}).say&#39;</span>
</code></pre></div><h3 id="www">WWW</h3>
<p>下载一个页面：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -M HTTP::UserAgent -e <span class="s1">&#39;say HTTP::UserAgent.new.get(&#34;google.com&#34;).content&#39;</span>
</code></pre></div><p>下载一个页面并剥离 HTML：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">wget -O - <span class="s2">&#34;http://raku.org&#34;</span> <span class="p">|</span> raku -ne <span class="s1">&#39;s:g/\&lt;.+?\&gt;//.say&#39;</span>
</code></pre></div><p>下载一个页面并剥离并解码 HTML：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">wget -O - <span class="s2">&#34;http://raku.org&#34;</span> <span class="p">|</span> raku -MHTML::Strip -ne <span class="s1">&#39;strip_html($_).say&#39;</span>
</code></pre></div><p>开启一个简单地 web 服务器：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -M HTTP::Server::Simple -e <span class="s1">&#39;HTTP::Server::Simple.new.run&#39;</span>
</code></pre></div><h3 id="转换到-windows">转换到 Windows</h3>
<p>一旦你知道了里面的门道之后那么在 Windows 上运行单行程序就是小草一碟。单行程序既可以在 cmd.exe 中运行，又可以在 Powershell 中运行。主要的规则是：用双引号替换掉外部的单引号，在单行程序的内部使用插值引用操作符 <code>qq//</code> 来把字符串括起来。对于非插值的引起，你可以使用单引号。我们来看几个例子。</p>
<p>这儿有一个打印时间的单行程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say DateTime.now&#39;</span>
</code></pre></div><p>要在 Windows 上运行，我们仅仅用双引号替换掉单引号好了：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s2">&#34;say DateTime.now&#34;</span>
</code></pre></div><p>这个单行程序给文件中每一行添加了一个换行符，使用了插值字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s1">&#39;$_ ~= &#34;\n&#34;&#39;</span> example.txt
</code></pre></div><p>在 Windows 上这应该写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -pe <span class="s2">&#34;</span><span class="nv">$_</span><span class="s2"> ~= qq/\n/&#34;</span> example.txt
</code></pre></div><p>这种情况下，我们想对换行符进行插值，并且不为该行字面地添加反斜线和字符&quot;n&quot;，所以我们必须使用 qq。但是你通常也可以像这样在单行程序中使用单引号：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s1">&#39;say &#34;Hello, World!&#34;&#39;</span>
</code></pre></div><p>在 Windows 上这应该写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s2">&#34;say &#39;hello, World!&#39;&#34;</span>
</code></pre></div><p>简单地输出重定向工作起来像基于 Unix 系统那样。 这个单行程序使用 <code>&gt;</code> 把 ASCII 字符索引表打印到一个文件中：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">raku -e <span class="s2">&#34;say .chr ~ &#39; &#39; ~ </span><span class="nv">$_</span><span class="s2"> for 0..255&#34;</span> &gt; ascii_codes.txt
</code></pre></div><p>在使用 <code>&gt;</code> 的时候，如果文件不存在就会创建一个。如果文件确实存在，它会被重写。你可能更想追加到文件，使用 <code>&gt;&gt;</code> 代替。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/oneliner" term="oneliner" label="oneliner" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的变量]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-08-25-variables-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-08-25-variables-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Variables in Raku</blockquote><p>变量名以一个叫做魔符 sigil 的特殊字符开头, 后面跟着一个可选的第二个叫做 <code>twigil</code> 的特殊字符, 然后是一个标识符.</p>
<h2 id="sigils">Sigils</h2>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">类型约束</th>
<th style="text-align:center">默认类型</th>
<th style="text-align:center">Flattens</th>
<th style="text-align:center">Assignment</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:left">Mu (no type constraint)</td>
<td style="text-align:center">Any</td>
<td style="text-align:center">No</td>
<td style="text-align:center">item</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:left">Callable</td>
<td style="text-align:center">Callable</td>
<td style="text-align:center">No</td>
<td style="text-align:center">item</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:left">Positional</td>
<td style="text-align:center">Array</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">list</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">Associative</td>
<td style="text-align:center">Hash</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">list</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$square</span> <span class="o">=</span> <span class="mi">9</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@array</span>  <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>   <span class="c1"># Array variable with three elements</span>
<span class="k">my</span> <span class="nv">%hash</span>   <span class="o">=</span> <span class="s">London</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">UK</span><span class="p">&#39;</span>, <span class="s">Berlin</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Germany</span><span class="p">&#39;;</span>
</code></pre></div><p>默认类型可以使用 <code>is</code> 关键字设置。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">FailHash</span> <span class="k">is</span> <span class="nb">Hash</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Bool</span> <span class="nv">$!final</span> <span class="o">=</span> <span class="nb">False</span><span class="p">;</span>

    <span class="k">multi</span> <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span> <span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nb">Str:D</span> \<span class="nb">key</span> <span class="p">){</span>
        <span class="nb">fail</span> <span class="ne">X::OutOfRange</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">what</span><span class="p">(&#34;</span><span class="s2">Hash key</span><span class="p">&#34;)</span><span class="o">,</span> <span class="p">:</span><span class="s">got</span><span class="p">(</span><span class="nb">key</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">range</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="nb">keys</span><span class="p">))</span> <span class="k">if</span> <span class="nv">$!final</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nb">self</span><span class="o">.</span><span class="nb">EXISTS-KEY</span><span class="p">(</span><span class="nb">key</span><span class="p">);</span>
        <span class="nb">callsame</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">finalize</span><span class="p">()</span> <span class="p">{</span>
        <span class="nv">$!final</span> <span class="o">=</span> <span class="nb">True</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">%h</span> <span class="k">is</span> <span class="nc">FailHash</span> <span class="o">=</span> <span class="s">oranges</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">round</span><span class="p">&#34;</span>, <span class="s">bananas</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">bendy</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">oranges</span><span class="p">&gt;;</span>
<span class="c1"># OUTPUT «round␤»</span>
<span class="nv">%h</span><span class="o">.</span><span class="nf">finalize</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%h</span><span class="p">&lt;</span><span class="s">cherry</span><span class="p">&gt;;</span>
<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">}</span>
<span class="c1"># OUTPUT «X::OutOfRange: Hash key out of range. Is: cherry, should be in (oranges bananas)»</span>
</code></pre></div><p>不带符号的变量也是可行的, 查看 <a href="http://doc.raku.org/language/variables#Sigilless_variables">无符号变量</a>.</p>
<h2 id="项和列表赋值">项和列表赋值</h2>
<p>有两种类型的赋值, item 赋值和 list 赋值。两者都使用 = 号操作符。根据 = 号左边的语法来区别 = 是 item 赋值还是 list 赋值。</p>
<p>Item 赋值把等号右侧的值放到左侧的变量(容器)中。</p>
<p>例如, <a href="https://docs.raku.org/type/Array">数组</a>变量(@符号)在列表赋值时清空数组自身, 然后把等号右侧的值都放进数组自身中. 跟 Item 赋值相比, 这意味着等号左侧的变量类型始终是 Array, 不管右侧是什么类型。</p>
<p>赋值类型(item 或 list)取决于当前表达式或声明符看到的第一个上下文:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>            <span class="c1"># item assignment</span>
<span class="nb">say</span> <span class="nv">$foo</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># 5</span>

<span class="k">my</span> <span class="nv">@bar</span> <span class="o">=</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="p">;</span>         <span class="c1"># list assignment</span>
<span class="nb">say</span> <span class="nv">@bar</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>          <span class="c1"># Array</span>
<span class="nb">say</span> <span class="nv">@bar</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># [7, 9]</span>

<span class="p">(</span><span class="k">my</span> <span class="nv">$baz</span><span class="p">)</span> <span class="o">=</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">13</span><span class="p">;</span>     <span class="c1"># list assignment</span>
<span class="nb">say</span> <span class="nv">$baz</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>          <span class="c1"># Parcel</span>
<span class="nb">say</span> <span class="nv">$baz</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># (11, 13)</span>
</code></pre></div><p>因此, 包含在列表赋值中的赋值行为依赖于表达式或包含表达式的声明符。
例如, 如果内部赋值是一个声明符(例如 <code>my</code>), 就使用 item 赋值, 它比逗号和列表赋值的优先级更高:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span><span class="p">;</span>
<span class="nv">@array</span> <span class="o">=</span> <span class="k">my</span> <span class="nv">$num</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>   <span class="c1"># item assignment: uses declarator</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
<span class="nb">say</span> <span class="nv">$num</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                  <span class="c1"># 42 (a Num)</span>
</code></pre></div><p>类似地, 如果内部赋值是一个用于声明符初始化的表达式, 则内部表达式的上下文决定赋值的类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$num</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="nv">$num</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>    <span class="c1"># item assignment: uses expression</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                 <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
<span class="nb">say</span> <span class="nv">$num</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                   <span class="c1"># 42 (a Num)</span>

<span class="k">my</span> <span class="p">(</span> <span class="nv">@foo</span><span class="o">,</span> <span class="nv">$bar</span> <span class="p">);</span>
<span class="nv">@foo</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$bar</span><span class="p">)</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>       <span class="c1"># list assignment: uses parens</span>
<span class="nb">say</span> <span class="nv">@foo</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                   <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
<span class="nb">say</span> <span class="nv">$bar</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                   <span class="c1"># $(42, &#34;str&#34;)  (a Parcel)</span>
</code></pre></div><p>然而, 如果内部赋值既不是声明符又不是表达式, 而是更大的表达式的一部分, 更大的表达式的上下文决定赋值的类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span> <span class="nv">@array</span><span class="o">,</span> <span class="nv">$num</span> <span class="p">);</span>
<span class="nv">@array</span> <span class="o">=</span> <span class="nv">$num</span> <span class="o">=</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">str</span><span class="p">&#34;;</span>    <span class="c1"># list assignment</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>              <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
<span class="nb">say</span> <span class="nv">$num</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>                <span class="c1"># [42, &#34;str&#34;] (an Array)</span>
</code></pre></div><p>这是因为整个表达式是 <code>@array = $num = 42, &quot;str&quot;</code>, 而 <code>$num = 42</code> 不是单独的表达式。</p>
<p>查看<a href="https://docs.raku.org/language/operators">操作符</a>获取关于优先级的更多详情。</p>
<h2 id="无符号变量">无符号变量</h2>
<p>在 Raku 中创建不带符号的变量也是可能的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">\degrees</span> <span class="o">=</span> <span class="no">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">\θ</span>       <span class="o">=</span> <span class="mi">15</span> <span class="o">*</span> <span class="n">degrees</span><span class="p">;</span>
</code></pre></div><p>然而, 这些无符号变量并不创建<a href="https://docs.raku.org/language/containers">容器</a>. 那意味着上面的 <code>degrees</code> 和 <code>θ</code> 实际上直接代表 <code>Nums</code>。 为了说明, 我们定义一个无符号变量后再赋值:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">θ</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1"># Dies with the error &#34;Cannot modify an immutable Num&#34;</span>
</code></pre></div><p>无符号变量不强制上下文, 所以它们可被用于原样地传递某些东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">logged</span><span class="p">(</span><span class="nv">&amp;f</span><span class="o">,</span> <span class="o">|</span><span class="nb">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span><span class="p">(&#39;</span><span class="s1">Calling </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">&amp;f</span><span class="o">.</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> with arguments </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">args</span><span class="o">.</span><span class="nb">perl</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">\result</span> <span class="o">=</span> <span class="nb">f</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="p">);</span>
    <span class="c1">#  ^^^^^^^ not enforcing any context here</span>
    <span class="nb">say</span><span class="p">(</span><span class="nv">&amp;f</span><span class="o">.</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> returned </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">result</span><span class="o">.</span><span class="nb">perl</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">|</span><span class="nb">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="twigils">Twigils</h2>
<p><code>Twigils</code> 影响变量的作用域。请记住 twigils 对基本的魔符插值没有影响，那就是，如果 <code>$a</code> 内插，<code>$^a</code>, <code>$*a</code>, <code>$=a</code>, <code>$?a</code>, <code>$.a</code>, 等等也会内插. 它仅仅取决于 <code>$</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Twigil</th>
<th style="text-align:left">Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">动态的</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:left">属性(类成员)</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">编译时变量</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:left">方法(并非真正的变量)</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:left">匹配对象索引(并非真正的变量)</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:left">自我声明的形式位置参数</td>
</tr>
<tr>
<td style="text-align:center">:</td>
<td style="text-align:left">自我声明的形式命名参数</td>
</tr>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:left">Pod 变量</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:left">子语言</td>
</tr>
</tbody>
</table>
<h2 id="-twigil">* Twigil</h2>
<p>动态变量通过 caller 查找, 不是通过外部作用域。例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$lexical</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">my</span> <span class="vg">$*dynamic1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">my</span> <span class="vg">$*dynamic2</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">say-all</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$lexical</span><span class="s2">, </span><span class="nv">$*dynamic1</span><span class="s2">, </span><span class="nv">$*dynamic2</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="c1"># prints 1, 10, 100</span>
<span class="nf">say-all</span><span class="p">();</span>

<span class="p">{</span>
    <span class="k">my</span> <span class="nv">$lexical</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">my</span> <span class="vg">$*dynamic1</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
    <span class="vg">$*dynamic2</span>    <span class="o">=</span> <span class="mi">101</span><span class="p">;</span> <span class="c1"># 注意,这儿没有使用 my 来声明</span>

    <span class="c1"># prints 1, 11, 101</span>
    <span class="nf">say-all</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1"># prints 1, 10, 101</span>
<span class="nf">say-all</span><span class="p">();</span>
</code></pre></div><p>第一次调用 <code>&amp;say-all</code> 时, 就像你期望的一样, 它打印 &ldquo;1, 10, 100&rdquo;。可是第二次它打印 &ldquo;1, 11, 101&rdquo;。 这是因为 <code>$lexical</code> 不是在调用者的作用域内被查找, 而是在 <code>&amp;say-all</code> 被定义的作用域里被查找的。这两个动态作用域变量在调用者的作用域内被查找, 所以值为 <code>11</code> 和 <code>101</code>。第三次调用 <code>&amp;say-all</code> 后,  <code>$*dynamic1</code> 不再是 11 了。但是 <code>$*dynamic2</code> 仍然是 101。这源于我们在块中声明了一个新的动态变量 <code>$*dynamic1</code> 的事实并且没有像我们对待 <code>$*dynamic2</code> 那样把值赋值给旧的变量。</p>
<p>动态变量与其他变量类型在引用一个未声明的动态变量上不同的是前者不是一个编译时错误，而是运行时 <a href="https://docs.raku.org/type/Failure">failure</a>，这样一个动态变量可以在未定义时使用只要在把它用作任何其它东西的时候检查它是否定义过:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="vg">$*FOO</span> <span class="o">//</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">foo</span><span class="p">;</span> <span class="c1"># -&gt; &#39;foo&#39;</span>

<span class="k">my</span> <span class="vg">$*FOO</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="n">foo</span><span class="p">;</span> <span class="c1"># -&gt; &#39;bar&#39;</span>
</code></pre></div><h2 id="-twigil-1">! Twigil</h2>
<p>属性是变量, 存在于每个类的实例中. 通过 <code>!</code> 符号它们可以从类的里面直接被访问到:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">(</span><span class="nv">$!x</span><span class="s2">, </span><span class="nv">$!y</span><span class="s2">)</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>注意属性是怎样被声明为 <code>$.x</code> 和 <code>$.y</code> 的, 但是仍然能够通过 <code>$!x</code> 和 <code>$!y</code> 访问到属性. 这是因为 在 Raku 中, 所有的属性都是<code>私有的</code>, 并且在类中能使用 <code>$!attribute-name</code> 直接访问这些属性. Raku 能自动为你生成访问方法. 关于对象、类和它们的属性和方法的详情, 请查看<a href="https://docs.raku.org/language/objects">面向对象</a>.</p>
<h2 id="-twigil-2">? Twigil</h2>
<p>编译时&quot;常量&quot;, 可通过 <code>?</code> twigil 访问. 编译器对它们很熟悉, 并且编译后不能被修改. 常用的一个例子如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$?FILE:</span><span class="s2"> </span><span class="nv">$?LINE</span><span class="p">&#34;;</span> <span class="c1"># prints &#34;hello.pl: 23&#34; if this is the 23 line of a</span>
                      <span class="c1"># file named &#34;hello.pl&#34;.</span>
</code></pre></div><p>关于这些特殊变量的列表请查看<a href="https://docs.raku.org/language/variables#Compile-time_variables">编译时变量</a>。</p>
<p>尽管不能在运行时改变它们, 用户可以(重新)定义这种常量.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="nv">$?TABSTOP</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1"># this causes leading tabs in a heredoc or in a POD</span>
                        <span class="c1"># block&#39;s virtual margin to be counted as 4 spaces.</span>
</code></pre></div><h2 id="-twigil-3">. Twigil</h2>
<p><code>.</code> twigil 真的不是用于变量的. 实际上, 看下面的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">(</span><span class="nv">$.x</span><span class="s2">, </span><span class="nv">$.y</span><span class="s2">)</span><span class="p">&#34;</span> <span class="c1"># 注意我们这次使用 . 而不是 !</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>对 <code>self</code>(自身)调用了方法 <code>x</code> 和方法 <code>y</code>, 这是自动为你生成的, 因为在你声明你的属性的时候, 你使用的是 <code>.</code> twigil 。 注意,  子类可能会覆盖那些方法. 如果你不想这个发生, 请使用 <code>$!x</code> 和 <code>$!y</code> 代替。</p>
<p><code>.</code> twigil 只是调用了一个方法也表明下面是可能的</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">SaySomething</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$.a</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">SaySomething</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span> <span class="c1"># prints &#34;a&#34;</span>
</code></pre></div><p>关于对象、类和它们的属性和方法的详情, 请查看<a href="https://docs.raku.org/language/objects">面向对象</a>.</p>
<h2 id="-twigil-4">&lt; Twigil</h2>
<p><code>&lt;</code> twigil 是 <code>$/&lt;...&gt;</code> 的别名, 其中,  <code>$/</code> 是匹配变量。关于匹配变量的更多详情请查看 <a href="https://docs.raku.org/language/variables#The_%24%2F_Variable">$/变量</a>和<a href="https://docs.raku.org/type/Match">类型匹配</a></p>
<h2 id="-twigil-5">^ Twigil</h2>
<p><code>^</code> twigil 为 block 块 或 子例程 声明了一个形式位置参数.  形如 <code>$^variable</code> 的变量是一种占位变量. 它们可用在裸代码块中来声明代码块的形式参数。看下面代码中的块:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="o">^</span><span class="mi">4</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$^seconds</span><span class="s2"> follows </span><span class="nv">$^first</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>它打印出:</p>
<pre><code>1 follows 0
3 follows 2
</code></pre><p>有两个形式参数，就是 <code>$first</code> 和 <code>$second</code>.  注意, 尽管 <code>$^second</code> 在代码中出现的比 <code>$^first</code> 早,  <code>$^first</code> 依然是代码块中的第一个形式参数. 这是因为占位符变量是以 Unicode 顺序排序的。</p>
<p>子例程也能使用占位符变量, 但是只有在子例程没有显式的参数列表时才行. 这对普通的块也适用</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">say-it</span>    <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># valid</span>
<span class="k">sub</span> <span class="nf">say-it</span><span class="p">()</span>  <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># invalid</span>
              <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># valid</span>
<span class="k">-&gt;</span> <span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="o">,</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$^a</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># 非法, 已经有参数列表 $x,$y,$x 了</span>
</code></pre></div><p>占位符变量语法上不能有类型限制. 也注意, 也不能使用单个大写字母的占位符变量, 如 <code>$^A</code></p>
<h2 id="-twigil-6">: Twigil</h2>
<p><code>:</code> twigil 为块或子例程声明了一个形式<strong>命名参数</strong>。使用这种形式声明的变量也是占位符变量的一种类型。因此适用于使用 <code>^</code> twigil 声明的变量的东西在这儿也适用(除了它们不是位置的以外, 因此没有使用 Unicode 顺序排序)。所以这个:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">{</span> <span class="nv">$:add</span> <span class="o">??</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="o">!!</span> <span class="nv">$^a</span> <span class="o">-</span> <span class="nv">$^b</span> <span class="p">}(</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">:!</span><span class="s">add</span>
<span class="c1"># OUTPUT:</span>
<span class="c1"># -1</span>
</code></pre></div><p>查看 <a href="https://docs.raku.org/routine/%5E">^</a>获取关于占位符变量的更多细节。</p>
<h2 id="-twigil-7">= Twigil</h2>
<p><code>=</code> twigil 用于访问 Pod 变量。当前文件中的每个 Pod 块都能通过一个 Pod 对象访问到, 例如 <code>$=data</code>, <code>$=SYNOPSIS</code> 或 <code>=UserBlock</code>, 即：一个和想要的块同名的变量加上一个 <code>=</code> twigil。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">=begin</span><span class="sd"> </span><span class="k">Foo</span><span class="sd">
</span><span class="sd">...
</span><span class="sd"></span><span class="k">=end Foo</span>

<span class="c1">#after that, $=Foo gives you all Foo-Pod-blocks</span>
</code></pre></div><p>您可以通过 <code>$=pod</code>访问 Pod 树，它包含所有作为分级数据结构的Pod结构。</p>
<p>请注意，所有这些 <code>$=someBlockName</code> 都支持位置和关联角色。</p>
<h2 id="-twigil-8">~ Twigil</h2>
<p>注意: Slangs（俚语）在 Rakudo 中还没有被实现。 NYI = Not Yet Implemented。</p>
<p><code>~</code> twigil 是指子语言（称为俚语）。下面是有用的：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:left">说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$~MAIN</td>
<td style="text-align:left">the current main language (e.g. Perl statements)</td>
</tr>
<tr>
<td style="text-align:center">$~Quote</td>
<td style="text-align:left">the current root of quoting language</td>
</tr>
<tr>
<td style="text-align:center">$~Quasi</td>
<td style="text-align:left">the current root of quasiquoting language</td>
</tr>
<tr>
<td style="text-align:center">$~Regex</td>
<td style="text-align:left">the current root of regex language</td>
</tr>
<tr>
<td style="text-align:center">$~Trans</td>
<td style="text-align:left">the current root of transliteration language</td>
</tr>
<tr>
<td style="text-align:center">$~P5Regex</td>
<td style="text-align:left">the current root of the Perl 5 regex language</td>
</tr>
</tbody>
</table>
<p>你在你当前的词法作用域中扩充这些语言。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">MONKEY-TYPING</span><span class="p">;</span>

<span class="k">augment</span> <span class="n">slang</span> <span class="nb">Regex</span> <span class="p">{</span>  <span class="c1"># derive from $~Regex and then modify $~Regex</span>
    <span class="k">token</span> <span class="nf">backslash:std</span>&lt;\Y&gt; <span class="p">{</span><span class="sr"> YY </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div><h2 id="变量声明符和作用域">变量声明符和作用域</h2>
<p>通常, 使用 <code>my</code> 关键字创建一个新的变量就足够了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$amazing-variable</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">World</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="nv">$amazing-variable</span><span class="s2">!</span><span class="p">&#34;;</span> <span class="c1"># Hello World!</span>
</code></pre></div><p>然而, 有很多声明符能在 <a href="https://docs.raku.org/language/variables#Twigils">Twigils</a> 的能力之外改变作用域的细节。</p>
<table>
<thead>
<tr>
<th style="text-align:center">声明符</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">my</td>
<td style="text-align:left">作为词法作用域名字的开头</td>
</tr>
<tr>
<td style="text-align:center">our</td>
<td style="text-align:left">作为包作用域名字的开头</td>
</tr>
<tr>
<td style="text-align:center">has</td>
<td style="text-align:left">作为属性名的开头</td>
</tr>
<tr>
<td style="text-align:center">anon</td>
<td style="text-align:left">作为私有名字的开头</td>
</tr>
<tr>
<td style="text-align:center">state</td>
<td style="text-align:left">作为词法作用域但是持久名字的开头</td>
</tr>
<tr>
<td style="text-align:center">augment</td>
<td style="text-align:left">给已存在的名字添加定义</td>
</tr>
<tr>
<td style="text-align:center">supersede</td>
<td style="text-align:left">替换已存在名字的定义</td>
</tr>
</tbody>
</table>
<p>还有两个类似于声明符的前缀, 但是作用于预定义变量:</p>
<table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">temp</td>
<td style="text-align:left">在作用域的最后恢复变量的值</td>
</tr>
<tr>
<td style="text-align:center">let</td>
<td style="text-align:left">如果 block 成功退出就恢复变量的值</td>
</tr>
</tbody>
</table>
<h3 id="my-声明符">my 声明符</h3>
<p>使用 <code>my</code> 声明一个变量给变量一个词法作用域. 这意味着变量只在当前块中存在.例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$foo</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;;</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span> <span class="c1"># -&gt; &#34;bar&#34;</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span> <span class="c1"># !!! &#34;Variable &#39;$foo&#39; is not declared&#34;</span>
</code></pre></div><p>它抛出异常,因为只要我们在同一个作用域内 <code>$foo</code> 才被定义. 此外, 词法作用域意味着变量能在新的作用域内被临时地重新定义:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$location</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">outside</span><span class="p">&#34;;</span>

<span class="k">sub</span> <span class="nf">outer-location</span> <span class="p">{</span>
    <span class="c1"># Not redefined:</span>
    <span class="nb">say</span> <span class="nv">$location</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">outer-location</span><span class="p">;</span> <span class="c1"># -&gt; &#34;outside&#34;</span>

<span class="k">sub</span> <span class="nf">in-building</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$location</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">inside</span><span class="p">&#34;;</span>
    <span class="nb">say</span> <span class="nv">$location</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">in-building</span><span class="p">;</span>    <span class="c1"># -&gt; &#34;inside&#34;</span>
<span class="n">outer-location</span><span class="p">;</span> <span class="c1"># -&gt; &#34;outside&#34;</span>
</code></pre></div><p>如果变量被重新定义了, 任何引用外部变量的代码会继续引用外部变量.
所以, 在这儿, <code>&amp;outer-location</code> 仍然打印外部的 <code>$location</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">new-location</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$location</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">nowhere</span><span class="p">&#34;</span>
    <span class="n">outer-location</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">new-location</span><span class="p">;</span> <span class="c1"># -&gt; &#34;outside&#34;</span>
</code></pre></div><p>为了让 <code>new-location()</code> 能打印 <code>nowwhere</code>, 需要使用 <code>*</code> <a href="https://docs.raku.org/language/variables#The_%2A_Twigil">twigil</a> 让 <code>$location</code> 变为动态变量.
对于子例程来说, <code>my</code> 是默认作用域, 所以 <code>my sub x( ) { }</code> 和 <code>sub x( ) { }</code> 是一样的.</p>
<h3 id="our-声明符">our 声明符</h3>
<p>our 跟 <code>my</code> 的作用类似, 除了把别名引入到符号表之外:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">module</span> <span class="nn">M</span> <span class="p">{</span>
    <span class="k">our</span> <span class="nv">$Var</span><span class="p">;</span>
    <span class="c1"># $Var available here</span>
<span class="p">}</span>

<span class="c1"># Available as $M::Var here.</span>
</code></pre></div><h3 id="声明一组变量">声明一组变量</h3>
<p>声明符 <code>my</code> 和 <code>our</code> 接收一组扩在圆括号中的变量作为参数来一次性声明多个变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">@a</span><span class="o">,</span> <span class="nv">$s</span><span class="o">,</span> <span class="nv">%h</span><span class="p">);</span>
</code></pre></div><p>这可以和解构赋值结合使用。任何对这样一个列表的赋值会取得左侧列表中提供的元素数量并且从右侧列表中把对应的值赋值给它们。没有得到赋值的元素会根据变量的类型得到一个未定义值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nb">Str</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$b</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="o">[</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="nv">$c</span><span class="o">].</span><span class="nb">perl</span><span class="p">;</span>
<span class="c1"># OUTPUT«[&#34;a&#34;, &#34;b&#34;, Int]␤»</span>
</code></pre></div><p>要把列表解构到一个单个的值中, 通过使用 <code>($var,)</code> 创建一个带有一个值的列表字面值。当使用了一个变量声明符时只在单个变量周围提供一个圆括号就足够了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span> <span class="p">{</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span> <span class="p">};</span>
<span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="o">=</span> <span class="nb">f</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
<span class="c1"># OUTPUT«1␤»</span>
</code></pre></div><p>要跳过列表中的元素, 使用匿名状态变量 <code>$</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$</span><span class="o">,</span><span class="nv">$a</span><span class="o">,</span><span class="nv">$</span><span class="o">,</span><span class="nv">%h</span><span class="p">)</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">],</span> <span class="p">{:</span><span class="s">1th</span><span class="p">});</span>
<span class="nb">say</span> <span class="o">[</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">%h</span><span class="o">].</span><span class="nb">perl</span><span class="p">;</span>
<span class="c1"># OUTPUT«[&#34;b&#34;, {:th(1)}]␤»</span>
</code></pre></div><h3 id="has-声明符">has 声明符</h3>
<p><code>has</code> 作用在类的实例或 role 的属性上, 还有类或 roles 的方法上。has 隐式作用于方法上, 所以 <code>has method x() {}</code> 和 <code>method x() {}</code> 做得是相同的事情。</p>
<p>查看<a href="https://docs.raku.org/language/objects">面向对象</a>获取更多文档和例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">has</span> <span class="k">method</span> <span class="nb">x</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">x</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><h3 id="anon-声明符">anon 声明符</h3>
<p><code>anon</code> 声明符阻止符号本安装在词法作用域内, 还有方法表中, 和其它任何地方.
例如, 你可以使用 <code>anon</code> 声明一个知道自己名字的子例程, 但是仍然不会被安装到作用域内:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%operations</span> <span class="o">=</span>
    <span class="s">half</span>   <span class="o">=&gt;</span> <span class="k">anon</span> <span class="k">sub</span> <span class="nf">half</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span>   <span class="p">{</span> <span class="nv">$x</span> <span class="o">/</span> <span class="mi">2</span>  <span class="p">}</span>,
    <span class="s">square</span> <span class="o">=&gt;</span> <span class="k">anon</span> <span class="k">sub</span> <span class="nf">square</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">*</span> <span class="nv">$x</span> <span class="p">}</span>,
    <span class="p">;</span>
<span class="nb">say</span> <span class="nv">%operations</span><span class="p">&lt;</span><span class="s">square</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>       <span class="c1"># square</span>
<span class="nb">say</span> <span class="nv">%operations</span><span class="p">&lt;</span><span class="s">square</span><span class="p">&gt;(</span><span class="mi">8</span><span class="p">);</span>         <span class="c1"># 64</span>
</code></pre></div><h3 id="state-声明符">state 声明符</h3>
<p><code>state</code> 声明词法作用域变量, 就像 my 那样。然而, <strong>初始化只发生一次</strong>, 就在正常执行流中第一次遇见初始化的时候。因此, state 变量会在闭合块或 程序的多次执行<strong>之间</strong>保留它们的值。</p>
<p>因此, 下面这个子例程:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span>
    <span class="k">state</span> <span class="nv">@x</span><span class="p">;</span>
    <span class="k">state</span> <span class="nv">$l</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;;</span>
    <span class="nv">@x</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$l</span><span class="o">++</span><span class="p">);</span>
<span class="p">};</span>

<span class="nb">say</span> <span class="n">a</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">6</span><span class="p">;</span>
</code></pre></div><p>会持续增加 <code>$l</code> 并在每次被调用时把它追加到 <code>@x</code> 中, 所以它会打印出:</p>
<pre><code>[A]
[A B]
[A B C]
[A B C D]
[A B C D E]
[A B C D E F]
</code></pre><p>This works per &ldquo;clone&rdquo; of the containing code object, as in this example:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">({</span> <span class="k">state</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span> <span class="ow">xx</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="nv">$_</span><span class="p">()</span><span class="o">,</span> <span class="nv">$_</span><span class="p">()};</span> <span class="c1"># says 1 then 2 thrice</span>
</code></pre></div><p>注意，这不是一个线程安全的解构, 当同一个 block 的同一个克隆运行在多个线程中时。要知道方法只有每个类一个克隆，而不是每个对象。</p>
<p>至于 <code>my</code>，声明多个状态变量必须放置在圆括号中, 而声明一个单一变量，圆括号可以省略。</p>
<p>请注意，许多操作符都伴随着隐式绑定，什么会导致超距作用。使用 <code>.clone</code> 或强迫创建一个可以绑定的新容器。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span><span class="p">;</span>
<span class="k">sub</span> <span class="nb">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">state</span> <span class="nv">$i</span><span class="p">;</span>
    <span class="nv">$i</span><span class="o">++</span><span class="p">;</span>
    <span class="nv">@a</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">k</span><span class="nv">$i</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="nv">$i</span> <span class="c1"># &lt;-- .clone goes here</span>
<span class="p">};</span>
<span class="nb">f</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">;</span>
<span class="n">dd</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># «Array $var = $[:k1(3), :k2(3), :k3(3)]»</span>
</code></pre></div><p>所有的状态变量都是线程间共享的。这个结果可能是你不希望得到的或危险的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">code</span><span class="p">(){</span> <span class="k">state</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">say</span> <span class="o">++</span><span class="nv">$i</span><span class="p">;</span> <span class="nv">$i</span> <span class="p">};</span>
<span class="nb">await</span>
    <span class="k">start</span> <span class="p">{</span> <span class="k">loop</span> <span class="p">{</span> <span class="nb">last</span> <span class="k">if</span> <span class="nb">code</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">}</span><span class="o">,</span>
    <span class="k">start</span> <span class="p">{</span> <span class="k">loop</span> <span class="p">{</span> <span class="nb">last</span> <span class="k">if</span> <span class="nb">code</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">};</span>

<span class="c1"># OUTPUT«1␤2␤3␤4␤4␤3␤5␤»</span>
<span class="c1"># OUTPUT«2␤1␤3␤4␤5␤»</span>
<span class="c1"># many other more or less odd variations can be produced</span>
</code></pre></div><h3 id="-变量">$ 变量</h3>
<p>和显式地声明命名状态变量一样, <code>$</code> 能够用作不带显式状态声明的匿名状态变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1-a 2-b 3-c</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span><span class="o">,</span> <span class="p">{&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span><span class="p">});</span>
<span class="c1"># OUTPUT«one-a two-b three-c␤»</span>
</code></pre></div><p>更进一步, 状态变量不需要存在于子例程中。你可以, 举个例子, 在单行程序中使用 <code>$</code> 在文件中编号行号。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">raku</span> <span class="o">-</span><span class="ow">ne</span> <span class="p">&#39;</span><span class="s1">say ++$ ~ &#34; $_&#34;</span><span class="p">&#39;</span> <span class="n">example</span><span class="o">.</span><span class="nf">txt</span>
</code></pre></div><p>实际上词法范围内每个对 <code>$</code> 的引用都是是一个<strong>单独的</strong>变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">{ say ++$; say $++  } for ^5</span><span class="p">&#39;</span>
<span class="c1"># OUTPUT«1␤0␤2␤1␤3␤2␤4␤3␤5␤4␤»</span>
</code></pre></div><p>如果在作用域内你需要多次引用 <code>$</code> 的值, 那么它应该被拷贝到一个新的变量中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">given</span> <span class="o">++</span><span class="nv">$</span> <span class="p">{</span>
        <span class="k">when</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">one</span><span class="p">&#34;;</span>
        <span class="p">}</span>
        <span class="k">when</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">two</span><span class="p">&#34;;</span>
        <span class="p">}</span>
        <span class="k">when</span> <span class="mi">3</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">three</span><span class="p">&#34;;</span>
        <span class="p">}</span>
        <span class="k">default</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">many</span><span class="p">&#34;;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">()</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>
<span class="c1"># OUTPUT«one␤two␤three␤»</span>
</code></pre></div><h3 id="-变量-1">@ 变量</h3>
<p>和 <code>$</code> 变量类似, 也有一个位置匿名状态变量 <code>@</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">@</span><span class="p">)</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># [0]</span>
<span class="c1"># [0 1]</span>
<span class="c1"># [0 1 2]</span>
</code></pre></div><p>这里的 <code>@</code> 是用圆括号括起来了以和名为 <code>@.push</code> 的类成员变量消除歧义。索引访问并不需要这种歧义，但你需要拷贝这个值，以便用它做任何有用的事情。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span> <span class="nv">@</span><span class="p">;</span>
    <span class="nv">$v</span><span class="o">[</span><span class="nv">$x</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
    <span class="nb">say</span> <span class="nv">$v</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># [0]</span>
<span class="c1"># [0 1]</span>
<span class="c1"># [0 1 2]</span>
</code></pre></div><p>就和 <code>$</code> 一样, 作用域中的每次提及 <code>@</code> 就引入了一个新的匿名数组。</p>
<h3 id="-变量-2">% 变量</h3>
<p>最后, 还有一个关联匿名状态变量 <code>%</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">%</span><span class="p">)</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">$x</span> <span class="o">=&gt;</span> <span class="nv">$x</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 0 =&gt; 0</span>
<span class="c1"># 0 =&gt; 0, 1 =&gt; 1</span>
<span class="c1"># 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 2</span>
</code></pre></div><p>关于歧义的同样警告适用。正如你可能期望，索引访问也有可能（使用复制以使之有用）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span> <span class="nv">%</span><span class="p">;</span>
    <span class="nv">$v</span><span class="p">{</span><span class="nv">$x</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
    <span class="nb">say</span> <span class="nv">$v</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="o">^</span><span class="mi">3</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 0 =&gt; 0</span>
<span class="c1"># 0 =&gt; 0, 1 =&gt; 1</span>
<span class="c1"># 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 2</span>
</code></pre></div><p>就像其它的匿名状态变量一样, 在给定作用域中每次提及 <code>%</code> 最终都会引入一个单独的变量。</p>
<h3 id="augment-声明符">augment 声明符</h3>
<p>使用 <code>augment</code>, 你可以给已经存在的类或 grammars 增加属性和方法.</p>
<p>因为类通常使用 our 作用域, 因此是全局的, 这意味着修改全局状态, 这是强烈不鼓励的, 对于大部分情况, 有更好的方法.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># don&#39;t do this</span>
<span class="k">use</span> <span class="nb">MONKEY-TYPING</span><span class="p">;</span>

<span class="k">augment</span> <span class="k">class</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">is-answer</span> <span class="p">{</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">42</span> <span class="p">}</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="mi">42</span><span class="o">.</span><span class="nf">is-answer</span><span class="p">;</span>       <span class="c1"># True</span>
</code></pre></div><h3 id="temp-前缀">temp 前缀</h3>
<p>像 my 一样, temp 在作用域的末尾恢复旧的变量值. 然而, temp 不创建新的变量.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># temp will &#34;entangle&#34; the global variable with the call stack</span>
            <span class="c1"># that keeps the calls at the bottom in order.</span>

<span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="o">*</span><span class="nv">@c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">temp</span> <span class="nv">$in</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
     <span class="p">&#34;</span><span class="s2">&lt;f&gt;\n</span><span class="p">&#34;</span>
     <span class="o">~</span> <span class="nv">@c</span><span class="o">&gt;&gt;.</span><span class="nb">indent</span><span class="p">(</span><span class="nv">$in</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span>
     <span class="o">~</span> <span class="p">(</span><span class="o">+</span><span class="nv">@c</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;&#34;)</span>
     <span class="o">~</span> <span class="p">&#39;</span><span class="s1">&lt;/f&gt;</span><span class="p">&#39;</span>
<span class="p">};</span>

<span class="k">sub</span> <span class="nf">g</span><span class="p">(</span><span class="o">*</span><span class="nv">@c</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="k">temp</span> <span class="nv">$in</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
    <span class="p">&#34;</span><span class="s2">&lt;g&gt;\n</span><span class="p">&#34;</span>
    <span class="o">~</span> <span class="nv">@c</span><span class="o">&gt;&gt;.</span><span class="nb">indent</span><span class="p">(</span><span class="nv">$in</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span>
    <span class="o">~</span> <span class="p">(</span><span class="o">+</span><span class="nv">@c</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;&#34;)</span>
    <span class="o">~</span> <span class="p">&#34;</span><span class="s2">&lt;/g&gt;</span><span class="p">&#34;</span>
<span class="p">};</span>

<span class="nb">print</span> <span class="nf">g</span><span class="p">(</span><span class="nf">g</span><span class="p">(</span><span class="nb">f</span><span class="p">(</span><span class="nf">g</span><span class="p">())</span><span class="o">,</span> <span class="nf">g</span><span class="p">()</span><span class="o">,</span> <span class="nb">f</span><span class="p">()));</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># &lt;g&gt;</span>
<span class="c1">#  &lt;g&gt;</span>
<span class="c1">#   &lt;f&gt;</span>
<span class="c1">#    &lt;g&gt;</span>
<span class="c1">#    &lt;/g&gt;</span>
<span class="c1">#   &lt;/f&gt;</span>
<span class="c1">#   &lt;g&gt;</span>
<span class="c1">#   &lt;/g&gt;</span>
<span class="c1">#   &lt;f&gt;</span>
<span class="c1">#   &lt;/f&gt;</span>
<span class="c1">#  &lt;/g&gt;</span>
<span class="c1"># &lt;/g&gt;</span>
</code></pre></div><h3 id="let-前缀">let 前缀</h3>
<p>跟 temp 类似, 如果 block 没有成功退出则恢复之前的值。成功的退出意味着该 block 返回了一个定义过的值或一个列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

<span class="p">{</span>
    <span class="k">let</span> <span class="nv">$answer</span> <span class="o">=</span> <span class="mi">84</span><span class="p">;</span>
    <span class="nb">die</span> <span class="k">if</span> <span class="nb">not</span> <span class="nb">Bool</span><span class="o">.</span><span class="nb">pick</span><span class="p">;</span>
    <span class="k">CATCH</span> <span class="p">{</span>
        <span class="k">default</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">it&#39;s been reset :(</span><span class="p">&#34;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we made it 84 sticks!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$answer</span><span class="p">;</span>
</code></pre></div><p>在上面的例子中, 如果 <code>Bool.pick</code> 返回 true, 那么答案会保持为 84, 因为那个 block 返回了一个定义了的值(say 返回 true)。
否则那个 <code>die</code> 语句会让那个 block 不成功地退出, 把答案重新设置为 42。</p>
<h2 id="类型约束和初始化">类型约束和初始化</h2>
<p>变量可以有类型约束, 约束在声明符和变量名之间:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="nv">$x</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a string</span><span class="p">&#39;;</span> <span class="c1"># throws an X::TypeCheck::Assignment error</span>
<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">: </span><span class="p">&#39;</span><span class="o">,</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">}</span>
<span class="c1"># OUTPUT: X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str (&#34;a string&#34;)</span>
</code></pre></div><p>如果一个标量有类型约束但是没有初始值, 它会使用类型约束的类型对象来初始化.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$x</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>    <span class="c1"># Int</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>  <span class="c1"># False</span>
</code></pre></div><p>没有显式类型约束的标量的类型为 Mu, 但是默认会是 Any 类型的对象.</p>
<p>带有 @ 符号的变量会被初始化为空的数组; 带有 % 符号的变量会被初始化为空的散列.</p>
<p>变量的默认值可以使用 <code>is default</code> 特性设置, 通过把 Nil 赋值给变量来重新应用默认值:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Real</span> <span class="nv">$product</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$product</span><span class="p">;</span>                       <span class="c1"># 1</span>
<span class="nv">$produce</span> <span class="o">*=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$product</span><span class="p">;</span>                       <span class="c1"># 5</span>
<span class="nv">$product</span> <span class="o">=</span> <span class="nb">Nil</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$product</span><span class="p">;</span>                       <span class="c1"># 1</span>
</code></pre></div><h2 id="默认的有定义的变量指令">默认的有定义的变量指令</h2>
<p>为了强制所有的变量拥有一个有定义的约束, 使用 <code>use variables :D</code> 指令。这个指令是词法作用域的并且可以使用 <code>use variables :_</code> 指令进行切换。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">variables</span> <span class="p">:</span><span class="s">D</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">$i</span><span class="p">;</span>
<span class="c1"># OUTPUT«===SORRY!=== Error while compiling &lt;tmp&gt;␤Variable definition of type Int:D (implicit :D by pragma) requires an initializer ...</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># that works</span>
<span class="p">{</span> <span class="k">use</span> <span class="nb">variables</span> <span class="p">:</span><span class="s">_</span><span class="p">;</span> <span class="k">my</span> <span class="nb">Int</span> <span class="nv">$i</span><span class="p">;</span> <span class="p">}</span> <span class="c1"># 在这个 block 中关掉它</span>
</code></pre></div><p>请注意, 赋值 Nil 会把这个变量恢复为它的默认值。一个有定义的约束类型的默认值是类型名加上 <code>:D</code>(例如 <code>Int:D</code>)。That means a definedness contraint is no guarantee of definedness. 这只适用于变量初始化, 不适用于签名。</p>
<h2 id="特殊变量">特殊变量</h2>
<p><strong>Pre-defined lexical variables</strong></p>
<p>每个代码块中都有3个特别的变量:</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$_</td>
<td style="text-align:left">特殊变量</td>
</tr>
<tr>
<td style="text-align:center">$/</td>
<td style="text-align:left">正则匹配</td>
</tr>
<tr>
<td style="text-align:center">$!</td>
<td style="text-align:left">异常</td>
</tr>
</tbody>
</table>
<h3 id="_">$_</h3>
<p><code>$_</code> 是特殊变量，在没有显式标识的代码块中，它是默认参数。所以诸如 <code>for @array { ... }</code> 和 <code>given $var { ... }</code> 之类的结构会将变量绑定给 <code>$_</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">{</span> <span class="nb">say</span> <span class="nv">$_</span> <span class="p">}</span>  <span class="c1"># sets $_ to &#39;a&#39;, &#39;b&#39; and &#39;c&#39; in turn</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>     <span class="c1"># same, even though it&#39;s not a block</span>
<span class="k">given</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span>   <span class="p">{</span> <span class="nb">say</span> <span class="nv">$_</span> <span class="p">}</span>  <span class="c1"># sets $_ to &#39;a&#39;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">given</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>       <span class="c1"># same, 尽管这不是一个块</span>
</code></pre></div><p>CATCH 块将 <code>$_</code> 设置为捕获到的异常。 <code>~~</code> 智能匹配操作符。
对 <code>$_</code> 调用一个方法可以省略特殊变量 <code>$_</code> 的名字，从而写的更短：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                   <span class="c1"># 与 $_.say 相同</span>
</code></pre></div><p><code>m/regex/</code> 和 <code>/regex/</code> 正则匹配 和 <code>s/regex/subst/</code> 替换是作用于 <code>$_</code> 上的.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Looking for strings with non-alphabetic characters...</span><span class="p">&#34;;</span>

<span class="k">for</span> <span class="p">&lt;</span><span class="s">ab:c d$e fgh ij*</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="k">m</span><span class="p">/&lt;</span><span class="o">!</span><span class="nb">alpha</span><span class="p">&gt;/;</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Looking</span> <span class="k">for</span> <span class="n">strings</span> <span class="k">with</span> <span class="n">non-alphabetic</span> <span class="n">characters</span><span class="o">...</span>
<span class="n">ab:c</span>
<span class="nb">d</span><span class="nv">$e</span>
<span class="n">ij</span><span class="o">*</span>
</code></pre></div><h3 id="heading">$/</h3>
<p><code>$/</code> 是匹配变量。它存储着最近一次<a href="https://docs.raku.org/language/regexes">正则</a>匹配的结果，通常包含 <a href="https://docs.raku.org/type/Match">Match</a> 类型的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#39;</span><span class="s1">abc 12</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\w</span><span class="o">+</span><span class="p">/;</span>  <span class="c1"># 设置 $/ 为一个Match 对象</span>
<span class="nb">say</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">Str</span><span class="p">;</span>         <span class="c1"># abc</span>
</code></pre></div><p><code>Grammar.parse</code> 方法会把调用者的 <code>$/</code> 设置为 <code>Match object</code> 的结果。看下面的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">XML::Grammar</span><span class="p">;</span> <span class="c1"># panda install XML</span>
<span class="n">XML</span><span class="o">.</span><span class="nb">Grammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#34;</span><span class="s2">&lt;p&gt;some text&lt;/p&gt;</span><span class="p">&#34;);</span>
<span class="nb">say</span> <span class="nv">$/</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># ｢&lt;p&gt;some text&lt;/p&gt;｣</span>
<span class="c1">#  root =&gt; ｢&lt;p&gt;some text&lt;/p&gt;｣</span>
<span class="c1">#   name =&gt; ｢p｣</span>
<span class="c1">#   child =&gt; ｢some text｣</span>
<span class="c1">#    text =&gt; ｢some text｣</span>
<span class="c1">#    textnode =&gt; ｢some text｣</span>
<span class="c1">#  element =&gt; ｢&lt;p&gt;some text&lt;/p&gt;｣</span>
<span class="c1">#   name =&gt; ｢p｣</span>
<span class="c1">#   child =&gt; ｢some text｣</span>
<span class="c1">#    text =&gt; ｢some text｣</span>
<span class="c1">#    textnode =&gt; ｢some text｣</span>
</code></pre></div><p>其他匹配变量是 <code>$/</code> 元素的别名：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$0</span>          <span class="c1"># same as $/[0]</span>
<span class="nv">$1</span>          <span class="c1"># same as $/[1]</span>
<span class="nv">$&lt;named&gt;</span>    <span class="c1"># same as $/&lt;named&gt;</span>
</code></pre></div><h3 id="位置属性">位置属性</h3>
<p>如果正则中有捕获分组, <code>$/</code> 中会有位置属性. 它们由圆括号组成.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#39;</span><span class="s1">abbbbbcdddddeffg</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> a </span><span class="p">(</span><span class="sr">b</span><span class="o">+</span><span class="p">)</span><span class="sr"> c </span><span class="p">(</span><span class="sr">d</span><span class="o">+</span><span class="sr">ef</span><span class="o">+</span><span class="p">)</span><span class="sr"> g </span><span class="p">/;</span>
<span class="nb">say</span> <span class="nv">$/</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># ｢bbbbb｣</span>
<span class="nb">say</span> <span class="nv">$/</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span> <span class="c1"># ｢dddddeff｣</span>
</code></pre></div><p>这些捕获分组也能使用 <code>$0</code>,<code>$1</code>,<code>$2</code> 等便捷形式取得:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$0</span><span class="p">;</span> <span class="c1"># ｢bbbbb｣</span>
<span class="nb">say</span> <span class="nv">$1</span><span class="p">;</span> <span class="c1"># ｢dddddeff｣</span>
</code></pre></div><p>要获取所有的位置属性, 使用 <code>$/.list</code>, <code>@$/</code>,<code>@( )</code> 中的任意一个都可以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">@</span><span class="p">()</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span> <span class="c1"># bbbbbdddddeff</span>
</code></pre></div><h3 id="命名属性">命名属性</h3>
<p>如果正则中有命名捕获分组, <code>$/</code> 可以有命名属性, 或者正则调用了另一个正则:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#39;</span><span class="s1">I.... see?</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="nv">$&lt;punctuation&gt;</span><span class="o">=</span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="se">\w\s</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="nv">$&lt;final-word&gt;</span><span class="sr"> </span><span class="o">=</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="ni">.</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">/;</span>
<span class="nb">say</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">punctuation</span><span class="p">&gt;;</span> <span class="c1"># ｢....｣</span>
<span class="nb">say</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">final-word</span><span class="p">&gt;;</span>  <span class="c1"># ｢see?｣</span>
</code></pre></div><p>这些命名捕获分组也能使用便捷形式的 <code>$&lt;named&gt;</code> 获取:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$&lt;punctuation&gt;</span><span class="p">;</span> <span class="c1"># ｢....｣</span>
<span class="nb">say</span> <span class="nv">$&lt;final-word&gt;</span><span class="p">;</span>  <span class="c1"># ｢see?｣</span>
</code></pre></div><p>要获取所有的命名属性, 使用 <code>$/.hash</code>,  <code>%$/</code>, <code>%()</code>中的任何一个:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">%</span><span class="p">()</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>  <span class="c1"># &#34;punctuation     ....final-word  see?&#34;</span>
</code></pre></div><h3 id="-变量-3">$! 变量</h3>
<p><code>$!</code> 是错误变量. 如果 <code>try</code> block 或语句前缀捕获到异常, 那个异常就会被存储在 <code>$!</code> 中。如果没有捕获到异常, 那么 <code>$!</code> 会被设置为 Any 类型对象。
注意, <code>CATCH</code> 块不设置 <code>$!</code>。CATCH 在 block 中把 <code>$_</code> 设置为捕获到的异常。</p>
<h2 id="编译时变量">编译时变量</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Compile-time Variables</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$?FILE</td>
<td style="text-align:left">所在文件</td>
</tr>
<tr>
<td style="text-align:center">$?LINE</td>
<td style="text-align:left">所在行</td>
</tr>
<tr>
<td style="text-align:center">::?CLASS</td>
<td style="text-align:left">所在类</td>
</tr>
<tr>
<td style="text-align:center">&amp;?ROUTINE</td>
<td style="text-align:left">所在子例程</td>
</tr>
<tr>
<td style="text-align:center">&amp;?BLOCK</td>
<td style="text-align:left">所在块</td>
</tr>
<tr>
<td style="text-align:center">%?LANG</td>
<td style="text-align:left">What is the current set of interwoven languages?</td>
</tr>
<tr>
<td style="text-align:center">%?RESOURCES</td>
<td style="text-align:left">The files associated with the &ldquo;Distribution&rdquo; of the current compilation unit.</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="o">!.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">d</span><span class="p">;</span>
    <span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">dir</span><span class="p">()</span><span class="o">&gt;&gt;.</span><span class="nv">&amp;?BLOCK</span> <span class="k">when</span> <span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">d</span> <span class="c1"># lets recurse a little!</span>
<span class="p">}</span>
</code></pre></div><p>其它编译时变量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Compile-time Variables</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$?PACKAGE</td>
<td style="text-align:left">所在包</td>
</tr>
<tr>
<td style="text-align:center">$?MODULE</td>
<td style="text-align:left">所在模块</td>
</tr>
<tr>
<td style="text-align:center">$?CLASS</td>
<td style="text-align:left">所在类(as variable)</td>
</tr>
<tr>
<td style="text-align:center">$?ROLE</td>
<td style="text-align:left">所在角色(as variable)</td>
</tr>
<tr>
<td style="text-align:center">$?GRAMMAR</td>
<td style="text-align:left">所在 grammar</td>
</tr>
<tr>
<td style="text-align:center">$?TABSTOP</td>
<td style="text-align:left">在 heredoc 或 虚拟边距中 tab 有多少空格</td>
</tr>
<tr>
<td style="text-align:center">$?USAGE</td>
<td style="text-align:left">从 MAIN 程序的签名中生成的使用信息</td>
</tr>
<tr>
<td style="text-align:center">$?ENC</td>
<td style="text-align:left">Str.encode/Buf.decode/various IO 方法的默认编码.</td>
</tr>
</tbody>
</table>
<h2 id="动态变量">动态变量</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Dynamic Variable</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$*ARGFILES</td>
<td style="text-align:left">神奇的命令行输入句柄</td>
</tr>
<tr>
<td style="text-align:center">@*ARGS</td>
<td style="text-align:left">来自命令行的参数</td>
</tr>
<tr>
<td style="text-align:center">$*IN</td>
<td style="text-align:left">标准输入文件句柄, AKA stdin</td>
</tr>
<tr>
<td style="text-align:center">$*OUT</td>
<td style="text-align:left">标准输出文件句柄, AKA stdout</td>
</tr>
<tr>
<td style="text-align:center">$*ERR</td>
<td style="text-align:left">标准错误文件句柄, AKA stderr</td>
</tr>
<tr>
<td style="text-align:center">%*ENV</td>
<td style="text-align:left">环境变量</td>
</tr>
<tr>
<td style="text-align:center">$*REPO</td>
<td style="text-align:left">存储安装过的/加载了的模块信息的变量</td>
</tr>
<tr>
<td style="text-align:center">$*TZ</td>
<td style="text-align:left">系统的本地时区.</td>
</tr>
<tr>
<td style="text-align:center">$*CWD</td>
<td style="text-align:left">当前工作目录.</td>
</tr>
<tr>
<td style="text-align:center">$*KERNEL</td>
<td style="text-align:left">在哪个内核下运行</td>
</tr>
<tr>
<td style="text-align:center">$*DISTRO</td>
<td style="text-align:left">在哪个操作系统分发下运行</td>
</tr>
<tr>
<td style="text-align:center">$*VM</td>
<td style="text-align:left">在哪个虚拟机下运行</td>
</tr>
<tr>
<td style="text-align:center">$*PERL</td>
<td style="text-align:left">在哪个 Perl 下运行</td>
</tr>
<tr>
<td style="text-align:center">$*PID</td>
<td style="text-align:left">当前进程的进程 ID</td>
</tr>
<tr>
<td style="text-align:center">$*PROGRAM-NAME</td>
<td style="text-align:left">当前可执行程序的路径就像它通过命令行键入一样, 或 -e 如果 perl 引用了 -e 标记</td>
</tr>
<tr>
<td style="text-align:center">$*PROGRAM</td>
<td style="text-align:left">正被执行的 Perl 程序的位置( 以 IO::Path 对象的形式)</td>
</tr>
<tr>
<td style="text-align:center">$*EXECUTABLE</td>
<td style="text-align:left">当前运行的可执行 perl 的绝对路径</td>
</tr>
<tr>
<td style="text-align:center">$*EXECUTABLE-NAME</td>
<td style="text-align:left">当前运行的可执行 perl 程序的名字。(e.g. raku-p, raku-m, Niecza.exe)</td>
</tr>
<tr>
<td style="text-align:center">$*USER</td>
<td style="text-align:left">正在运行该程序的用户. 它是一个被求值为 &ldquo;username (uid)&rdquo; 的对象. 它只有在被当作字符串时才被求值为用户名, 如果被当作数字则被求值为数值化的用户 id。</td>
</tr>
<tr>
<td style="text-align:center">$*GROUP</td>
<td style="text-align:left">运行程序的用户的主要组. 它是被计算为  &ldquo;groupname (gid)&rdquo; 的对象.它只有在被当作字符串时才被求值为组名, 如果被当作数字则被求值为数值化的组 id。</td>
</tr>
<tr>
<td style="text-align:center">$*HOME</td>
<td style="text-align:left">代表当前运行程序的用户家目录的 IO::Path 对象。如果家目录不确定则为 Nil。</td>
</tr>
<tr>
<td style="text-align:center">$*SPEC</td>
<td style="text-align:left">程序运行的平台的合适的 IO::Spec 子类, 对于特定操作系统代码,使用智能匹配: say &ldquo;We are on Windows!&rdquo; if $*SPEC ~~ IO::Spec::Win32</td>
</tr>
<tr>
<td style="text-align:center">$*TMPDIR</td>
<td style="text-align:left">代表着 &ldquo;系统临时目录&rdquo; 的 IO::Path 对象</td>
</tr>
<tr>
<td style="text-align:center">$*TOLERANCE</td>
<td style="text-align:left">由 &lt;=~=&gt; 操作符使用并且任何依赖它的操作, 来决定两个值是否近似地相等, 默认为 1e-15。</td>
</tr>
<tr>
<td style="text-align:center">$*THREAD</td>
<td style="text-align:left">代表当前执行线程的 Thread 对象。</td>
</tr>
<tr>
<td style="text-align:center">$*SCHEDULER</td>
<td style="text-align:left">代表当前默认调度程序的 ThreadPoolScheduler 对象。</td>
</tr>
</tbody>
</table>
<p>注意 <code>$*SCHEDULER</code> 的用法:</p>
<p>对于当前的 Rakudo, 这个默认在方法 <code>.hyper</code> 和 <code>.race</code> 上采用最大 16 个线程。要更改线程的最大数量, 要么在运行 perl 之前设置环境变量  RAKUDO_MAX_THREADS 的值, 要么在使用 .hyper 或 .race 之前创建一个默认改变了的作用域的拷贝:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="vg">$*SCHEDULER</span> <span class="o">=</span> <span class="nb">ThreadPoolScheduler</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">max_threads</span> <span class="o">=&gt;</span> <span class="mi">64</span> <span class="p">);</span>
</code></pre></div><p>这种行为在 spec 测试中没有被测试并且还会变化。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/variable" term="variable" label="variable" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的引号]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-08-24-quote-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-08-24-quote-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Quote in Raku</blockquote><p>除了 q 和 qq 之外，现在还有一种基本形式的 Q，它不会进行插值，除非显式地修改它那样做。所以，q 实际上是 Q:q 的简称，qq 实际上是 <code>Q:qq</code> 的简称。实际上所有的 quote-like 形式都派生自带有副词的 Q 形式：</p>
<p><a href="https://github.com/raku/roast/blob/master/S02-literals/quoting.t#L95-L116">S02-literals/quoting.t lines 95–116</a>
<a href="https://github.com/raku/roast/blob/master/S02-literals/quoting.t#L132-L139">S02-literals/quoting.t lines 132–139</a></p>
<pre><code>q//         Q :q //
qq//        Q :qq //
rx//        Q :regex //
s///        Q :subst ///
tr///       Q :trans ///
</code></pre><p>诸如 <code>:regex</code> 的副词通过转换到不同的解析器改变了语言的解析。这能完全改变任何之后的副词还有所引起的东西自身的解释。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">q</span><span class="sa">:s</span><span class="p">//</span><span class="s">       Q :q :scalar </span>
<span class="k">rx</span><span class="p">:</span><span class="na">s</span><span class="p">//</span><span class="sr">      Q </span><span class="p">:</span><span class="na">regex</span><span class="sr"> </span><span class="p">:</span><span class="na">scalar</span><span class="sr"> //
</span></code></pre></div><p>就像 <code>q[...]</code> 拥有简写形式的 &lsquo;&hellip;&rsquo;, 并且 <code>qq[...]</code> 拥有简写形式的 &ldquo;&hellip;&rdquo; 一样，完整的 <code>Q[...]</code> 引用也有一种使用半角括号 ｢&hellip;｣ 的短形式。</p>
<h2 id="引号上的副词">引号上的副词</h2>
<p>广义上的引号现在可以接收副词了：</p>
<ul>
<li><a href="https://github.com/raku/roast/blob/master/S02-literals/quoting.t#L210-L223">S02-literals/quoting.t lines 210–223</a></li>
<li><a href="https://github.com/raku/roast/blob/master/S02-literals/quoting.t#L55-L69">S02-literals/quoting.t lines 55–69</a></li>
<li><a href="https://github.com/raku/roast/blob/master/S02-literals/quoting.t#L427-L501">S02-literals/quoting.t lines 427–501</a></li>
</ul>
<pre><code>Short       Long            Meaning
=====       ====            =======
:x          :exec           作为命令执行并返回结果
:w          :words          按单词分割结果(没有引号保护)


:ww         :quotewords     按单词分割结果 (带有引号保护)
:v          :val            Evaluate word or words for value literals
:q          :single         插值 \\, \q 和 \' (or whatever)


:qq         :double         使用 :s, :a, :h, :f, :c, :b 进行插值
:s          :scalar         插值 $ vars
:a          :array          插值 @ vars
:h          :hash           插值 % vars


:f          :function       插值 &amp; 调用
:c          :closure        插值 {...} 表达式
:b          :backslash      插值 \n, \t, 等. (至少暗示了 :q )
:to         :heredoc        把结果解析为 heredoc 终止符
            :regex          解析为正则表达式
            :subst          解析为置换 (substitution)
            :trans          解析为转换 (transliteration)
            :code           Quasiquoting
:p          :path           返回一个 Path 对象 (查看 S16 获取更多选项)
</code></pre><p>通过在开头加入一个带有短形式的单个副词的 Q，q，或 qq，你可以省略掉第一个冒号，这产生了如下形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">q</span><span class="sa">w</span> <span class="p">/</span><span class="s">a b c</span><span class="p">;</span>                         <span class="c1"># P5-esque qw// meaning q:w</span>
<span class="k">Q</span><span class="sa">c</span> <span class="p">&#39;</span><span class="s">...</span><span class="p">{</span><span class="nv">$x</span><span class="p">}</span><span class="s">...</span><span class="p">;</span>                    <span class="c1"># Q:c//, interpolate only closures</span>
<span class="k">qq</span><span class="sa">x</span><span class="p">/</span><span class="nv">$cmd</span><span class="s2"> </span><span class="nv">@args</span><span class="o">[]</span>                   <span class="c1"># equivalent to P5&#39;s qx//</span>
</code></pre></div><p>(注意 <code>qx//</code> 不插值)</p>
<p>如果你想进一步缩写，那么定义一个宏：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">macro</span> <span class="k">q</span><span class="sa">x</span> <span class="p">{</span><span class="s"> &#39;qq:x &#39; </span><span class="p">}</span>          <span class="c1"># equivalent to P5&#39;s qx//</span>
<span class="n">macro</span> <span class="n">qTO</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">qq❌w:to </span><span class="p">&#39;</span> <span class="p">}</span>    <span class="c1"># qq❌w:to//</span>
<span class="nf">macro</span> <span class="n">quote:</span><span class="p">&lt;</span><span class="s">❰ ❱</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$text</span><span class="p">)</span> <span class="p">{</span> <span class="n">quasi</span> <span class="p">{</span> <span class="p">{{{</span><span class="nv">$text</span><span class="p">}}}</span><span class="o">.</span><span class="nf">quoteharder</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div><p>所有大写的副词被保留用作用户定义的引号。所有在 Latin-1 上面的 Unicode 分隔符被保留用作用户定义的引号。
<a href="https://github.com/raku/roast/blob/master/S02-literals/quoting.t#L352-L426">S02-literals/quoting.t lines 352–426</a></p>
<p>关于上面我们现在有了一个推论，我们现在能说：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span> <span class="o">=</span> <span class="k">q</span><span class="sa">w:c</span><span class="p">/</span><span class="s">a b c d </span><span class="p">{</span><span class="nv">@array</span><span class="p">}</span><span class="s"> </span><span class="p">{</span><span class="nv">%hash</span><span class="p">};</span>
</code></pre></div><p>或：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span> <span class="o">=</span> <span class="k">qq</span><span class="sa">:w</span><span class="p">/</span><span class="s2">a b c d </span><span class="p">{</span><span class="nv">@array</span><span class="p">}</span><span class="s2"> </span><span class="p">{</span><span class="nv">%hash</span><span class="p">};</span>
</code></pre></div><p>把东西(items)插值到 qw 中。默认地，数组和散列在插值时只带有空格分隔符，所以之后的按空格分割仍旧能工作。（但是内置的  «&hellip;»  引号自动进行了等价于 <code>qq:ww:v/.../</code> 的插值）。 内置的 <code>&lt;...&gt;</code> 等价于 <code>q:w:v/.../</code>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/quote" term="quote" label="quote" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的自省]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-07-25-introspection-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-07-25-introspection-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Introspection in Raku</blockquote><p>Raku 支持&quot;泛型, roles 和 多重分发&quot;, 它们都是很好的特点, 并且已经在其它 advent calendar 中发布过了。</p>
<p>但是今天我们要看的是 <strong>MOP</strong>。 &ldquo;MOP&rdquo; 代表着元对象协议(&ldquo;Meta-Object Protocol&rdquo;)。那意味着, 它们实际上是你能从用户那边改变的一部分, 而不是对象、类等定义语言的东西。</p>
<p>实际上, 在 Raku中, 你可以为类型添加方法, 移除某个方法, 包裹方法, 使用更多能力增强类(<a href="https://github.com/jnthn/oo-actors">OO::Actors</a> 和 <a href="https://github.com/jnthn/oo-monitors">OO::Monitors</a> 就是两个这样的例子), 或者你可以完全重定义它(并且, 例如, 使用 Ruby-like 的对象系统。<a href="https://github.com/edumentab/rakudo-and-nqp-internals-course">这儿有个例子</a>)。</p>
<p>但是今天, 我们首先看一下第一部分: 自省。在类型创建完之后查看它的类型, 了解它, 并使用这些信息。</p>
<p>我们将要创建的模块是基于 <a href="https://github.com/vendethiel/sixcheck">Sixcheck</a> 模块(一个 <a href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck-like</a> 模块)的需求: 为某个类型生成一些随机数据, 然后把数据喂给我们正测试的函数, 并检查某些后置条件(post-condition)。</p>
<p>所以, 我们先写出第一个版本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%special-cases</span><span class="p">{</span><span class="nb">Mu</span><span class="p">}</span> <span class="o">=</span>
  <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">-&gt;</span> <span class="p">{</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span> <span class="p">}</span>,
  <span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">-&gt;</span> <span class="p">{</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;&#39;)</span> <span class="p">}</span>,
<span class="p">;</span>

<span class="k">sub</span> <span class="nf">generate-data</span><span class="p">(</span><span class="nb">Mu:U</span> \<span class="nb">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">%special-cases</span><span class="p">{</span><span class="nb">t</span><span class="p">}</span> <span class="o">??</span> <span class="nv">%special-cases</span><span class="p">{</span><span class="nb">t</span><span class="p">}()</span> <span class="o">!!</span> <span class="nb">t</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">generate-data</span><span class="p">(</span><span class="nb">Int</span><span class="p">);</span>
</code></pre></div><p>注意以下几点:</p>
<ul>
<li>我们给 <code>%special-cases</code> 指定了键的类型。那是因为默认地, 键的类型为 <strong>Str</strong>。显然地, 我们不想让我们的类型字符串化。我们实际上做的是指定它们为&quot;Mu&quot;的子类(这在类型&quot;食物链&quot;的顶端)。</li>
<li>我们在 <strong>Int</strong> 和 <strong>Str</strong> 周围放上圆括号, 以避免字符串化。</li>
<li>我们在函数参数类型中使用了 <code>:U</code>。那意味着那个值必须是未定义的(undefined)。类型对象(就像 Int、Str 等等)是未定义的, 所以它能满足我们(你可能见过一个叫 Nil 的不同的未知值)。</li>
<li>类型对象实际上是对象, 就像其它任何对象一样。这就是为什么我们在类型对象上调用 <code>.new</code> 方法, 例如, 它和直接调用 <code>Int.new</code> 相同(那对一致性和 <a href="https://design.raku.org/S09.html#Autovivification">autovivification</a> 很有用)。</li>
<li>我们为 <em>Int</em> 和 <em>Str</em> 提供了 fallback, 因为调用 <em>Int.new</em> 和 <em>Str.new</em> ( 0 和 &quot;&quot; )不会在我们创建的数据中给我们任何随机化。</li>
<li>Raku 在函数中自动返回最后一个表达式。所以不需要在那儿放上一个 <em>return</em>。</li>
</ul>
<p>我们用代码生成数据, 公平且公正。但是我们需要生成更多那样简单的数据。</p>
<p>我们至少需要支持带有属性的类: 我们想查看属性列表, 为它们的类型生成数据, 并把它们喂给构造器。</p>
<p>我们要能够看到类的内部。用 Raku 的术语来说, 我们将要到达的是元对象协议(<a href="https://rakuadvent.wordpress.com/2010/12/22/day-22-the-meta-object-protocol/">Meta-Object Protocol</a>)。首先我们定义一个类:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Article</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.title</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.content</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.view-count</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># 我们可以这样手动创建一个实例</span>
<span class="n">Article</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">title</span>      <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Raku Advent</span>, <span class="n">第</span> <span class="mi">19</span> <span class="n">天</span><span class="p">&#34;</span><span class="s2">,
</span><span class="s2">            content    =&gt; </span><span class="p">&#34;</span><span class="n">Magic</span><span class="o">!</span><span class="p">&#34;</span><span class="s2">,
</span><span class="s2">            view-count =&gt; 0
</span><span class="s2">            );
</span></code></pre></div><p>但是我们不想亲手创建那个文章 (article)。我们想把那个 <strong>class</strong> Article 传递给我们的 <em>generate-data</em> 函数, 并返回一个 Article(里面带有随机数据)。让我们回到我们的 <em>REPL</em>&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">Article</span><span class="o">.^</span><span class="nb">attributes</span><span class="p">;</span>         <span class="c1"># (Str $!title Str $!content Int $!view-count)</span>
<span class="nb">say</span> <span class="n">Article</span><span class="o">.^</span><span class="nb">attributes</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">WHAT</span><span class="p">;</span> <span class="c1"># (Attribute)</span>
</code></pre></div><p>如果你点击了 MOP 链接, 你不会对我们得到一个含有 3 个元素的数组感到惊讶。如果你仍旧对该语法感到惊讶, 那么 <code>.^</code> 是元方法调用。意思是 <code>a.^b</code> 会被转换为 <code>a.HOW.b(a)</code>。</p>
<p>如果我们想知道我们可以访问到什么, 我们问它就是了(移除了匿名的那些):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Attribute</span><span class="o">.^</span><span class="nb">methods</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">name</span> <span class="ow">ne</span> <span class="p">&#39;</span><span class="s1">&lt;anon&gt;</span><span class="p">&#39;);</span>
<span class="c1"># (compose apply_handles get_value set_value</span>
<span class="c1">#      container readonly package inlined WHY set_why Str gist)</span>

<span class="nb">Attribute</span><span class="o">.^</span><span class="nb">attributes</span> <span class="c1"># Method &#39;gist&#39; not found for invocant of class &#39;BOOTSTRAPATTR&#39;</span>
</code></pre></div><p>哎吆… 看起来这有点太 meta 了。幸好, 我们能使用 Rakudo 的一个非常好的属性: 它的大部分都是用 Raku 写的! 要查看我们可以得到什么, 我们查看<a href="https://github.com/rakudo/rakudo/blob/nom/src/core/Attribute.pm">源代码</a>就好了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># has Str $!name;</span>
<span class="o">...</span>
<span class="c1"># has Mu $!type;</span>
</code></pre></div><p>我们得到了键的名字, 还有去生成值的类型。让我们看看&hellip;</p>
<pre><code>&gt; say Article.^attributes.map(*.name)
($!title $!content $!view-count)
&gt; say Article.^attributes.map(*.type)
((Str) (Str) (Int))
</code></pre><p>天才! 看起来是正确的。(如果你想知道为什么我们得到 <code>$!</code>（私有的） twigils, 那是因为 <code>$.</code> 只意味着将会生成的一个 getter 方法)。属性本身仍然是私有的, 并且在类中是可访问的。</p>
<p>现在, 我们唯一要做的事情就是创建一个循环&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%args</span><span class="p">;</span>

<span class="k">for</span> <span class="n">Article</span><span class="o">.^</span><span class="nb">attributes</span> <span class="k">-&gt;</span> <span class="nv">$attr</span> <span class="p">{</span>
    <span class="nv">%args</span><span class="p">{</span><span class="nv">$attr</span><span class="o">.</span><span class="nb">name</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">2</span><span class="p">)}</span> <span class="o">=</span> <span class="nf">generate-data</span><span class="p">(</span><span class="nv">$attr</span><span class="o">.</span><span class="nb">type</span><span class="p">);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nv">%args</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
</code></pre></div><p>这是一个将会打印什么的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{:</span><span class="s">content</span><span class="p">(&#34;</span><span class="s2">muenglhaxrvykfdjzopqbtwisc</span><span class="p">&#34;)</span><span class="o">,</span> <span class="p">:</span><span class="s">title</span><span class="p">(&#34;</span><span class="s2">rfpjndgohmasuwkyzebixqtvcl</span><span class="p">&#34;)</span><span class="o">,</span> <span class="p">:</span><span class="s">view-count</span><span class="p">(</span><span class="mi">45</span><span class="p">)}</span>
</code></pre></div><p>每次你运行你的代码你都会得到不同的结果(然而我不认为它会创建一篇值得阅读的文章…)。剩下唯一要做的就是把它们传递给 Article 的构造函数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">Article</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">|</span><span class="nv">%args</span><span class="p">);</span>
</code></pre></div><p>(前缀 <code>|</code> 允许我们把 <em>%args</em> 作为具名参数传递, 而不是单个位置参数)。再次, 你应该会打印这些东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Article</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">title</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">kyvphxqmejtuicrbsnfoldgzaw</span><span class="p">&#34;</span>, <span class="s">content</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">jqbtcyovxlngpwikdszfmeuahr</span><span class="p">&#34;</span>, <span class="s">view-count</span> <span class="o">=&gt;</span> <span class="mi">26</span><span class="p">)</span>
</code></pre></div><p>呀! 我们设法在不了解 Article 的情况下胡乱地(blindly)创建了一个 Article 实例。 我们的代码能够用于为任何期望传递它的类属性的构造函数生成数据。好了!</p>
<p>PS: 留个作业! 移动到 generate-data 函数, 以至于我们能给 Article 添加一个 User <code>$.author</code> 属性, 并且构建好这个函数。祝你好运!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/introspection" term="introspection" label="introspection" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的角色冲突]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-16-roles-conflict-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2016-01-21-protocol-in-swift-and-roles-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Swift 中的 protocol 和 Raku 中的 roles 一例" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-16-roles-conflict-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Roles Conflict in Raku</blockquote><p>学会了怎么创建类, 我们继续用它来构建我们的中心内容:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Hammer</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">hammer</span><span class="p">(</span><span class="nv">$stuff</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You hammer on </span><span class="nv">$stuff</span><span class="s2">. BAM BAM BAM!</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Gavel</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">hammer</span><span class="p">(</span><span class="nv">$stuff</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You hammer on </span><span class="nv">$stuff</span><span class="s2">. BAM BAM BAM!</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Mallet</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">hammer</span><span class="p">(</span><span class="nv">$stuff</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You hammer on </span><span class="nv">$stuff</span><span class="s2">. BAM BAM BAM!</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>但是注意到了吗？这三个方法包含了同样的方法, 在类中重复了。我们必须那样做如果我们想让每个 <strong>Hammar</strong>、<strong>Gavel</strong> 和 <strong>Mallet</strong> 有能力击打的话。（并且那是合理的）。但是遗憾的是我们不得不把那个方法一式三份。</p>
<p>为什么遗憾？ 因为一方面在真实世界中, 方法并不是很彼此相似, 有一天你决定在 <strong>hammer</strong> 方法中更改某些东西, 并没有意识到这个方法在三个不同的地方&hellip; 这导致了一堆痛苦和难受。</p>
<p>所以我们的新玩具, 类, 展现出了一个问题。我们想在每个类中重用 hammer 方法。一个新的概念, <strong>role</strong> 来拯救我们来了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">Hammering</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">hammer</span><span class="p">(</span><span class="nv">$stuff</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You hammer on </span><span class="nv">$stuff</span><span class="s2">. BAM BAM BAM!</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>虽然类经常以一个合适的名词命名, 但是 roles 经常以一个分词命名, 例如 <strong>Hammering</strong>。这不是一个必须遵守的规则, 但是它是一个好的经验法则。现在类的定义变的简单了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Hammer</span> <span class="k">does</span> <span class="nc">Hammering</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Gavel</span>  <span class="k">does</span> <span class="nc">Hammering</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">Mallet</span> <span class="k">does</span> <span class="nc">Hammering</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>是的, 我们喜欢那样。</p>
<p>这发生了什么？ 我们在类上使用 <strong>does</strong> 是干什么用的？ role 定义中的所有方法都被拷贝到类定义中。因为它是一个拷贝操作, 所以我们可以使用尽可能多的类。</p>
<p>所以, 我们做的是: 当我们想重用方法的时候把方法放进 roles 里面。</p>
<p>但是好处不止这一点儿。至少有两个好处:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$hammer</span> <span class="o">=</span> <span class="n">Hammer</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>    <span class="c1"># create a new hammer object</span>
<span class="nb">say</span> <span class="nv">$hammer</span> <span class="o">~~</span> <span class="n">Hammer</span><span class="p">;</span>      <span class="c1"># &#34;Bool::True&#34; -- yes, this we know</span>
<span class="nb">say</span> <span class="nv">$hammer</span> <span class="o">~~</span> <span class="n">Hammering</span><span class="p">;</span>   <span class="c1"># &#34;Bool::True&#34; -- ooh!</span>
</code></pre></div><p>所以 <code>$hammer</code> 知道它遵守了(does) <strong>Hammering</strong>, 我们现在不仅知道了对象属于哪个类, 还知道了对象并入了什么 role。这很有用如果我们不确定我们处理的是什么类型的对象:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$unkown_object</span> <span class="o">~~</span> <span class="n">Hammering</span> <span class="p">{</span>
    <span class="nv">$unknown_object</span><span class="o">.</span><span class="nf">hammer</span><span class="p">(&#34;</span><span class="s2">砸在钉子上</span><span class="p">&#34;);</span>     <span class="c1"># will always work</span>
<span class="p">}</span>
</code></pre></div><p>一个类能一次接收几个 roles 吗？ 是的, 它可以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">Flying</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">fly</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Whooosh!</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">FlyingHammer</span> <span class="k">does</span> <span class="nc">Hammering</span> <span class="k">does</span> <span class="nc">Flying</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>让一个类像那样遵守几个 roles 引入了一个有意思的可能: 冲突, 当来自两个不同 roles 的两个同名方法尝试占领同一个类时。这时会发生什么？ 好吧, 至少有 3 种可能:</p>
<ul>
<li>
<ol>
<li>第一个 role 赢了。 它的方法住进了类中</li>
</ol>
</li>
<li>
<ol>
<li>最后一个 role 赢了。 它覆盖了之前的方法</li>
</ol>
</li>
<li>
<ol>
<li>编译失败。冲突必须被解决。</li>
</ol>
</li>
</ul>
<p>这种情况下选项 3  应该是正确答案。原因和之前相同: 因为类和工程越来越庞大, 程序员可能意识不到两个 role 之间在哪儿发生冲突。所以我们标记了它。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">Sleeping</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">lie</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">水平躺下</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">Lying</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">lie</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">说谎...</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">SleepingLiar</span> <span class="k">does</span> <span class="nc">Sleeping</span> <span class="k">does</span> <span class="nc">Lying</span> <span class="p">{</span> <span class="p">}</span>    <span class="c1"># 冲突!</span>

</code></pre></div><p>下一个问题, 那么: 当在类中有  role 冲突时, 我们怎么修复它？ 简单: 在类中自己定义一个同名的方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">class</span> <span class="nc">SleepingLiar</span> <span class="k">does</span> <span class="nc">Sleeping</span> <span class="k">does</span> <span class="nc">Lying</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">lie</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Lying in my sleep....</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果你想从一个贴别的 role 中调用一个方法, 语法是这样的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">SleepingLiar</span> <span class="k">does</span> <span class="nc">Sleeping</span> <span class="k">does</span> <span class="nc">Lying</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">lie</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">Sleeping::lie</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这就是 roles。它们把可重用的行为混合进类中。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/roles" term="roles" label="roles" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的面向对象]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-06-15-object-orientation-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-06-15-object-orientation-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Object Orientation in Raku</blockquote><p>Raku 为<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程(OOP)</a>提供强大支持。尽管 Raku 允许程序员以多种范式进行编程, 但面向对象编程是该语言的核心。</p>
<p>Raku 带有丰富的预定义类型, 可分为两类：常规类型和<a href="https://docs.raku.org/language/nativetypes">原生类型</a>。所有你能存储到变量中的东西要么是一个原生的 value, 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。</p>
<p>原生类型用于<code>底层类型</code>（例如 <code>uint64</code>）。尽管原生类型没有和对象同样的功能, 如果在其上调用方法, 它们也会自动装入普通对象。</p>
<p>一切不是原生值的东西都是一个对象。对象确实允许<a href="https://en.wikipedia.org/wiki/Object-oriented_programming#Inheritance_and_behavioral_subtyping">继承</a>和<a href="https://en.wikipedia.org/wiki/Object-oriented_programming#Encapsulation">封装</a>。</p>
<h2 id="使用对象">使用对象</h2>
<p>要在对象上调用方法, 请在对象名上添加一个点, 然后添加方法名称：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">abc</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uc</span><span class="p">;</span>
<span class="c1"># OUTPUT: «ABC␤» </span>
</code></pre></div><p>这将在 &ldquo;abc&rdquo; 上调用 <code>uc</code> 方法, 这是一个 <code>Str</code> 类型的对象。要为方法提供参数, 请在方法后面的括号内添加参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$formatted-text</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Fourscore and seven years ago...</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">indent</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$formatted-text</span><span class="p">;</span>
<span class="c1"># OUTPUT: «        Fourscore and seven years ago...» </span>
</code></pre></div><p><code>$formatted-text</code> 现在包含上面的文本, 但缩进了8个空格。</p>
<p>多个参数由逗号分隔：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Abe</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Lincoln</span><span class="p">&#34;;</span>
<span class="nv">@words</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#34;</span><span class="s2">said</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$formatted-text</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/));</span>
<span class="nb">say</span> <span class="nv">@words</span><span class="p">;</span>
<span class="c1"># OUTPUT: «[Abe Lincoln said (Fourscore and seven years ago)]␤» </span>
</code></pre></div><p>类似地, 可以通过在方法后放置冒号并使用逗号分隔参数列表来指定多个参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">@words</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">--</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">subst</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">years</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">DAYS</span><span class="p">&#39;;</span>
<span class="c1"># OUTPUT: «Abe--Lincoln--said--Fourscore and seven DAYS ago␤» </span>
</code></pre></div><p>如果要在没有括号的情况下传递参数, 则必须在方法之后添加一个 <code>:</code>, 因此没有冒号或括号的方法调用明确地是没有参数列表的方法调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">4</span><span class="o">.</span><span class="nb">log</span><span class="o">:</span>   <span class="p">;</span> <span class="c1"># OUTPUT: «1.38629436111989␤» ( natural logarithm of 4 ) </span>
<span class="nb">say</span> <span class="mi">4</span><span class="o">.</span><span class="nb">log</span><span class="o">:</span> <span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="c1"># OUTPUT: «2␤» ( base-2 logarithm of 4 ) </span>
<span class="nb">say</span> <span class="mi">4</span><span class="o">.</span><span class="nb">log</span>  <span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="c1"># OUTPUT: «3.38629436111989␤» ( natural logarithm of 4, plus 2 )</span>
</code></pre></div><p>许多看起来不像方法调用的操作（例如, 智能匹配或将对象插值到字符串中）可能会导致方法调用。</p>
<p>方法可以返回可变容器, 在这种情况下, 您可以分配方法调用的返回值。这是使用对象的可读写属性的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="vg">$*IN</span><span class="o">.</span><span class="nb">nl-in</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">\r\n</span><span class="p">&#34;;</span>
</code></pre></div><p>在这里, 我们在 <code>$*IN</code> 对象上调用 <code>nl-in</code> 方法, 不带参数, 并使用 <code>=</code> 运算符将其赋值给它返回的容器。</p>
<p>所有对象都支持类<a href="https://docs.raku.org/type/Mu">Mu</a>的方法, 它是层次结构的根。所有对象都来自 <code>Mu</code>。</p>
<h2 id="类型对象">类型对象</h2>
<p>类型本身是对象, 你可以使用类型的名字获取类型对象:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$int-type-obj</span> <span class="o">=</span> <span class="nb">Int</span><span class="p">;</span>
</code></pre></div><p>你可以通过调用 <code>WHAT</code> 方法查看任何对象的 type object(它实际上是一个方法形式的宏):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$int-type-obj</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
</code></pre></div><p>使用 <a href="https://docs.raku.org/routine/===">===</a> 恒等运算符可以比较类型对象(<a href="https://docs.raku.org/type/Mu">Mu</a>除外)的相等性：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">WHAT</span> <span class="o">===</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">you passed an Int</span><span class="p">&#39;;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">you passed a subtype of Int</span><span class="p">&#39;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>虽然, 在大多数情况下, <a href="https://docs.raku.org/routine/isa"><code>.isa</code></a>方法就足够了：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$x</span><span class="o">.</span><span class="nb">isa</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>子类型可以使用 <a href="https://docs.raku.org/language/operators#infix_~~">smartmatching</a> 来检查：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$type</span> <span class="o">~~</span> <span class="nb">Real</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">$type contains Real or a subtype thereof</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><h2 id="类">类</h2>
<p>使用 <code>class</code> 关键字进行类的声明, 通常后跟类名：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div><p>此声明会创建类型对象并将其安装在名字 <code>Journey</code> 下的当前包和当前词法作用域中。您还可以通过词法声明类</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div><p>这限制了它们对当前词法范围的可见性, 如果该类是嵌套在模块或另一个类中的实现细节, 这可能很有用。</p>
<h2 id="属性">属性</h2>
<p>属性存在于每个类的实例中。属性中存储着对象的状态。在 Raku 中, 一切属性都是<code>私有的</code>.  它们一般使用 <code>has</code> 关键字和 <code>!</code> twigil 进行声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!origin</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!destination</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!notes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>虽然没有公共(甚至保护属性)属性, 不过有一种方式可以自动生成访问器方法: 使用 <code>.</code> twigil 代替 <code>!</code> twigil 。(那个 <code>.</code> 应该让你想起了方法调用)。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.notes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这默认提供只读访问器, 为了允许更改属性, 要添加 <code>is rw</code> 特性:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.notes</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>现在, <code>Journey</code>对象创建之后, 它的 <code>.origin</code>, <code>.destination</code> 和 <code>.notes</code> 都能从类的外部访问, 但只有 <code>.notes</code> 可以被修改。</p>
<p>如果在没有某些属性（例如 <code>origin</code> 或 <code>destination</code>）的情况下实例化对象, 我们可能无法获得想要的结果。要防止这种情况, 请提供默认值或通过使用<a href="https://docs.raku.org/routine/is%20required">is required</a> trait 来标记属性以确保在对象创建时设置属性。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
    <span class="c1"># error if origin is not provided </span>
    <span class="k">has</span> <span class="nv">$.origin</span> <span class="k">is</span> <span class="k">required</span><span class="p">;</span>
    <span class="c1"># set the destination to Orlando as default (unless that is the origin!) </span>
    <span class="k">has</span> <span class="nv">$.destination</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="nf">origin</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">Orlando</span><span class="p">&#39;</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">Kampala</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">Orlando</span><span class="p">&#39;;</span>
    <span class="k">has</span> <span class="nv">@!travelers</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.notes</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>因为类从 <code>Mu</code> 继承了一个默认的构造器, 并且我们也要求类为我们生成一些<strong>访问器方法</strong>.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 创建一个新的类的实例.</span>
<span class="k">my</span> <span class="nv">$vacation</span> <span class="o">=</span> <span class="n">Journey</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
    <span class="s">origin</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Sweden</span><span class="p">&#39;</span>,
    <span class="s">destination</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Switzerland</span><span class="p">&#39;</span>,
    <span class="s">notes</span>       <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Pack hiking gear!</span><span class="p">&#39;</span>
<span class="p">);</span>

<span class="c1"># 使用访问器; 这打印出 Sweden.</span>
<span class="nb">say</span> <span class="nv">$vacation</span><span class="o">.</span><span class="nf">origin</span><span class="p">;</span>
<span class="c1"># 使用 rw 存取器来更改属性的值.</span>
<span class="nv">$vacation</span><span class="o">.</span><span class="nf">notes</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Pack hiking gear and sunglasses!</span><span class="p">&#39;;</span>
</code></pre></div><p>请注意, 虽然默认构造函数可以初始化只读属性, 但它只会设置具有访问器方法的属性。也就是说, 即使您传递 <code>travelers =&gt; [&quot;Alex&quot;, &quot;Betty&quot;]</code> 给默认构造函数, <code>@!travelers</code> 也不会初始化该属性。</p>
<h2 id="方法">方法</h2>
<p>使用 <code>method</code> 关键字在类的 body 中声明方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@!travellers</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.notes</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">add_traveller</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$name</span> <span class="ow">ne</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@!travellers</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">push</span> <span class="nv">@!travellers</span><span class="o">,</span> <span class="nv">$name</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">warn</span> <span class="p">&#34;</span><span class="nv">$name</span><span class="s2"> is already going on the journey!</span><span class="p">&#34;;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">describe</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">&#34;</span><span class="s2">From </span><span class="nv">$!origin</span><span class="s2"> to </span><span class="nv">$!destination</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>方法可以有签名, 就像子例程一样。 属性可以在方法中使用, 并且可以始终与 <code>!</code> twigil 一起使用, 即使属性是用 <code>.</code> twigil 声明的。 这是因为 <code>.</code> twigil 声明了 <code>!</code> twigil 并生成一个访问方法。</p>
<p>看看上面的代码, 在方法 <code>describe</code> 中使用 <code>$!origin</code> 和 <code>$.origin</code> 有一个微妙但重要的区别。<code>$!origin</code> 是一种廉价且明显的属性查找。<code>$.origin</code> 是一个方法调用, 因此可以在子类中重写。只在你想要允许覆盖时使用 <code>$.origin</code>。</p>
<p>与子例程不同, 其他命名参数不会产生编译时或运行时错误。这允许通过<a href="https://docs.raku.org/language/functions#Re-dispatching">重新分派</a>来链接方法。</p>
<p>你可以编写自己的访问器来覆盖任何或所有自动生成的访问器。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$ⲧ</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="ow">xx</span> <span class="mi">4</span><span class="p">;</span> <span class="c1"># A tab-like thing </span>
<span class="k">class</span> <span class="nc">Journey</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.travelers</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.notes</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
 
    <span class="k">multi</span> <span class="k">method</span> <span class="nf">notes</span><span class="p">()</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$!notes</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="p">};</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nf">notes</span><span class="p">(</span> <span class="nb">Str</span> <span class="nv">$note</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$!notes</span> <span class="o">~=</span> <span class="p">&#34;</span><span class="nv">$note</span><span class="s2">\n</span><span class="nv">$ⲧ</span><span class="p">&#34;</span> <span class="p">};</span>
 
    <span class="k">method</span> <span class="nb">Str</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">⤷ </span><span class="nv">$!origin</span><span class="s2">\n</span><span class="nv">$ⲧ</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nf">notes</span><span class="p">()</span> <span class="o">~</span> <span class="p">&#34;</span><span class="nv">$!destination</span><span class="s2"> ⤶\n</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="p">}</span>
 
<span class="k">my</span> <span class="nv">$trip</span> <span class="o">=</span> <span class="n">Journey</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="p">:</span><span class="s">origin</span><span class="p">&lt;</span><span class="s">Here</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">destination</span><span class="p">&lt;</span><span class="s">There</span><span class="p">&gt;</span><span class="o">,</span>
                        <span class="s">travelers</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">þor Freya</span><span class="p">&gt;</span> <span class="p">);</span>
 
<span class="nv">$trip</span><span class="o">.</span><span class="nf">notes</span><span class="p">(&#34;</span><span class="s2">First steps</span><span class="p">&#34;);</span>
<span class="nf">notes</span> <span class="nv">$trip:</span> <span class="p">&#34;</span><span class="s2">Almost there</span><span class="p">&#34;;</span>
<span class="nb">print</span> <span class="nv">$trip</span><span class="p">;</span>
 
<span class="c1"># OUTPUT: </span>
<span class="c1">#⤷ Here </span>
<span class="c1">#       First steps </span>
<span class="c1">#       Almost there </span>
<span class="c1"># </span>
<span class="c1">#There ⤶ </span>
</code></pre></div><p>声明的 multi 方法 <code>notes</code> 使用不同的签名进行读写, <code>notes</code> 覆盖了 <code>$.notes</code> 声明中隐含的自动生成的方法。</p>
<p>请注意, 在 <code>notes $trip: &quot;Almost there&quot;</code> 中我们使用了间接调用语法, 它首先放置方法名称, 然后放置对象, 然后用冒号分隔参数：<code>method invocant: arguments</code>。只要感觉比经典的句点和括号更自然, 我们就可以使用这种语法。它的工作原理完全相同。</p>
<p>可以在运行时使用 <code>.&quot;&quot;</code> 运算符解析方法名称。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">has</span> <span class="nv">$.b</span> <span class="p">};</span>
<span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>
<span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="p">&#34;</span><span class="nv">$name</span><span class="p">&#34;()</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
<span class="c1"># OUTPUT: «(Any)␤» </span>
</code></pre></div><p>相对于先前的<a href="https://docs.raku.org/language/objects#Attributes">属性</a>部分, 过去用于更新 <code>$.notes</code> 的语法在本节已改变。代替赋值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$vacation</span><span class="o">.</span><span class="nf">notes</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Pack hiking gear and sunglasses!</span><span class="p">&#39;;</span>
</code></pre></div><p>我们现在做一个方法调用:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$trip</span><span class="o">.</span><span class="nf">notes</span><span class="p">(&#34;</span><span class="s2">First steps</span><span class="p">&#34;);</span>
</code></pre></div><p>覆盖默认的自动生成的访问器意味着它在返回赋值时提供可变容器不再可用。方法调用是将属性的更新添加到计算和逻辑的首选方法。许多现代语言可以通过使用 “setter” 方法重载赋值来更新属性。虽然 Raku 可以为此目的使用 <a href="https://github.com/raku/roast/blob/master/S12-attributes/mutators.t"><code>Proxy</code></a> 对象重载赋值运算符, 但是目前不鼓励使用复杂逻辑重载赋值运算符来设置属性作为<a href="https://6guts.wordpress.com/2016/11/25/perl-6-is-biased-towards-mutators-being-really-simple-thats-a-good-thing/">弱面向对象设计</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">has</span> <span class="nv">$!attribute</span>
<span class="k">method</span> <span class="nf">attribute</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>    
    <span class="k">has</span> <span class="nv">$.attr</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>    
    <span class="k">has</span> <span class="nv">$!attr</span><span class="p">;</span>    
    <span class="k">method</span> <span class="nf">attr</span><span class="p">()</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
        <span class="nv">$!attr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="类和实例方法">类和实例方法</h2>
<p>方法的签名可以有一个调用者(invocant)作为第一个参数, 后跟一个冒号, 这允许该方法引用它被调用的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">$me:</span> <span class="nv">$person</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hi, I am </span><span class="nv">$me</span><span class="o">.</span><span class="nf">^name</span><span class="p">()</span><span class="s2">, nice to meet you, </span><span class="nv">$person</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">greet</span><span class="p">(&#34;</span><span class="s2">Bob</span><span class="p">&#34;);</span> <span class="c1"># OUTPUT: «Hi, I am Foo, nice to meet you, Bob␤» </span>
</code></pre></div><p>在方法签名中提供调用者还允许通过使用<a href="https://docs.raku.org/type/Signature#Type_constraints">类型约束</a>将方法定义为类方法或对象方法。<code>::?CLASS</code> 变量可用于在编译时提供类名, 与 <code>:U</code>（对于类方法）或 <code>:D</code>（对于实例方法）结合使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Pizza</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!radius</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.ingredients</span><span class="p">;</span>
 
    <span class="c1"># 类方法: construct from a list of ingredients </span>
    <span class="k">method</span> <span class="nf">from-ingredients</span><span class="p">(</span><span class="vg">::?CLASS:U</span> <span class="nv">$pizza:</span> <span class="nv">@ingredients</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$pizza</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">ingredients</span> <span class="o">=&gt;</span> <span class="nv">@ingredients</span> <span class="p">);</span>
    <span class="p">}</span>
 
    <span class="c1"># 实例方法 </span>
    <span class="k">method</span> <span class="nf">get-radius</span><span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$!radius</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">.</span><span class="nf">from-ingredients:</span> <span class="p">&lt;</span><span class="s">cheese pepperoni vegetables</span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nf">ingredients</span><span class="p">;</span>     <span class="c1"># OUTPUT: «[cheese pepperoni vegetables]␤» </span>
<span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nf">get-radius</span><span class="p">;</span>      <span class="c1"># OUTPUT: «42␤» </span>
<span class="nb">say</span> <span class="n">Pizza</span><span class="o">.</span><span class="nf">get-radius</span><span class="p">;</span>   <span class="c1"># This will fail. </span>

<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">:\n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1"># OUTPUT: «X::Parameter::InvalidConcreteness:␤ </span>
<span class="c1">#          Invocant of method &#39;get-radius&#39; must be </span>
<span class="c1">#          an object instance of type &#39;Pizza&#39;, </span>
<span class="c1">#          not a type object of type &#39;Pizza&#39;. </span>
<span class="c1">#          Did you forget a &#39;.new&#39;?» </span>
</code></pre></div><p>通过使用<a href="https://docs.raku.org/syntax/multi">multi</a>声明符, 方法既可以是类方法也可以是对象方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nb">f</span><span class="p">(</span><span class="vg">::?CLASS:U</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">class method</span><span class="p">&#34;</span>  <span class="p">}</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nb">f</span><span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">object method</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="n">C</span><span class="o">.</span><span class="nb">f</span><span class="p">;</span>       <span class="c1"># OUTPUT: «class method␤» </span>
<span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">f</span><span class="p">;</span>   <span class="c1"># OUTPUT: «object method␤» </span>
</code></pre></div><h2 id="self">self</h2>
<p>在方法内部, 术语 <code>self</code> 可用并绑定到调用对象。<code>self</code> 可以用来调用调用者的其他方法, 包括构造函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Box</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.data</span><span class="p">;</span>
 
    <span class="k">method</span> <span class="nf">make-new-box-from</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="s">data</span> <span class="o">=&gt;</span> <span class="nv">$!data</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>self</code> 也可以用在类方法或实例方法中, 但要注意尝试从另一个方法调用一种类型的方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">g</span><span class="p">()</span>            <span class="p">{</span> <span class="mi">42</span>     <span class="p">}</span>
    <span class="k">method</span> <span class="nb">f</span><span class="p">(</span><span class="vg">::?CLASS:U</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">g</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nb">d</span><span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">f</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">C</span><span class="o">.</span><span class="nb">f</span><span class="p">;</span>        <span class="c1"># OUTPUT: «42␤» </span>
<span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">d</span><span class="p">;</span>    <span class="c1"># This will fail. </span>

<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">:\n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
<span class="c1"># OUTPUT: «X::Parameter::InvalidConcreteness:␤ </span>
<span class="c1">#          Invocant of method &#39;f&#39; must be a type object of type &#39;C&#39;, </span>
<span class="c1">#          not an object instance of type &#39;C&#39;.  Did you forget a &#39;multi&#39;?» </span>
</code></pre></div><p><code>self</code> 也可以与属性一起使用, 只要它们具有访问器。<code>self.a</code> 将为声明为 <code>has $.a</code> 的属性调用访问器。然而, <code>self.a</code> 和 <code>$.a</code> 之间存在差异, 因为后者将项化; <code>$.a</code> 将等同于 <code>self.a.item</code> 或 <code>$(self.a)</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">method</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">self</span><span class="o">.</span><span class="nb">x</span><span class="p">;</span> <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$.x</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">b</span><span class="p">;</span> <span class="c1"># OUTPUT: «1␤2␤3␤(1 2 3)␤» </span>
</code></pre></div><p>方法调用的冒号语法仅支持使用方法调用 <code>self</code>, 而不支持快捷方式。</p>
<p>请注意, 如果 <a href="https://docs.raku.org/type/Mu">Mu</a> 中的相关方法 <code>bless</code>, <code>CREATE</code> 没有重载, <code>self</code> 将指向这些方法的类型对象。</p>
<p>在另一方面, 在初始化的不同阶段, 在实例上调用子方法 <code>BUILD</code> 和 <code>TWEAK</code>。子类中同名的子方法尚未运行, 因此你不应该依赖这些方法中的潜在虚方法调用。</p>
<h3 id="私有方法">私有方法</h3>
<p>方法名前带有感叹号的方法不能从定义类之外的任何地方调用; 这些方法是私有的, 因为它们在声明它们的类之外是不可见的。使用感叹号而不是点号调用私有方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">FunMath</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.value</span> <span class="k">is</span> <span class="k">required</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">!do-subtraction</span><span class="p">(</span> <span class="nv">$num</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$num</span> <span class="o">~~</span> <span class="nb">Str</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nv">$!value</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nv">$num</span><span class="o">.</span><span class="nb">chars</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nv">$!value</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nv">$num</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">minus</span><span class="p">(</span> <span class="nv">$minuend:</span> <span class="nv">$subtrahend</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1"># invoking the private method on the explicit invocant </span>
        <span class="nv">$minuend</span><span class="o">!</span><span class="nf">do-subtraction</span><span class="p">(</span><span class="nv">$subtrahend</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$five</span> <span class="o">=</span> <span class="n">FunMath</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">value</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$five</span><span class="o">.</span><span class="nf">minus</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>         <span class="c1"># OUTPUT: «-1␤» </span>
<span class="nb">say</span> <span class="nv">$five</span><span class="o">.</span><span class="nf">do-subtraction</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

<span class="k">CATCH</span> <span class="p">{</span> <span class="k">default</span> <span class="p">{</span> <span class="nb">put</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">:\n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">}</span>
<span class="c1"># OUTPUT: «X::Method::NotFound: </span>
<span class="c1"># No such method &#39;do-subtraction&#39; for invocant of type </span>
<span class="c1"># &#39;FunMath&#39;. Did you mean &#39;!do-subtraction&#39;?␤» </span>
</code></pre></div><p>私有方法不能被子类继承。</p>
<h3 id="子方法">子方法</h3>
<p>子方法是子类不继承的公共方法。该名称源于它们在语义上与子例程类似的事实。</p>
<p>子方法对于对象构造和销毁任务以及特定于特定类型的任务非常有用, 因此子类型必须重写它们。</p>
<p>例如, <a href="https://docs.raku.org/type/Mu#method_new">默认方法 new</a> 在<a href="https://docs.raku.org/language/objects#Inheritance">继承</a>链中的每个类上调用 submethod <code>BUILD</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point2D</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
 
    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">$!x</span><span class="o">,</span> <span class="o">:</span><span class="nv">$!y</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Initializing Point2D</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">class</span> <span class="nc">InvertiblePoint2D</span> <span class="k">is</span> <span class="nc">Point2D</span> <span class="p">{</span>
    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Initializing InvertiblePoint2D</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nb">invert</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="o">-</span> <span class="nv">$.x</span>, <span class="s">y</span> <span class="o">=&gt;</span> <span class="o">-</span> <span class="nv">$.y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="nb">say</span> <span class="n">InvertiblePoint2D</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1"># OUTPUT: «Initializing Point2D␤» </span>
<span class="c1"># OUTPUT: «Initializing InvertiblePoint2D␤» </span>
<span class="c1"># OUTPUT: «InvertiblePoint2D.new(x =&gt; 1, y =&gt; 2)␤» </span>
</code></pre></div><p>另请参见：<a href="https://docs.raku.org/language/objects#Object_construction">Object_construction</a>。</p>
<h2 id="继承">继承</h2>
<p>类可以有父类:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Child</span> <span class="k">is</span> <span class="nc">Parent1</span> <span class="k">is</span> <span class="nc">Parent2</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>如果在子类上调用一个方法, 但是子类没有提供该方法, 则调用其中一个父类中同名方法(如果存在)。父类被查询的顺序就叫做方法解析顺序(MRO)。Raku 使用 <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 方法解析顺序</a>。你可以通过调用类型的元类型方法得知这个类型的 MRO.</p>
<p>如果一个类没有指定它的父类, 就默认使用 <a href="https://docs.raku.org/type/Any">Any</a>. 所有的类都直接或间接的派生于 <a href="https://docs.raku.org/type/Mu">Mu</a> - 类型层级结构的根。</p>
<p>所有对公共方法的调用都是 <code>C++</code> 意义上的“虚拟”, 这意味着对象的实际类型决定了要调用的方法, 而不是声明的类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Parent</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">frob</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">the parent class frobs</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">class</span> <span class="nc">Child</span> <span class="k">is</span> <span class="nc">Parent</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">frob</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">the child&#39;s somewhat more fancy frob is called</span><span class="p">&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">my</span> <span class="n">Parent</span> <span class="nv">$test</span><span class="p">;</span>
<span class="nv">$test</span> <span class="o">=</span> <span class="n">Child</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nv">$test</span><span class="o">.</span><span class="nf">frob</span><span class="p">;</span> <span class="c1"># calls the frob method of Child rather than Parent </span>
<span class="c1"># OUTPUT: «the child&#39;s somewhat more fancy frob is called␤» </span>
</code></pre></div><h2 id="对象构造">对象构造</h2>
<p>对象通常通过方法调用创建, 或者通过类型对象或者通过同类型的其它对象创建。</p>
<p>类 <a href="https://docs.raku.org/type/Mu">Mu</a> 提供了一个名为 <a href="https://docs.raku.org/routine/new">new</a> 的构造函数方法, 它接受命名<a href="https://docs.raku.org/language/functions#Arguments">参数</a>并使用它们来初始化公共属性。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">5</span>, <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>
<span class="c1">#             ^^^ inherited from class Mu</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">x: </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$p</span><span class="o">.</span><span class="nb">x</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">y: </span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">$p</span><span class="o">.</span><span class="nf">y</span><span class="p">;</span>
<span class="c1"># OUTPUT: «x: 5␤» </span>
<span class="c1"># OUTPUT: «y: 2␤» </span>
</code></pre></div><p><code>Mu.new</code> 在调用者身上调用 <code>bless</code> 方法, 传递所有的命名<a href="https://docs.raku.org/language/functions#Arguments">参数</a>。 <code>bless</code> 创建新的对象, 然后以反向方法解析顺序(即从<a href="https://docs.raku.org/type/Mu">Mu</a>到大多数派生类)遍历所有子类, 并且在每个类中检查是否存在名为 <code>BUILD</code> 的方法。 如果该方法存在, 则使用该方法中的所有命名参数调用该 <code>new</code> 方法。如果不存在名为 <code>BUILD</code> 的方法, 这个类的公开属性就会用同名的命名参数进行初始化。  在任何一种情况下, 如果 <strong>BULID</strong> 方法和 <strong>默认构造函数</strong> 都没有对属性进行初始化, 则应用默认值。这意味着 <code>BUILD</code> 可以更改属性, 但它无权访问声明为其默认值的属性的内容; 这些只在 <code>TWEAK</code>（见下文）中可用, 它可以“看到”在类的声明中初始化的属性的内容。</p>
<p>在 <code>BUILD</code> 被调用之后, 名为 <code>TWEAK</code> 的方法会被调用, 如果它们存在, 传递给 <code>new</code> 的所有命名参数也会传递给 <code>TWEAK</code>。请参阅下面的使用示例。</p>
<p>由于 <code>BUILD</code> 和 <code>TWEAK</code> 子方法的默认行为, 派生于 <code>Mu</code> 的 <code>new</code> 构造函数的命名参数可直接对应的任何方法解析顺序类的公共属性, 或对应于任何 <code>BUILD</code> 或 <code>TWEAK</code> 子方法的任何命名参数。</p>
<p>此对象构造方案对自定义构造函数有几个含义。首先, 自定义 <code>BUILD</code> 方法应始终是子方法, 否则它们会破坏子类中的属性初始化。其次, <code>BUILD</code> 子方法可用于在对象构造时运行自定义代码。它们还可用于为属性初始化创建别名：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">EncodedBuffer</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.enc</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.data</span><span class="p">;</span>
 
    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(:</span><span class="s">encoding</span><span class="p">(</span><span class="o">:</span><span class="nv">$enc</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">$data</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$!enc</span>  <span class="o">:=</span>  <span class="nv">$enc</span><span class="p">;</span>
        <span class="nv">$!data</span> <span class="o">:=</span> <span class="nv">$data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$b1</span> <span class="o">=</span> <span class="n">EncodedBuffer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">encoding</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">UTF-8</span><span class="p">&#39;</span>, <span class="s">data</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">64</span>, <span class="mi">65</span><span class="o">]</span> <span class="p">);</span>
<span class="k">my</span> <span class="nv">$b2</span> <span class="o">=</span> <span class="n">EncodedBuffer</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">enc</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">UTF-8</span><span class="p">&#39;</span>, <span class="s">data</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">64</span>, <span class="mi">65</span><span class="o">]</span> <span class="p">);</span>
<span class="c1">#  both enc and encoding are allowed now </span>
</code></pre></div><p>因为传递实参给子例程把实参绑定给了形参, 如果把属性用作形参, 则不需要单独的绑定步骤。 所以上面的例子可以写为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(:</span><span class="s">encoding</span><span class="p">(</span><span class="o">:</span><span class="nv">$!enc</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">$!data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># nothing to do here anymore, the signature binding</span>
    <span class="c1"># does all the work for us.</span>
<span class="p">}</span>
</code></pre></div><p>但是, 当属性可能具有特殊类型要求（例如 <code>:$!id</code> 必须为正整数）时, 请谨慎使用此属性的自动绑定。请记住, 除非您专门处理此属性, 否则将分配默认值, 并且该默认值将为 <code>Any</code>, 这会导致类型错误。</p>
<p>第三个含义是, 如果你想要一个接受位置参数的构造函数, 你必须编写自己的 <code>new</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">$x</span><span class="o">,</span> <span class="o">:</span><span class="nv">$y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然而, 这不是最佳实践, 因为它使得从子类正确地初始化对象变得更难了。</p>
<p>另外需要注意的是, 名字 <code>new</code> 在 Raku 中并不特别。它只是一个常见的约定, 在<a href="https://docs.raku.org/routine/new">大多数Raku类中</a>都非常彻底。你可以从在调用的任何方法调用 <code>bless</code>, 或者使用 <code>CREATE</code> 来摆弄低级别的工作。</p>
<p><code>TWEAK</code> 子方法允许你在对象构造后检查或修改属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">RectangleWithCachedArea</span> <span class="p">{</span>
    <span class="k">has</span> <span class="p">(</span><span class="nv">$.x1</span><span class="o">,</span> <span class="nv">$.x2</span><span class="o">,</span> <span class="nv">$.y1</span><span class="o">,</span> <span class="nv">$.y2</span><span class="p">);</span>
    <span class="k">has</span> <span class="nv">$.area</span><span class="p">;</span>

    <span class="k">submethod</span> <span class="nb">TWEAK</span><span class="p">()</span> <span class="p">{</span>
        <span class="nv">$!area</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="p">(</span><span class="nv">$!x2</span> <span class="o">-</span> <span class="nv">$!x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="nv">$!y2</span> <span class="o">-</span> <span class="nv">$!y1</span><span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="nb">say</span> <span class="n">RectangleWithCachedArea</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">x2</span> <span class="o">=&gt;</span> <span class="mi">5</span>, <span class="s">x1</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">y2</span> <span class="o">=&gt;</span> <span class="mi">1</span>, <span class="s">y1</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="nf">area</span><span class="p">;</span>
<span class="c1"># OUTPUT: «4␤» </span>
</code></pre></div><h2 id="对象克隆">对象克隆</h2>
<p>克隆是使用所有对象上可用的<a href="https://docs.raku.org/routine/clone">clone</a>方法完成的, 这些克隆方法可以浅克隆公共和私有属性。公共属性的新值可以作为命名参数提供。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.foo</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.bar</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">my</span> <span class="nv">$o1</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$o2</span> <span class="o">=</span> <span class="nv">$o1</span><span class="o">.</span><span class="nb">clone</span><span class="o">:</span> <span class="p">:</span><span class="s">bar</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>

<span class="nb">say</span> <span class="nv">$o1</span><span class="p">;</span> <span class="c1"># Foo.new(foo =&gt; 42, bar =&gt; 100) </span>
<span class="nb">say</span> <span class="nv">$o2</span><span class="p">;</span> <span class="c1"># Foo.new(foo =&gt; 42, bar =&gt; 5000) </span>
</code></pre></div><p>有关如何<a href="https://docs.raku.org/routine/clone">克隆</a>非标量属性的详细信息, 请参阅文档以获取克隆, 以及实现自己的自定义克隆方法的示例。</p>
<h2 id="角色">角色</h2>
<p>角色是属性和方法的集合; 但是, 与类不同, 角色仅用于描述对象行为的一部分; 这就是为什么一般来说, 角色应该在类和对象中混合使用。通常, 类用于管理对象, 而角色用于管理对象内的行为和代码重用。</p>
<p>角色使用关键字 <code>role</code> 放在所声明的角色名称前面。角色使用 <code>does</code> 关键字 mixed in, does 关键字放在角色名之前。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">ⲧ</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="ow">xx</span> <span class="mi">4</span><span class="p">;</span> <span class="c1"># Just a ⲧab </span>

<span class="k">role</span> <span class="nc">Notable</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.notes</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
 
    <span class="k">multi</span> <span class="k">method</span> <span class="nf">notes</span><span class="p">()</span> <span class="p">{</span> <span class="p">&#34;</span><span class="nv">$!notes</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="p">};</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nf">notes</span><span class="p">(</span> <span class="nb">Str</span> <span class="nv">$note</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$!notes</span> <span class="o">~=</span> <span class="p">&#34;</span><span class="nv">$note</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">ⲧ</span> <span class="p">};</span>
<span class="p">}</span>
 
<span class="k">class</span> <span class="nc">Journey</span> <span class="k">does</span> <span class="nc">Notable</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.origin</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.destination</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.travelers</span><span class="p">;</span>
 
    <span class="k">method</span> <span class="nb">Str</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">⤷ </span><span class="nv">$!origin</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">ⲧ</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nf">notes</span><span class="p">()</span> <span class="o">~</span> <span class="p">&#34;</span><span class="nv">$!destination</span><span class="s2"> ⤶\n</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="p">}</span>
 
<span class="k">my</span> <span class="nv">$trip</span> <span class="o">=</span> <span class="n">Journey</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="p">:</span><span class="s">origin</span><span class="p">&lt;</span><span class="s">Here</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">destination</span><span class="p">&lt;</span><span class="s">There</span><span class="p">&gt;</span><span class="o">,</span>
                        <span class="s">travelers</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">þor Freya</span><span class="p">&gt;</span> <span class="p">);</span>
 
<span class="nv">$trip</span><span class="o">.</span><span class="nf">notes</span><span class="p">(&#34;</span><span class="s2">First steps</span><span class="p">&#34;);</span>
<span class="nf">notes</span> <span class="nv">$trip:</span> <span class="p">&#34;</span><span class="s2">Almost there</span><span class="p">&#34;;</span>
<span class="nb">print</span> <span class="nv">$trip</span><span class="p">;</span>

<span class="c1"># OUTPUT: </span>
<span class="c1">#⤷ Here </span>
<span class="c1">#       First steps </span>
<span class="c1">#       Almost there </span>
<span class="c1"># </span>
<span class="c1">#There ⤶ </span>
</code></pre></div><p>一旦编译器解析角色声明的结束大括号, 角色就是不可变的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">Serializable</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">serialize</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span> <span class="c1"># 很粗超的序列化</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">deserialization-code</span><span class="p">(</span><span class="nv">$buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">EVAL</span> <span class="nv">$buf</span><span class="p">;</span> <span class="c1">#  反转 .perl 操作</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Point</span> <span class="k">does</span> <span class="nc">Serializable</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">y</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="k">my</span> <span class="nv">$serialized</span> <span class="o">=</span> <span class="nv">$p</span><span class="o">.</span><span class="nf">serialize</span><span class="p">;</span>  <span class="c1"># 由 role 提供的方法</span>
<span class="k">my</span> <span class="nv">$clone-of-p</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nf">deserialization-code</span><span class="p">(</span><span class="nv">$serialized</span><span class="p">);</span>

<span class="nb">say</span> <span class="nv">$clone-of-p</span><span class="o">.</span><span class="nb">x</span><span class="p">;</span>      <span class="c1"># 1</span>
</code></pre></div><p>编译器一解析到 role 声明的闭合花括号, roles 就不可变了。</p>
<h2 id="应用角色">应用角色</h2>
<p>角色应用程序与类继承有很大不同。将角色应用于类时, 该角色的方法将复制到类中。如果将多个角色应用于同一个类, 则冲突（例如, 同名的属性或 non-multi 方法）会导致编译时错误, 这可以通过在类中提供同名的方法来解决。</p>
<p>这比多重继承安全得多, 其中编译器从不检测冲突, 而是解析为方法解析顺序中较早出现的超类, 这可能不是程序员想要的。</p>
<p>例如, 如果你已经发现了一种有效的方法来骑牛, 并试图把它作为一种新的流行交通形式推销, 你可能会有一个 <code>Bull</code> 类, 对于你在房子周围的所有公牛, 以及一个 <code>Automobile</code> 类, 你可以驾驶的东西。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Bull</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Bool</span> <span class="nv">$.castrated</span> <span class="o">=</span> <span class="nb">False</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">steer</span> <span class="p">{</span>
        <span class="c1"># Turn your bull into a steer </span>
        <span class="nv">$!castrated</span> <span class="o">=</span> <span class="nb">True</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Automobile</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.direction</span><span class="p">;</span>
    <span class="k">method</span> <span class="nf">steer</span><span class="p">(</span><span class="nv">$!direction</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Taurus</span> <span class="k">is</span> <span class="nc">Bull</span> <span class="k">is</span> <span class="nc">Automobile</span> <span class="p">{</span> <span class="p">}</span>
 
<span class="k">my</span> <span class="nv">$t</span> <span class="o">=</span> <span class="n">Taurus</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$t</span><span class="o">.</span><span class="nf">steer</span><span class="p">;</span>
<span class="c1"># OUTPUT: «Taurus.new(castrated =&gt; Bool::True, direction =&gt; Any)␤» </span>
</code></pre></div><p>通过这种设置, 您的贫困客户将发现自己无法转动他们的金牛座, 您将无法生产更多的产品！在这种情况下, 使用角色可能更好：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">Bull-Like</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Bool</span> <span class="nv">$.castrated</span> <span class="o">=</span> <span class="nb">False</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">steer</span> <span class="p">{</span>
        <span class="c1"># Turn your bull into a steer </span>
        <span class="nv">$!castrated</span> <span class="o">=</span> <span class="nb">True</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">role</span> <span class="nc">Steerable</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Real</span> <span class="nv">$.direction</span><span class="p">;</span>
    <span class="k">method</span> <span class="nf">steer</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$!direction</span> <span class="o">+=</span> <span class="nv">$d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Taurus</span> <span class="k">does</span> <span class="nc">Bull-Like</span> <span class="k">does</span> <span class="nc">Steerable</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>这段代码会死于：</p>
<pre><code>===SORRY!===
Method 'steer' must be resolved by class Taurus because it exists in
multiple roles (Steerable, Bull-Like)
</code></pre><p>这项检查可以为你省去很多麻烦：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Taurus</span> <span class="k">does</span> <span class="nc">Bull-Like</span> <span class="k">does</span> <span class="nc">Steerable</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">steer</span><span class="p">(</span><span class="nv">$direction</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">Steerable::steer</span><span class="p">(</span><span class="nv">$direction</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>将角色应用于第二个角色时, 实际应用程序将延迟, 直到第二个角色应用于类, 此时两个角色都将应用于该类。从而</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span> <span class="p">{</span>
    <span class="c1"># methods here </span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">R2</span> <span class="k">does</span> <span class="nc">R1</span> <span class="p">{</span>
    <span class="c1"># methods here </span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="nc">R2</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>产生相同类 <code>C</code> 为</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span> <span class="p">{</span>
    <span class="c1"># methods here </span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">R2</span> <span class="p">{</span>
    <span class="c1"># methods here </span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="nc">R1</span> <span class="k">does</span> <span class="nc">R2</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><h2 id="stubs">Stubs</h2>
<p>当角色包含 <a href="https://docs.raku.org/routine/....html">stubbed</a> 方法时, 必须在将角色应用于类时提供同名方法的 non-stubbed  版本。这允许您创建充当抽象接口的角色。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">AbstractSerializable</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">serialize</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>        <span class="c1"># literal ... here marks the </span>
                                      <span class="c1"># method as a stub </span>
<span class="p">}</span>
 
<span class="c1"># the following is a compile time error, for example </span>
<span class="c1">#        Method &#39;serialize&#39; must be implemented by Point because </span>
<span class="c1">#        it&#39;s required by a role </span>
 
<span class="k">class</span> <span class="nc">APoint</span> <span class="k">does</span> <span class="nc">AbstractSerializable</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="c1"># this works: </span>
<span class="k">class</span> <span class="nc">SPoint</span> <span class="k">does</span> <span class="nc">AbstractSerializable</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>
    <span class="k">method</span> <span class="nf">serialize</span><span class="p">()</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">p(</span><span class="nv">$.x</span><span class="s2">, </span><span class="nv">$.y</span><span class="s2">)</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>stubbed 方法的实现也可以由另一个角色提供。</p>
<h2 id="继承-1">继承</h2>
<p>角色不能从类继承, 但它们可以携带类, 导致任何具有该角色的类从承载的类继承。所以, 如果你写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">A</span> <span class="k">is</span> <span class="nb">Exception</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="ne">X::Ouch</span> <span class="k">does</span> <span class="nc">A</span> <span class="p">{</span> <span class="p">}</span>
<span class="ne">X::Ouch</span><span class="o">.^</span><span class="nb">parents</span><span class="o">.</span><span class="nb">say</span> <span class="c1"># OUTPUT: «((Exception))␤»</span>
</code></pre></div><p>然后 <code>X::Ouch</code> 将直接从 Exception 继承, 我们可以通过列出其父项来看到。</p>
<p>由于它们不使用可能称为继承的东西, 因此角色不是类层次结构的一部分。使用 <code>.^roles</code> 元方法列出角色, 它使用 <code>transitive</code> 标记来包含所有级别或仅包含第一个级别。尽管如此, 仍然可以使用智能匹配或类型约束来测试类或实例, 以查看它是否起作用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">F</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">G</span> <span class="k">does</span> <span class="nc">F</span> <span class="p">{</span> <span class="p">}</span>
<span class="n">G</span><span class="o">.^</span><span class="nf">roles</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                    <span class="c1"># OUTPUT: «((F))␤» </span>
<span class="k">role</span> <span class="nc">Ur</span> <span class="p">{}</span>
<span class="k">role</span> <span class="nc">Ar</span> <span class="k">does</span> <span class="nc">Ur</span> <span class="p">{}</span>
<span class="k">class</span> <span class="nc">Whim</span> <span class="k">does</span> <span class="nc">Ar</span> <span class="p">{};</span> <span class="n">Whim</span><span class="o">.^</span><span class="nf">roles</span><span class="p">(:!</span><span class="s">transitive</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>   <span class="c1"># OUTPUT: «((Ar))␤» </span>
<span class="nb">say</span> <span class="n">G</span> <span class="o">~~</span> <span class="n">F</span><span class="p">;</span>                      <span class="c1"># OUTPUT: «True␤» </span>
<span class="k">multi</span> <span class="nf">a</span> <span class="p">(</span><span class="n">F</span> <span class="nv">$a</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">F</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">a</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span>   <span class="p">{</span> <span class="p">&#34;</span><span class="s2">not F</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span> <span class="p">}</span>
<span class="nf">a</span><span class="p">(</span><span class="n">G</span><span class="p">);</span>                            <span class="c1"># OUTPUT: «F␤» </span>
</code></pre></div><h2 id="主从秩序">主从秩序</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">M</span> <span class="p">{</span>
  <span class="k">method</span> <span class="nb">f</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I am in role M</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">method</span> <span class="nb">f</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I am in class A</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">A</span> <span class="k">does</span> <span class="nc">M</span> <span class="p">{</span>
  <span class="k">method</span> <span class="nb">f</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I am in class B</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">class</span> <span class="nc">C</span> <span class="k">is</span> <span class="nc">A</span> <span class="k">does</span> <span class="nc">M</span> <span class="p">{</span> <span class="p">}</span>
 
<span class="n">B</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">f</span><span class="p">;</span> <span class="c1"># OUTPUT «I am in class B␤» </span>
<span class="n">C</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">f</span><span class="p">;</span> <span class="c1"># OUTPUT «I am in role M␤» </span>
</code></pre></div><p>请注意, multi-method 的每个候选项都是它自己的方法。在这种情况下, 以上仅适用于两个这样的候选项具有相同签名的情况。否则, 没有冲突, 候选者只是添加到 multi-method 中。</p>
<h2 id="自动角色双关">自动角色双关</h2>
<p>任何直接实例化角色或将其用作类型对象的尝试都将自动创建一个与角色同名的类, 从而可以透明地使用角色, 就好像它是一个类一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">abs</span> <span class="p">{</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nv">$.x</span> <span class="o">*</span> <span class="nv">$.x</span> <span class="o">+</span> <span class="nv">$.y</span> <span class="o">*</span> <span class="nv">$.y</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">dimensions</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">6</span>, <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="nb">abs</span><span class="p">;</span> <span class="c1"># OUTPUT «10␤» </span>
<span class="nb">say</span> <span class="n">Point</span><span class="o">.</span><span class="nf">dimensions</span><span class="p">;</span>              <span class="c1"># OUTPUT «2␤» </span>
</code></pre></div><p>我们把这种自动创建的类叫双关, 并且将生成的类叫双关语。</p>
<p>但是, Punning 不是由大多数<a href="https://docs.raku.org/language/mop">元编程</a>构造引起的, 因为它们有时用于直接使用角色。</p>
<h2 id="参数化角色">参数化角色</h2>
<p>角色可以通过在方括号中给它们签名来参数化：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">BinaryTree</span><span class="o">[:</span><span class="p">:</span><span class="s">Type</span><span class="o">]</span> <span class="p">{</span>
    <span class="k">has</span> <span class="n">BinaryTree</span><span class="o">[</span><span class="n">Type</span><span class="o">]</span> <span class="nv">$.left</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">BinaryTree</span><span class="o">[</span><span class="n">Type</span><span class="o">]</span> <span class="nv">$.right</span><span class="p">;</span>
    <span class="k">has</span> <span class="n">Type</span> <span class="nv">$.node</span><span class="p">;</span>
 
    <span class="k">method</span> <span class="nf">visit-preorder</span><span class="p">(</span><span class="nv">&amp;cb</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cb</span> <span class="nv">$.node</span><span class="p">;</span>
        <span class="k">for</span> <span class="nv">$.left</span><span class="o">,</span> <span class="nv">$.right</span> <span class="k">-&gt;</span> <span class="nv">$branch</span> <span class="p">{</span>
            <span class="nv">$branch</span><span class="o">.</span><span class="nf">visit-preorder</span><span class="p">(</span><span class="nv">&amp;cb</span><span class="p">)</span> <span class="k">if</span> <span class="nb">defined</span> <span class="nv">$branch</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">visit-postorder</span><span class="p">(</span><span class="nv">&amp;cb</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nv">$.left</span><span class="o">,</span> <span class="nv">$.right</span> <span class="k">-&gt;</span> <span class="nv">$branch</span> <span class="p">{</span>
            <span class="nv">$branch</span><span class="o">.</span><span class="nf">visit-postorder</span><span class="p">(</span><span class="nv">&amp;cb</span><span class="p">)</span> <span class="k">if</span> <span class="nb">defined</span> <span class="nv">$branch</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cb</span> <span class="nv">$.node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">new-from-list</span><span class="p">(</span><span class="vg">::?CLASS:U</span><span class="o">:</span> <span class="o">*</span><span class="nv">@el</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$middle-index</span> <span class="o">=</span> <span class="nv">@el</span><span class="o">.</span><span class="nb">elems</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">@left</span>         <span class="o">=</span> <span class="nv">@el</span><span class="o">[</span><span class="mi">0</span> <span class="o">..</span> <span class="nv">$middle-index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$middle</span>       <span class="o">=</span> <span class="nv">@el</span><span class="o">[</span><span class="nv">$middle-index</span><span class="o">]</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">@right</span>        <span class="o">=</span> <span class="nv">@el</span><span class="o">[</span><span class="nv">$middle-index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">..</span> <span class="o">*]</span><span class="p">;</span>

        <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
            <span class="s">node</span>    <span class="o">=&gt;</span> <span class="nv">$middle</span>,
            <span class="s">left</span>    <span class="o">=&gt;</span> <span class="nv">@left</span>  <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">new-from-list</span><span class="p">(</span><span class="nv">@left</span><span class="p">)</span>  <span class="o">!!</span> <span class="nb">self</span>,
            <span class="s">right</span>   <span class="o">=&gt;</span> <span class="nv">@right</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">new-from-list</span><span class="p">(</span><span class="nv">@right</span><span class="p">)</span> <span class="o">!!</span> <span class="nb">self</span>,
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">my</span> <span class="nv">$t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="o">[</span><span class="nb">Int</span><span class="o">].</span><span class="nf">new-from-list</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="nv">$t</span><span class="o">.</span><span class="nf">visit-preorder</span><span class="p">(</span><span class="nv">&amp;say</span><span class="p">);</span>    <span class="c1"># OUTPUT: «5␤4␤6␤» </span>
<span class="nv">$t</span><span class="o">.</span><span class="nf">visit-postorder</span><span class="p">(</span><span class="nv">&amp;say</span><span class="p">);</span>   <span class="c1"># OUTPUT: «4␤6␤5␤» </span>
</code></pre></div><p>这里, 签名只包含类型捕获, 但任何签名都可以：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">enum</span> <span class="n">Severity</span> <span class="p">&lt;</span><span class="s">debug info warn error critical</span><span class="p">&gt;;</span>
 
<span class="k">role</span> <span class="nc">Logging</span><span class="o">[</span><span class="nv">$filehandle</span> <span class="o">=</span> <span class="vg">$*ERR</span><span class="o">]</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nb">log</span><span class="p">(</span><span class="n">Severity</span> <span class="nv">$sev</span><span class="o">,</span> <span class="nv">$message</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$filehandle</span><span class="o">.</span><span class="nb">print</span><span class="p">(&#34;</span><span class="s2">[</span><span class="p">{</span><span class="nb">uc</span> <span class="nv">$sev</span><span class="p">}</span><span class="s2">] </span><span class="nv">$message</span><span class="s2">\n</span><span class="p">&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="n">Logging</span><span class="o">[</span><span class="vg">$*OUT</span><span class="o">].</span><span class="nb">log</span><span class="p">(</span><span class="n">debug</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here we go</span><span class="p">&#39;);</span> <span class="c1"># OUTPUT: «[DEBUG] here we go␤» </span>
</code></pre></div><p>您可以拥有多个同名角色, 但签名不同; 多重分派的正常规则适用于选择多个候选者。</p>
<h2 id="混合角色">混合角色</h2>
<p>角色可以混合到对象中。角色的给定属性和方法将添加到对象已有的方法和属性中。支持多个mixin和匿名角色。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{&#39;</span><span class="s1">hidden!</span><span class="p">&#39;}</span> <span class="p">};</span>
<span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">but</span> <span class="ow">R</span><span class="err">;</span>
<span class="k">sub</span> <span class="nb">f</span><span class="p">(</span>\<span class="n">bound</span><span class="p">){</span> <span class="nb">put</span> <span class="n">bound</span> <span class="p">};</span>
<span class="nb">f</span><span class="p">(</span><span class="nv">$i</span><span class="p">);</span> <span class="c1"># OUTPUT: «hidden!␤» </span>
<span class="k">my</span> <span class="nv">@positional</span> <span class="o">:=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;</span> <span class="k">but</span> <span class="ow">R</span><span class="err">;</span>
<span class="nb">say</span> <span class="nv">@positional</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «List+{R}␤» </span>
</code></pre></div><p>请注意, 对象混合了角色, 而不是对象的类或容器。因此, <code>@</code>-sigiled 容器将需要绑定以使角色坚持, 如示例中的 <code>@positional</code> 所示。某些运算符将返回一个新值, 从而有效地从结果中删除 mixin。这就是为什么使用 <code>does</code> 在变量声明中混合角色可能更为清晰：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{};</span>
<span class="k">my</span> <span class="nv">@positional</span> <span class="k">does</span> <span class="nc">R</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">a b</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">@positional</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Array+{R}␤» </span>
</code></pre></div><p>运算符 <code>infix:&lt;but&gt;</code> 比列表构造函数窄。提供要混合的角色列表时, 请始终使用括号。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">m</span> <span class="p">{}</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R2</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">n</span> <span class="p">{}</span> <span class="p">}</span>
<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">but</span> <span class="nc">R1</span><span class="o">,</span><span class="n">R2</span><span class="p">;</span> <span class="c1"># R2 is in sink context, issues a WARNING </span>
<span class="nb">say</span> <span class="nv">$a</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
<span class="c1"># OUTPUT: «Int+{R1}␤» </span>
<span class="k">my</span> <span class="nv">$all-roles</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">but</span> <span class="p">(</span><span class="n">R1</span><span class="o">,</span><span class="n">R2</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$all-roles</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># OUTPUT: «Int+{R1,R2}␤» </span>
</code></pre></div><p>Mixins 可用于对象生命中的任何一点。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># A counter for Table of Contents </span>
<span class="k">role</span> <span class="nc">TOC-Counter</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@!counters</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{</span> <span class="nv">@!counters</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">inc</span><span class="p">(</span><span class="nv">$level</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">@!counters</span><span class="o">[</span><span class="nv">$level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]++</span><span class="p">;</span>
        <span class="nv">@!counters</span><span class="o">.</span><span class="nb">splice</span><span class="p">(</span><span class="nv">$level</span><span class="p">);</span>
        <span class="nb">self</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">my</span> <span class="nb">Num</span> <span class="nv">$toc-counter</span> <span class="o">=</span> <span class="n">NaN</span><span class="p">;</span>     <span class="c1"># don&#39;t do math with Not A Number </span>
<span class="nb">say</span> <span class="nv">$toc-counter</span><span class="p">;</span>              <span class="c1"># OUTPUT: «NaN␤» </span>

<span class="nv">$toc-counter</span> <span class="k">does</span> <span class="nc">TOC-Counter</span><span class="p">;</span> <span class="c1"># now we mix the role in </span>
<span class="nv">$toc-counter</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nf">inc</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nb">put</span> <span class="nv">$toc-counter</span> <span class="o">/</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1"># OUTPUT: «NaN␤» (because that&#39;s numerical context) </span>
<span class="nb">put</span> <span class="nv">$toc-counter</span><span class="p">;</span>              <span class="c1"># OUTPUT: «2.2.2␤» (put will call TOC-Counter::Str) </span>
</code></pre></div><p>角色可以是匿名的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%seen</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">0</span> <span class="k">but</span> <span class="k">role</span> <span class="nc">::</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{&#39;</span><span class="s1">NULL</span><span class="p">&#39;}</span> <span class="p">});</span>
<span class="nb">say</span> <span class="nv">%seen</span><span class="p">&lt;</span><span class="s">not-there</span><span class="p">&gt;;</span>          <span class="c1"># OUTPUT: «NULL␤» </span>
<span class="nb">say</span> <span class="nv">%seen</span><span class="p">&lt;</span><span class="s">not-there</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">defined</span><span class="p">;</span>  <span class="c1"># OUTPUT: «True␤» (0 may be False but is well defined) </span>
<span class="nb">say</span> <span class="nb">Int</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">%seen</span><span class="p">&lt;</span><span class="s">not-there</span><span class="p">&gt;);</span> <span class="c1"># OUTPUT: «0␤» </span>
</code></pre></div><h2 id="元对象编程和自省">元对象编程和自省</h2>
<p>Raku 有一个元对象系统, 这意味着对象、类、角色、Grammars、enums 等行为本身由其它对象控制; 这些对象叫做元对象(想想元操作符, 它操作的对象是普通操作符). 像普通对象一样, 元对象是类的实例, 这时我们称它们为元类。</p>
<p>对每个对象或类, 你能通过调用 <code>.HOW</code> 方法获取元对象. 注意, 尽管这看起来像是一个方法调用, 但它更像宏。</p>
<p>所以, 你能用元对象干些什么呢? 你可以通过比较元类的相等性来检查两个对象是否具有同样的元类:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">===</span>   <span class="mi">2</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>      <span class="c1"># True</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">===</span> <span class="nb">Int</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>      <span class="c1"># True</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span> <span class="o">===</span> <span class="nb">Num</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>      <span class="c1"># False</span>
</code></pre></div><p>Raku 使用单词 <code>HOW</code>, Higher Order Workings, 来引用元对象系统。因此, 在 Rakudo 中不必对此吃惊, 控制类行为的元类的类名叫做 <code>Raku::Metamodel::ClassHow</code>。每个类都有一个 <code>Raku::Metamodel::ClassHOW</code>的实例。</p>
<p>但是,理所当然的, 元模型为你做了很多。例如它允许你内省对象和类。元对象方法调用的约定是, 在元对象上调用方法, 并且传递感兴趣的对象作为对象的第一参数。所以, 要获取对象的类名, 你可以这样写:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$object</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$metaobject</span> <span class="o">=</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">$metaobject</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="nv">$object</span><span class="p">);</span>      <span class="c1"># Int</span>
<span class="c1"># or shorter:</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                  <span class="c1"># Int</span>
</code></pre></div><p>为了避免使用同一个对象两次, 有一个便捷写法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>                        <span class="c1"># Int</span>
<span class="c1"># same as</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                  <span class="c1"># Int</span>
</code></pre></div><h2 id="内省">内省</h2>
<p>内省就是在运行时获取对象或类的信息的过程。在 Raku 中, 所有的内省都会搜查原对象。标准的基于类对象的 ClassHow 提供了这些工具:</p>
<h3 id="can">can</h3>
<p>给定一个方法名, can 返回可用的方法名</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span>      <span class="p">{</span> <span class="k">method</span> <span class="nb">x</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{}</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">x</span><span class="p">()</span>   <span class="p">{}</span> <span class="p">};</span>

<span class="nb">say</span> <span class="n">B</span><span class="o">.^</span><span class="nb">can</span><span class="p">(&#39;</span><span class="s1">x</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>              <span class="c1"># 2</span>
<span class="k">for</span> <span class="n">B</span><span class="o">.^</span><span class="nb">can</span><span class="p">(&#39;</span><span class="s1">x</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">arity</span><span class="p">;</span>                     <span class="c1"># 1, 2</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中, 类 B 中有两个名为 x 的方法可能可用(尽管一个正常的方法调用仅仅会直接调用安置在 B 中那个方法). B 中的那个方法有一个参数(例如, 它期望一个参数, 一个调用者(self)), 而 A 中的 x 方法期望 2 个参数( self 和 $a).</p>
<h3 id="methods">methods</h3>
<p>返回类中可用公共方法的列表( 这包括父类和 roles 中的方法). 默认它会停在类 Cool, Any 或 Mu 那儿; 若真要获取所有的方法, 使用副词 <code>:all</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nb">x</span><span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">methods</span><span class="p">();</span>                   <span class="c1"># x</span>
<span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">methods</span><span class="p">(:</span><span class="s">all</span><span class="p">);</span>               <span class="c1"># x infinite defined ...</span>
</code></pre></div><h3 id="mro">mro</h3>
<p>按方法解析顺序返回类自身的列表和它们的父类.  当方法被调用时, 类和它的父类按那个顺序被访问.(仅仅是概念上; 实际上方法列表在类构建是就创建了).</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span><span class="o">.^</span><span class="nb">mro</span><span class="p">;</span>                         <span class="c1"># (Int) (Cool) (Any) (Mu)</span>
</code></pre></div><h3 id="name">name</h3>
<p>返回类的名字:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a string</span><span class="p">&#39;</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>               <span class="c1"># Str</span>
</code></pre></div><h3 id="parents">parents</h3>
<p>返回一个父类的列表. 默认它会停在 Cool, Any 或者 Mu 那儿, 但你可以提供一个副词 <code>:all</code>来压制它. 使用副词 <code>:tree</code> 会返回一个嵌套列表.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">D</span>             <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">C1</span> <span class="k">is</span> <span class="nc">D</span>       <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">C2</span> <span class="k">is</span> <span class="nc">D</span>       <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="k">is</span> <span class="nc">C1</span> <span class="k">is</span> <span class="nc">C2</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">A</span> <span class="k">is</span> <span class="nc">B</span>        <span class="p">{</span> <span class="p">};</span>

<span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">parents</span><span class="p">(:</span><span class="s">all</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>          <span class="c1"># (B, C1, C2, D, Any, Mu)</span>
<span class="nb">say</span> <span class="n">A</span><span class="o">.^</span><span class="nb">parents</span><span class="p">(:</span><span class="s">all</span><span class="o">,</span> <span class="p">:</span><span class="s">tree</span><span class="p">)</span><span class="o">.</span><span class="nb">perl</span><span class="p">;</span>
    <span class="c1"># ([B, [C1, [D, [Any, [Mu]]]], [C2, [D, [Any, [Mu]]]]],)</span>
</code></pre></div><p><a href="https://docs.raku.org/language/objects">https://docs.raku.org/language/objects</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/object" term="object" label="object" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的项]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-21-terms-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-11-21-terms-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Terms in Raku</blockquote><p>Raku 中的大部分句法结构能归类为项和操作符. 这儿你能找到各种不同类型的项的概览.</p>
<h2 id="literals">Literals</h2>
<h3 id="int">Int</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">42</span>
<span class="mi">12_300_00</span>
<span class="p">:</span><span class="mi">16</span><span class="p">&lt;</span><span class="s">DEAD_BEEF</span><span class="p">&gt;</span>    <span class="c1">#十六进制</span>
</code></pre></div><p>Int 字面量由数字组成, 并且能在数字之间包含下划线. 使用 <code>:radix&lt;number&gt;</code> 冒号对儿形式能指定 10 进制外的其它进制.</p>
<h3 id="rat-有理数">Rat 有理数</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mf">12.34</span>
<span class="mf">1_200.345_678</span>
</code></pre></div><p>Rat(有理数)字面量由一个点号分割的两部分整数组成. 注意尾部的点号是不允许的, 所以你必须写成 <code>1.0</code> 而非 <code>1.</code> ( 这个规则很重要, 因为有一个以点号开头的中缀操作符, 例如 <code>..</code> 范围操作符 ).</p>
<h3 id="num-浮点数">Num 浮点数</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mf">12.3e-32</span>
<span class="mf">3e8</span>
</code></pre></div><p>Num(浮点数)字面量由 Rat 或 Int 字面量后面再跟着一个字母 e 和 一个指数(可能为负)组成. <code>3e8</code> 使用 值 <code>3* 10**8</code> 构建了一个 Num.</p>
<h3 id="str">Str</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#39;</span><span class="s1">a string</span><span class="p">&#39;&#39;</span><span class="s1">I\&#39;m escaped!</span><span class="p">&#39;</span>
<span class="p">&#34;</span><span class="s2">I don&#39;t need to be</span><span class="p">&#34;</span>
<span class="p">&#34;</span><span class="s2">\&#34;But I still can be,\&#34; he said.</span><span class="p">&#34;</span>
<span class="k">q</span><span class="p">|</span><span class="s">Other delimiters can be used too!</span>
</code></pre></div><p>字符串字面量常常使用 <code>'</code> 或 <code>&quot;</code> 创建, 然儿, 字符串在 Raku 中其实是一种强大的子语言.</p>
<h3 id="regex">Regex</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/</span><span class="sr"> match some text </span><span class="p">/</span>
<span class="k">rx</span><span class="p">/</span><span class="sr">slurp </span><span class="se">\s</span><span class="sr"> rest </span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr"> </span><span class="ni">$</span><span class="p">/</span>
</code></pre></div><p>这两种会产生字面正则。</p>
<h3 id="pair">Pair</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span>
<span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span>
<span class="p">:</span><span class="s">identifier</span>
<span class="p">:!</span><span class="s">identifier</span>
<span class="p">:</span><span class="s">identifier</span><span class="p">&lt;</span><span class="s">value</span><span class="p">&gt;</span>
<span class="p">:</span><span class="s">identifier</span><span class="p">&lt;</span><span class="s">value1 value2</span><span class="p">&gt;</span>
<span class="p">:</span><span class="s">identifier</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span>
<span class="p">:</span><span class="s">identifier</span><span class="p">[&#39;</span><span class="s1">val1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">val2</span><span class="p">&#39;]</span>
<span class="p">:</span><span class="s">identifier</span><span class="p">{</span><span class="s">key1</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">val1</span><span class="p">&#39;</span>, <span class="s">key2</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">value2</span><span class="p">&#39;}</span>
<span class="o">:</span><span class="nv">$item</span>
<span class="o">:</span><span class="nv">@array</span>
<span class="o">:</span><span class="nv">%hash</span>
<span class="o">:</span><span class="nv">&amp;callable</span>
</code></pre></div><p>Pair 对象的创建要么使用 <code>infix:«=&gt;»</code> (它会自动括起左边, 如果左边是标识符的话), 要么使用各种冒号对儿形式.  那些总是以一个冒号开头的创建形式, 冒号后面要么跟着一个标识符, 要么跟着一个已经存在的变量(不带符号的变量名作为 pair 的键, 变量的值作为 pair 的键值).</p>
<p>在标识符形式的冒号对儿中, 可选的值可以是任意环缀. 如果没有环缀, 那它的值就是 <code>Bool::True</code>. <code>!:identifier</code> 形式的值是 <code>Bool::False</code>.</p>
<p>如果冒号对儿在参数列表中, 所有的冒号对儿都会作为命名参数, 但是 <code>'quoted string' =&gt; $value</code> 除外.</p>
<h3 id="term-">term *</h3>
<p><code>*</code> 会创建一个类型为 Whatever 的对象. 详情查看 <a href="http://doc.raku.org/type/Whatever">Whatever</a>.</p>
<h2 id="identifier-terms">Identifier terms</h2>
<p>Raku中有内建的标识符项, 列出如下. 此外, 使用该语法能添加新的标识符项.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">term</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fourty-two</span><span class="p">&gt;</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">};</span>
<span class="nb">say</span> <span class="n">fourty-two</span>
</code></pre></div><p>或者作为常量:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">forty-two</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">fourty-two</span>
</code></pre></div><h3 id="self">self</h3>
<p>在方法中, self 指向方法的调用者( 例如, 方法被调用的对象). 如果把它用在没有意义的上下文中, 会抛出一个 <code> X::Syntax::NoSelf</code> 类型的编译时错误.</p>
<h3 id="now">now</h3>
<p>返回一个代表当前时间的实例对象.</p>
<h3 id="rand">rand</h3>
<p>返回一个范围为 <code>0..^1</code> 的伪随机浮点数.</p>
<h3 id="pi">pi</h3>
<p>返回数值 pi, 例如, 圆的周长和半径之间的比率.</p>
<h3 id="e">e</h3>
<p>返回欧拉数值.</p>
<h3 id="i">i</h3>
<p>返回复数的虚部.</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/term" term="term" label="term" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 入门]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-12-21-raku-intro/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-12-21-raku-intro/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Intro</blockquote><h2 id="第八章-函数式编程">第八章 函数式编程</h2>
<p>在本章中，我们将看看一些有利于函数式编程的功能。</p>
<h3 id="函数是一等公民">函数是一等公民</h3>
<p>函数/子例程是一等公民:</p>
<ul>
<li>它们能作为参数传递</li>
<li>它们能从另外一个函数中返回</li>
<li>它们能被赋值给变量</li>
</ul>
<p><code>map</code> 函数是用来说明这个概念的极好例子。<code>map</code> 是高阶函数, 它接收另外一个函数作为参数。</p>
<p><strong>脚本</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">1 2 3 4 5</span><span class="p">&gt;;</span>

<span class="k">sub</span> <span class="nf">squared</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nb">map</span><span class="p">(</span><span class="nv">&amp;squared</span><span class="o">,</span> <span class="nv">@array</span><span class="p">);</span>
</code></pre></div><p><strong>输出</strong></p>
<pre><code>(1 4 9 16 25)
</code></pre><p><strong>解释</strong></p>
<p>我们定义了一个叫做 <code>squared</code> 的子例程, 它接收一个数字并返回该数字的二次幂。下一步, 我们使用 <code>map</code> 这个高阶函数并传递给它两个参数, 一个子例程和一个数组。结果是所有数组元素的平方组成的列表。</p>
<p>注意当传递子例程作为参数时, 我们需要在子例程的名字前添加一个 <code>&amp;</code> 符号。</p>
<h3 id="闭包">闭包</h3>
<p>　
在 Raku 中所有的代码对象都是闭包, 这意味着它们能从外部作用域(outer scope)引用词法变量(lexical variables)。</p>
<h3 id="匿名函数">匿名函数</h3>
<p>　
<strong>匿名函数</strong>也叫做 <strong>lambda</strong>。</p>
<p>匿名函数没有绑定到标识符(匿名函数没有名字)。</p>
<p>让我们使用匿名函数重写 <code>map</code> 那个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">1 2 3 4 5</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nb">map</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span><span class="nv">$x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">}</span><span class="o">,</span> <span class="nv">@array</span><span class="p">);</span>
</code></pre></div><p>我们没有声明子例程并把它作为参数传递给 <code>map</code>, 而是在里面直接定义了匿名函数。</p>
<p>匿名函数 <code>-&gt; $x {$x ** 2}</code> 没有句柄并且不能被调用。</p>
<p>按照 Raku 的说法我们把这个标记叫做 <strong>pointy block</strong>。</p>
<p>pointy block 也能用于把函数赋值给变量:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$squared</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span>
    <span class="nv">$x</span> <span class="o">**</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$squared</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
</code></pre></div><h3 id="链式调用">链式调用</h3>
<p>　
在 Raku 中, 方法可以链接起来, 你不再需要把一个方法的结果作为参数传递给另外一个方法了。</p>
<p>我们假设你有一个数组。你被要求返回该数组的唯一值, 并且按从大到小的顺序排序。</p>
<p>你可能会通过写出近似于这样的代码来解决那个问题:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span>       <span class="o">=</span> <span class="p">&lt;</span><span class="s">7 8 9 0 1 2 4 3 5 6 7 8 9 </span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@final-array</span> <span class="o">=</span> <span class="nb">reverse</span><span class="p">(</span><span class="nb">sort</span><span class="p">(</span><span class="nb">unique</span><span class="p">(</span><span class="nv">@array</span><span class="p">)));</span>
<span class="nb">say</span> <span class="nv">@final-array</span><span class="p">;</span>
</code></pre></div><p>首先我们在 <code>@array</code> 身上调用 <code>unique</code> 函数, 然后我们把它的结果作为参数传递给 <code>sort</code> 函数, 再然后我们把结果传递给 <code>reverse</code> 函数。</p>
<p>和上面的例子相比, Raku 允许链式方法。</p>
<p>上面的例子可以像下面这样写, 利用<strong>方法链</strong>的优点:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span>       <span class="o">=</span> <span class="p">&lt;</span><span class="s">7 8 9 0 1 2 4 3 5 6 7 8 9 </span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@final-array</span> <span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">unique</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@final-array</span><span class="p">;</span>
</code></pre></div><p>你已经看到链式方法看起来有多清爽啦。</p>
<h3 id="feed-操作符">Feed 操作符</h3>
<p>　
<strong>feed 操作符</strong>, 在有些函数式编程语言中也叫<strong>管道</strong>, 然而它是链式方法的一个更好的可视化产出。</p>
<p><strong>向前流</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">7 8 9 0 1 2 4 3 5 6</span><span class="p">&gt;;</span>
<span class="nv">@array</span> <span class="o">==&gt;</span> <span class="nb">unique</span><span class="p">()</span>
       <span class="o">==&gt;</span> <span class="nb">sort</span><span class="p">()</span>
       <span class="o">==&gt;</span> <span class="nb">reverse</span><span class="p">()</span>
       <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@final-array</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@final-array</span><span class="p">;</span>
</code></pre></div><p><strong>解释</strong></p>
<pre><code>从 @array 开始, 然后返回一个唯一元素的列表
                 然后 排序它
                 然后 反转它
                 然后 把结果保存到 @final-array 中
</code></pre><p>就像你看到的那样, 方法的流向是自上而下的。</p>
<p><strong>向后流</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">7 8 9 0 1 2 4 3 5 6</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">@final-array-v2</span> <span class="o">&lt;==</span> <span class="nb">reverse</span><span class="p">()</span>
                   <span class="o">&lt;==</span> <span class="nb">sort</span><span class="p">()</span>
                   <span class="o">&lt;==</span> <span class="nb">unique</span><span class="p">()</span>
                   <span class="o">&lt;==</span> <span class="nv">@array</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@final-array-v2</span><span class="p">;</span>
</code></pre></div><p><strong>解释</strong></p>
<p>向后流就像向前流一样, 但是是以反转的顺序写的。</p>
<p>方法的流动方向是自下而上。</p>
<h3 id="hyper-操作符">Hyper 操作符</h3>
<p>　
<strong>hyper 操作符</strong> <code>».</code> 会在列表的所有元素身上调用一个方法并返回所有结果的一个列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">0 1 2 3 4 5 6 7 8 9 10</span><span class="p">&gt;;</span>
<span class="k">sub</span> <span class="nf">is-even</span><span class="p">(</span><span class="nv">$var</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$var</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">};</span>

<span class="nb">say</span> <span class="nv">@array</span><span class="o">».</span><span class="nb">is-prime</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="o">».</span><span class="nv">&amp;is-even</span><span class="p">;</span>
</code></pre></div><p>使用 hyper 操作符我们能调用 Raku 中已经定义过的方法, 例如 <code>is-prime</code> 告诉我们一个数字是否是质数。</p>
<p>此外我们能定义新的子例程并使用 hyper 操作符调用它们。但是这时我们必须在方法的名字前面加上 <code>&amp;</code> 符号。例如 <code>&amp;is-even</code>。</p>
<p>这很实用因为它使我们不必写 <code>for</code> 循环就可以迭代每个值。</p>
<h3 id="junctions">Junctions</h3>
<p>　
<strong>junction</strong> 是值的逻辑叠加。</p>
<p>在下面的例子中 <code>1|2|3</code> 是一个 junction。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$var</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">if</span> <span class="nv">$var</span> <span class="o">==</span> <span class="mi">1</span><span class="o">|</span><span class="mi">2</span><span class="o">|</span><span class="mi">3</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The variable is 1 or 2 or 3</span><span class="p">&#34;</span>
<span class="p">}</span>
</code></pre></div><p>junctions 的使用常常触发<strong>自动线程化</strong>; 每个 junction 元素都执行该操作, 并且所有的结果被组合到一个新的 junction 中并返回。</p>
<h3 id="lazy-lists">Lazy Lists</h3>
<p>　
<strong>惰性列表</strong>是被惰性求值的列表。</p>
<p>惰性求值延迟表达式的计算直到需要时, 并把结果存储到查询表中以避免重复计算。</p>
<p>惰性列表的优点包括:</p>
<ul>
<li>通过避免不必要的计算带来的性能提升</li>
<li>构建潜在的无限数据结构的能力</li>
<li>定义控制流的能力</li>
</ul>
<p>我们使用中缀操作符 <code>...</code> 来创建惰性列表。</p>
<p>惰性列表拥有一个<strong>初始元素</strong>, 一个<strong>发生器</strong>和一个<strong>结束点</strong>。</p>
<p><strong>简单的惰性列表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$lazylist</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">...</span> <span class="mi">10</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$lazylist</span><span class="p">;</span>
</code></pre></div><p>初始元素为 1 而结束点为 10。因为没有定义发生器所以默认的发生器为 successor(+1)。换句话说, 这个惰性列表可能返回(如果需要的话)下面的元素 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)。</p>
<p><strong>无限惰性列表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$lazylist</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">...</span> <span class="no">Inf</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$lazylist</span><span class="p">;</span>
</code></pre></div><p>该列表可能返回(如果需要的话) 1 到无穷大之间的任何整数, 换句话说, 可以返回任何整数。</p>
<p><strong>使用推断发生器创建惰性列表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$lazylist</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">10</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$lazylist</span><span class="p">;</span>
</code></pre></div><p>初始的元素是 0 和 2 而结束点是 10。虽然没有定义发生器, 但是使用了初始元素, Raku 会把生成器推断为 (+2)。</p>
<p>这个惰性列表可能返回(如果需要的话)下面的元素 (0, 2, 4, 6, 8, 10)。</p>
<p><strong>使用定义的发生器创建惰性列表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$lazylist</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">}</span> <span class="o">...</span> <span class="mi">12</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$lazylist</span><span class="p">;</span>
</code></pre></div><p>在这个例子中, 我们在闭合 <code>{ }</code> 中显式地定义了一个发生器。</p>
<p>这个惰性列表可能返回(如果需要的话)下面的元素 (0, 3, 6, 9, 12)。</p>
<blockquote>
<p>当使用显式的发生器时, 结束点必须是发生器能返回的一个值。</p>
<p>如果在上面的例子中我们使用的结束点是 10 而非 12, 那么发生器就不会停止。发生器会跳过那个结束点。</p>
<p>二选一, 你可以使用 <code>0 ...^ * &gt; 10</code> 代替 <code>0 ... 10</code>。你可以把它读作: 从 0 直到第一个大于 10(不包括它)的值</p>
<p><strong>这不会使发生器停止</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">$lazylist</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">}</span> <span class="o">...</span> <span class="mi">10</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$lazylist</span><span class="p">;</span>
</code></pre></div><p><strong>这会使发生器停止</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">$lazylist</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">}</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$lazylist</span><span class="p">;</span>
</code></pre></div></blockquote>
<h2 id="第九章-类和对象">第九章 类和对象</h2>
<p>在上一章中我们学习了 Raku 中函数式编程的便利性。在这一章中我们将看看 Raku 中的面向对象编程。</p>
<h3 id="介绍">介绍</h3>
<p>　
面向对象编程是当今广泛使用的范式之一。<strong>对象</strong>是一组绑定在一起的变量和子例程。</p>
<p>其中的变量叫做<strong>属性</strong>, 而子例程被叫做<strong>方法</strong>。属性定义对象的<strong>状态</strong>, 而方法定义对象的<strong>行为</strong>。</p>
<p><strong>类</strong>定义一组<strong>对象</strong>结构。</p>
<p>为了理解它们之间的关系, 考虑下面的例子:</p>
<table>
<thead>
<tr>
<th style="text-align:left">房间里有 4 个 people</th>
<th style="text-align:left"><strong>objects</strong> =&gt; 4 people</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">这 4 个人是 humans</td>
<td style="text-align:left"><strong>class</strong> =&gt; Human</td>
</tr>
<tr>
<td style="text-align:left">它们有不同的名字,年纪,性别和国籍</td>
<td style="text-align:left"><strong>attribute</strong> =&gt; name,age,sex,nationality</td>
</tr>
</tbody>
</table>
<p>按面向对象的说法, 对象是类的<strong>实例</strong>。</p>
<p>考虑下面的脚本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$age</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$sex</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$nationality</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span>,
                     <span class="s">age</span>  <span class="o">=&gt;</span> <span class="mi">23</span>,
                     <span class="s">sex</span>  <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">M</span><span class="p">&#39;</span>
                     <span class="s">nationality</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">American</span><span class="p">&#39;)</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="p">;</span>
</code></pre></div><ul>
<li><code>class</code> 关键字用于定义类。</li>
<li><code>has</code> 关键字用于定义类的属性。</li>
<li><code>.new</code> 方法被称之为<strong>构造函数</strong>。它创建了对象作为类的实例。</li>
</ul>
<p>在上面的例子中, 新的变量 <code>$john</code> 保存了由 <code>Human.new()</code> 所定义的新 &ldquo;Human&rdquo; 实例。
传递给 <code>.new()</code> 方法的参数用于设置底层对象的属性。
类可以使用 <code>my</code> 来声明一个本地作用域:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div><h3 id="封装">封装</h3>
<p>　
封装是一个面向对象的概念, 它把一组数据和方法捆绑在一块。
对象中的数据(属性)应该是<strong>私有的</strong>, 换句话说, 只能从对象内部访问它。
为了从对象外部访问对象的属性, 我们使用叫做<strong>存取器</strong>的方法。
下面两个脚本拥有同样的结果。</p>
<p><strong>直接访问变量</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">$var</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$var</span><span class="p">;</span>
</code></pre></div><p><strong>封装</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$var</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="k">sub</span> <span class="nf">sayvar</span> <span class="p">{</span>
    <span class="nv">$var</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="n">sayvar</span><span class="p">;</span>
</code></pre></div><p><code>sayvar</code> 是一个存取器。它让我们通过不直接访问这个变量来访问这个变量。
在 Raku 中使用  <strong>twigils</strong> 使得封装很便利。
Twigils 是第二 <em><strong>符号</strong></em>。它们存在于符号和属性名之间。
有两个 twigils 用在类中:</p>
<ul>
<li><code>!</code> 用于显式地声明属性是私有的</li>
<li><code>.</code> 用于为属性自动生成存取器</li>
</ul>
<p>默认地, 所有的属性都是私有的, 但是总是用 <code>!</code> twigil 是一个好习惯。
为了和我说的相一致, 我们应该把上面的类重写成下面这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!age</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!sex</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!nationality</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span>, <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">23</span>, <span class="s">sex</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">M</span><span class="p">&#39;</span>, <span class="s">nationality</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">American</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="p">;</span>
</code></pre></div><p>给脚本追加这样的的语句: <code>say $john.age</code>;
它会返回这样的错误: <code>Method 'age' not found for invocant of class 'Human'</code>。
原因是 <code>$!age</code> 是私有的并且只能用于对象内部。 尝试在对象外部访问它会返回一个错误。
现在用 <code>has $.age</code> 代替 <code>$!age</code> 并看看 <code>say $john.age;</code> 的结果是什么。</p>
<h3 id="具名参数-vs-位置参数">具名参数 vs. 位置参数</h3>
<p>　
在 Raku 中, 所有的类继承了一个默认的 <code>.new</code> 构造函数。
通过为他提供参数, 它能用于创建对象。
只能提供<strong>具名参数</strong>给默认的构造函数。</p>
<p>如果你考虑到上面的例子, 你会看到所有提供给 <code>.new</code> 方法的参数都是按名字定义的:</p>
<ul>
<li>name =&gt; &lsquo;John&rsquo;</li>
<li>age     =&gt; 23</li>
</ul>
<p>假如我不想在每次创建新对象的时候为每个属性提供一个名字呢?
那么我需要创建另外一个接收<strong>位置参数</strong>的构造函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.sex</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.nationality</span><span class="p">;</span>

    <span class="c1"># 重写默认构造函数的新构造函数</span>
    <span class="k">method</span> <span class="nb">new</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">$age</span><span class="o">,</span> <span class="nv">$sex</span><span class="o">,</span> <span class="nv">$nationality</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="o">,</span> <span class="o">:</span><span class="nv">$age</span><span class="o">,</span> <span class="o">:</span><span class="nv">$sex</span><span class="o">,</span> <span class="o">:</span><span class="nv">$nationality</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">John</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">M</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">American</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="p">;</span>
</code></pre></div><p>能接收位置参数的构造函数需要按上面那样定义。</p>
<h3 id="方法">方法</h3>
<p>　</p>
<h4 id="介绍-1">介绍</h4>
<p>　
方法是对象的子例程。
像子例程一样, 方法是一种打包一组功能的手段, 它们接收<strong>参数</strong>, 拥有<strong>签名</strong>并可以被定义为 <strong>multi</strong>。
方法是使用关键字 <code>method</code> 来定义的。</p>
<p>正常情况下, 方法被要求在对象的属性身上执行一些动作。这强制了封装的概念。对象的属性只能在对象里面使用方法来操作。在对象外面, 只能和对象的方法交互, 并且不能访问它的属性。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.sex</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.nationality</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.eligible</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">assess-eligibility</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">self</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">21</span> <span class="p">{</span>
            <span class="nv">$!eligible</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">No</span><span class="p">&#39;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$!eligible</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Yes</span><span class="p">&#39;</span>
        <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span>, <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">23</span>, <span class="s">sex</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">M</span><span class="p">&#39;</span>, <span class="s">nationality</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">American</span><span class="p">&#39;);</span>
<span class="nv">$john</span><span class="o">.</span><span class="nf">assess-eligibility</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="o">.</span><span class="nf">eligible</span><span class="p">;</span>
</code></pre></div><p>一旦方法定义在类中, 它们就能在对象身上使用<strong>点记号</strong>来调用:
<code>object.method</code> 或像上面的例子那样: <code>$john.assess-eligibility</code>。
在方法的定义中, 如果我们需要引用对象本身以调用另一个方法, 则使用 <code>self</code> 关键字。
在方法的定义中, 如果我们需要引用属性, 则使用 <code>!</code>, 即使属性是使用 <code>.</code> 定义的。
理由是 <code>.</code> twigil 做的就是使用 <code>!</code> 声明一个属性并自动创建存取器。</p>
<p>在上面的例子中, <code>if self.age &lt; 21</code> 和  <code>if $!age &lt; 21</code> 会有同样的效果, 尽管它们从技术上来讲是不同的:</p>
<ul>
<li><code>self.age</code> 调用了 <code>.age</code> 方法(存取器)</li>
</ul>
<p>二选一, 还能写成 <code>$.age</code></p>
<ul>
<li><code>$!age</code> 是直接调用那个变量</li>
</ul>
<h4 id="私有方法">私有方法</h4>
<p>　
正常的方法能从类的外面在对象身上调用。
<strong>私有方法</strong>是只能从类的内部调用的方法。</p>
<p>一个可能的使用情况是一个方法调用另外一个执行特定动作的方法。连接外部世界的方法是公共的而被引用的那个方法应该保持私有。我们不想让用户直接调用它, 所以我们把它声明为私有的。</p>
<p>私有方法的声明需要在方法的名字前使用 <code>!</code> twigil。
私有方法是使用 <code>!</code> 而非 <code>.</code> 调用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">!iamprivate</span> <span class="p">{</span>
    <span class="c1"># code goes in here</span>
<span class="p">}</span>

<span class="k">method</span> <span class="nf">iampublic</span> <span class="p">{</span>
    <span class="nb">self</span><span class="o">!</span><span class="nf">iamprivate</span><span class="p">;</span>
    <span class="c1"># do additional things</span>
<span class="p">}</span>
</code></pre></div><h3 id="类属性">类属性</h3>
<p>　
<strong>类属性</strong>是属于类自身而非类的对象的属性。
它们能在定义期间初始化。
类属性是使用 <code>my</code> 关键字而非 <code>has</code> 关键字声明的。
它们是在类自己身上而非它的对象身上调用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$.counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Human</span><span class="o">.</span><span class="nf">counter</span><span class="o">++</span><span class="p">;</span>
        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;);</span>
<span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#39;</span><span class="s1">b</span><span class="p">&#39;);</span>

<span class="nb">say</span> <span class="n">Human</span><span class="o">.</span><span class="nf">counter</span><span class="p">;</span>
</code></pre></div><h3 id="访问类型">访问类型</h3>
<p>　
到现在为止我们看到的所以例子都使用存取器来从对象属性中获取信息。
假如我们需要修改属性的值呢?
我们需要使用下面的 <code>is rw</code> 关键字把它标记为 <code>read/write</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span>, <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">21</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="o">.</span><span class="nf">age</span><span class="p">;</span>

<span class="nv">$john</span><span class="o">.</span><span class="nf">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="o">.</span><span class="nf">age</span><span class="p">;</span>
</code></pre></div><p>默认地, 所有属性都声明为只读, 但是你可以显式地使用 <code>is readonly</code> 来声明。</p>
<h3 id="继承">继承</h3>
<p>　</p>
<h4 id="介绍-2">介绍</h4>
<p>　
<strong>继承</strong>是面向对象编程的另一个概念。
当定义类的时候, 很快我们会意思到很多属性/方法在很多类中是共有的。
我们应该重复代码吗?</p>
<p>不! 我们应该使用<strong>继承</strong>。
假设我们想定义两个类, 一个类是 Human, 一个类是 Employees。
Human 拥有两个属性: name 和 age。</p>
<p>Employees 拥有 4  个属性: name, age, company 和 salary。
尝试按下面定义类:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Employee</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.company</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.salary</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>虽然上面的代码技术上是正确的, 但是概念上差。
更好的写法是下面这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Employee</span> <span class="k">is</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.company</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.salary</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>is</code> 关键字定义了继承。
按面向对象的说法, Employee 是 Human 的<strong>孩子</strong>, 而 Human 是 Employee 的<strong>父亲</strong>。</p>
<p>所有的子类继承了父类的属性和方法, 所以没有必要重新它们。</p>
<h4 id="重写">重写</h4>
<p>　
类从它们的父类中继承所有的属性和方法。
有些情况下, 我们需要让子类中的方法表现得和继承的方法不一样。
为了做到这, 我们在子类中重新定义方法。</p>
<p>这个概念就叫做<strong>重写</strong>。</p>
<p>在下面的例子中, <code>introduce-yourself</code> 方法被 Employee 类继承。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">introduce-yourself</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Hi 我是人类, 我的名字是 </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Employee</span> <span class="k">is</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.company</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.salary</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span>, <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">23</span>,<span class="p">);</span>
<span class="k">my</span> <span class="nv">$jane</span> <span class="o">=</span> <span class="n">Employee</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Jane</span><span class="p">&#39;</span>, <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">25</span>, <span class="s">company</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Acme</span><span class="p">&#39;</span>, <span class="s">salary</span> <span class="o">=&gt;</span> <span class="mi">4000</span><span class="p">);</span>

<span class="nv">$john</span><span class="o">.</span><span class="nf">introduce-yourself</span><span class="p">;</span>
<span class="nv">$jane</span><span class="o">.</span><span class="nf">introduce-yourself</span><span class="p">;</span>
</code></pre></div><p>重写工作如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.age</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">introduce-yourself</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Hi 我是人类, 我的名字是 </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Employee</span> <span class="k">is</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.company</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.salary</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">introduce-yourself</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Hi 我是一名员工, 我的名字是 </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> 我工作在: </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nf">comapny</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span>,<span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">23</span>,<span class="p">);</span>
<span class="k">my</span> <span class="nv">$jane</span> <span class="o">=</span> <span class="n">Employee</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">Jane</span><span class="p">&#39;</span>,<span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">25</span>,<span class="s">company</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Acme</span><span class="p">&#39;</span>,<span class="s">salary</span> <span class="o">=&gt;</span> <span class="mi">4000</span><span class="p">);</span>

<span class="nv">$john</span><span class="o">.</span><span class="nf">introduce-yourself</span><span class="p">;</span>
<span class="nv">$jane</span><span class="o">.</span><span class="nf">introduce-yourself</span><span class="p">;</span>
</code></pre></div><p>根据对象所属的类, 会调用正确的方法。</p>
<h4 id="submethods">Submethods</h4>
<p>　
<strong>Submethods</strong> 是一种子类继承不到的方法。</p>
<p>它们只能从所声明的类中访问。
它们使用 <code>submethod</code> 关键字定义。</p>
<h3 id="多重继承">多重继承</h3>
<p>　
在 Raku 中允许多重继承。一个类可以继承自多个其它的类。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">bar-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.bar-values</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">line-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.line-values</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.line-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">combo-chart</span> <span class="k">is</span> <span class="nc">bar-chart</span> <span class="k">is</span> <span class="nc">line-chart</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actual-sales</span> <span class="o">=</span> <span class="n">bar-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$forecast-sales</span> <span class="o">=</span> <span class="n">line-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$actual-vs-forecast</span> <span class="o">=</span> <span class="n">combo-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span>
                                         <span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">实际的销售: </span><span class="p">&#34;;</span>
<span class="nv">$actual-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">预测的销售: </span><span class="p">&#34;;</span>
<span class="nv">$forecast-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">实际 vs 预测:</span><span class="p">&#34;;</span>
<span class="nv">$actual-vs-forecast</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
</code></pre></div><p>输出:</p>
<pre><code>实际的销售:
[10 9 11 8 7 10]
预测的销售:
[9 8 10 7 6 9]
实际 vs 预测:
[10 9 11 8 7 10]
</code></pre><p><strong>解释</strong></p>
<p><code>combo-chart</code> 类应该能持有两个序列, 一个是绘制条形图的实际值, 另一个是绘制折线图的预测值。</p>
<p>这就是我们为什么把它定义为 <code>line-chart</code> 和 <code>bar-chart</code> 的孩子的原因。</p>
<p>你应该注意到了, 在 <code>combo-chart</code> 身上调用 <code>plot</code> 方法并没有产生所要求的结果。它只绘制了一个序列。</p>
<p>发生了什么事?</p>
<p><code>combo-chart</code> 继承自 <code>line-chart</code> 和 <code>bar-chart</code>, 它们都有一个叫做 <code>plot</code> 的方法。当我们在 <code>combo-chart</code> 身上调用那个方法时, Raku 内部会尝试通过调用其所继承的方法之一来解决冲突。</p>
<p><strong>纠正</strong></p>
<p>为了表现得正确, 我们应该在 <code>combo-chart</code> 中重写 <code>plot</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">bar-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.bar-values</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">line-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.line-values</span><span class="p">;</span>
    
    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.line-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">combo-chart</span> <span class="k">is</span> <span class="nc">bar-chart</span> <span class="k">is</span> <span class="nc">line-chart</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.bar-values</span><span class="p">;</span>
        <span class="nb">say</span> <span class="nv">@.line-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actual-sales</span> <span class="o">=</span> <span class="n">bar-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$forecast-sales</span> <span class="o">=</span> <span class="n">line-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$actual-vs-forecast</span> <span class="o">=</span> <span class="n">combo-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span>
                                         <span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">实际的销售: </span><span class="p">&#34;;</span>
<span class="nv">$actual-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">预测的销售: </span><span class="p">&#34;;</span>
<span class="nv">$forecast-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">实际 vs 预测:</span><span class="p">&#34;;</span>
<span class="nv">$actual-vs-forecast</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
</code></pre></div><p>输出:</p>
<pre><code>实际的销售:
[10 9 11 8 7 10]
预测的销售:
[9 8 10 7 6 9]
实际 vs 预测:
[10 9 11 8 7 10]
[9 8 10 7 6 9]
</code></pre><h3 id="roles">Roles</h3>
<p>　
<strong>Roles</strong> 在它们是属性和方法的集合这个意义上和类有点类似。
Roles 使用关键字 <code>role</code> 声明, 而想实现该 role 的类可以使用 <code>does</code> 关键字。</p>
<p><strong>使用 roles 重写多重继承的例子</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">bar-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    
    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">line-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.line-values</span><span class="p">;</span>
    
    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.line-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">combo-chart</span> <span class="k">does</span> <span class="nc">bar-chart</span> <span class="k">does</span> <span class="nc">line-chart</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.bar-values</span><span class="p">;</span>
        <span class="nb">say</span> <span class="nv">@.line-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actual-sales</span> <span class="o">=</span> <span class="n">bar-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$forecast-sales</span> <span class="o">=</span> <span class="n">line-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$actual-vs-forecast</span> <span class="o">=</span> <span class="n">combo-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span>
                                         <span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">实际的销售: </span><span class="p">&#34;;</span>
<span class="nv">$actual-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">预测的销售: </span><span class="p">&#34;;</span>
<span class="nv">$forecast-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">实际 vs 预测:</span><span class="p">&#34;;</span>
<span class="nv">$actual-vs-forecast</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
</code></pre></div><p>运行上面的脚本你会看到结果是一样的。</p>
<p>现在你问问自己, 如果 roles 表现得像类的话那么它们的用途是什么呢?</p>
<p>要回答你的问题, 修改第一个用于展示多重继承的脚本,  这个脚本中我们忘记重写 <code>plot</code> 方法了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">bar-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.bar-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">line-chart</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">@.line-values</span><span class="p">;</span>
    
    <span class="k">method</span> <span class="nf">plot</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">@.line-values</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">combo-chart</span> <span class="k">does</span> <span class="nc">bar-chart</span> <span class="k">does</span> <span class="nc">line-chart</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actual-sales</span> <span class="o">=</span> <span class="n">bar-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">]</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$forecast-sales</span> <span class="o">=</span> <span class="n">line-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$actual-vs-forecast</span> <span class="o">=</span> <span class="n">combo-chart</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">bar-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">10</span>,<span class="mi">9</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">10</span><span class="o">],</span>
                                         <span class="s">line-values</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">9</span>,<span class="mi">8</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">9</span><span class="o">]</span><span class="p">);</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Actual sales:</span><span class="p">&#34;;</span>
<span class="nv">$actual-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Forecast sales:</span><span class="p">&#34;;</span>
<span class="nv">$forecast-sales</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Actual vs Forecast:</span><span class="p">&#34;;</span>
<span class="nv">$actual-vs-forecast</span><span class="o">.</span><span class="nf">plot</span><span class="p">;</span>
</code></pre></div><p>输出:</p>
<pre><code>===SORRY!===
Method 'plot' must be resolved by class combo-chart because it exists in multiple roles (line-chart, bar-chart)
</code></pre><p><strong>解释</strong></p>
<p>如果多个 roles 被应用到同一个类中, 会出现冲突并抛出一个编译时错误。
这是比多重继承更安全的方法, 其中冲突不被认为是错误并且简单地在运行时解决。
Roles 会提醒你有冲突。</p>
<h3 id="内省">内省</h3>
<p>　
<strong>内省</strong>是获取诸如对象的类型、属性或方法等对象属性的信息的过程。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.age</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">introduce-yourself</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Hi i am a human being, my name is </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nb">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Employee</span> <span class="k">is</span> <span class="nc">Human</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.company</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.salary</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">introduce-yourself</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Hi i am a employee, my name is </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> and I work at: </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nb">self</span><span class="o">.</span><span class="nf">company</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$john</span> <span class="o">=</span> <span class="n">Human</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">John</span><span class="p">&#39;</span>,<span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">23</span>,<span class="p">);</span>
<span class="k">my</span> <span class="nv">$jane</span> <span class="o">=</span> <span class="n">Employee</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">Jane</span><span class="p">&#39;</span>,<span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">25</span>,<span class="s">company</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Acme</span><span class="p">&#39;</span>,<span class="s">salary</span> <span class="o">=&gt;</span> <span class="mi">4000</span><span class="p">);</span>

<span class="nb">say</span> <span class="nv">$john</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$jane</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="o">.^</span><span class="nb">attributes</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$jane</span><span class="o">.^</span><span class="nb">attributes</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$john</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$jane</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$jane</span><span class="o">.^</span><span class="nb">parents</span><span class="p">;</span>
<span class="k">if</span> <span class="nv">$jane</span> <span class="o">~~</span> <span class="n">Human</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Jane is a Human</span><span class="p">&#39;};</span>
</code></pre></div><p>内省使用了:</p>
<ul>
<li><code>.WHAT</code>  返回已经创建的对象所属的类。</li>
<li><code>.^attributes</code> 返回一个包含该对象所有属性的列表。</li>
<li><code>.^mtethods</code> 返回能在该对象身上调用的所有方法。</li>
<li><code>.^parents</code> 返回该对象所属类的所有父类。</li>
<li><code>~~</code> 叫做智能匹配操作符。如果对象是从它所进行比较的类或任何它继承的类创建的, 则计算为 True。</li>
</ul>
<h2 id="第十章-异常处理">第十章 异常处理</h2>
<h3 id="捕获异常">捕获异常</h3>
<p>　　
<strong>异常</strong>是当某些东西出错时发生在运行时的特殊行为。</p>
<p>我们说异常被抛出。考虑下面这个运行正确的脚本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Str</span> <span class="nv">$name</span><span class="p">;</span>
<span class="nv">$name</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Joanna</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$name</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">How are you doing today?</span><span class="p">&#34;</span>
</code></pre></div><p>输出:</p>
<pre><code>Hello Joanna
How are you doing today?
</code></pre><p>现在让这个脚本抛出异常:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Str</span> <span class="nv">$name</span><span class="p">;</span>
<span class="nv">$name</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$name</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">How are you doing today?</span><span class="p">&#34;</span>
</code></pre></div><p>输出:</p>
<pre><code>Type check failed in assignment to $name; expected Str but got Int
   in block &lt;unit&gt; at exceptions.pl6:2
</code></pre><p>你应该看到当错误出现时(在这个例子中把数组赋值给字符串变量)程序会停止并且其它行的代码不会被执行, 即使它们是正确的。</p>
<p><strong>异常处理</strong>是捕获已经抛出的异常的过程以使脚本能继续工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Str</span> <span class="nv">$name</span><span class="p">;</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="nv">$name</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$name</span><span class="p">;</span>
    <span class="k">CATCH</span> <span class="p">{</span>
        <span class="k">default</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Can you tell us your name again, we couldn&#39;t find it in the register.</span><span class="p">&#34;;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">How are you doing today?</span><span class="p">&#34;;</span>
</code></pre></div><p>输出:</p>
<pre><code>Can you tell us your name again, we couldn't find it in the register.
How are you doing today?
</code></pre><p>异常处理是使用 <code>try-catch</code> block 完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">try</span> <span class="p">{</span>
    <span class="c1"># code goes in here</span>
    <span class="c1"># 如果有东西出错, 脚本会进入到下面的 CATCH block 中</span>
    <span class="c1"># 如果什么错误也没有, 那么 CATCH block 会被忽略</span>
    <span class="k">CATCH</span> <span class="p">{</span>
        <span class="k">default</span> <span class="p">{</span>
            <span class="c1"># 只有抛出异常时, 这儿的代码才会被求值</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>CATCH</code> block 能像定义 <code>given</code> block 那样定义。这意味着我们能捕获并处理各种不同类型的异常。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">try</span> <span class="p">{</span>
    <span class="c1">#code goes in here</span>
    <span class="c1">#if anything goes wrong, the script will enter the below CATCH block</span>
    <span class="c1">#if nothing goes wrong the CATCH block will be ignored</span>
    <span class="k">CATCH</span> <span class="p">{</span>
        <span class="k">when</span> <span class="ne">X::AdHoc</span> <span class="p">{</span> <span class="c1">#do something if an exception of type X::AdHoc is thrown }</span>
        <span class="k">when</span> <span class="ne">X::IO</span> <span class="p">{</span> <span class="c1">#do something if an exception of type X::IO is thrown }</span>
        <span class="k">when</span> <span class="ne">X::OS</span> <span class="p">{</span> <span class="c1">#do something if an exception of type X::OS is thrown }</span>
        <span class="k">default</span> <span class="p">{</span> <span class="c1">#do something if an exception is thrown and doesn&#39;t belong to the above types }</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="抛出异常">抛出异常</h3>
<p>　
和捕获异常相比, Raku 也允许你显式地抛出异常。
有两种类型的异常可以抛出:</p>
<ul>
<li>ad-hoc 异常</li>
<li>类型异常</li>
</ul>
<p><strong>ad-hoc</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
<span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Error !</span><span class="p">&#34;;</span>
</code></pre></div><p><strong>typed</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
<span class="ne">X::AdHoc</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">payload</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Error !</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">throw</span><span class="p">;</span>
</code></pre></div><p>使用 <code>die</code> 子例程后面跟着异常消息来抛出 Ad-hoc 异常。</p>
<p>Typed 异常是对象, 因此上面的例子中使用了 <code>.new()</code> 构造函数。</p>
<p>所有类型化的异常都是从类 <code>X</code> 开始, 下面是一些例子:</p>
<ul>
<li><code>X::AdHoc</code> 是最简单的异常类型</li>
<li><code>X::IO</code> 跟 IO 错误有关。</li>
<li><code>X::OS</code> 跟 OS 错误有关。</li>
<li><code>X::Str::Numeric</code> 跟把字符串强制转换为数字有关。</li>
</ul>
<blockquote>
<p>查看异常类型和相关方法的完整列表请到  <a href="http://doc.raku.org/type.html">http://doc.raku.org/type.html</a> 并导航到以 X 开头的类型。</p>
</blockquote>
<h2 id="第十一章-正则表达式">第十一章 正则表达式</h2>
<p>正则表达式, 或 <strong>regex</strong> 是一个用于模式匹配的字符序列。</p>
<p>理解它最简单的一种方式是把它看作模式。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">enlightenment</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> light </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">enlightenment contains the word light</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中, 智能匹配操作符 <code>~~</code> 用于检查一个字符串(enlightenment)是否包含一个单词(light)。</p>
<p>&ldquo;Enlightenment&rdquo;  与正则表达式 <code>m/ light /</code> 匹配。</p>
<h3 id="regex-定义">Regex 定义</h3>
<p>　
正则表达式可以按如下方式定义:</p>
<ul>
<li>/light/</li>
<li>m/light/</li>
<li>rx/light/</li>
</ul>
<p>除非显式地指定, 否则空白是无关紧要的, <code>m/light/</code> 和 <code>m/ light /</code> 是相同的。</p>
<h3 id="匹配字符">匹配字符</h3>
<p>　
字母数字字符和下划线 <code>_</code> 在正则表达式中是按原样写出的。</p>
<p>所有其它字符必须使用反斜线或用引号围起来以转义。</p>
<p><strong>反斜线</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">Temperature: 13</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> \</span><span class="o">:</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The string provided contains a colon :</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p><strong>单引号</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">Age = 13</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The string provided contains an equal character = </span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p><strong>双引号</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">name@company.com</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">@</span><span class="p">&#34;</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">This is a valid email address because it contains an @ character</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><h3 id="匹配字符类">匹配字符类</h3>
<p>　
就像之前章节看到的, 匹配字符类很方便。</p>
<p>话虽这么说，更系统的方法是使用 Unicode 属性。</p>
<p>Unicode 属性闭合在 <code>&lt;: &gt;</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#34;</span><span class="s2">John123</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">N</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Contains a number</span><span class="p">&#34;;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Doesn&#39;t contain a number</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#34;</span><span class="s2">John-Doe</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">Lu</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Contains an uppercase letter</span><span class="p">&#34;;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Doesn&#39;t contain an upper case letter</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#34;</span><span class="s2">John-Doe</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">Pd</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Contains a dash</span><span class="p">&#34;;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Doesn&#39;t contain a dash</span><span class="p">&#34;</span>
<span class="p">}</span>
</code></pre></div><h3 id="通配符">通配符</h3>
<p>通配符也可以用在正则表达式中。</p>
<p>点 <code>.</code> 意味着任何单个字符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">abc</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="ni">.</span><span class="sr">c </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">a2c</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="ni">.</span><span class="sr">c </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">ac</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="ni">.</span><span class="sr">c </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><h3 id="量词">量词</h3>
<p>　
量词在字符后面用于指定我们期望匹配它前面的东西的次数。</p>
<p>问号 <code>?</code> 意思是 0 或 1 次。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">ac</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">?</span><span class="sr">c </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">?</span><span class="sr">c </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>星号 <code>*</code> 意思是 0 或多次。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">az</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">*</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">aaz</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">*</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">aaaaaaaaaaz</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">*</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">*</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p><code>+</code> 意思是至少匹配 1 次。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">az</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">+</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">aaz</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">+</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">aaaaaaaaaaz</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">+</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="sr"> a</span><span class="o">+</span><span class="sr">z </span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Match</span><span class="p">&#34;;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">No Match</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><h3 id="匹配结果">匹配结果</h3>
<p>　
当匹配字符串的正则表达式成功时, 匹配结果被存储在一个特殊的变量 <code>$/</code> 中。</p>
<p><strong>脚本</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">&#39;</span><span class="s1">Rakudo is a Raku compiler</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/:</span><span class="na">s</span><span class="sr"> Raku</span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The match is: </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The string before the match is: </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">prematch</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The string after the match is: </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">postmatch</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The matching string starts at position: </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">from</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The matching string ends at position: </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$/</span><span class="o">.</span><span class="nb">to</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><strong>输出</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">The</span> <span class="nb">match</span> <span class="n">is:</span> <span class="nb">Raku</span>
<span class="n">The</span> <span class="n">string</span> <span class="ow">before</span> <span class="n">the</span> <span class="nb">match</span> <span class="n">is:</span> <span class="n">Rakudo</span> <span class="k">is</span> <span class="nc">a</span>
<span class="n">The</span> <span class="n">string</span> <span class="nb">after</span> <span class="n">the</span> <span class="nb">match</span> <span class="n">is:</span>  <span class="nb">compiler</span>
<span class="n">The</span> <span class="n">matching</span> <span class="n">string</span> <span class="n">starts</span> <span class="nb">at</span> <span class="n">position:</span> <span class="mi">12</span>
<span class="n">The</span> <span class="n">matching</span> <span class="n">string</span> <span class="n">ends</span> <span class="nb">at</span> <span class="n">position:</span> <span class="mi">18</span>
</code></pre></div><p><strong>解释</strong></p>
<p><code>$/</code> 返回一个 <strong>Match Object</strong>(匹配 regex 的字符串)。</p>
<p>下面的方法可以在 <strong>Match Object</strong> 身上调用:</p>
<ul>
<li><code>.prematch</code> 返回匹配前面的字符串</li>
<li><code>.postmatch</code> 返回匹配后面的字符串</li>
<li><code>.from</code> 返回匹配的开始位置</li>
<li><code>.to</code> 返回匹配的结束位置</li>
</ul>
<blockquote>
<p>默认地空白在 regex 中是无关紧要的。
如果我们想在 regex 中包含空白, 我们必须显式地这样做。
regex <code>m/:s Raku/</code> 中的 <code>:s</code> 强制考虑空白并且不会被删除。
二选一, 我们能把 regex 写为 <code>m/Perl\s6/</code> 并使用 <code>\s</code> 占位符。
如果 regex 中包含的空白不止一个, 使用 <code>:s</code> 比使用 <code>\s</code> 更高效。</p>
</blockquote>
<h3 id="例子">例子</h3>
<p>　
让我们检查一个邮件是否合法。</p>
<p>我们假设一个合法的电子邮件地址的形式如下:</p>
<p>first name [dot] last name [at] company [dot] (com/org/net)</p>
<blockquote>
<p>这个例子中用于电子邮件检测的 regex 不是很准确。它的核心意图是用来解释 Raku 中的 regex 的功能的。 不要在生产中原样使用它。</p>
</blockquote>
<p><strong>脚本</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$email</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">john.doe@raku.org</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$regex</span> <span class="o">=</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">L</span><span class="p">&gt;</span><span class="o">+</span><span class="sr">\</span><span class="ni">.</span><span class="p">&lt;:</span><span class="na">L</span><span class="p">&gt;</span><span class="o">+</span><span class="sr">\</span><span class="nv">@&lt;:L+:N&gt;</span><span class="o">+</span><span class="sr">\</span><span class="ni">.</span><span class="p">&lt;:</span><span class="na">L</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">/;</span>

<span class="k">if</span> <span class="nv">$email</span> <span class="o">~~</span> <span class="nv">$regex</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="nv">$/</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> is a valid email</span><span class="p">&#34;;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">This is not a valid email</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p><strong>输出</strong></p>
<pre><code>john.doe@raku.org is a valid email
</code></pre><p><strong>解释</strong></p>
<ul>
<li><code>&lt;:L&gt;</code> 匹配单个字符</li>
<li><code>&lt;:L&gt;+</code> 匹配单个字符或更多字符</li>
<li><code>\.</code> 匹配单个点号字符</li>
<li><code>\@</code> 匹配单个  [at] 符号</li>
<li><code>&lt;:L+:N&gt;</code> 匹配一个字母和数字</li>
<li><code>&lt;:L+:N&gt;+</code> 匹配一个或多个字母和数字</li>
</ul>
<p>其中的 regex 可以分解成如下:</p>
<ul>
<li><strong>first name</strong> <code>&lt;:L&gt;+</code></li>
<li><strong>[dot]</strong> <code>\.</code></li>
<li><strong>last name</strong> <code>&lt;:L&gt;+</code></li>
<li><strong>[at]</strong> <code>\@</code></li>
<li><strong>company name</strong> <code>&lt;:L+:N&gt;+</code></li>
<li><strong>[dot]</strong> <code>\.</code></li>
<li><strong>com/org/net</strong> <code>&lt;:L&gt;+</code></li>
</ul>
<p>可选地, 一个 regex 可以被分解成多个具名 regexes。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$email</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">john.doe@raku.org</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">many-letters</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">L</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">dot</span> <span class="p">{</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">at</span> <span class="p">{</span><span class="sr"> \</span><span class="nv">@</span><span class="sr"> </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">many-letters-numbers</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;:</span><span class="na">L</span><span class="o">+</span><span class="p">:</span><span class="na">N</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">};</span>

<span class="k">if</span> <span class="nv">$email</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">many-letters</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">dot</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">many-letters</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">at</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">many-letters-numbers</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">dot</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">many-letters</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="nv">$/</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> is a valid email</span><span class="p">&#34;;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">This is not a valid email</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>具名 regex 是使用 <code>my regex regex-name { regex definition }</code> 定义的。</p>
<p>具名 regex 可以使用 <code>&lt;regex-name&gt;</code> 来调用。</p>
<blockquote>
<p>更多关于 regexes 的东西, 查看 <a href="http://doc.raku.org/language/regexes">http://doc.raku.org/language/regexes</a></p>
</blockquote>
<h2 id="第十二章-raku-模块">第十二章 Raku 模块</h2>
<p>Rakudo 自带了 Panda 这个模块安装工具。</p>
<p>要安装指定的模块, 在终端中键入如下命令:</p>
<pre><code>zef install &quot;module name&quot;
</code></pre><blockquote>
<p>Raku 的模块目录可以在  <a href="http://modules.raku.org/">http://modules.raku.org/</a> 中找到。</p>
</blockquote>
<h3 id="使用模块">使用模块</h3>
<p>　
MD5 是一个关于密码的散列函数，它产生一个128位的散列值。
MD5 有多种加密存储在数据库中的口令的应用程序。当新用户注册时，其证书并不存储为纯文本，而是散列。这样做的理由是，如果该数据库被破解，攻击者将不能够知道口令是什么。</p>
<p>比方说，你需要一个生成密码的MD5哈希以存储在数据库中备用的脚本。</p>
<p>幸运的是，Raku 已经有一个能实现MD5算法的模块。我们安装下:</p>
<p><code>zef install Digest::MD5</code></p>
<p>现在运行下面的脚本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Digest::MD5</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$password</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">password123</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$hashed-password</span> <span class="o">=</span> <span class="n">Digest::MD5</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nf">md5_hex</span><span class="p">(</span><span class="nv">$password</span><span class="p">);</span>

<span class="nb">say</span> <span class="nv">$hashed-password</span><span class="p">;</span>
</code></pre></div><p>为了运行创建哈希的 <code>md5_hex()</code> 函数, 我们需要加载需要的模块。<code>use</code> 关键字用于加载模块。</p>
<h2 id="第十三章-unicode">第十三章 Unicode</h2>
<p>Unicode 是编码并表现文本的标准, 它满足了世界上的大部分系统。</p>
<p>UTF-8 是能够以Unicode编码所有可能的字符或代码点的字符编码。</p>
<p>字符的定义是通过:</p>
<p><strong>字素</strong>: 可见的表示</p>
<p><strong>代码点</strong>: 赋值给字符的数字</p>
<h3 id="使用-unicode">使用 Unicode</h3>
<p>　
<strong>让我们看一下使用 Unicode 能输出什么</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">a</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="se">\x</span><span class="mh">0061</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN SMALL LETTER A</span><span class="p">]&#34;;</span>
</code></pre></div><p>上面 3 行展示了构建字符的不同方法:</p>
<ol>
<li>直接写出字符(字素)</li>
<li>使用 <code>\x</code> 和代码点</li>
<li>使用 <code>\c</code> 和代码点名字</li>
</ol>
<p><strong>现在我们来输出笑脸</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">☺</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="se">\x</span><span class="mh">263a</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">WHITE SMILING FACE</span><span class="p">]&#34;;</span>
</code></pre></div><p><strong>组合两个代码点的另外一个例子</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">á</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="se">\x</span><span class="mh">00e1</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="se">\x</span><span class="mh">0061</span><span class="se">\x</span><span class="mh">0301</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="se">\c</span><span class="p">[</span><span class="s">LATIN SMALL LETTER A WITH ACUTE</span><span class="p">]&#34;;</span>
</code></pre></div><p>字母 <code>á</code> 可以被写为:</p>
<ul>
<li>使用它的唯一代码点 <code>\x00e1</code></li>
<li>或作为 <code>a</code> 和 重音符号 <code>\x0061\x0301</code> 代码点的组合</li>
</ul>
<p><strong>有些方法可以使用</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">á</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">NFC</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">á</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">NFD</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">á</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">uniname</span><span class="p">;</span>
</code></pre></div><p><strong>输出</strong></p>
<pre><code>NFC:0x&lt;00e1&gt;
NFD:0x&lt;0061 0301&gt;
LATIN SMALL LETTER A WITH ACUTE
</code></pre><p><code>NFC</code> 返回唯一的代码点。</p>
<p><code>NFD</code> 分解(decompose)那个字符并返回每部分的代码点。</p>
<p><code>uniname</code> 返回代码点的名字。</p>
<p><strong>Unicode 字符可以用作标识符</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$Δ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nv">$Δ</span><span class="o">++</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$Δ</span><span class="p">;</span>
</code></pre></div><h2 id="第十四章-并行并发和异步">第十四章 并行、并发和异步</h2>
<p>在正常情况下, 程序中的所有任务都是相继地运行的。</p>
<p>这可能不是个事儿除非你正尝试去做的东西需要耗费很多时间。</p>
<p>很自然地说, Raku 拥有能让你并行地运行东西的功能。</p>
<p>在这个阶段, 注意并行可以是下面两个东西之一是很重要的:</p>
<ul>
<li><strong>任务并行化</strong>: 两个(或更多)独立的表达式并行地运行。</li>
<li><strong>数据并行化</strong>: 单个表达式并行地迭代列表中的元素。</li>
</ul>
<p>让我们从后者开始。</p>
<h3 id="数据并行化">数据并行化　</h3>
<p>　</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">50000</span><span class="p">);</span>                     <span class="c1">#Array population</span>
<span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nb">is-prime</span> <span class="nv">$_</span> <span class="p">});</span>   <span class="c1">#call is-prime for each array element</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>                         <span class="c1">#Output the time it took for the script to complete</span>
</code></pre></div><p><strong>考虑上面的例子</strong>
　
我们只做一个操作 <code>@array.map({is-prime $_})</code>。<code>is-prime</code> 子例程相继被每个数组元素所调用:</p>
<p><code>is-prime @array[0] </code> 然后是 <code>is-prime @array[1]</code> 然后是 <code>is-prime @array[2]</code> 等等。</p>
<p><strong>幸运的是, 我们能同时在多个数组元素身上调用 <code>is-prime</code> 函数:</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">50000</span><span class="p">);</span>                         <span class="c1">#Array population</span>
<span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">race</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="nb">is-prime</span> <span class="nv">$_</span> <span class="p">});</span>  <span class="c1">#call is-prime for each array element</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>                             <span class="c1">#Output the time it took to complete</span>
</code></pre></div><p>注意表达式中使用的 <code>race</code>。这个方法会使数组元素能够并行地迭代。</p>
<p>运行两个例子(使用和不使用 <code>race</code>)运行之后, 比较两个脚本运行结束所花费的时间。</p>
<blockquote>
<p><code>race</code> 不会保存元素的顺序。如果你想那样做, 使用 <code>hyper</code> 代替。</p>
<p><strong>race</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">race</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span> <span class="p">);</span>
<span class="nv">@result</span><span class="o">».</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p><strong>hyper</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1000</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@result</span> <span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">hyper</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span> <span class="p">);</span>
<span class="nv">@result</span><span class="o">».</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>如果你俩个脚本都运行了, 你应该注意到一个排序了一个没有排序。</p>
</blockquote>
<h3 id="任务并行化">任务并行化</h3>
<p>　</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">49999</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@array2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">50001</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">@result1</span> <span class="o">=</span> <span class="nv">@array1</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nb">is-prime</span><span class="p">(</span><span class="nv">$_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span> <span class="p">);</span>
<span class="k">my</span> <span class="nv">@result2</span> <span class="o">=</span> <span class="nv">@array2</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nb">is-prime</span><span class="p">(</span><span class="nv">$_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)}</span> <span class="p">);</span>

<span class="nb">say</span> <span class="nv">@result1</span> <span class="o">==</span> <span class="nv">@result2</span><span class="p">;</span>

<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p><strong>考虑上面的例子</strong>:</p>
<ol>
<li>我们定义了 2 个数组</li>
<li>对每个数组应用不同的操作并保存结果</li>
<li>并检查两个结果是否相同</li>
</ol>
<p>该脚本等到 <code>@array1.map( {is-prime($_ +1)} )</code> 完成然后计算 <code>@array1.map( {is-prime($_ +1)} )</code>。</p>
<p>应用到每个数组的俩个操作彼此间没有依赖。</p>
<p><strong>为什么不并行地执行呢?</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@array1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">49999</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@array2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">50001</span><span class="p">);</span>

<span class="k">my</span> <span class="nv">$promise1</span> <span class="o">=</span> <span class="k">start</span> <span class="nv">@array1</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span> <span class="p">);</span>
<span class="k">my</span> <span class="nv">$promise2</span> <span class="o">=</span> <span class="k">start</span> <span class="nv">@array2</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span> <span class="p">);</span>

<span class="k">my</span> <span class="nv">@result1</span> <span class="o">=</span> <span class="nb">await</span> <span class="nv">$promise1</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@result2</span> <span class="o">=</span> <span class="nb">await</span> <span class="nv">$promise2</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">@result1</span> <span class="o">==</span> <span class="nv">@result2</span><span class="p">;</span>

<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p><strong>解释</strong></p>
<p><code>start</code> 方法计算它后面的代码并返回<strong>promise 类型的对象</strong>或<strong>promise</strong>。</p>
<p>如果代码被正确地求值, 那么 promise 会被<strong>保留</strong>(kept)。</p>
<p>如果代码抛出异常, 那么 promise 会被<strong>破坏</strong>(broken)。</p>
<p><code>await</code> 方法等待一个 <strong>promise</strong>。</p>
<p>如果那个 promise 是被<strong>保留</strong>的, await 会获取到返回值。</p>
<p>如果那个 promise 是被<strong>破坏</strong>的, await 会获取到抛出异常。</p>
<p>检查每个脚本完成所花费的时间。</p>
<blockquote>
<p>并行总是添加线程开销。如果开销抵消不了运算速度的增长，那么该脚本会显得较慢。
这就是为什么，在很简单的脚本中使用 <strong>race</strong>，<strong>hyper</strong>，<strong>start</strong> 和 <strong>await</strong> 实际上可以使它们慢下来。</p>
</blockquote>
<h3 id="并发和异步">并发和异步</h3>
<p>　</p>
<blockquote>
<p>关于并发和异步编程的更多信息, 请查看  <a href="http://doc.raku.org/language/concurrency">http://doc.raku.org/language/concurrency</a></p>
</blockquote>
<h2 id="第十五章-社区">第十五章 社区</h2>
<p>很多讨论发生在 <a href="irc://irc.freenode.net/#raku">#raku</a> IRC 频道中。你可以到 <a href="http://raku.org/community/irc">http://raku.org/community/irc</a> 进行任何询问。</p>
<p><a href="http://pl6anet.org/">http://pl6anet.org/</a> 是一个 Raku 博客聚合器。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/intro" term="intro" label="intro" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 圣诞月历(2010)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-10-05-raku-calendar-2010/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-04-15-raku-calendar-2012/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 圣诞月历 2012" />
                <link href="https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 圣诞月历 - 2014" />
            
                <id>https://ohmyweekly.github.io/notes/2015-10-05-raku-calendar-2010/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Calendar(2010)</blockquote><h2 id="第二天-用-main-函数控制命令行交互">第二天: 用 MAIN 函数控制命令行交互</h2>
<p>在 UNIX 环境下，很多脚本都是要从命令行里获取运行参数的。在 Raku 中实现这个相当简单。比如下面这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cat add.pl
sub MAIN <span class="o">(</span><span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span> <span class="o">{</span>
    say <span class="nv">$x</span> + <span class="nv">$y</span>
<span class="o">}</span>
$ raku add.pl <span class="m">3</span> <span class="m">4</span>
<span class="m">7</span>
$ raku add.pl too many arguments
Usage:
add.pl x y
</code></pre></div><p>只要定义一个带命名变量的 MAIN 函数，你就可以获得一个命令行分析器。然后命令行参数就被自动绑定到 <code>$x</code> 和 <code>$y</code> 上了。如果不匹配，还有温馨的 Usage 提示。</p>
<p>当然，你可能更喜欢自己定制 Usage 信息。那么自己动手，编写 USAGE 函数好了：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cat add2.pl
sub MAIN<span class="o">(</span><span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span> <span class="o">{</span>
    say <span class="nv">$x</span> + <span class="nv">$y</span>
<span class="o">}</span>
sub USAGE <span class="o">()</span> <span class="o">{</span>
    say <span class="s2">&#34;Usage: add.pl &lt;num1&gt; &lt;num2&gt;&#34;</span><span class="p">;</span>
<span class="o">}</span>
$ raku add2.pl too many arguments
Usage: add.pl &lt;num1&gt; &lt;num2&gt;
</code></pre></div><p>更进一步的，你可以用 <code>multi</code> 指令声明多个 MAIN 函数以完成一种可替代的语法，或者根据某些常量做出不同反应，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cat calc
<span class="c1">#!/usr/bin/env raku</span>

multi MAIN<span class="o">(</span><span class="s1">&#39;add&#39;</span>, <span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span>  <span class="o">{</span> say <span class="nv">$x</span> + <span class="nv">$y</span> <span class="o">}</span>
multi MAIN<span class="o">(</span><span class="s1">&#39;div&#39;</span>, <span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span>  <span class="o">{</span> say <span class="nv">$x</span> / <span class="nv">$y</span> <span class="o">}</span>
multi MAIN<span class="o">(</span><span class="s1">&#39;mult&#39;</span>, <span class="nv">$x</span>, <span class="nv">$y</span><span class="o">)</span> <span class="o">{</span> say <span class="nv">$x</span> * <span class="nv">$y</span> <span class="o">}</span>
$ ./calc add <span class="m">3</span> <span class="m">5</span>
<span class="m">8</span>
$ ./calc mult <span class="m">3</span> <span class="m">5</span>
<span class="m">15</span>
$ ./calc
Usage:
./calc add x y
or
./calc div x y
or
./calc mult x y
</code></pre></div><p>还有命名参数对应不同的选项的情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cat copy.pl
sub MAIN<span class="o">(</span><span class="nv">$source</span>, <span class="nv">$target</span>, Bool :<span class="nv">$verbose</span><span class="o">)</span> <span class="o">{</span>
    say <span class="s2">&#34;Copying &#39;</span><span class="nv">$source</span><span class="s2">&#39; to &#39;</span><span class="nv">$target</span><span class="s2">&#39;&#34;</span> <span class="k">if</span> <span class="nv">$verbose</span><span class="p">;</span>
    run <span class="s2">&#34;cp </span><span class="nv">$source</span><span class="s2"> </span><span class="nv">$target</span><span class="s2">&#34;</span><span class="p">;</span>
<span class="o">}</span>
$ raku copy.pl calc calc2
$ raku copy.pl  --verbose calc calc2
Copying <span class="s1">&#39;calc&#39;</span> to <span class="s1">&#39;calc2&#39;</span>
</code></pre></div><p>这里申明变量 <code>$verbose</code> 类型为 Bool，也就是不接受赋值。如果没有这个类型约束的话，它是需要赋值的，就像下面这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cat <span class="k">do</span>-nothing.pl
sub MAIN<span class="o">(</span>:<span class="nv">$how</span> <span class="o">=</span> <span class="s1">&#39;fast&#39;</span><span class="o">)</span> <span class="o">{</span>
    say <span class="s2">&#34;Do nothing, but do it </span><span class="nv">$how</span><span class="s2">&#34;</span><span class="p">;</span>
<span class="o">}</span>
$ raku <span class="k">do</span>-nothing.pl
Do nothing, but <span class="k">do</span> it fast

$ raku <span class="k">do</span>-nothing.pl --how<span class="o">=</span>well
Do nothing, but <span class="k">do</span> it well

$ raku <span class="k">do</span>-nothing.pl what?
Usage:
<span class="k">do</span>-nothing.pl <span class="o">[</span>--how<span class="o">=</span>value-of-how<span class="o">]</span>
</code></pre></div><p>总之，Raku 提供了内置的命令行解析功能和使用帮助说明，你只要声明好函数就行了。</p>
<h2 id="文件操作">文件操作</h2>
<ul>
<li>目录</li>
</ul>
<p>不再用 <code>opendir</code> 和其他神马滴，Raku 中有专门的 <code>dir</code> 函数，用来列出指定目录（默认是当前所在目录）下所有的文件。好了，直接贴代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">dir</span>
<span class="nb">dir</span> <span class="p">&#39;</span><span class="s1">t</span><span class="p">&#39;</span> <span class="c1"># t 目录下的文件</span>
</code></pre></div><p><code>dir</code> 还有一个可选的命名参数 <code>test</code>，用来 <code>grep</code> 结果，这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">dir</span> <span class="p">&#39;</span><span class="s1">src/core</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">test</span> <span class="o">=&gt;</span> <span class="nb">any</span><span class="p">(/</span><span class="ni">^</span><span class="sr">C</span><span class="p">/</span>, <span class="p">/</span><span class="ni">^</span><span class="sr">P</span><span class="p">/)</span>
</code></pre></div><p>创建目录，还是 <code>mkdir</code> 函数没错啦。</p>
<ul>
<li>文件</li>
</ul>
<p>最简单的读取文件的办法，是直接使用 <code>slurp</code> 函数，这个函数以标量形式返回文件的内容，这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span> <span class="p">&#39;</span><span class="s1">VERSION</span><span class="p">&#39;</span>
</code></pre></div><p>当然原始的文件句柄方式还是有效的，这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">CREDITS</span><span class="p">&#39;</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">getc</span> <span class="c1">#读取一个字符</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">get</span>  <span class="c1">#读取一行（译者注：这两看起来好有 C 语言的赶脚啊）</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>

<span class="nv">$fh</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">new</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span>  <span class="c1"># 以可写方式打开</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">print</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">say</span><span class="p">(&#39;</span><span class="s1">bar</span><span class="p">&#39;)</span>
<span class="nv">$fh</span><span class="o">.</span><span class="nb">close</span><span class="p">;</span>
<span class="nb">say</span> <span class="nb">slurp</span><span class="p">(&#39;</span><span class="s1">new</span><span class="p">&#39;)</span>
</code></pre></div><ul>
<li>文件测试</li>
</ul>
<p>如果要测试文件是否存在以及文件的具体类型，直接使用 <code>~~</code> 操作符就搞定了，还是用代码说话：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#39;</span><span class="s1">LICENSE</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">e</span>     <span class="c1"># 文件(广义的)是否存在</span>
<span class="p">&#39;</span><span class="s1">LICENSE</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">d</span>     <span class="c1"># 那么他是目录么？</span>
<span class="p">&#39;</span><span class="s1">LICENSE</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span> <span class="o">~~</span> <span class="p">:</span><span class="s">f</span>     <span class="c1"># 那么是文件么(狭义的)？</span>
</code></pre></div><ul>
<li>File::Find</li>
</ul>
<p>如果这些个标准特性还不够，那模块就派上用场了。<code>File::Tools</code> 包里的 <code>File::Find</code> 模块可以递归你指定的目录找你要的东西然后列出来。这个模块应该是跟着 Rakudo Star 一起打包了，如果你只裸装了 Rakudo，那么用 neutro 命令安装也是挺方便的。</p>
<p>额，还是要例子？好吧~很简单的一行 <code>find(:dir, :type, :name(/foo/))</code>，这就会在 <code>t/dir1</code> 目录下，寻找名字匹配 foo 的文件，然后以树的形式列出来~不过要注意的是：这命令的返回可不是文本标量，而是一个个包括他们的完整路径在内的对象，而且还提供文件本身以及文件所在目录的访问器！更多信息，直接看文档吧。</p>
<p>1、创建新文件</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">open</span><span class="p">(&#39;</span><span class="s1">new</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">)</span><span class="o">.</span><span class="nb">close</span>
</code></pre></div><p>2、匿名文件句柄</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">given</span> <span class="nb">open</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span><span class="p">(&#39;</span><span class="s1">Hello, world!</span><span class="p">&#39;);</span>
    <span class="o">.</span><span class="nb">close</span>
<span class="p">}</span>
</code></pre></div><h2 id="第四天--序列操作符">第四天 – 序列操作符</h2>
<p>去年，有一个序列操作符的简要梳理：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@even-numbers</span>  <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>    <span class="c1"># 算术序列</span>
<span class="k">my</span> <span class="nv">@odd-numbers</span>   <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@powers-of-two</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># 几何序列</span>
</code></pre></div><p>这些现在在 Rakudo 里面实现了：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@powers-of-two</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="nv">@powers-of-two</span><span class="o">[^</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span>
<span class="c1"># 1 2 4 8 16 32 64 128 256 512</span>
</code></pre></div><p>我们需要削减这个无限列表让 Rakudo 不会花费无限长的时间来计算它。这种情况下，我使用 <code>[^10]</code>, 这其实是说 &ldquo;给我前 10 个元素&rdquo;。注意，当你把一个惰性列表绑定到一个数组变量上时，被计算过的值是会被记忆的，这是一种快捷的缓存。</p>
<p>序列操作符 <code>...</code> 是一个生成惰性列表的强大工具。上面的例子仅仅暗示了它能做什么。给定一个数字，它就从这个数字开始往下计数（除非序列的终点是一个更小的数字，这种情况下，它会倒数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span> <span class="o">...</span> <span class="mi">10</span><span class="p">;</span> <span class="c1"># 1 2 3 4 5 6 7 8 9 10</span>
<span class="mi">5</span> <span class="o">...</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1"># 5 4 3 2 1</span>
</code></pre></div><p>给定两个数字来开始一个序列，它会把这当作一个算术序列，把前两个元素的差异添加到最后一个生成的元素上来产生下一个元素。如果给定三个元素，它会检查它们是否代表一个算术序列的开始或者它是否是一个几何序列，然后继续这个序列。</p>
<p>当然，很多有趣的序列既非算术序列也非几何序列，这时，你需要显式地提供一个 sub 来生成序列中的下一个数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@Fibonacci</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="nv">@Fibonacci</span><span class="o">[^</span><span class="mi">10</span><span class="o">]</span><span class="p">;</span> <span class="c1"># 0 1 1 2 3 5 8 13 21 34</span>
</code></pre></div><p>上面的 <code>-&gt; $a, $b { $a + $b }</code> 是一个 pointy block (或者是一个匿名函数)，它带有 2 个参数并返回它们的和。这个序列操作符计算出该 block 有多少个参数，然后从当前序列的末尾传递所需的参数来生成序列的下一个数字，以此类推，循环下去。</p>
<p>或者也可以中断循环，目前为止，所有的例子都有一个星号 <code>*</code> 放在右边，它意味着“没有终止条件”。如果你反而在那里放上一个数字，这个列表就会终止在那个数字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">,</span> <span class="mf">1.1</span> <span class="o">...</span> <span class="mi">2</span><span class="p">;</span>          <span class="c1"># 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2</span>
<span class="mi">1</span><span class="o">,</span> <span class="mf">1.1</span> <span class="o">...</span> <span class="mf">2.01</span><span class="p">;</span>       <span class="c1"># 1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2</span>
<span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mf">1.1</span> <span class="o">...</span> <span class="mf">2.01</span><span class="p">)</span><span class="o">[^</span><span class="mi">14</span><span class="o">]</span> <span class="c1"># (1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 Nil Nil Nil)</span>
</code></pre></div><p>第一个列表很自然地终止了，但是第二个列表漏掉了终止数，它会循环下去。结果就是一个无限列表，所以我把它限制到前 14 个元素，以至于我们能明白它正在做什么。</p>
<p>那些有做浮点数学背景的人可能会气急败坏地说反复增加 0.1 直到精确到 2 为止很危险。</p>
<p>在 Raku 中，没有这个问题，因为它会在可能的地方使用有理数（例如.分数)。如果我想找出所有 10000 以下的斐波纳契数，要找到到何处停止的那个精确的数字是很大的问题。幸运的是，就像你能使用块来指定怎样生成序列中的下一个元素一样，你可以使用块来测试序列是否结束：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">&gt;</span> <span class="mi">10000</span> <span class="p">};</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946</span>
</code></pre></div><p>尖头块 <code>-&gt; $a { $a &gt; 10000 }</code> 创建了一个含有一个参数的块，并且当参数大于 10000 时返回真；这就是我们需要的测试。</p>
<p>除了我们所期待的所有斐波那契数小于 10000。 我们生成的裴波纳契数有一个大于 10000 的，当传递一个块作为终止测试时，该序列操作符所有的元素直到那个块返回真为止，然后它返回最后一个元素，然后停止。但是有一种替代形式的操作符能做同样的事情：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...^</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">&gt;</span> <span class="mi">10000</span> <span class="p">};</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</span>
</code></pre></div><p>从 <code>...</code> 转换为 <code>...^</code> 意味着结果列表不包含让终止测试返回真时的第一个元素。</p>
<p>在 Raku 中这真是一种冗长的指定序列的方法。在这里我没有地方解释所谓的闭包，但是去年的文章已经说过它们。使用闭包，你可以将上一个序列写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">;</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</span>
</code></pre></div><p>这样写是否清晰完全取决于你，条条大路通罗马。并且，序列操作符的左侧可以是任何列表，甚至是惰性的。这意味着你可以很容易的使用一个终止块来得到已存在的惰性列表的有限的一部分：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@Fibonacci</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*</span> <span class="o">+</span> <span class="o">*</span> <span class="o">...</span> <span class="o">*</span><span class="p">;</span>
<span class="nv">@Fibonacci</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">;</span>
<span class="c1"># 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</span>
<span class="nb">say</span> <span class="nv">@Fibonacci</span><span class="o">[</span><span class="mi">30</span><span class="o">]</span><span class="p">;</span> <span class="c1"># 832040</span>
</code></pre></div><p>(我坚持最后的检查只是为了说明 <code>@Fibonacci</code> 在超过 10000 之后依然会继续。</p>
<p>这才触及到序列能做什么的皮毛，更多的信息，查看细则中的 “List infix precedence”，然后下拉到序列操作符（尽管如此，注意这还没有全部实现！它是一个极其复杂的操作符。）</p>
<p>我还要告诉你的是，序列操作符不局限于工作于数字，如果你显式地指定了你自己的生成器，你可以生成任何类型的序列。但是我喜欢将这保留到未来的圣诞节礼物。</p>
<h2 id="第五天--为什么-raku-语法是你想要的">第五天 – 为什么 Raku 语法是你想要的</h2>
<p>圣临月第五天，您或许有些失望没能看到 Raku 酷呆了的新玩法。这次会是直观的解释一些编程语言的运行原理。
作为样例，先说下面这两行吧：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Price: 15 Euro</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="p">/</span><span class="se">\d</span><span class="o">+</span><span class="p">/;</span>
</code></pre></div><p>嗯，两行代码的运行结果分别是 2 和 15。相信这对 Raku 程序员来说没什么可奇怪的。但你再细看看，两行都有斜杠 <code>/</code>，却为了完全不一样的目的，第一个是数值运算，第二 个是正则匹配。</p>
<p>Raku 怎么知道一个 <code>/</code> 号意味着什么？这当然不是简单的看 <code>/</code> 号后面的文本来决定，因为正则表达式可以看起来跟普通代码一样。
答案是：Raku 会持续跟踪他的预期。Raku 预期中最重要的两样东西就是：词和操作符。</p>
<p>一个词可以是像 23 或者 str 这样的文字。当解释器发现这样一个文字，然后后面就会是一个语句的结束（即分号;），或者一个操作符像 <code>+/*</code> 等等。过了这个操作符，解 释器又开始预期下一个词。</p>
<p>其实这就是问题的答案了：当解释器预期为词的时候，斜线 / 就代表正则表达式的开始；当预期为操作符的时候，斜线 / 就代表数字的除法运算。</p>
<p>这种做法造成了深远的后果。子函数运行可以不加括号，而在函数名后面，perl 预期一个词开端的参数列表。另一方面，类型名必须跟在操作符后面，所以，所有的类型名必 须在解析时就是已知的。</p>
<p>这样，很多字符都可以重复使用在不同的语法环境下了。</p>
<h2 id="第六天--x-和-z-元操作符">第六天 – X 和 Z 元操作符</h2>
<p>Raku 中一个新的创意就是元操作符，这种元操作符和普通的操作符结合改变了普通操作符的行为。这种元操作符有很多，但这里我们只关注它们中的两个: <code>X</code> 和 <code>Z</code>。</p>
<p><code>X</code> 操作符你可能已经见过它作为中缀交叉操作符的普通角色。它将列表联合在一起，每个列表中各取一个元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1">#  ((1, &#34;a&#34;), (1, &#34;b&#34;), (2, &#34;a&#34;), (2, &#34;b&#34;))</span>
</code></pre></div><p>然而, 这个中缀操作符 <code>infix:&lt;X&gt;</code> 其实是将 <code>X</code> 操作符应用到列表连接操作符 <code>infix:&lt;,&gt;</code> 上的简便形式。事实上，你可以这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">,</span> <span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># ((1, 10), (1, 11), (2, 10), (2, 11))</span>
</code></pre></div><p>如果你将 <code>X</code> 应用到不同的中缀操作符上面会发生什么？应用到 <code>infix:&lt;+&gt;</code> 上呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">+</span> <span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (11, 12, 12, 13).list</span>
</code></pre></div><p>它做了什么？它不是从每个组合中挑出所有的元素列表，这个操作符将中缀操作符 <code>+</code> 应用到元素间，并且结果不是一个列表，而是一个数字，是那个组合中所有元素的和。</p>
<p>这对任何中缀操作符都有效。看看字符串连接 <code>infix:&lt; ~ &gt;</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">~</span> <span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (&#34;110&#34;, &#34;111&#34;, &#34;210&#34;, &#34;211&#34;)</span>
</code></pre></div><p>或者也许数值相等操作符 <code>infix:&lt;==&gt;</code></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">X</span><span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span>
<span class="c1"># (Bool::True, Bool::True, Bool::False, Bool::False)</span>
</code></pre></div><p>但是这篇文章也是关于 <code>Z</code> 元操作符的。我们期望你已经知道他是什么了。如果你遇见过中缀操作符 <code>Z</code>，它当然是 <code>Z,</code> 的便捷形式。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">Z</span><span class="o">,</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># ((1, 3), (2, 4))</span>
<span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">Z</span><span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (4, 6).list</span>
<span class="nb">say</span> <span class="p">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">Z</span><span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># (Bool::True, Bool::False)</span>
</code></pre></div><p><code>Z,</code> 然后, 依次操作每个列表的每个元素，同时操作每个列表中的第一个元素，然后同时操作第二对儿，然后第三对儿，不管有多少。当到达列表的结尾时停止。</p>
<p><code>Z</code> 也是惰性的,所以你可以将它用在两个无限列表上，它会尽可能多地生成你需要的结果。<code>X</code> 只能处理左边是无限列表的列表，否则它不会设法得到任何东西。</p>
<p>有一个键和值得列表，你想得到一个散列？ 容易！</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="nv">@keys</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@values</span><span class="p">;</span>
</code></pre></div><p>或者，也许你想并行遍历两个列表？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>或者三个?</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="ow">Z</span> <span class="nv">@c</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="nv">$c</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>或者你能从扔3次有10个面的骰子的所有数字组合中，得到所有可能的总数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@d10</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">(</span><span class="nv">@d10</span> <span class="ow">X</span><span class="o">+</span> <span class="nv">@d10</span><span class="p">)</span> <span class="ow">X</span><span class="o">+</span> <span class="nv">@d10</span><span class="p">;</span>
</code></pre></div><p>如果你想看到一些在真实世界这些原操作符的用途，看看 Moritz Lenz’s 写的 Sudoku.pm 数独解算器。</p>
<h2 id="第七天-词法变量">第七天 词法变量</h2>
<p>编程总是件很难持续做下去的事情。串几行代码很容易，根据想法做一个原型也是轻松愉快的。但随着程序慢慢变大，维护时间慢慢变长，事情慢慢就棘手起来了……最后，如果不幸的话，我们就得被迫重构——不是因为早先的问题复杂，而是因为程序本身复杂了……在不断的调试中急白了头的程序员们，早就不记得到底要怎么扩展程序以完成目的了……</p>
<p>所以我们回溯一下编程史，找找对着复杂性的办法。而答案就在那里，不来不去——<code>限制长度</code>。当你架构一个成百上千模块组成的大型程序的时候，你必须能够让这些组件通过表面上很小的设置进行交互——否则你就等着被乱七八糟的组合干死吧。</p>
<p>在各层次的编程上，我们都可以看到这么一个原则。因为他就只关心这一件事情：分散注意，专一的做一件事情！BCNF 范式、monads (译者注：不知道这东东咋翻译)、单子，例程，类，角色，模块，包等。这些都是在督促和指导我们限制编程的长度。这样我们才不会输在组
合学上。而这方面最简单的例子，就是词法变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$var</span><span class="p">;</span>
    <span class="c1"># $var可见</span>
<span class="p">}</span>
<span class="c1"># $var不可见</span>
</code></pre></div><p>哈哈，这就是今天要介绍的一个非常酷的功能了！非常有趣的说。</p>
<p>Perl 从第一版开始，在这方面一直不太对。比如 Perl5 的默认变量作用域是包。而这就是全局变量的一种。我在某个代码块里定义了一个变量，其他地方居然也能看到……</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ perl -v
This is perl 5, version 12, subversion <span class="m">1</span> <span class="o">(</span>v5.12.1<span class="o">)</span>
$ perl -E <span class="s1">&#39;{ $var = 42 }; say $var&#39;</span>
<span class="m">42</span>
$ perl -wE <span class="s1">&#39;{ my $var= 42 }; say $var&#39;</span>
Name <span class="s2">&#34;main::var&#34;</span> used only once: possible typo at -e line 1.
Use of uninitialized value <span class="nv">$var</span> in say at -e line 1.
</code></pre></div><p>在 Raku 里，词法变量变成了默认设置。在 Rakudo 上运行上面的代码，根本无法通过编译：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku -e <span class="s1">&#39;{ $var = 42 }; say $var&#39;</span>
<span class="o">===</span>SORRY!<span class="o">===</span>
Symbol <span class="s1">&#39;$var&#39;</span> not predeclared in &lt;anonymous&gt;
$ raku -e <span class="s1">&#39;{ my $var = 42 }; say $var&#39;</span>
<span class="o">===</span>SORRY!<span class="o">===</span>
Symbol <span class="s1">&#39;$var&#39;</span> not predeclared in &lt;anonymous&gt;
</code></pre></div><p>好了，你可能说：“嗯，可以减少点打错字的可能了”。这当然没错，但是更重要的是：这让你认真坦诚的对待<code>变量作用域</code>。这对你控制代码复杂性很有利！</p>
<p>我们可以说出很多很多解释来说明为啥 Perl5 这么做。比如 Perl5 已经建议大家 <code>use warnings;</code> <code>use strict;</code> ，比如 Perl5 承诺的向后兼容，嗯，很伟大的做法，而 Perl1 压根没打算用来写大型程序和管理带来的复杂性；比如全局变量在单行模式下的各种方便……</p>
<p>Raku 内置的强制你从小处着手，帮你在系统扩容的时候，更苛责的关注架构基础。在变量方面，也就是在脚本和模块中，将词法变量作为默认设置。不过在 perl -e 执行的单行命令中，默认依然是全局变量。（ Rakudo 还没有实现这个，目前单行依然是词法变量，期待实现的那天~）</p>
<p>继续。好像到这里你感觉词法变量的价值已经说完了？没有！正确设计的结果可是令人惊讶和奖金源源不断啊~考虑一下这个子程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">counter</span><span class="p">(</span><span class="nv">$start_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$count</span> <span class="o">=</span> <span class="nv">$start_value</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nv">$count</span><span class="o">++</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div><p>这里返回的是一个代码块。所以每次我们调用 <code>counter()</code> 的时候，得到的都是一小片断开的代码。然后看看当我创建两片这样的代码后的结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$c1</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$c1</span><span class="p">();</span>           <span class="c1"># 5</span>
<span class="nb">say</span> <span class="nv">$c1</span><span class="p">();</span>           <span class="c1"># 6</span>
<span class="nv">&amp;nbsp_place_holder</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$c2</span> <span class="o">=</span> <span class="nf">counter</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$c2</span><span class="p">();</span>           <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$c1</span><span class="p">();</span>           <span class="c1"># 7</span>
<span class="nb">say</span> <span class="nv">$c2</span><span class="p">();</span>           <span class="c1"># 43</span>
</code></pre></div><p>看到了吧， <code>$c1</code> 和 <code>$c2</code> 是完全分开的，他们相互独立互不影响。尽管他们都写成 $count 的样子，看起来真是差不多，但他们都有自己独立的存储单元——因为每次我们运行进入那个代码块的时候，就是一次重新开始。这个小代码块从运行中的计数器里返回，这些计数器里保留了存储单元的对应关系。（他“关闭”这个存储单元，保护它不被 GC 回收掉。这类代码块叫闭包）</p>
<p>这个闭包看起来像是个轻量级的对象？gxgx，他们确实就是。闭包背后的原则，即规范对闭包值的访问方式，与面向对象背后的封装和信息的原则是一样的。他们都是尽力限制事情的程度，在事情变得糟糕的时候，帮忙减少其影响和损失。</p>
<p>你可以用词法变量做些很有趣的事情，比如闭包；而包变量不行。词法变量最酷啦！吼吼~~</p>
<h2 id="第八天---不同东西用不同名字">第八天 - 不同东西用不同名字</h2>
<p>Perl5 的新手们，总会很奇怪的说为啥自己没法倒装呢？Perl 里有内置的 reverse 命令，但好像压根不起作用啊：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ perl -E <span class="s2">&#34;say reverse &#39;hello&#39;&#34;</span>
hello
</code></pre></div><p>当他们去问一些有经验的 perler 的时候，解决办法很快就有了。因为 reverse 有两种操作模式，分别工作在标量和列表环境下，用来倒装字符串和列表元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ perl -E <span class="s2">&#34;say scalar reverse &#39;hello&#39;&#34;</span>
olleh
</code></pre></div><p>比较悲剧的是这个情况和大多数的 perl 语境是不一致的。比方说，绝大多数的操作符和函数由自己决定语境，并在这个语境下分析数据。好比 + 和 * 作用于数字，. 作用于字符串。所以说他们代表一个操作并且提供语境，而 <code>reverse</code> 却不是。</p>
<p>在 Raku 里，我们从过去的错误里吸取教训以摆脱历史的窘境。所以我们把列表倒叙，字符串翻转，哈希反演分开成了三个操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 字符串翻转，改名叫flip</span>
<span class="nv">$</span> <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say flip &#34;hello&#34;</span><span class="p">&#39;</span>
<span class="n">olleh</span>
<span class="c1"># 列表倒叙</span>
<span class="nv">$</span> <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">say join &#34;, &#34;, reverse &lt;ab cd ef&gt;</span><span class="p">&#39;</span>
<span class="n">ef</span><span class="o">,</span> <span class="n">cd</span><span class="o">,</span> <span class="n">ab</span>
<span class="c1"># 哈希反转，叫 invert</span>

<span class="k">my</span> <span class="nv">%capitals</span> <span class="o">=</span> <span class="s">France</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Paris</span><span class="p">&#34;</span>, <span class="s">UK</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">London</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%capitals</span><span class="o">.</span><span class="nb">invert</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="p">(&#34;</span><span class="s2">Paris</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">France</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">London</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">UK</span><span class="p">&#34;)</span>
</code></pre></div><p>注意哈希的反演和其他两个不同。因为哈希的值不要求是唯一的，所以反演后，哈希结构可能会被改变，或者某些值被覆盖……
如果必要的话，使用者可以自己决定返回哈希结构时的操作方式。比如下面就是一种无损的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%inverse</span><span class="p">;</span>
<span class="nv">%inverse</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span> <span class="nv">%original</span><span class="o">.</span><span class="nb">invert</span> <span class="p">);</span>
</code></pre></div><p>这个方法会在键值对存在的情况下，把新值 push 在原有值的队尾变成一个数组：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span>
<span class="nv">%h</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1"># foo =&gt; 1</span>
<span class="nv">%h</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1"># foo =&gt; [1, 2]</span>
<span class="nv">%h</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">);</span>    <span class="c1"># foo =&gt; [1, 2, 3]</span>
</code></pre></div><p>这三个函数，都会强制转换他们的参数。也就是说，如果你传递一个列表给 flip，这个列表会被强制成字符串后再翻转返回。</p>
<h2 id="第十天--feed-operators">第十天 – Feed operators</h2>
<p>使用Perl 5 编程一段时间的人可能遇到或写过下面这样相似的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="k">my</span> <span class="nv">@new</span> <span class="o">=</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="nv">@original</span><span class="p">;</span>
</code></pre></div><p>在这个构造中，数据从 <code>@original</code> 数组流进 <code>grep</code>，然后按顺序，流进 <code>map</code> ，然后流进 <code>sort</code>，最后将结果赋值给 <code>@new</code> 数组。因为它们每个都将列表作为它们最终的参数，仅仅通过位置，数据从一个操作符向左流进下一个操作符。</p>
<p>Raku, 从另一方面，通过引入流向操作符让数据从一个操作符流进另一个操作符，让这种思想更明确。上面的 Perl 5 代码能使用 Raku 重写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@new</span> <span class="o">&lt;==</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nv">@original</span><span class="p">;</span>
</code></pre></div><p>注意条条大路通罗马，这个在 Raku 中更能体现。你也可以跟 Perl 5 的写法相同：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@new</span> <span class="o">=</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@original</span><span class="p">;</span>
</code></pre></div><p>唯一不同的是额外的逗号。</p>
<p>所以，我们从这些流向操作符得到了什么？通常，当我们阅读代码的时候，你是从左向右读的，在原来的 Perl 5 代码中，你可能从左到右阅读你的代码直到你发现正在处理的结构，其流向是从右向左的，然后你跳到末尾，按照从右往左的方式再读一遍。</p>
<p>在 Raku 中，现在有一个突出的句法标记，告诉你数据向左流动的性质。</p>
<p>这样写也可以：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@original</span> <span class="o">==&gt;</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">sort</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>  <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@new</span><span class="p">;</span>
</code></pre></div><p>下面是一些使用流向操作符的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@random-nums</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">);</span>  <span class="c1"># 100个随机数</span>
<span class="k">my</span> <span class="nv">@odds-squared</span> <span class="o">&lt;==</span> <span class="nb">sort</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nv">@random-nums</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">~</span><span class="nv">@odds-squared</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@a</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">);</span>

<span class="nv">@a</span> <span class="o">==&gt;</span> <span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span><span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">sort</span> <span class="p">{</span><span class="nv">$^a</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span><span class="p">}</span> <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@c</span><span class="p">;</span>
<span class="c1"># 1 9 25 49 81 121 169 225 289 361 441 529 625 729 841 961 1089 1225 1369 1521 1681 1849 2025 2209 2401 2601 2809 3025 3249 3481 3721 3969 4225 4489 4761 5041 5329 5625 5929 6241 6561 6889 7225 7569 7921 8281 8649 9025 9409 9801</span>

<span class="k">my</span> <span class="nv">@odds-squared</span> <span class="o">&lt;==</span> <span class="nb">sort</span> <span class="p">{</span><span class="nv">$^b</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^a</span><span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span> <span class="nv">%</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">&lt;==</span> <span class="nv">@random-nums</span>   <span class="c1"># 降序排列</span>
<span class="c1"># 9801 9409 9025 8649 8281 7921 7569 7225 6889 6561 6241 5929 5625 5329 5041 4761 4489 4225 3969 3721 3481 3249 3025 2809 2601 2401 2209 2025 1849 1681</span>
<span class="mi">1521</span> <span class="mi">1369</span> <span class="mi">1225</span> <span class="mi">1089</span> <span class="mi">961</span> <span class="mi">841</span> <span class="mi">729</span> <span class="mi">625</span> <span class="mi">529</span> <span class="mi">441</span> <span class="mi">361</span> <span class="mi">289</span> <span class="mi">225</span> <span class="mi">169</span> <span class="mi">121</span> <span class="mi">81</span> <span class="mi">49</span> <span class="mi">25</span> <span class="mi">9</span> <span class="mi">1</span>

<span class="k">my</span> <span class="nv">@rakudo-people</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">scott patrick carl moritz jonathan jerry stephen</span><span class="p">&gt;;</span>
<span class="nv">@rakudo-people</span> <span class="o">==&gt;</span> <span class="nb">grep</span> <span class="p">{</span> <span class="o">/</span><span class="nb">at</span><span class="o">/</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">.</span><span class="nf">ucfirst</span> <span class="p">}</span> <span class="o">==&gt;</span> <span class="k">my</span> <span class="nv">@who-it&#39;s-at</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">~</span><span class="nv">@who-it&#39;s-at</span><span class="p">;</span>    <span class="c1"># Patrick Jonathan</span>

<span class="o">[+]</span><span class="p">(</span><span class="k">my</span> <span class="nv">@a</span><span class="p">)</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">**</span><span class="mi">2</span><span class="p">}</span> <span class="o">&lt;==</span>  <span class="mi">1</span><span class="o">..</span><span class="mi">10</span>   <span class="c1"># 385， 1 到 10 的平方和</span>
<span class="o">[+]</span><span class="p">()</span> <span class="o">&lt;==</span> <span class="nb">map</span> <span class="p">{</span><span class="nv">$_</span> <span class="o">**</span><span class="mi">2</span><span class="p">}</span> <span class="o">&lt;==</span>  <span class="mi">1</span><span class="o">..</span><span class="mi">10</span>        <span class="c1"># 385</span>
</code></pre></div><h2 id="第十二天--智能匹配">第十二天 – 智能匹配</h2>
<p>还记得<a href="http://rakuadvent.wordpress.com/2010/12/04/the-sequence-operator/">Raku Advent</a> 序列操作符吗?因为最后一个参数它接受的是一个上限，这让序列的生成停止了，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">32</span><span class="p">;</span>         <span class="c1"># 1 2 4 8 16 32</span>
<span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">;</span>     <span class="c1"># 1 2 4 8 16</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span> <span class="o">...</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>      <span class="c1"># 1 2 4 8 16 32 64 128</span>
<span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">;</span>     <span class="c1"># 1 2 4 8 16 32 64</span>
</code></pre></div><p>你能看到，在第一种情况下，使用了数值相等。第二个更有意思：<code>*&gt;10</code> 在内部被重写为一个闭包，像这样 <code>-&gt; $x { $x &gt; 10 }</code> (through currying).</p>
<p>序列操作符做了一些不可思议的比较，根据匹配者的类型。这种比较就叫做智能匹配，并且是在 Raku 中重复出现的一个概念，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># after the &#39;when&#39; keyword:</span>
<span class="k">given</span> <span class="nv">$age</span> <span class="p">{</span>
    <span class="k">when</span> <span class="mi">100</span>    <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">congratulations!</span><span class="p">&#34;</span>      <span class="p">}</span>
    <span class="k">when</span> <span class="o">*</span> <span class="o">&lt;</span> <span class="mi">18</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You&#39;re not of age yet</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># after &#39;where&#39;:</span>
<span class="k">subset</span> <span class="nc">Even</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1"># 显式地使用智能匹配操作符:</span>
<span class="k">if</span> <span class="nv">$input</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="se">\d</span><span class="o">+</span><span class="ni">$</span><span class="p">/</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$input</span><span class="s2"> is an integer</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="c1"># arguments to grep(), first() etc.:</span>
<span class="k">my</span> <span class="nv">@even</span> <span class="o">=</span> <span class="nv">@numbers</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="n">Even</span><span class="p">;</span>
</code></pre></div><p>在智能操作符 <code>~~</code> 的右侧，并且在 <code>when</code> 和 <code>where</code> 的后面，要匹配的值被设置为 主题变量 <code>$_</code>。</p>
<p>下面是一些智能操作符的用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$foo</span> <span class="o">~~</span> <span class="nb">Str</span>             <span class="c1">#它的类型是 Str吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="mi">6</span>               <span class="c1">#它等于 6 吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="p">&#34;</span><span class="s2">bar</span><span class="p">&#34;</span>           <span class="c1">#或者它是 &#34;bar&#34; 吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">/</span> <span class="c1"># 它匹配某个模式吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="p">(</span><span class="mi">15</span><span class="o">..</span><span class="mi">25</span><span class="p">)</span>        <span class="c1"># 它的值在 15 和 25 之间吗?</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ok</span><span class="p">&#39;</span> <span class="k">if</span> <span class="mi">5</span> <span class="o">&lt;</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">25</span> <span class="p">}</span> <span class="c1"># 调用闭包</span>
<span class="nv">$foo</span> <span class="o">~~</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="o">*,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*]</span> <span class="c1"># 含有6个元素的数组，是否其所有的奇数元素的值都为 1?</span>
</code></pre></div><p><a href="http://perlcabal.org/syn/S03.html#Smart_matching">智能匹配的全部表现可以在这找到：</a>.</p>
<p>智能匹配没有特殊的操作符，而大部分智能匹配的情况会返回 Bool 值，对正则进行匹配会返回一个 Match 对象</p>
<p>你可能开始怀疑：一个正确的，内置的类型，我怎么将它用在我自己的类中？你需要为它写一个特别的 ACCEPTS 方法。假如我们有一个叫Point 的类：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.x</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.y</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">ACCEPTS</span><span class="p">(</span><span class="nb">Positional</span> <span class="nv">$p2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$.x</span> <span class="o">==</span> <span class="nv">$p2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="ow">and</span> <span class="nv">$.y</span> <span class="o">==</span> <span class="nv">$p2</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>一切都清楚了吗?让我们看看它是如何工作的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">Point</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">x</span> <span class="o">=&gt;</span> <span class="mi">7</span>, <span class="s">y</span> <span class="o">=&gt;</span> <span class="mi">9</span><span class="p">);</span>
<span class="nb">say</span> <span class="o">[</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">]</span> <span class="o">~~</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># Bool::False</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">~~</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># Bool::True</span>
</code></pre></div><p>现在能恰当地做到你想要的，甚至使用你自己的类。</p>
<h2 id="第-16-天---raku-里的时间">第 16 天 - Raku 里的时间</h2>
<p>今天是圣诞月历的第 0x10 天，是时候学习一下 raku 里的时间了。S32::Temporal 简介在过去一年中有了大量的修改，今天我们就来介绍一下在 raku 实现中关于时间的一些基础知识。</p>
<p><code>time</code> 和 <code>now</code> 是两个可以返回当前时间（至少是你的系统认为的当前时间）的词。简单的展示一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">time</span><span class="p">;</span>
<span class="nb">say</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><pre><code>1292460064
Instant:2010-12-16T00:41:4.873248Z
</code></pre><p>第一个明显的区别，前者返回的是 POSIX 格式的数值型的结果；而后者返回的是一个瞬间的对象。如果你想获取秒级以下小数点位或者说闰秒，请用 now ；如果不用，那用 time 获取 POSIX 格式就够了。随你的便。</p>
<ul>
<li>DateTime 和他的伙伴</li>
</ul>
<p>大多数时候，你要的不是当前时间。这种时候，你需要的是 <code>DateTime</code> 。比如还是获取当前时间：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$moment</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">now</span><span class="p">);</span> <span class="c1"># 或者 DateTime.new(time)</span>
</code></pre></div><p>你有两种方式来创建 DateTime 对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$dw</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">year</span><span class="p">(</span><span class="mi">1963</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">month</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">day</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">hour</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">minute</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span>
</code></pre></div><p>这是 UTC 时区，如果你要更改时区的话，再加上 <code>:timezone</code> 就好了。这个格式里，只有 <code>:year</code> 是必须的，其他的默认就是1月1号半夜0点0分。</p>
<p>上面这种写法确实乏味，你可以采用 ISO8601 格式的输入，来创建一个 DateTime 对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$dw</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">1963-11-23T17:15:00Z</span><span class="p">&#34;);</span>
</code></pre></div><p>其中 Z 表示 UTC ，想改变的话，把 Z 替换成 <code>+hhmm</code> 或者 <code>-hhmm</code> 就好了。hh 表示小时，mm 表示分钟。
此外，还有一个更简略的 Date 对象。只包括年月日的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$jfk</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">1963-11-22</span><span class="p">&#34;);</span> <span class="c1"># 你也可以用:year 等的写法</span>
</code></pre></div><p>引入 Date 对象，是吸取了 CPAN 上 DateTime 模块的教训：有时候你压根不关心什么时区啊闰秒啊的。Date 对象非常容易处理，比如它有内置的 <code>.succ</code> 和 <code>.pred</code> 方法，用来简单的递增和递减。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$jfk</span><span class="o">++</span><span class="p">;</span> <span class="c1"># 肯尼迪遇刺后的第二天</span>
</code></pre></div><p>最后…</p>
<p>以上就是关于 Raku 里的时间的内容了，想了解更多细节，去看看规范吧；或者去社区里提问</p>
<h2 id="第十九天---假作真时真亦假">第十九天 - 假作真时真亦假</h2>
<p>今天的圣临礼物是教大家怎么用混淆完成一个小邪恶滴目的，吼吼~看起来这个功能挺疯狂的，其实有时候蛮有用的。先看下面这个用 but 的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="mi">42</span> <span class="k">but</span> <span class="k">role</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">Bool</span>  <span class="p">{</span> <span class="nb">False</span> <span class="p">}</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">$value</span><span class="p">;</span>    <span class="c1"># 42</span>
<span class="nb">say</span> <span class="o">?</span><span class="nv">$value</span><span class="p">;</span>   <span class="c1"># False</span>
</code></pre></div><p>你看，我们改变了 <code>$value</code> 的 <code>.Bool</code> 方法。他不影响程序里其他所有的整数，哪怕别的变量也是 42。一般情况下，对于 Int 型，<code>.Bool</code> 方法（通过?操作符）返回值依据是是否等于 0。但这次它永远都返回 false 了。
事实上，我们还可以写的更简单，因为 False 是一个枚举值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="mi">42</span> <span class="k">but</span> <span class="nb">False</span><span class="p">;</span>
</code></pre></div><p>因为 False 是 Bool 值，所有它会自动重载 <code>.Bool</code> 方法。这是 Raku 的一种转换方法。其他的值，也会对应的重载。</p>
<p>这样在有的时候，这个东西就比较有用了：在 Perl5 里，你用 system 调用 shell 的时候，得牢牢记住在 shell 里，返回 0 才是正常的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span> <span class="nf">system</span><span class="p">(</span><span class="nv">$cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1"># 或者!system($cmd)</span>
    <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div><p>而在 Raku 中，对应的 run 命令返回的是上面说的这种重载过的 Int，当且仅当返回值是 0 的时候，它的 bool 变成了 True，这正是我们想要的额！</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">run</span><span class="p">(</span><span class="nv">$cmd</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">#不需要否定了</span>
    <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div><p>好了，现在进入最疯狂的部分 —— 我们可以重载布尔值的布尔方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nb">True</span> <span class="k">but</span> <span class="nb">False</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$value</span><span class="p">;</span>    <span class="c1"># True</span>
<span class="nb">say</span> <span class="o">?</span><span class="nv">$value</span><span class="p">;</span>   <span class="c1"># False</span>
</code></pre></div><p>没错，Raku 允许你这样自己踢自己屁股~~虽然我也不知道除了捣乱外怎么会有人愿意这么做，但是我还是很高兴看到 Raku 保持这种微妙的跟踪和重载类型的心态。我可没有……</p>
<h2 id="day-21--transliteration-and-beyond">Day 21 – transliteration and beyond</h2>
<p>转换听起来像拉丁词根,意味着字母的变化。这就是 Str.trans 方法所做的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">GATTACA</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">TCAG</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">0123</span><span class="p">&#34;</span> <span class="p">);</span>  <span class="c1"># prints &#34;3200212\n&#34;</span>
</code></pre></div><p>使用过Perl5 的人马上意识到这就是 <code>tr/tcag/0123/</code> .</p>
<p>下面是一个例子，使用 ROT-13算法加密文本：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">rot13</span><span class="p">(</span><span class="nv">$text</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">A..Za..z</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">N..ZA..Mn..za..m</span><span class="p">&#34;</span> <span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>当 <code>.trans</code> 方法看到那些 <code>..</code> 区间时，它会在内部将那些字母展开 (所以 &ldquo;n..z&rdquo; 意思是 &ldquo;nopqrstuvwxyz&rdquo;). 因此,rot13子例程的最终效果是将ASCII字母表的特定部分映射到其他部分。</p>
<p>在 Perl5 中，两个点跟一个破折号相同，但是在Raku 中我们让那两个点 .. 代表 范围的概念，在主程序中，在正则中，还有在这里，转换。</p>
<p>要注意的是，<code>.trans</code> 方法是不会改变原来的字符串； 它不会噶边 $text, 而是返回一个新的值。这在 Raku 中也是一个通用的旋律。要改变原值，请使用  <code>.=trans</code></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$kabbala</span><span class="o">.=</span><span class="nb">trans</span><span class="p">(&#34;</span><span class="s2">A..Ia..i</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">1..91..9</span><span class="p">&#34;);</span>
</code></pre></div><p>(并且，它不仅仅适用于 <code>.trans</code> 方法，它对所有方法都适用。)</p>
<p><code>.trans</code> 方法包含了一个秘密武器：假如我们想转义一些HTML，即，根据下面这个表来替换东西：</p>
<pre><code>&amp; =&gt; &amp;amp;
&lt; =&gt; &amp;lt;
&gt; =&gt; &amp;gt;
</code></pre><p>但是我们不想关心替换还要按顺序进行：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="s">foo</span>         <span class="o">=&gt;</span> <span class="n">bar</span>
<span class="s">foolishness</span> <span class="o">=&gt;</span> <span class="n">folly</span>
</code></pre></div><p>在上面的例子中，如果前面的替换先发生，就不回有后面的替换出现了 - 这可能不是你想要的。通常，我们想在短的子串之前，尝试并匹配最长的子串。</p>
<p>所以，这看起来我们需要一个最长记号的替换匹配，以避免因为偶然的重复替换而产生的无限循环。
那就是 Raku 的 <code>.trans</code> 方法所提供的。这就是它的秘密武器：嵌入两个数组而非字符串。对于 HTML 转义，我们所需要的就是：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$escaped</span> <span class="o">=</span> <span class="nv">$html</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span>
    <span class="o">[</span> <span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="o">,</span>     <span class="p">&#39;</span><span class="s1">&lt;</span><span class="p">&#39;</span><span class="o">,</span>    <span class="p">&#39;</span><span class="s1">&gt;</span><span class="p">&#39;</span>    <span class="o">]</span> <span class="o">=&gt;</span>
    <span class="o">[</span> <span class="p">&#39;</span><span class="s1">&amp;amp;</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">&amp;lt;</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">&amp;gt;</span><span class="p">&#39;</span> <span class="o">]</span>
<span class="p">);</span>
</code></pre></div><p>替换的顺序问题和避免循环就不用我们关心了。</p>
<h2 id="第二十二天---meta-object-protocol">第二十二天 - Meta-Object Protocol</h2>
<p>你有没有想过用你最爱的编程语言写一个类——但是不是按部就班的写类定义，而是通过几行代码？有些语言提供了 API 来完成这个功能。这些 API 的后面，就是元对象协议( Meta-Object Protocol )，简称 MOP。</p>
<p>Raku 就有 MOP，你可以自己创建类、角色、语法，添加方法和属性，并且内省类。比如我们可以调用 MOP 查看 Rakudo 是如何实现 Rat 类型（有理数）的。调用 MOP ，只要把一般的 <code>.</code> 换成 <code>.^</code> 就可以了。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ raku
&gt; say join <span class="s1">&#39;, &#39;</span>, Rat.^attributes
<span class="nv">$!</span>numerator, <span class="nv">$!</span>denominator
&gt; <span class="c1"># 列出全部方法比较多，所以随机选几个</span>
&gt; say join <span class="s1">&#39;, &#39;</span>, Rat.^methods<span class="o">(</span>:local<span class="o">)</span>.pick<span class="o">(</span>5<span class="o">)</span>
unpolar, ceiling, reals, Str, round
&gt; say Rat.^methods<span class="o">(</span>:local<span class="o">)</span>.grep<span class="o">(</span><span class="s1">&#39;log&#39;</span><span class="o">)</span>.<span class="o">[</span>0<span class="o">]</span>.signature.raku
:<span class="o">(</span>Numeric <span class="nv">$x</span>: Numeric <span class="nv">$base</span> <span class="o">=</span> <span class="o">{</span> ... <span class="o">}</span><span class="p">;;</span> *%_<span class="o">)</span>
</code></pre></div><p>显示出来的这几行信息相信都是不言自明了。Rat 有两个属性，<code>$!numerator</code> 和 <code>$!denominator</code>；有很多方法，其中 log 方法可接受的第一个变量是数值型 invocant(译者注：不知道怎么翻译，反正就是对象本身的引用 <code>$_[0]</code> )，用冒号标记过；第二个变量参数是可选的，名字是 <code>$base</code>，它设有一个默认值，不过 Rakudo 不打算告诉你……</p>
<p>Raku 的数据库接口代码里有一个很不错的使用实例。它有一个选项用来记录对象的调用，但是只是记录一部分特定角色（比如和连接管理或者数据检索有关的）。下面是 dbi 里的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">log-calls</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="n">Role</span> <span class="nv">$r</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">my</span> <span class="nv">$wrapper</span> <span class="o">=</span> <span class="n">RoleHOW</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>

     <span class="k">for</span> <span class="nv">$r</span><span class="o">.^</span><span class="nb">methods</span> <span class="k">-&gt;</span> <span class="nv">$m</span> <span class="p">{</span>
         <span class="nv">$wrapper</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(</span><span class="nv">$m</span><span class="o">.</span><span class="nb">name</span><span class="o">,</span> <span class="k">method</span> <span class="p">(</span><span class="o">|</span><span class="nv">$c</span><span class="p">)</span> <span class="p">{</span>
             <span class="c1"># 打印日志信息，note() 函数输出到标准错误</span>
             <span class="nb">note</span> <span class="p">&#34;</span><span class="s2">&gt;&gt; </span><span class="nv">$m</span><span class="p">&#34;;</span>
             <span class="nb">nextsame</span><span class="p">;</span>
         <span class="p">});</span>
     <span class="p">}</span>

     <span class="nv">$wrapper</span><span class="o">.^</span><span class="nb">compose</span><span class="p">();</span>
     <span class="c1"># does 操作符和 but 类似，不过只修改一个对象的拷贝</span>
     <span class="nv">$obj</span> <span class="k">does</span> <span class="nv">$wrapper</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">role</span> <span class="nc">Greet</span> <span class="p">{</span>
     <span class="k">method</span> <span class="nf">greet</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
         <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">hello, </span><span class="nv">$x</span><span class="p">&#34;;</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">SomeGreeter</span> <span class="k">does</span> <span class="nc">Greet</span> <span class="p">{</span>
     <span class="k">method</span> <span class="nf">LOLGREET</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
         <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">OH HAI </span><span class="p">&#34;</span><span class="o">~</span> <span class="nb">uc</span> <span class="nv">$x</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$o</span> <span class="o">=</span> <span class="nf">log-calls</span><span class="p">(</span><span class="n">SomeGreeter</span><span class="o">.</span><span class="nb">new</span><span class="o">,</span> <span class="n">Greet</span><span class="p">);</span>
<span class="c1"># 记录日志啦，因为由 Greet 角色提供了</span>
<span class="nv">$o</span><span class="o">.</span><span class="nf">greet</span><span class="p">(&#39;</span><span class="s1">you</span><span class="p">&#39;);</span>
<span class="c1"># 没记录，因为没角色提供这个</span>
<span class="nv">$o</span><span class="o">.</span><span class="nf">LOLGREET</span><span class="p">(&#39;</span><span class="s1">u</span><span class="p">&#39;);</span>
</code></pre></div><p>运行结果如下：</p>
<pre><code>&gt;&gt; greet
hello, you
OH HAI U
</code></pre><p>所以说，有了 MOP ，除了指定的语法，你还可以像普通接口一样访问类、角色、语法和属性。这给了面向对象更大的灵活性，可以轻松的内省和修改对象了。</p>
<h2 id="第23天----一些精彩的排序示例">第23天 -  一些精彩的排序示例</h2>
<p>继续我们的圣临礼物。</p>
<p>排序是一个非常非常常见的编程任务。Raku 加强了它的 <code>.sort</code> 功能来帮助大家更好的排序。
最最正常的默认写法是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span> <span class="c1"># 或者这样</span>
<span class="nb">sort</span> <span class="nv">@unsorted</span><span class="p">;</span>
</code></pre></div><p>和 Perl 5 一样，也是可以自定义函数的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># 数值比较</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span> <span class="p">};</span>
<span class="c1"># 或者用函数调用的形式</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nb">sort</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@unsorted</span><span class="p">;</span>
<span class="c1"># 字符串比对 ( 跟Perl5的cmp一样 )</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="ow">leg</span> <span class="nv">$^b</span> <span class="p">};</span>
<span class="c1"># 类型依赖比对</span>
<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="ow">cmp</span> <span class="nv">$^b</span> <span class="p">};</span>
</code></pre></div><p>你也可以把 <code>:</code> 换成 <code>()</code> ，然后再跟上一些方法进行后续处理，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@topten</span> <span class="o">=</span> <span class="nv">@scores</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">$^b</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^a</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">list</span><span class="o">.</span><span class="nf">munch</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div><p>小提示： <code>$a</code> 和 <code>$b</code> 不再像在 Perl5 中那样有特殊含义了，在 sort 代码块里用别的命名变量 <code>$var</code>、位置变量 <code>$^var</code> 或者其他任何的都跟在其他代码段里一样。</p>
<p>你可以直接在排序的时候直接就做好变换函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$^a</span><span class="p">)</span> <span class="ow">cmp</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$^b</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div><p>不过 <code>foo()</code> 会在重复执行，如果列表不大也就罢了，如果比较大的话……如果 <code>foo()</code> 还是个计算密集型的……你懂的！</p>
<p>在这种情况下，Perl 5 里有个习惯就是使用施瓦茨( Schwartzian )变换。施瓦茨变换的做法就是 decorate-sort-undecorate，<code>foo()</code> 函数只用执行一次：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@sorted</span> <span class="o">=</span>
    <span class="nb">map</span>  <span class="p">{</span> <span class="nv">$_-</span><span class="o">&gt;[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>
    <span class="nb">sort</span> <span class="p">{</span> <span class="nv">$a-</span><span class="o">&gt;[</span><span class="mi">1</span><span class="o">]</span> <span class="ow">cmp</span> <span class="nv">$b-</span><span class="o">&gt;[</span><span class="mi">1</span><span class="o">]</span> <span class="p">}</span>
    <span class="nb">map</span>  <span class="p">{</span> <span class="o">[</span><span class="nv">$_</span><span class="o">,</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">]</span> <span class="p">}</span>
    <span class="nv">@unsorted</span><span class="p">;</span>
</code></pre></div><p>Raku 里，你一样可以使用施瓦茨变换，不过 Raku 内置了一些智能方法。如果你有一个函数，它接受的参数个数是 0 或 1，Raku 会自动的替你启用施瓦茨变换。</p>
<p>现在让我们来看一些例子吧。</p>
<ul>
<li>不区分大小写的排序</li>
</ul>
<p>把每个元素都改成小写，然后把数组按照小写的次序排好返回。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">lc</span> <span class="p">};</span>
</code></pre></div><ul>
<li>单词长度排序</li>
</ul>
<p>把每个元素的单词按照从短到长排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>
</code></pre></div><p>或者从长到短:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@unsorted</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">-.</span><span class="nb">chars</span> <span class="p">};</span>
</code></pre></div><ul>
<li>多次排序比较</li>
</ul>
<p>你可以在 <code>sort</code> 代码块里放多个比较函数，<code>sort</code> 会注意执行直到退出。比如在单词长度的基础上，再按照 ASCII 码的顺序排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span><span class="o">,</span> <span class="nv">$^a</span> <span class="p">}</span> <span class="p">;</span>
</code></pre></div><p>不过，在 Rakudo 里好像运行有点问题……它只会比较长度不会比较数值，也就是说，10 排在 2 的前面。（没关系，TMTONTDI）</p>
<p>Raku 里的 <code>sort</code> 本身是稳定工作的，你可以重复使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span> <span class="p">};</span>
</code></pre></div><p>不过这样 <code>sort</code> 有两次调用，no fashion！所以你还可以这么写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span> <span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;</span> <span class="nv">$^b</span><span class="o">.</span><span class="nb">chars</span> <span class="o">||</span> <span class="nv">$^a</span> <span class="ow">leg</span> <span class="nv">$^b</span> <span class="p">};</span>
</code></pre></div><p>不过这下你有两个参数了，Raku 没法自动给你启动施瓦茨变换了。</p>
<p>又或者，你可以加上一个给自然数排序的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@a</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$^a</span><span class="o">.</span><span class="nb">chars</span><span class="o">.&amp;</span><span class="nf">naturally</span><span class="o">,</span> <span class="nv">$^a</span> <span class="p">};</span>
</code></pre></div><p>“给自然数排序？”我好像听到你们的哭声了，“哪里有？” 很高兴你们这么问，现在继续解决这个问题。</p>
<ul>
<li>自然数排序</li>
</ul>
<p>标准的词法排序是按照 ASCII 次序的。先是自然数，然后是大写字母，最后是小写字母。所以人们在排序的时候经常得到这样的结果：</p>
<pre><code>0
1
100
11
144th
2
21
210
3rd
33rd
AND
ARE
An
Bit
Can
and
by
car
d1
d10
d2
</code></pre><p>完全正确，但是没用……尤其是对非程序员来说，更郁闷了就……真正的自然排序，应该是先按数学量级排自然数，然后才是大小写字母。比如上面那个例子，应该排成这样：</p>
<pre><code>0
1
2
3rd
11
21
33rd
100
144th
210
An
AND
and
ARE
Bit
by
Can
car
d1
d2
d10
</code></pre><p>所以，我们必须的在排序的时候加上一点转换了。我使用 <code>.subst</code> 方法，这是我们所熟悉的 <code>s///</code> 操作符的面向对象形式。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span>
</code></pre></div><p>第一部分，捕获一个连续的数字，然后由 <code>-&gt; $/ {}</code> 构成一个尖号块，意思是：“传递匹配到 <code>$/</code> 的数组到 <code>{}</code> 代码里”。然后代码里替换成用 0 按照数量级排序的顺序联结的字符串。这个 0 是以 ASCII 字符串出现，联结在原始字符串上的。最后 <code>/g</code> 表示全局替换。</p>
<p>如果也不区分大小写，那么：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">lc</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span>
</code></pre></div><p>改成子例程的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">naturally</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$a</span><span class="o">.</span><span class="nb">lc</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>看起来很不错了，不过还有点小问题，比如 THE 、 The 和 the 会按照他们在列表里的顺序返回，而不是我们预计的顺序。有个简单的解决办法，就是在转换过的元素的结尾，加上一个中断。所以最终结果是：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">naturally</span> <span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$a</span><span class="o">.</span><span class="nb">lc</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$/</span> <span class="p">{</span> <span class="mi">0</span> <span class="o">~</span> <span class="nv">$0</span><span class="o">.</span><span class="nb">chars</span><span class="o">.</span><span class="nb">chr</span> <span class="o">~</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="se">\x</span><span class="mh">0</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$a</span>
<span class="p">}</span>
</code></pre></div><p>然后你看，这个子例程只有一个参数，所以我们还可以用上施瓦茨变换了：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">0 1 100 11 144th 2 21 210 3rd 33rd AND ARE An Bit Can and by car d1 d10 d2</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.&amp;</span><span class="nf">naturally</span> <span class="p">};</span>
</code></pre></div><p>或者用来给 ip 排序：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@ips</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="o">..</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span><span class="k">for</span> <span class="mi">0</span><span class="o">..</span><span class="mi">99</span><span class="p">);</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">@ips</span><span class="o">.</span><span class="nb">sort</span><span class="o">:</span> <span class="p">{</span> <span class="o">.&amp;</span><span class="nf">naturally</span> <span class="p">};</span>
</code></pre></div><p>输出:</p>
<pre><code>4.108.172.65
5.149.121.70
10.24.201.53
11.10.90.219
12.83.84.206
12.124.106.41
12.162.149.98
14.203.88.93
16.18.0.178
17.68.226.104
21.201.181.225
23.61.166.202
</code></pre><p>以及目录排序啊等等各种数字与字母的混合体。</p>
<p>最后，圣诞快乐，排序快乐，愿施瓦茨与你同在！</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/calendar" term="calendar" label="calendar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 核心魔改: Grammar 的胡言乱语]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Grammar 解析文本: 一个例子" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Core Hacking Grammatical Babble</blockquote><p>喜欢修复 Raku 编译器中的 bug? 这儿有一个<a href="https://rt.perl.org/Ticket/Display.html?id=128304">great grammar bugglet</a>: 当 <code>„”</code> 引号用在引起的用空白分割的单词列表构造器中时看起来好像不能工作:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> „<span class="n">hello</span> <span class="n">world</span>”<span class="p">;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="k">q</span><span class="sa">ww</span><span class="p">&lt;</span><span class="s2">„hello world”</span><span class="p">&gt;;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="k">q</span><span class="sa">ww</span><span class="p">&lt;</span><span class="s2">&#34;hello world&#34;</span><span class="p">&gt;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># hello world</span>
<span class="c1"># „hello</span>
<span class="c1"># world”</span>
<span class="c1"># hello world</span>
</code></pre></div><p><code>”</code> 引号不应该出现在输出中并且在输出中我们应该只有 3 行输出; 这 3 行输出都是 <code>hello world</code>。看起来像是一个待修复的有趣的 bug! 我们进去看看。</p>
<h2 id="你怎样拼写它">你怎样拼写它?</h2>
<p>事实上这段代码没能正确解析表明这是一个 grammar bug。大部分的 grammar 住在 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/Grammar.nqp">src/Raku/Grammar.nqp</a>中, 但是在我们的手变脏之前, 让我们来解决我们应该查看什么。</p>
<p>二进制 <code>raku</code> 有一个 <code>--target</code> 命令行参数来接收其中之一的编译步骤并且会导致那个步骤的输出被产生出来。那儿有哪些步骤? 根据你正使用的后端它们也会有所不同, 但是你可以仅仅运行 <code>raku --stagestats -e ''</code> 把它们都打印出来:</p>
<pre><code>zoffix@leliana:~$ raku --stagestats -e ''
Stage start      :   0.000
Stage parse      :   0.077
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   0.001
Stage mast       :   0.004
Stage mbc        :   0.000
Stage moar       :   0.000
</code></pre><p>Grammars 是关于解析的, 所以我们会查询 <code>parse</code> 目标(target)。至于要执行的代码, 我们会仅仅给它有问题的那块; 即 <code>qww&lt;&gt;</code>:</p>
<pre><code>zoffix@leliana:~$ raku --target=parse -e 'qww&lt;„hello world”&gt;'
- statementlist: qww&lt;„hello world”&gt;
  - statement: 1 matches
    - EXPR: qww&lt;„hello world”&gt;
      - value: qww&lt;„hello world”&gt;
        - quote: qww&lt;„hello world”&gt;
          - quibble: &lt;„hello world”&gt;
            - babble:
              - B:
            - nibble: „hello world”
          - quote_mod: ww
            - sym: ww
</code></pre><p>那很棒! 每一行前面都有能在 grammar 中找到的 token 的名字, 所以现在我们知道了在哪里查找问题。</p>
<p>我们还知道基本的引号能正确地工作, 所以我们也倾倒出它们的解析步骤, 来看看这两个输出之间是否有什么不同:</p>
<pre><code>zoffix@leliana:~$ raku --target=parse -e 'qww&lt;&quot;hello world&quot;&gt;'
- statementlist: qww&lt;&quot;hello world&quot;&gt;
  - statement: 1 matches
    - EXPR: qww&lt;&quot;hello world&quot;&gt;
      - value: qww&lt;&quot;hello world&quot;&gt;
        - quote: qww&lt;&quot;hello world&quot;&gt;
          - quibble: &lt;&quot;hello world&quot;&gt;
            - babble:
              - B:
            - nibble: &quot;hello world&quot;
          - quote_mod: ww
            - sym: ww
</code></pre><p>那么&hellip; 好吧, 除了引号不同, 解析数完全一样。所以它看起来好像所有涉及的 tokens 都是相同的, 但是那些 tokens 所做的事情不同。</p>
<p>我们不必检查输出中我们看到的每个 tokens。<code>statementlist</code> 和 <code>statement</code> 是匹配普通语句的 tokens, <code>EXPR</code> 是占位符解析器, <code>value</code> 是它正操作的值中的一个。我们会忽略上面那些, 留给我们的是下面这样一个可疑的列表:</p>
<pre><code>- quote: qww&lt;„hello world”&gt;
  - quibble: &lt;„hello world”&gt;
    - babble:
      - B:
    - nibble: „hello world”
  - quote_mod: ww
    - sym: ww
</code></pre><p>让我们开始质问它们。</p>
<h2 id="到兔子洞里去">到兔子洞里去&hellip;</h2>
<p>你自己搞一份本地的 <a href="https://github.com/rakudo/rakudo/">Rakudo 仓库</a>, 如果你已经有了一份,那么打开 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/Grammar.nqp">src/Raku/Grammar.nqp</a>, 然后放松点。</p>
<p>我们会从树的顶部到底部跟随我们的 tokens, 所以我们首先需要找到的是 <code>token quote</code>, <code>rule quote</code>, <code>regex quote</code> 或 <code>method quote</code>; 以那个顺序搜索, 因为第一项很可能就是正确的东西。</p>
<p>这种情况下, 它是一个 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/Grammar.nqp#L3555">token quote</a>, 它是一个 <a href="https://docs.raku.org/language/grammars#Protoregexes">proto regex</a>。我们的代码使用了它的 <code>q</code> 版本并且你还可以认出靠近它的 <code>qq</code> 和 <code>Q</code> 版本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quote:sym</span>&lt;q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">quote:sym</span>&lt;qq&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">qq</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">qq</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">qq</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">quote:sym</span>&lt;Q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">Q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>可以看到 <code>qq</code> 和 <code>Q</code> 的主体看起来像 <code>q</code>, 我们也来看看它们是否有我们要找的那个 bug:</p>
<pre><code>zoffix@leliana:~$ raku -e '.say for qqww&lt;„hello world”&gt;'
„hello
world”
zoffix@leliana:~$ raku -e '.say for Qww&lt;„hello world”&gt;'
„hello
world
</code></pre><p>是的, 它们也存在, 所以 <code>token quote</code> 不可能是那个问题。我们来分解下 <code>token quote:sym&lt;q&gt;</code> 是做什么的, 来算出怎么进行到下一步; 它的备选之一没有被用在我们当前的代码中, 所以我会省略它:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quote:sym</span>&lt;q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="c1"># (this branch omited)
</span><span class="c1"></span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>在第二行中, 我们创建了一个变量, 然后匹配字面值 <code>q</code> 然后是 <code>quote_mod</code> token。那个是我们的 <code>--target=parse</code> 输出中的一部分并且如果你像我们找出 <code>quote</code> token 那样找出它, 你会注意到它是一个 proto regex, 即, 在那种情况下, 匹配我们代码的 <code>ww</code> 块。后面跟着的空 <code>{}</code> 块我们可以忽略(那是一个 bug 的替代方法可能在你读到这儿时已经被修复了)。目前为止, 我们已经匹配了我们代码的 <code>qww</code> 块。</p>
<p>再往前走, 我们遇见了对 <code>qok</code> token 的调用, 当前的 <a href="https://docs.raku.org/type/Match">Match</a> 对象作为其参数。<code>&lt;.qok&gt;</code> 中的点号表明这是一个非捕获 token 匹配, 这就是它为什么它没有在我们的 <code>--target=parse</code> 输出中出现的原因。我们定位到那个 token 并看看它是关于什么的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">qok</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">»</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="p">[</span><span class="sr">(</span><span class="p">]&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">:</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="p">{</span>
            <span class="k">my</span> <span class="nv">$n</span> <span class="o">:=</span> <span class="o">~</span><span class="nv">$x</span><span class="p">;</span> <span class="vg">$*W</span><span class="o">.</span><span class="nf">is_name</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">)</span> <span class="o">||</span> <span class="vg">$*W</span><span class="o">.</span><span class="nf">is_name</span><span class="p">(</span><span class="o">[</span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$n</span><span class="o">]</span><span class="p">)</span>
        <span class="p">}&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">#</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">panic</span><span class="p">:</span> <span class="p">&#34;</span><span class="s2"># not allowed as delimiter</span><span class="p">&#34;&gt;</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">.</span><span class="ow">ws</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>我的天呐! 这么多符号, 但是这个家伙很容易了: <code>»</code> 是一个<a href="https://docs.raku.org/language/regexes#%3C%3C_and_%3E%3E_,_left_and_right_word_boundary">右单词边界</a>后面不能跟着一个开圆括号(<code>&lt;![(]&gt;</code>), 再跟着一个备选分支(<code>[]</code>), 再跟着一个检查, 即我们不想尝试使用 <code>#</code> 号作为分割符(<code>[...]?</code>), 最后跟着一个 <a href="https://docs.raku.org/language/grammars#ws">&lt;.ws&gt;</a> token 吞噬各种各样的空白。</p>
<p>在备选分支中, 我们使用了首个token匹配的 <code>||</code> 备选分支(和最长token匹配 <code>|</code> 相反), 并且首个 token 向前查看一个冒号 <code>&lt;?[:]&gt;</code>。 如果失败了, 我们就字符串化那个给定的参数(<code>~$x</code>)并且之后在 <a href="https://github.com/rakudo/rakudo/blob/83b8b1a/src/Raku/World.nqp">World对象</a> 身上调用 <code>is_name</code> 方法, 原样地传递带有前置 <code>&amp;</code> 符号的字符串化的参数。传递的 <code>~$x</code> 是目前为止我们的 <code>token quote:sym&lt;q&gt;</code> token 所匹配到的东西(并且那是字符串 <code>qww</code>)。<code>is_name</code> 方法仅仅检查那个给定的符号是否被定义还有根据那个返回值检查我们的 token 匹配会通过还是会失败。如果那个求值代码返回一个真值那么我们正在使用的  <code>&lt;!{ ... }&gt;</code> 结构就会失败。</p>
<p>总而言之, 这个 token 所做的所有事情就是检查我们没有使用 <code>#</code> 作为分隔符并且没有尝试去调用一个方法或sub。房间的这个角落没有 bug 迹象。 让我们回到我们的 <code>token quote:sym&lt;q&gt;</code> 来查看下一步做什么:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quote:sym</span>&lt;q&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$qm</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quote_mod</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">qok</span><span class="p">(</span><span class="nv">$/</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="nv">$qm</span> <span class="o">:=</span> <span class="nv">$&lt;quote_mod&gt;</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="o">|</span><span class="sr"> </span><span class="c1"># (this branch omited)
</span><span class="c1"></span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>我们已经完成了 <code>&lt;.qok&gt;</code> 的检查, 所以下一步是 <code>{ $qm := $&lt;quote_mod&gt;.Str }</code>, 那仅仅把匹配到 <code>quote_mod</code> token 的字符串值存到 <code>$qm</code> 变量中。在我们的例子中, 那个值就是字符串 <code>ww</code>。</p>
<p>下面跟着的是另外一个 token, 它在我们的 <code>--target=parse</code> s输出中出现过:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&lt;</span><span class="nf">quibble</span><span class="p">(</span><span class="vg">%*LANG</span><span class="p">&lt;</span><span class="s">Quote</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">q</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$qm</span><span class="p">)</span><span class="o">&gt;</span>
</code></pre></div><p>这里, 我们使用三个位置参数引用了那个 token: <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp#L424">Quote language braid</a>, 字符串 <code>q</code> 和 我们保存在变量 <code>$qm</code> 中的字符串 <code>ww</code>。我想知道它是做什么的。那是我们的下一站。全力以赴!</p>
<h2 id="nibble-quibble-babbling-nibbler">Nibble Quibble Babbling Nibbler</h2>
<p>这里是完整的 <code>token quibble</code> 并且你马上可以发现我们不得不从开始往更深处挖掘, 因为第 5 行是另外一个 token 匹配:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">quibble</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="o">*</span><span class="nv">@base_tweaks</span><span class="p">)</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$lang</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$start</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">$stop</span><span class="p">;</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="nf">babble</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">{</span>
        <span class="k">my</span> <span class="nv">$B</span>  <span class="o">:=</span> <span class="nv">$&lt;babble&gt;&lt;B&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
        <span class="nv">$lang</span>  <span class="o">:=</span> <span class="nv">$B</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="nv">$start</span> <span class="o">:=</span> <span class="nv">$B</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
        <span class="nv">$stop</span>  <span class="o">:=</span> <span class="nv">$B</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    </span><span class="nv">$start</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">nibble</span><span class="p">(</span><span class="nv">$lang</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="nv">$stop</span><span class="sr">
</span><span class="sr">        </span><span class="o">||</span><span class="sr"> </span><span class="p">{</span>
            <span class="nv">$/</span><span class="o">.</span><span class="nf">CURSOR</span><span class="o">.</span><span class="nf">typed_panic</span><span class="p">(</span>
                <span class="p">&#39;</span><span class="s1">X::Comp::AdHoc</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="s">payload</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Couldn&#39;t find terminator </span><span class="nv">$stop</span><span class="s2"> (corresponding </span><span class="nv">$start</span><span class="s2"> was at line {</span>
                    <span class="n">HLL::Compiler</span><span class="o">.</span><span class="nf">lineof</span><span class="p">(</span>
                        <span class="nv">$&lt;babble&gt;&lt;B&gt;</span><span class="o">.</span><span class="nb">orig</span><span class="p">()</span><span class="o">,</span> <span class="nv">$&lt;babble&gt;&lt;B&gt;</span><span class="o">.</span><span class="nb">from</span><span class="p">()</span>
                    <span class="p">)</span>
                <span class="p">})&#34;</span><span class="s2">,
</span><span class="s2">                expected =&gt; [</span><span class="nv">$stop</span><span class="s2">],
</span><span class="s2">            )
</span><span class="s2">        }
</span><span class="s2">    ]
</span><span class="s2">
</span><span class="s2">    </span><span class="p">{</span>
        <span class="nf">nqp::can</span><span class="p">(</span><span class="nv">$lang</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">herelang</span><span class="p">&#39;)</span>
        <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="o">.</span><span class="nf">queue_heredoc</span><span class="p">(</span>
            <span class="vg">$*W</span><span class="o">.</span><span class="nf">nibble_to_str</span><span class="p">(</span>
                <span class="nv">$/</span><span class="o">,</span>
                <span class="nv">$&lt;nibble&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="k">-&gt;</span> <span class="p">{</span>
                    <span class="p">&#34;</span><span class="s2">Stopper &#39;</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$&lt;nibble&gt;</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">&#39; too complex for heredoc</span><span class="p">&#34;</span>
                <span class="p">}</span><span class="s2">
</span><span class="s2">            ),
</span><span class="s2">            </span><span class="nv">$lang</span><span class="s2">.herelang,
</span><span class="s2">        )
</span><span class="s2">    }
</span><span class="s2">}
</span></code></pre></div><p>我们定义了 3 个变量然后引用了 <code>babble</code> token, 这个 babble 引用了和 <code>quibble</code> token 所引用的同样的参数。我们来以和查找所有之前的 tokens 同样的方式查找它并窥探它的内核。为了简洁, 我移除了大约一半<a href="https://github.com/rakudo/rakudo/blob/bc35922/src/Raku/Grammar.nqp#L111-L125">代码</a>:那部分是处理副词的, 目前我们不能在我们的代码中使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">babble</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="o">:</span><span class="kd">my</span> <span class="nv">@extra_tweaks</span><span class="p">;</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    </span><span class="c1"># &lt;irrelevant portion redacted&gt;
</span><span class="c1"></span><span class="sr">
</span><span class="sr">    </span><span class="nv">$&lt;B&gt;</span><span class="o">=</span><span class="p">[&lt;</span><span class="o">?</span><span class="ow">before</span><span class="sr"> </span><span class="ni">.</span><span class="p">&gt;]</span><span class="sr">
</span><span class="sr">    </span><span class="p">{</span>
        <span class="c1"># Work out the delimeters.</span>
        <span class="k">my</span> <span class="nv">$c</span> <span class="o">:=</span> <span class="nv">$/</span><span class="o">.</span><span class="nf">CURSOR</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">@delims</span> <span class="o">:=</span> <span class="nv">$c</span><span class="o">.</span><span class="nf">peek_delimiters</span><span class="p">(</span><span class="nv">$c</span><span class="o">.</span><span class="nb">target</span><span class="o">,</span> <span class="nv">$c</span><span class="o">.</span><span class="nb">pos</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$start</span> <span class="o">:=</span> <span class="nv">@delims</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$stop</span>  <span class="o">:=</span> <span class="nv">@delims</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>

        <span class="c1"># Get the language.</span>
        <span class="k">my</span> <span class="nv">$lang</span> <span class="o">:=</span> <span class="nb">self</span><span class="o">.</span><span class="nf">quote_lang</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="o">,</span> <span class="nv">@extra_tweaks</span><span class="p">);</span>
        <span class="nv">$&lt;B&gt;</span><span class="o">.</span><span class="p">&#39;</span><span class="s1">!make</span><span class="p">&#39;(</span><span class="o">[</span><span class="nv">$lang</span><span class="o">,</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="o">]</span><span class="p">);</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">}
</span></code></pre></div><p>我们通过把向前查看捕获到 <code>$&lt;B&gt;</code> 捕获中开始, 它用作更新当前的 Cursor 位置, 然后进入以执行那个代码块。我们把当前的 Cursor 存储在 <code>$c</code> 中, 然后在它身上调用 <code>.peek_delimiters</code> 方法。如果我们为了它在内置的 rakudo 目录中进行 <code>grep</code>, 我们会看到它被定义在 <a href="https://github.com/raku/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp#L200">NQP</a>中, 在 <a href="https://github.com/raku/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp#L200">nqp/src/HLL/Grammar.nqp</a>中, 但是在我们冲出去阅读它的代码之前, 注意它是怎样返回两个分隔符的。我们仅仅把它们打印出来好了?</p>
<p><code>src/Raku/Grammar.nqp</code> 的 <code>.nqp</code> 后缀名表明我们正处在 NQP 的地盘儿, 所以我们不要使用 <a href="https://github.com/raku/nqp/blob/master/docs/ops.markdown">NQP ops</a>仅仅并且不是完全的 Raku 代码。通过把下面这一行代码添加到 <code>@delim</code> 被赋值给 <code>$start</code> 和 <code>$stop</code> 的地方, 我们能找出 <code>.peek_delimiters</code> 给我们的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::say</span><span class="p">(&#34;</span><span class="nv">$sart</span><span class="s2"> </span><span class="nv">$stop</span><span class="p">&#34;);</span>
</code></pre></div><p>编译!</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ perl Configure.pl --gen-moar --gen-nqp --backends<span class="o">=</span>moar <span class="o">&amp;&amp;</span>
  make <span class="o">&amp;&amp;</span>
  make <span class="nb">test</span> <span class="o">&amp;&amp;</span>
  make install
</code></pre></div><p>即使在编译期间, 通过吐出额外的东西, 我们的调试行已经给了我们所有那些分隔符是关于什么的启发。再次运行我们的有问题的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;„hello world”&gt;;&#39;</span>
&lt; &gt;
hello world
</code></pre></div><p>打印出的分隔符是 <code>qww</code> 里的尖括号分隔符。我们对那些不感兴趣, 所以我们可以忽略 <code>.peek_delimiters</code> 并继续。再往上是 <code>.quote_lang</code> 方法。 它的名字里有一个&quot;引号&quot;而我们有一个关于引号的问题.. 听起来我们离真相越来越近了。我们来看看我们正传递给它的是什么参数:</p>
<ul>
<li><code>$1</code> — <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp#L4752">Quote language braid</a></li>
<li><code>$start</code> / <code>$stop</code> — 尖括号分隔符</li>
<li><code>@base_tweaks</code> — 包含一个元素: 字符串 <code>ww</code></li>
<li><code>@extra_tweaks</code> — 额外的副词, 这里我们没有, 所以这个数组是空的</li>
</ul>
<p>定位到 <code>method quote_lang</code>; 它仍然在 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp#L65">src/Raku/Grammar.nqp</a>文件中:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">quote_lang</span><span class="p">(</span><span class="nv">$l</span><span class="o">,</span> <span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="o">,</span> <span class="nv">@base_tweaks</span><span class="o">?,</span> <span class="nv">@extra_tweaks</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">lang_key</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1"># &lt;body redacted&gt;</span>
    <span class="p">}</span>
    <span class="k">sub</span> <span class="nf">con_lang</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1"># &lt;body redacted&gt;</span>
    <span class="p">}</span>

    <span class="c1"># Get language from cache or derive it.</span>
    <span class="k">my</span> <span class="nv">$key</span> <span class="o">:=</span> <span class="nf">lang_key</span><span class="p">();</span>
    <span class="nf">nqp::existskey</span><span class="p">(</span><span class="nv">%quote_lang_cache</span><span class="o">,</span> <span class="nv">$key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$key</span> <span class="ow">ne</span> <span class="p">&#39;</span><span class="s1">NOCACHE</span><span class="p">&#39;</span>
        <span class="o">??</span> <span class="nv">%quote_lang_cache</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span>
        <span class="o">!!</span> <span class="p">(</span><span class="nv">%quote_lang_cache</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span> <span class="o">:=</span> <span class="nf">con_lang</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div><p>我们有两个词法子例程 <code>lang_key</code> 和 <code>con_lang</code>, 在它们下面我们把 <code>lang_key</code> 的输出存储到 <code>$key</code> 中, 在 <code>%quote_lang_cache</code> 中这个 <code>$key</code> 被用在整个缓存 dance 中, 所以我们可以忽略掉 <code>lang_key</code> sub 并直接进入 <code>con_lang</code>, 它被调用以生成我们的 <code>quote_lang</code> 方法的返回值:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">con_lang</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$lang</span> <span class="o">:=</span> <span class="nv">$l</span><span class="o">.</span><span class="p">&#39;</span><span class="s1">!cursor_init</span><span class="p">&#39;(</span><span class="nb">self</span><span class="o">.</span><span class="nb">orig</span><span class="p">()</span><span class="o">,</span> <span class="p">:</span><span class="s">p</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="nb">pos</span><span class="p">())</span><span class="o">,</span> <span class="p">:</span><span class="s">shared</span><span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="p">&#39;</span><span class="s1">!shared</span><span class="p">&#39;()));</span>
    <span class="k">for</span> <span class="nv">@base_tweaks</span> <span class="p">{</span>
        <span class="nv">$lang</span> <span class="o">:=</span> <span class="nv">$lang</span><span class="o">.</span><span class="p">&#34;</span><span class="s2">tweak_</span><span class="nv">$_</span><span class="p">&#34;(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nv">@extra_tweaks</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$t</span> <span class="o">:=</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="k">if</span> <span class="nf">nqp::can</span><span class="p">(</span><span class="nv">$lang</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">tweak_</span><span class="nv">$t</span><span class="p">&#34;)</span> <span class="p">{</span>
            <span class="nv">$lang</span> <span class="o">:=</span> <span class="nv">$lang</span><span class="o">.</span><span class="p">&#34;</span><span class="s2">tweak_</span><span class="nv">$t</span><span class="p">&#34;(</span><span class="nv">$_</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nb">self</span><span class="o">.</span><span class="nf">sorry</span><span class="p">(&#34;</span><span class="s2">Unrecognized adverb: :</span><span class="nv">$t</span><span class="p">&#34;);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$stop</span><span class="o">,</span><span class="n">VMArray</span><span class="p">)</span> <span class="o">||</span>
    <span class="nv">$start</span> <span class="ow">ne</span> <span class="nv">$stop</span> <span class="o">??</span> <span class="nv">$lang</span><span class="o">.</span><span class="nf">balanced</span><span class="p">(</span><span class="nv">$start</span><span class="o">,</span> <span class="nv">$stop</span><span class="p">)</span>
                    <span class="o">!!</span> <span class="nv">$lang</span><span class="o">.</span><span class="nf">unbalanced</span><span class="p">(</span><span class="nv">$stop</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在初始化 Cursor 位置之后, <code>$lang</code> 继续包含我们的 Quote 语言编织然后我们落进一个 <code>for</code> 循环来迭代 <code>@base_tweaks</code>, 对于里面的每一个元素, 我们都调用方法 <code>tweak_$_</code>, 给它传递一个真值 <code>1</code>。因为我们仅仅只有一个 base tweak, 这意味着我们正在Quote braid上调用方法 <code>tweak_ww</code>。我们来看看那个方法是关于什么的。</p>
<p>因为 Quote braid 被定义在同一个文件中, 仅仅搜索 <code>method tweak_ww</code> 好了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">tweak_ww</span><span class="p">(</span><span class="nv">$v</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$v</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">add-postproc</span><span class="p">(&#34;</span><span class="s2">quotewords</span><span class="p">&#34;)</span><span class="o">.</span><span class="nf">apply_tweak</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>
       <span class="o">!!</span> <span class="nb">self</span>
<span class="p">}</span>
</code></pre></div><p>很好。我们给它的 <code>$v</code> 为真, 所以我们调用了 <code>.add-postproc</code> 然后调用 <code>.apply_tweak(ww)</code>。看一下那个方法的上面和下面, 我们看到 <code>.add-postproc</code> 也用在其它不含 bug 的引号中, 所以我们忽略它并直接跳到 <code>.apply_tweak</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">apply_tweak</span><span class="p">(</span><span class="nv">$role</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$target</span> <span class="o">:=</span> <span class="nf">nqp::can</span><span class="p">(</span><span class="nb">self</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">herelang</span><span class="p">&#39;)</span> <span class="o">??</span> <span class="nb">self</span><span class="o">.</span><span class="nf">herelang</span> <span class="o">!!</span> <span class="nb">self</span><span class="p">;</span>
    <span class="nv">$target</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">mixin</span><span class="p">(</span><span class="nv">$target</span><span class="o">,</span> <span class="nv">$role</span><span class="p">);</span>
    <span class="nb">self</span>
<span class="p">}</span>
</code></pre></div><p>啊哈! 它的参数是一个 role 并且它把该 role 混进来我们的 Quote braid 中。我们来看看那个 role 是关于什么的(再一次, 仅仅在文件中搜索 <a href="https://github.com/rakudo/rakudo/blob/94b09ab9280d39438f84cb467d4b3d3042b8f672/src/Raku/Grammar.nqp#L4846">role ww</a>, 或者仅仅向上滚动一点):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">ww</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;&#39; &#39;&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">&#39;</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;‘ ’&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">‘</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;&#34; &#34;&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">&#34;</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;“ ”&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">“</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;colonpair&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">:</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">!</span><span class="nf">RESTRICTED</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">colonpair</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">colonpair</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">escape:sym</span>&lt;#&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">#</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">comment</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>奥, 我的天呐!引号! 如果这个地方不是我们修复 bug 的地方, 那么我就是一个芭蕾舞女演员。 我们找到它了!</p>
<p>我们定位到的 role 把进了某些 tokens 混合进了我们正使用的 Quote braid 中来解析 <code>qww</code> 的内容。我们带有 bug 的 <code>„”</code> 引号组合明显不在那个列表中。我们来把它添加进去!</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">escape:sym</span>&lt;„ ”&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">„</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>编译! 运行我们带有 bug 的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;foo „hello world” bar&gt;&#39;</span>
foo
bar
</code></pre></div><p>悲催! 好吧, 我们确实为引号处理找到了正确的地方, 但是我们让问题变得更加糟糕了。发生了什么?</p>
<h2 id="quotastic-inaction">Quotastic Inaction</h2>
<p>我们新的 token 肯定解析了那个引号, 但是我们绝对没有给它添加 Actions 动作&hellip; 好吧, 对它起作用。Action 类和 Grammars 相邻, 在 <code>src/Raku/Actions.nqp</code> 中。打开它并定位到匹配的方法那里; 比如 <a href="https://github.com/rakudo/rakudo/blob/94b09ab9280d39438f84cb467d4b3d3042b8f672/src/Raku/Actions.nqp#L9243">method escape:sym&lt;“ ”&gt;</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">&#39; &#39;</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
<span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">&#34; &#34;</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
<span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">‘ ’</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
<span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">“ ”</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>并在列表中添加我们自己的版本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">„ ”</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>编译! 运行我们带有 bug 的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;foo „hello world” bar&gt;&#39;</span>
foo
hello world
bar
</code></pre></div><p>呼! 成功了! 不再有 bug 了。我们修复了那个 bug!</p>
<p>但是, 等一下&hellip;</p>
<h2 id="遗漏了-但是没有忘记">遗漏了, 但是没有忘记</h2>
<p>看一下<a href="https://docs.raku.org/language/unicode_texas#Other_acceptable_single_codepoints">所有可能的奢华的引号的列表</a>。尽管我们的 bug 报告中仅仅提到了 <code>„”</code> 引号对儿, 但是 <code>‚‘</code> 和 <code>「」</code> 都不在我们的 <code>role ww</code> tokens 中。远远不止的是, 某些左/右引号, 当它们交换位置后, 在引起字符串的时候也刚好能工作, 所以它们也应该在 <code>qww</code> 中起效。然而, 添加一整串额外的 tokens 和一整串其它的 actions 方法是相当不精彩的。有没有更好的方法?</p>
<p>我们仔细看看我们的 tokens:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">escape:sym</span>&lt;“ ”&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr">“</span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p><code>sym&lt;“ ”&gt;</code> 我们可以把它省略了 — 这里它的功能仅仅是作为一个名字。我们留下的是一个向前查看的 <code>“</code> 引号还有 <code>&lt;quote=.LANG('MAIN','quote')&gt;</code>。所以我们可以向前查看所有的我们关心的开口引号并让 MAIN braid 接管所有的细节。</p>
<p>所以, 让我们用这个单个 token 替换掉所有的引号处理 tokens:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">escape:sym</span>&lt;&#39;&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">    </span><span class="p">&lt;</span><span class="o">?</span><span class="p">[</span><span class="sr"> &#39; &#34; ‘ ‚ ’ “ „ ” 「 </span><span class="p">]&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">quote</span><span class="o">=.</span><span class="nf">LANG</span><span class="p">(&#39;</span><span class="s1">MAIN</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">quote</span><span class="p">&#39;)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>并且使用下面这个单个 action 替换掉所有的匹配 actions 方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">escape</span><span class="p">:</span><span class="na">sym</span><span class="p">&lt;</span><span class="s">&#39;</span><span class="p">&gt;(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="nf">mark_ww_atom</span><span class="p">(</span><span class="nv">$&lt;quote&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>编译! 运行我们的带有某些引号变体的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./raku -e <span class="s1">&#39;.say for qww&lt;„looks like” ‚we fixed‘ ｢this thing｣&gt;&#39;</span>
looks like
we fixed
this thing
</code></pre></div><p>精彩! 我们不仅让所有的引号都能正常工作, 还设法清理的存在的 tokens 和 actions 方法。现在所有我们需要做的就是对我们的修复做测试并且我们已经准备提交了。</p>
<h2 id="享用-bug-烤肉">享用 bug 烤肉</h2>
<p><a href="https://github.com/raku/roast">Raku 官方测试套件 Roast</a> 是在 Rakudo 内建目录中的 <code>t/spec</code> 中，如果它不存在, 仅仅运行 <code>make spectest</code> 就好了并且在它把 roast 仓库克隆到 <code>t/spec</code> 中后就中止它。我们需要找到在哪里插入我们的测试而 <code>grep</code> 是干那件事的好朋友:</p>
<pre><code>zoffix@VirtualBox:~/CPANPRC/rakudo/t/spec$ grep -R 'qww' .
Binary file ./.git/objects/pack/pack-5bdee39f28283fef4b500859f5b288ea4eec20d7.pack matches
./S02-literals/allomorphic.t:    my @wordlist = qqww[1 2/3 4.5 6e7 8+9i] Z (IntStr, RatStr, RatStr, NumStr, ComplexStr);
./S02-literals/allomorphic.t:        isa-ok $val, Str, &quot;'$val' from qqww[] is a Str&quot;;
./S02-literals/allomorphic.t:        nok $val.isa($wrong-type), &quot;'$val' from qqww[] is not a $wrong-type.perl()&quot;;
./S02-literals/allomorphic.t:    my @wordlist  = qqww:v[1 2/3 4.5 6e7 8+9i];
./S02-literals/allomorphic.t:    my @written = qqww:v[1 2/3 $num 6e7 8+9i ten];
./S02-literals/allomorphic.t:    is-deeply @angled, @written, &quot;«...» is equivalent to qqww:v[...]&quot;;
./S02-literals/quoting.t:    is(qqww[$alpha $beta], &lt;foo bar&gt;, 'qqww');
./S02-literals/quoting.t:    for (&lt;&lt;$a b c&gt;&gt;, qqww{$a b c}, qqw{$a b c}).kv -&gt; $i, $_ {
./S02-literals/quoting.t:    is-deeply qww&lt;a a ‘b b’ ‚b b’ ’b b‘ ’b b‘ ’b b’ ‚b b‘ ‚b b’ “b b” „b b”
./S02-literals/quoting.t:    'fancy quotes in qww work just like regular quotes';
./integration/advent2014-day16.t:    for flat qww/ foo bar 'first second' / Z @a -&gt; $string, $result {
</code></pre><p>看起来 <code>S02-literals/quoting.t</code> 是它的一个好地方。打开那个文件, 在它的顶部, 通过我们添加的测试的数量来增加 <code>plan</code> 的数量 — 在这个例子中仅仅增加一条就好了。然后滚动到底部并创建一个 block 块, 前面添加一个注释, 并为我们正修复的 <a href="https://rt.perl.org/Ticket/Display.html?id=128304">bug 报告</a>引用那个 RT 标签数字。</p>
<p>在文件里面, 我们使用 <a href="https://docs.raku.org/language/testing#index-entry-is-deeply-is-deeply%28%24value%2C_%24expected%2C_%24description%3F%29">is-deeply</a> 测试函数, 它使用 <a href="https://docs.raku.org/routine/eqv">eqv 操作符</a>语义来做测试。我们会给它一个带有完整引号串的 <code>qww&lt;&gt;</code> 行并告诉它我们所期望返回的项目列表。还要写下测试描述:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># RT #128304</span>
<span class="p">{</span>
    <span class="nb">is-deeply</span> <span class="k">q</span><span class="sa">ww</span><span class="p">&lt;</span><span class="s2">a a ‘b b’ ‚b b’ ’b b‘ ’b b‘ ’b b’ ‚b b‘ ‚b b’ “b b” „b b”
</span><span class="s2">            ”b b“ ”b b“ ”b b” „b b“ „b b” ｢b b｣ ｢b b｣</span><span class="p">&gt;</span><span class="o">,</span>
        <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">|</span><span class="p">(&#39;</span><span class="s1">b b</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="mi">16</span><span class="p">))</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">fancy quotes in qww work just like regular quotes</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><p>返回到 Rakudo checkout, 运行修改后的测试并保证它通过:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ make t/spec/S02-literals/quoting.t
<span class="c1"># &lt;lots of output&gt;</span>
All tests successful.
<span class="nv">Files</span><span class="o">=</span>1, <span class="nv">Tests</span><span class="o">=</span>185,  <span class="m">3</span> wallclock secs <span class="o">(</span> 0.03 usr  0.01 sys +  2.76 cusr  0.11 <span class="nv">csys</span> <span class="o">=</span>  2.91 CPU<span class="o">)</span>
Result: PASS
</code></pre></div><p>漂亮。提交测试 bug 修复好了并且把它们送走! 我们做到了!</p>
<h2 id="结论">结论</h2>
<p>当我们在修复 Raku 中的解析 bugs 的时候, 把程序减少到能重新产生那个 bug 的最小部分然后使用 <code>--target=parse</code> 命令行参数, 得到解析树的输出, 找到所匹配的那个 tokens。<code>statementlist</code></p>
<p>然后, 在 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Grammar.nqp">src/Raku/Grammar.nqp</a> 中跟随这些 tokens, 它也继承自 <a href="https://github.com/raku/nqp/blob/4fd4b48afb45c8b25ccf7cfc5e39cb4bd658901d/src/HLL/Grammar.nqp">NQP 的 src/HLL/Grammar.nqp</a> 。 与位于 <a href="https://github.com/rakudo/rakudo/blob/04af57c3b3d32353e36614de53396d2b4a08b7be/src/Raku/Actions.nqp">src/Raku/Actions.nqp</a> 中的 actions 类协作, 跟随着代码找出正在做什么并期望找出问题出现在什么位置。</p>
<p>修复它。测试它。发布它。</p>
<p>充满了乐趣。</p>
<p><a href="http://raku.party/post/Perl-6-Core-Hacking-Grammatical-Babble">http://raku.party/post/Perl-6-Core-Hacking-Grammatical-Babble</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[rotor: 列表操作之王]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-07-14-the-king-of-list-manipulation/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-12-14-add-separator/?utm_source=atom_feed" rel="related" type="text/html" title="给数字添加千分位符" />
            
                <id>https://ohmyweekly.github.io/notes/2015-07-14-the-king-of-list-manipulation/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>The King of List Manipulation</blockquote><p>对于 Raku 程序员, <code>.rotor</code> 是一个强大的列表操作工具。</p>
<h2 id="分段">分段</h2>
<p>最简单的, <code>.rotor</code> 接收一个整数 <strong>$number</strong> 并把列表分成多个子列表, 每个子列表含有 <strong>$number</strong> 个元素:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c d e f  g h</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">3</span>
<span class="c1"># ((a b c) (d e f))</span>
</code></pre></div><p>我们有一个含有 8 个元素的列表, 我们在该列表上调用接收参数 3 的 <code>.rotor</code> 方法, 它返回 2 个列表, 每个列表中含有 3 个元素。不包括原列表中的最后 2 个元素, 因为它们没有组成一个完整的3个元素的列表。然而它们可以被包含进来, 使用 <code>:partial</code> 具名参数设置为 <strong>True</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c  d e f  g h</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span>
<span class="c1"># ((a b c) (d e f) (g h))</span>

<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c  d e f  g h</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">(</span><span class="nb">True</span><span class="p">)</span>
<span class="c1"># ((a b c) (d e f) (g h))</span>

<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c  d e f  g h</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">3</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">(</span><span class="nb">False</span><span class="p">)</span>
<span class="c1"># ((a b c) (d e f))</span>
</code></pre></div><p>下面应用一下我们刚刚学到的。把字符串分成列宽相等的几段:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">foobarberboorboozebazmeow</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">)</span><span class="o">».</span><span class="nb">join</span><span class="o">».</span><span class="nb">say</span><span class="p">;</span>

<span class="c1"># foobarberb</span>
<span class="c1"># oorboozeba</span>
<span class="c1"># zmeow</span>
</code></pre></div><p>分行然后每行前面添加 4 个空格:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">foobarberboorboozebazmeow</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">10</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">)</span><span class="o">».</span><span class="nb">join</span><span class="o">».</span><span class="nb">indent</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">».</span><span class="nb">say</span><span class="p">;</span>

<span class="c1">#    foobarberb</span>
<span class="c1">#    oorboozeba</span>
<span class="c1">#    zmeow</span>
</code></pre></div><p>但是这最好被写为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">foobarberboorboozebazmeow</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">».</span><span class="nb">say</span>
</code></pre></div><h2 id="注意缝隙">注意缝隙</h2>
<p>假设你正在接受输入: 你得到一个单词, 它的法语翻译和它的西班牙语翻译, 等一堆单词。你只想输出特定语言, 所以我们需要在我们的列表中跳过某些项。 <code>.rotor</code> 来拯救来了!</p>
<p>指定一对儿(Pair)整数作为 rotor 的参数会让每个列表中含有 <strong>$key</strong> 个元素, 每个列表之间有 <strong>$value</strong> 个空隙。看例子更简单一些:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">^</span><span class="mi">10</span> <span class="o">.</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">;</span>
<span class="c1"># OUTPUT: ((0 1 2) (4 5 6) (8 9))</span>

<span class="nb">say</span> <span class="o">^</span><span class="mi">10</span> <span class="o">.</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">;</span>
<span class="c1"># OUTPUT: ((0 1) (4 5) (8 9))</span>
</code></pre></div><p>第一个例子我们把缝隙设置为 1, 第二个例子我们把缝隙增加为 2。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">enum</span> <span class="p">&lt;</span><span class="s">English French Spanish</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nb">join</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&lt;</span><span class="s">Good Bon Buenos morning matin días</span><span class="p">&gt;</span><span class="o">[</span><span class="n">French</span><span class="o">..*].</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1"># OUTPUT: Bon matin</span>
</code></pre></div><p>其中 <code>[French..*]</code> 意思为 <code>[1..*]</code>, 例子中 French 被枚举化为整数 1。</p>
<h2 id="重叠">重叠</h2>
<p>当我们让缝隙变为负数的时候, 分段的列表中就会有元素重叠:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a a b c c c d</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotor</span><span class="o">:</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1"># OUTPUT: ((a a) (a b) (b c) (c c) (c c) (c d))</span>

<span class="nb">say</span> <span class="p">&lt;</span><span class="s">a a b c c c d</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="nv">$_</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="ow">eq</span> <span class="nv">$_</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">same</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">different</span><span class="p">&#34;}</span>
<span class="c1"># OUTPUT: (same different different same same different)</span>
</code></pre></div><h2 id="全力以赴">全力以赴</h2>
<p><code>.rotor</code> 不单单只能接受单个 <strong>Int</strong> 值或 <strong>Pair</strong>, 你可以指定额外的 <strong>Int</strong> 或 <strong>Pairs</strong> 位置参数来把列表分成不同尺寸大小的子列表, 列表之间的缝隙也不同。下面以一个日志文件为例:</p>
<pre><code>IP: 198.0.1.22
Login: suser
Time: 1454017107
Resource: /report/accounting/x23gs
Input: x=42,y=32
Output: success
===================================================
IP: 198.0.1.23
Login: nanom
Time: 1454027106
Resource: /report/systems/boot
Input: mode=standard
Output: success
</code></pre><p>每段之间有一行双划线。</p>
<p>我们想这样输出: <strong>Header</strong> 里包含 IP, Login, Time, Resource; <strong>Operation</strong> 里包含 Resource, Input, Output。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&#39;</span><span class="s1">report.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="o">».</span><span class="nb">indent</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$head</span><span class="o">,</span> <span class="nv">$op</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">Header:</span><span class="p">&#34;</span><span class="o">,</span>    <span class="o">|</span><span class="nv">$head</span><span class="o">,</span>
             <span class="p">&#34;</span><span class="s2">Operation:</span><span class="p">&#34;</span><span class="o">,</span> <span class="o">|</span><span class="nv">$op</span><span class="o">,</span> <span class="p">&#39;&#39;;</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>Header:
    IP: 198.0.1.22
    Login: suser
    Time: 1454017107
    Resource: /report/accounting/x23gs
Operation:
    Resource: /report/accounting/x23gs
    Input: x=42,y=32
    Output: success

Header:
    IP: 198.0.1.23
    Login: nanom
    Time: 1454027106
    Resource: /report/systems/boot
Operation:
    Resource: /report/systems/boot
    Input: mode=standard
    Output: success
</code></pre><p>先是 4 个元素一块, 缝隙为 -1(有重叠), 然后是 3 个元素一块, 缝隙为 1。这就在每个分段的列表中包含了 Resource 字段。因为 <code>$op</code> 和 <code>$head</code> 是列表, 我们使用管道符号 <code>|</code> 来展平列表。</p>
<p>记住, 你提供给 <code>.rotor</code> 方法的模式可以动态地生成! 这儿我们使用 <code>sin</code> 函数来生成:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">^</span><span class="mi">92</span> <span class="o">.</span><span class="nb">rotor</span><span class="p">(</span>
    <span class="p">(</span><span class="mf">0.2</span><span class="o">,</span> <span class="mf">0.4</span> <span class="o">...</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="o">*.</span><span class="nb">sin</span><span class="p">)</span><span class="o">.</span><span class="nb">Int</span> <span class="c1"># pattern we supply to .rotor</span>
<span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;&#39;</span><span class="s1">
</span></code></pre></div><p>输出:</p>
<pre><code>0
1 2 3
4 5 6 7 8
9 10 11 12 13 14 15
16 17 18 19 20 21 22 23
24 25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40 41
42 43 44 45 46 47 48 49 50
51 52 53 54 55 56 57 58 59
60 61 62 63 64 65 66 67 68
69 70 71 72 73 74 75 76
77 78 79 80 81 82
83 84 85 86 87
88 89 90
91
</code></pre><p>再举个例子:</p>
<p>我现在想要将同类的序列（字符串）进行合并，比如有这样一个文件：</p>
<pre><code>&gt;seq-1A
GACACAGTCACCCGAGCCT
&gt;seq-1B
TCAATCAATACTGAAGCGA
&gt;seq-1C
AAAACTAGTCGAGAAGAGAG
&gt;seq-1D
CGTGGAAAACTCCAG
&gt;seq-2A
TAAAAGGCGTTCATTGGATATTTC
&gt;seq-2B
ACTGGCAGTGCATCC
</code></pre><p>我想要进行合并 得到这样的结果：</p>
<pre><code>&gt;seq-1
GACACAGTCACCCGAGCCTTCAATCAATACTGAAGCGAAAAACTAGTCGAGAAGAGAGCGTGGAAAACTCCAG
&gt;seq-2
TAAAAGGCGTTCATTGGATATTTCACTGGCAGTGCATCC
</code></pre><p>使用 <code>rotor</code> 来实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%re</span><span class="p">;</span>
<span class="k">for</span> <span class="p">&#39;</span><span class="s1">input.txt</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="o">».</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$header</span><span class="o">,</span> <span class="nv">$data</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$key</span> <span class="o">=</span> <span class="nv">$header</span><span class="p">;</span>
    <span class="nv">$key</span> <span class="o">~~</span> <span class="k">s</span><span class="p">/&lt;</span><span class="nb">upper</span><span class="p">&gt;</span><span class="ni">$</span><span class="p">//;</span>
    <span class="nv">%re</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span> <span class="o">~=</span> <span class="nv">$data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nv">%re</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2">\n</span><span class="nv">$value</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><h2 id="官网的例子">官网的例子</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">rotor</span><span class="p">(</span><span class="o">*</span><span class="nv">@cycle</span><span class="o">,</span> <span class="nb">Bool</span><span class="p">()</span> <span class="o">:</span><span class="nv">$partial</span><span class="p">)</span>
</code></pre></div><p>rotor 返回一个 list, 这个 list 的元素也是 list,  其中每个子列表由调用者中的元素组成.  在最简单的情况下, <code>@cycle</code> 只包含一个整数, 这时调用者列表被分割为多个子列表, 每个子列表中的元素尽可能多的为那个整数指定的个数. 如果 <code>:$partial</code> 为 True, 不够分的最后那部分也会被包括进去, 即使它不满足长度的要求:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;);</span>           <span class="c1"># a b c|d e f</span>
<span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="p">:</span><span class="s">partial</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;);</span> <span class="c1"># a b c|d e f|g h</span>
</code></pre></div><p>如果 <code>@cycle</code> 的元素是一个  <a href="">/type/Pair</a>, 则 Pair 的键指定了所返回子列表的长度(即每个子列表中含有的元素数), Pair 的键值指定两个列表之间的间隙; 负的间隙会产生重叠:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;);</span>  <span class="c1"># a b|d e|g h</span>
<span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">3</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;);</span> <span class="c1"># a b c|c d e|e f g</span>

<span class="k">my</span> <span class="nv">$pair</span>  <span class="o">=</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$key</span>   <span class="o">=</span> <span class="nv">$pair</span><span class="o">.</span><span class="nb">key</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nv">$pair</span><span class="o">.</span><span class="nb">value</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="nv">$key</span> <span class="o">=&gt;</span> <span class="nv">$value</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;)</span> <span class="c1"># a b|d e|g h</span>
</code></pre></div><p>如果 <code>@cycle</code> 的元素个数大于 1 时,  rotor 会按 <code>@cycle</code> 中的元素依次循环调用者列表, 得到每个子列表:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;);</span>      <span class="c1"># a b|c d e|f g</span>
<span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">|</span><span class="p">&#39;);</span> <span class="c1"># a|c d e|f</span>
</code></pre></div><p>组合多个循环周期和 <code>:partial</code> 也有效:</p>
<div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="nf">say </span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="n">..</span><span class="s">&#39;h&#39;</span><span class="p">)</span><span class="nf">.rotor</span><span class="p">(</span><span class="m">1</span> <span class="o">=&gt;</span> <span class="m">1</span><span class="p">,</span> <span class="m">3</span> <span class="o">=&gt;</span> <span class="m">-1</span><span class="p">,</span> <span class="o">:</span><span class="n">partial</span><span class="p">)</span><span class="nf">.join</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">);</span> <span class="c1"># a|c d e|e|g h</span>
</code></pre></div><p>注意, 从 <code>rotor</code> 函数返回的一列列表们赋值给一个变量时会展开为一个数组:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@maybe_lol</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="nv">@maybe_lol</span><span class="o">.</span><span class="nb">raku</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1">#  [&#34;a&#34;, &#34;b&#34;, &#34;d&#34;, &#34;e&#34;, &#34;g&#34;, &#34;h&#34;]&lt;&gt;</span>
</code></pre></div><p>这可能不是你想要的, 因为 rotor 之后的输出看起来是这样的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="c1"># ((&#34;a&#34;, &#34;b&#34;), (&#34;d&#34;, &#34;e&#34;), (&#34;g&#34;, &#34;h&#34;))</span>
</code></pre></div><p>要强制返回列表的列表, 使用绑定而非赋值:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@really_lol</span> <span class="o">:=</span> <span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">h</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="nv">@really_lol</span><span class="o">.</span><span class="nb">raku</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># ((&#34;a&#34;, &#34;b&#34;), (&#34;d&#34;, &#34;e&#34;), (&#34;g&#34;, &#34;h&#34;))</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rotor" term="rotor" label="rotor" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Sneaky Methods]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-05-01-sneaky-methods/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-05-01-sneaky-methods/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Sneaky Methods</blockquote><p>就像你想的那样, 在类的定义中可以声明和定义方法。你期望不高的甚至文档中都很少提及是用 <code>my</code> 关键字声明的免费浮点方法。现在为什么你想要:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">method</span> <span class="nf">foo</span><span class="p">(</span><span class="n">SomeClass:D:</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span> <span class="p">}</span>
</code></pre></div><p>明显的答案是<a href="https://docs.raku.org/language/mop">元对象协议</a>中的 <a href="https://docs.raku.org/type/Metamodel$COLON$COLONMethodContainer#method_add_method">add_method</a> 方法, 在 Rakudo 里你能找到它：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">src</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="nb">Bool</span><span class="o">.</span><span class="nf">pm</span>
<span class="mi">32</span><span class="o">:</span>    <span class="nb">Bool</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">pred</span><span class="p">&#39;</span><span class="o">,</span>  <span class="k">my</span> <span class="k">method</span> <span class="nb">pred</span><span class="p">()</span> <span class="p">{</span> <span class="nb">Bool</span><span class="o">:</span><span class="p">:</span><span class="s">False</span> <span class="p">});</span>
<span class="mi">33</span><span class="o">:</span>    <span class="nb">Bool</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">succ</span><span class="p">&#39;</span><span class="o">,</span>  <span class="k">my</span> <span class="k">method</span> <span class="nb">succ</span><span class="p">()</span> <span class="p">{</span> <span class="nb">Bool</span><span class="o">:</span><span class="p">:</span><span class="s">True</span> <span class="p">});</span>
<span class="mi">35</span><span class="o">:</span>    <span class="nb">Bool</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">enums</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">my</span> <span class="k">method</span> <span class="nb">enums</span><span class="p">()</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.^</span><span class="nb">enum_values</span> <span class="p">});</span>
</code></pre></div><p>这种方法还有另外一种更诡异的用法。你可能很想知道在链式方法调用中究竟发生了什么。我们可以扯开最上面的那个表达式并插入一个短的变量, 输出我们的调试, 并且继续链式调用。好的名字很重要并且把它们浪费在一个短变量上没有必要。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.&amp;</span><span class="p">(</span><span class="k">my</span> <span class="k">method</span> <span class="nf">::</span><span class="p">(</span><span class="nb">List:D</span><span class="p">)</span> <span class="p">{</span> <span class="n">dd</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

<span class="c1"># output</span>
<span class="c1"># (&#34;a&#34;, &#34;b&#34;, &#34;c&#34;)</span>
<span class="c1"># (a b c)</span>
</code></pre></div><p>没有显式调用我们就不能没有名字, 因为 Raku 不允许我们这样做, 所以我们使用了空的作用域 <code>::</code> 以使解析器高兴。使用一个合适的调用, 我们就不需要它了。还有, 那个匿名方法不是 List 中的一员。我们需要使用后缀 <code>.&amp;</code> 来调用它。如果我们需要多次使用那个方法我们可以把它拉出来并给它一个名字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nf">debug</span><span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">)</span> <span class="p">{</span> <span class="n">dd</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span> <span class="p">};</span>
<span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">.&amp;</span><span class="nf">debug</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

<span class="c1"># output</span>
<span class="p">(&#34;</span><span class="s2">a</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">b</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">c</span><span class="p">&#34;)</span>
<span class="p">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div><p>或者, 如果我们想允许回调的话, 我们可以把它作为默认参数赋值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">@l</span><span class="o">,</span> <span class="o">:</span><span class="nv">&amp;debug</span> <span class="o">=</span> <span class="k">my</span> <span class="k">method</span> <span class="p">(</span><span class="nb">List</span><span class="p">:</span><span class="s">D</span><span class="o">:</span><span class="p">){</span><span class="nb">self</span><span class="p">})</span> <span class="p">{</span> <span class="nv">@l</span><span class="o">.&amp;</span><span class="nf">debug</span><span class="o">.</span><span class="nb">say</span> <span class="p">};</span>
<span class="nb">f</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">,</span> <span class="s">debug</span> <span class="o">=&gt;</span> <span class="k">my</span> <span class="k">method</span> <span class="nf">::</span><span class="p">(</span><span class="nb">List:D</span><span class="p">){</span><span class="n">dd</span> <span class="nb">self</span><span class="p">;</span> <span class="nb">self</span><span class="p">};</span>

<span class="c1"># output</span>
<span class="c1">#(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;)</span>
<span class="c1"># (a b c)</span>
</code></pre></div><p>在 Raku 中基本上所有的东西都是类, 包括<a href="https://docs.raku.org/type/Method">方法</a>。 如果它是类它可以是一个对象并且我们能在我们喜欢的任何地方溜进去。</p>
<p><a href="https://gfldex.wordpress.com/2016/07/20/sneaky-methods/">https://gfldex.wordpress.com/2016/07/20/sneaky-methods/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/method" term="method" label="method" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Swift 中的 protocol 和 Raku 中的 roles 一例]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-21-protocol-in-swift-and-roles-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-roles-conflict-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的角色冲突" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-21-protocol-in-swift-and-roles-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Protocol in Swift and Roles in Raku</blockquote><p>Protocol 在 Swift 中是一组方法和属性的集合, 可用于代码复用。 Raku 中有与之类似的结构, 叫做 <code>Role</code>, 下面转换一个 Swift 的 Protocol 为 Raku 的 Role, 把部门人员的相关信息打印为一个表格:</p>
<h2 id="protocol-in-swift">Protocol in Swift</h2>
<p>　</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="nb">import</span> <span class="n">UIKit</span>

<span class="n">func</span> <span class="n">padding</span><span class="p">(</span><span class="n">amount:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">paddingString</span> <span class="o">=</span> <span class="s">&#34;&#34;</span>
    <span class="k">for</span> <span class="n">_</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="n">amount</span> <span class="p">{</span>
        <span class="n">paddingString</span> <span class="o">+=</span> <span class="s">&#34; &#34;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">paddingString</span>
<span class="p">}</span>

<span class="sr">//</span> <span class="n">协议</span>

<span class="n">protocol</span> <span class="n">TabularDataSource</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">numberOfRows:</span> <span class="n">Int</span>    <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>
    <span class="n">var</span> <span class="n">numberOfColumns:</span> <span class="n">Int</span> <span class="p">{</span> <span class="n">get</span> <span class="p">}</span>

    <span class="n">func</span> <span class="n">labelForRow</span><span class="p">(</span><span class="n">row:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span>        <span class="sr">//</span> <span class="n">行标签</span>
    <span class="n">func</span> <span class="n">labelForColumn</span><span class="p">(</span><span class="n">column:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span>  <span class="sr">//</span> <span class="n">列标签</span>

    <span class="n">func</span> <span class="n">itemForRow</span><span class="p">(</span><span class="n">row:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">column:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="sr">//</span> <span class="n">表格中的单元格</span>
<span class="p">}</span>



<span class="n">struct</span> <span class="n">Person</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">name:</span> <span class="n">String</span>
    <span class="n">let</span> <span class="n">age:</span> <span class="n">Int</span>
    <span class="n">let</span> <span class="n">yearsOfExperience:</span> <span class="n">Int</span>
<span class="p">}</span>

<span class="sr">//</span> <span class="n">让</span> <span class="o">**</span><span class="n">Department</span><span class="o">**</span> <span class="n">遵守</span> <span class="o">**</span><span class="n">TabularDataSource</span><span class="o">**</span><span class="n">协议</span>
<span class="n">struct</span> <span class="n">Department:</span> <span class="n">TabularDataSource</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">name:</span> <span class="n">String</span>
    <span class="n">var</span> <span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">Person</span><span class="p">]()</span>

    <span class="n">init</span><span class="p">(</span><span class="n">name:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>

    <span class="n">mutating</span> <span class="n">func</span> <span class="n">addPerson</span><span class="p">(</span><span class="n">person:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">people</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="sr">//</span> <span class="n">实现协议中声明的属性和方法</span>
    <span class="n">var</span> <span class="n">numberOfRows:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">people</span><span class="o">.</span><span class="n">count</span>
    <span class="p">}</span>

    <span class="n">var</span> <span class="n">numberOfColumns:</span> <span class="n">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="n">func</span> <span class="n">labelForRow</span><span class="p">(</span><span class="n">row:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">people</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
    <span class="p">}</span>

    <span class="n">func</span> <span class="n">labelForColumn</span><span class="p">(</span><span class="n">column:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
        <span class="n">switch</span> <span class="n">column</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="s">&#34;Age&#34;</span>
            <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="s">&#34;Years of Experence&#34;</span>
            <span class="n">default:</span> <span class="n">fatalError</span><span class="p">(</span><span class="s">&#34;Invalid column!&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">func</span> <span class="n">itemForRow</span><span class="p">(</span><span class="n">row:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">column:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
         <span class="n">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">people</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="sr">//</span> <span class="n">指定的行</span>
         <span class="n">switch</span> <span class="n">column</span> <span class="p">{</span>
             <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">person</span><span class="o">.</span><span class="n">age</span>
             <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">person</span><span class="o">.</span><span class="n">yearsOfExperience</span>
             <span class="n">default:fatalError</span><span class="p">(</span><span class="s">&#34;Invalid column!&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">var</span> <span class="n">deparment</span> <span class="o">=</span> <span class="n">Department</span><span class="p">(</span><span class="n">name:</span> <span class="s">&#34;Engineering&#34;</span><span class="p">)</span>
<span class="n">deparment</span><span class="o">.</span><span class="n">addPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="n">name:</span> <span class="s">&#34;Joe&#34;</span><span class="p">,</span> <span class="n">age:</span> <span class="mi">30</span><span class="p">,</span> <span class="n">yearsOfExperience:</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">deparment</span><span class="o">.</span><span class="n">addPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="n">name:</span> <span class="s">&#34;Karen&#34;</span><span class="p">,</span> <span class="n">age:</span> <span class="mi">40</span><span class="p">,</span> <span class="n">yearsOfExperience:</span> <span class="mi">18</span><span class="p">))</span>
<span class="n">deparment</span><span class="o">.</span><span class="n">addPerson</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="n">name:</span> <span class="s">&#34;Fred&#34;</span><span class="p">,</span> <span class="n">age:</span> <span class="mi">50</span><span class="p">,</span> <span class="n">yearsOfExperience:</span> <span class="mi">20</span><span class="p">))</span>

<span class="sr">//</span> <span class="n">传入一个数据源</span>
<span class="n">func</span> <span class="n">printTable</span><span class="p">(</span><span class="n">dataSource:</span> <span class="n">TabularDataSource</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">rowLabels</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..&lt;</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">numberOfRows</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span> <span class="p">{</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">labelForRow</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">let</span> <span class="n">columnLabels</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..&lt;</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">numberOfColumns</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span> <span class="p">{</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">labelForColumn</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>

    <span class="sr">//</span> <span class="n">创建一个数组存储每个行标签的宽度</span>
    <span class="n">let</span> <span class="n">rowLabelWidths</span> <span class="o">=</span> <span class="n">rowLabels</span><span class="o">.</span><span class="nb">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span> <span class="p">}</span>

    <span class="sr">//</span> <span class="n">限定行标签的最大长度</span>
    <span class="n">guard</span> <span class="n">let</span> <span class="n">maxRowLabelWidth</span> <span class="o">=</span> <span class="n">rowLabelWidths</span><span class="o">.</span><span class="n">maxElement</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="sr">//</span> <span class="n">创建第一行</span><span class="p">,</span> <span class="n">包含列标题</span>
    <span class="n">var</span> <span class="n">firstRow</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">maxRowLabelWidth</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34; |&#34;</span>

    <span class="sr">//</span> <span class="n">跟踪每列的宽度</span>
    <span class="n">var</span> <span class="n">columnWidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">Int</span><span class="p">]()</span>

    <span class="k">for</span> <span class="n">columnLabel</span> <span class="n">in</span> <span class="n">columnLabels</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">columnHeader</span> <span class="o">=</span> <span class="s">&#34; \(columnLabel) |&#34;</span>
        <span class="n">firstRow</span> <span class="o">+=</span> <span class="n">columnHeader</span>
        <span class="n">columnWidths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">columnHeader</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">print</span><span class="p">(</span><span class="n">firstRow</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span> <span class="o">..&lt;</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">numberOfRows</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">paddingAmount</span> <span class="o">=</span> <span class="n">maxRowLabelWidth</span> <span class="o">-</span> <span class="n">rowLabelWidths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">var</span> <span class="n">out</span> <span class="o">=</span> <span class="n">rowLabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span><span class="p">(</span><span class="n">paddingAmount</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34; |&#34;</span>

        <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="mi">0</span> <span class="o">..&lt;</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">numberOfColumns</span> <span class="p">{</span>
            <span class="n">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="n">itemForRow</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">column:</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">let</span> <span class="n">itemString</span> <span class="o">=</span> <span class="s">&#34; \(item) |&#34;</span>
            <span class="n">let</span> <span class="n">paddingAmount</span> <span class="o">=</span> <span class="n">columnWidths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">itemString</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">padding</span><span class="p">(</span><span class="n">paddingAmount</span><span class="p">)</span> <span class="o">+</span> <span class="n">itemString</span>
        <span class="p">}</span>
        <span class="k">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">printTable</span><span class="p">(</span><span class="n">deparment</span><span class="p">)</span>
</code></pre></div><p>其中的计算属性在 Raku 中可以使用重写属性的方法来完成。</p>
<h3 id="role-in-raku">Role in Raku</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">padding</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$paddingString</span> <span class="o">=</span> <span class="p">&#34;&#34;;</span>
    <span class="nv">$paddingString</span> <span class="o">~=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="k">for</span>  <span class="mi">0</span> <span class="o">..^</span> <span class="nv">$amount</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$paddingString</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># 声明一个接口, 只定义了方法和属性, 没有做实现</span>
<span class="k">role</span> <span class="nc">TabularDataSource</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.numberOfRows</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.numberOfColumns</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">labelForRow</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$row</span><span class="p">)</span>             <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">labelForColumn</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$column</span><span class="p">)</span>       <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nf">itemForRow</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$row</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$column</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Str</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.age</span><span class="p">;</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.yearsOfExperience</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Department</span> <span class="k">does</span> <span class="nc">TabularDataSource</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.people</span><span class="p">;</span>

    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nb">bless</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="nv">$name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1"># 实现接口中的方法</span>

    <span class="c1"># 重写方法 has $.numberOfRows 其实是 has $!numberOfRows 加上 method numberOfRows() { ... } 方法。</span>
    <span class="k">method</span> <span class="nf">numberOfRows</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">@!people</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">numberOfColumns</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">addPerson</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
        <span class="nv">@!people</span><span class="o">.</span><span class="nb">append</span><span class="p">(</span><span class="nv">$person</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1"># 如果类遵守了某个 role 但是未实现其中的方法, 则会报错如下:</span>
    <span class="c1"># Method &#39;labelForRow&#39; must be implemented by Department because it is required by a role</span>
    <span class="k">method</span> <span class="nf">labelForRow</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$row</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nv">@!people</span><span class="o">[</span><span class="nv">$row</span><span class="o">].</span><span class="nb">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">labelForColumn</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$column</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">given</span> <span class="nv">$column</span> <span class="p">{</span>
            <span class="k">when</span> <span class="mi">0</span>  <span class="p">{</span> <span class="k">return</span> <span class="p">&#34;</span><span class="s2">Age</span><span class="p">&#34;</span> <span class="p">}</span>
            <span class="k">when</span> <span class="mi">1</span>  <span class="p">{</span> <span class="k">return</span> <span class="p">&#34;</span><span class="s2">Years of Experence</span><span class="p">&#34;</span> <span class="p">}</span>
            <span class="k">default</span> <span class="p">{</span> <span class="nb">die</span><span class="p">(&#34;</span><span class="s2">Invalid column!</span><span class="p">&#34;)}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">itemForRow</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$row</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$column</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$person</span> <span class="o">=</span> <span class="nv">@!people</span><span class="o">[</span><span class="nv">$row</span><span class="o">]</span><span class="p">;</span>

        <span class="k">given</span> <span class="nv">$column</span> <span class="p">{</span>
            <span class="k">when</span> <span class="mi">0</span>  <span class="p">{</span> <span class="k">return</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span>               <span class="p">}</span>
            <span class="k">when</span> <span class="mi">1</span>  <span class="p">{</span> <span class="k">return</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">yearsOfExperience</span> <span class="p">}</span>
            <span class="k">default</span> <span class="p">{</span> <span class="nb">die</span><span class="p">(&#34;</span><span class="s2">Invalid column</span><span class="p">&#34;)</span>            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$department</span> <span class="o">=</span> <span class="n">Department</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">Engineering</span><span class="p">&#34;);</span>
<span class="nv">$department</span><span class="o">.</span><span class="nf">addPerson</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Joe</span><span class="p">&#34;</span>,   <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">30</span>, <span class="s">yearsOfExperience</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="p">));</span>
<span class="nv">$department</span><span class="o">.</span><span class="nf">addPerson</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Karen</span><span class="p">&#34;</span>, <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">40</span>, <span class="s">yearsOfExperience</span> <span class="o">=&gt;</span> <span class="mi">18</span><span class="p">));</span>
<span class="nv">$department</span><span class="o">.</span><span class="nf">addPerson</span><span class="p">(</span><span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">Fred</span><span class="p">&#34;</span>,  <span class="s">age</span> <span class="o">=&gt;</span> <span class="mi">50</span>, <span class="s">yearsOfExperience</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="p">));</span>

<span class="k">sub</span> <span class="nf">printTable</span><span class="p">(</span><span class="n">TabularDataSource</span> <span class="nv">$dataSource</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@rowLabels</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..^</span> <span class="nv">$dataSource</span><span class="o">.</span><span class="nf">numberOfRows</span> <span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$dataSource</span><span class="o">.</span><span class="nf">labelForRow</span><span class="p">(</span><span class="nv">$_</span><span class="p">)};</span>
    <span class="k">my</span> <span class="nv">@columnLabels</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..^</span> <span class="nv">$dataSource</span><span class="o">.</span><span class="nf">numberOfColumns</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="nv">$dataSource</span><span class="o">.</span><span class="nf">labelForColumn</span><span class="p">(</span><span class="nv">$_</span><span class="p">)};</span>
 
    <span class="k">my</span> <span class="nv">@rowLabelWidths</span> <span class="o">=</span> <span class="nv">@rowLabels</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span><span class="nv">$_</span><span class="o">.</span><span class="nb">chars</span><span class="p">};</span>
    <span class="k">my</span> <span class="nv">$maxRowLabelWidth</span> <span class="o">=</span> <span class="nv">@rowLabelWidths</span><span class="o">.</span><span class="nb">max</span> <span class="o">//</span> <span class="k">return</span><span class="p">;</span>
 
    <span class="k">my</span> <span class="nv">$firstRow</span> <span class="o">=</span> <span class="nf">padding</span><span class="p">(</span><span class="nv">$maxRowLabelWidth</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> |</span><span class="p">&#34;;</span>
    <span class="k">my</span> <span class="nv">@columnWidths</span><span class="p">;</span>
 
    <span class="k">for</span> <span class="nv">@columnLabels</span> <span class="k">-&gt;</span> <span class="nv">$columnLabel</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$columnHeader</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="nv">$columnLabel</span><span class="s2"> |</span><span class="p">&#34;;</span>
        <span class="nv">$firstRow</span> <span class="o">~=</span> <span class="nv">$columnHeader</span><span class="p">;</span>
        <span class="nv">@columnWidths</span><span class="o">.</span><span class="nb">append</span><span class="p">(</span><span class="nv">$columnHeader</span><span class="o">.</span><span class="nb">chars</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nb">say</span><span class="p">(</span><span class="nv">$firstRow</span><span class="p">);</span>
 
    <span class="k">for</span> <span class="mi">0</span> <span class="o">..^</span> <span class="nv">$dataSource</span><span class="o">.</span><span class="nf">numberOfRows</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$paddingAmount</span> <span class="o">=</span> <span class="nv">$maxRowLabelWidth</span> <span class="o">-</span> <span class="nv">@rowLabelWidths</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$out</span> <span class="o">=</span> <span class="nv">@rowLabels</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span> <span class="o">~</span> <span class="nf">padding</span><span class="p">(</span><span class="nv">$paddingAmount</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> |</span><span class="p">&#34;;</span>
 
        <span class="k">for</span> <span class="mi">0</span> <span class="o">..^</span> <span class="nv">$dataSource</span><span class="o">.</span><span class="nf">numberOfColumns</span> <span class="k">-&gt;</span> <span class="nv">$j</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">$item</span> <span class="o">=</span> <span class="nv">$dataSource</span><span class="o">.</span><span class="nf">itemForRow</span><span class="p">(</span><span class="nv">$i</span><span class="o">,</span> <span class="nv">$j</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">$itemString</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="nv">$item</span><span class="s2"> |</span><span class="p">&#34;;</span>
            <span class="k">my</span> <span class="nv">$paddingAmount</span> <span class="o">=</span> <span class="nv">@columnWidths</span><span class="o">[</span><span class="nv">$j</span><span class="o">]</span> <span class="o">-</span> <span class="nv">$itemString</span><span class="o">.</span><span class="nb">chars</span><span class="p">;</span>
            <span class="nv">$out</span> <span class="o">~=</span> <span class="nf">padding</span><span class="p">(</span><span class="nv">$paddingAmount</span><span class="p">)</span> <span class="o">~</span> <span class="nv">$itemString</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nb">say</span><span class="p">(</span><span class="nv">$out</span><span class="p">);</span>
   <span class="p">}</span>

<span class="p">}</span>

<span class="nf">printTable</span><span class="p">(</span><span class="nv">$department</span><span class="p">);</span>
</code></pre></div><p>role 中的 <code>{ ... }</code> 是 yadayada 操作符, 起占位作用, 表示方法会在别处实现。类中的方法同样也可以这样声明。</p>
<p>最后输出:</p>
<pre><code>      | Age | Years of Experence |
Joe   |  30 |                  6 |
Karen |  40 |                 18 |
Fred  |  50 |                 20 |
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/roles" term="roles" label="roles" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[下标副词]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-05-18-subscripts-adverbs/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-08-18-add-subscripts-for-custom-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中为自定义的类添加下标" />
            
                <id>https://ohmyweekly.github.io/notes/2015-05-18-subscripts-adverbs/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Subscripts Adverbs</blockquote><h1 id="下标副词httpsdesginrakuorgs02htmlsubscript_adverbs"><a href="https://desgin.raku.org/S02.html#Subscript_adverbs">下标副词</a></h1>
<p>为了使切片下标返回除了值以外的其它东西，那么给下标(subscript)添加合适的副词。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@array</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B</span><span class="p">&gt;;</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>      <span class="c1"># returns &#39;A&#39;, &#39;B&#39;, (Any)</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="p">:</span><span class="s">p</span><span class="p">;</span>   <span class="c1"># returns 0 =&gt; &#39;A&#39;, 1 =&gt; &#39;B&#39;</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="p">:</span><span class="s">kv</span><span class="p">;</span>  <span class="c1"># returns 0, &#39;A&#39;, 1, &#39;B&#39;</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="p">:</span><span class="s">k</span><span class="p">;</span>   <span class="c1"># returns 0, 1</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="p">:</span><span class="s">v</span><span class="p">;</span>   <span class="c1"># returns &#39;A&#39;, &#39;B&#39;</span>

<span class="nv">%hash</span> <span class="o">=</span> <span class="p">(:</span><span class="s">a</span><span class="p">&lt;</span><span class="s">A</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">b</span><span class="p">&lt;</span><span class="s">B</span><span class="p">&gt;);</span>
<span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;;</span>       <span class="c1"># returns &#39;A&#39;, &#39;B&#39;, (Any)</span>
<span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">p</span><span class="p">;</span>    <span class="c1"># returns a =&gt; &#39;A&#39;, b =&gt; &#39;B&#39;</span>
<span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">kv</span><span class="p">;</span>   <span class="c1"># returns &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, &#39;B&#39;</span>
<span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">k</span><span class="p">;</span>    <span class="c1"># returns &#39;a&#39;, &#39;b&#39;</span>
<span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">v</span><span class="p">;</span>    <span class="c1"># returns &#39;A&#39;, &#39;B&#39;</span>
</code></pre></div><p>如果副词为真，那么这些副词形式都会清除不存在的条目；如果为假的话，就会留下不存在的项，就像普通的切片那样。所以：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@array</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="p">:!</span><span class="s">p</span><span class="p">;</span>  <span class="c1"># returns 0 =&gt; &#39;A&#39;, 1 =&gt; &#39;B&#39;, 2 =&gt; (Any)</span>
<span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span>  <span class="p">:!</span><span class="s">kv</span><span class="p">;</span> <span class="c1"># returns &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, &#39;B&#39;, &#39;c&#39;, (Any)</span>
</code></pre></div><p>同样地，</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span><span class="nv">$b</span><span class="o">,</span><span class="nv">$c</span><span class="p">)</span> <span class="o">=</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">delete</span><span class="p">;</span>
</code></pre></div><p>删除那些条目并顺道返回它们。这种形式能够工作是因为下标是顶端的在前的操作符。如果某些其它的操作符的优先级比处于顶端的逗号操作符的优先级紧凑，那么你必须用括号括起它或强制为列表上下文：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="nv">%hash</span><span class="p">{</span><span class="nv">$x</span><span class="p">}</span> <span class="p">:</span><span class="s">delete</span><span class="p">);</span>
<span class="nv">$x</span> <span class="o">=</span> <span class="p">(</span><span class="nv">%hash</span><span class="p">{</span><span class="nv">$x</span><span class="p">}</span> <span class="p">:</span><span class="s">delete</span><span class="p">);</span>
<span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="o">=</span> <span class="nv">%hash</span><span class="p">{</span><span class="nv">$x</span><span class="p">}</span> <span class="p">:</span><span class="s">delete</span><span class="p">;</span>
</code></pre></div><p>只有在副词为真的时候元素才会被删除。而 <code>:!delete</code> 本质上是一个空操作；你可以基于传递的诸如 <code>:delete($kill'em)</code> 标记顺带有条件地删除条目。在任何一种情况下，被删除的值会被返回。</p>
<p>你也可以执行存在性测试，要么测试单个条目是否存在，要么测试条目的连接是否存在：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">exists</span>           <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nv">%hash</span><span class="p">{</span><span class="nb">any</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;}</span>  <span class="p">:</span><span class="s">exists</span>  <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nv">%hash</span><span class="p">{</span><span class="nb">all</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;}</span>  <span class="p">:</span><span class="s">exists</span>  <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nv">%hash</span><span class="p">{</span><span class="nb">one</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;}</span>  <span class="p">:</span><span class="s">exists</span>  <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nv">%hash</span><span class="p">{</span><span class="nb">none</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;}</span> <span class="p">:</span><span class="s">exists</span>  <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>把 <code>:exists</code> 副词和一组切片结果的布尔值列表结合起来使用，你也可以用类型的语义这样使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">any</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span>  <span class="p">:</span><span class="s">exists</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nb">all</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span>  <span class="p">:</span><span class="s">exists</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nb">one</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span>  <span class="p">:</span><span class="s">exists</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nb">none</span> <span class="nv">%hash</span><span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="p">:</span><span class="s">exists</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>你可以使用 <code>:!exists</code> 来测试不存在。这特别便捷因为优先级规则让 <code>!%hash&lt;a&gt; :exists</code> 把 <code>:exists</code> 应用到前缀 <code>!</code> 上。 <code>%hash&lt;a&gt; :!exists</code> 没有那个问题。</p>
<h2 id="组合下标副词">组合下标副词</h2>
<p>像调用中得具名参数那样，下标中处理多个副词是没有顺序之分的。有些组合有意义，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%a</span> <span class="o">=</span> <span class="nv">%b</span><span class="p">{</span><span class="nv">@keys-to-extract</span><span class="p">}</span> <span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">p</span><span class="p">;</span> <span class="c1"># same as :p :delete</span>
</code></pre></div><p>会把给定的键分片到另外一个散列中。而</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@actually-deleted</span> <span class="o">=</span> <span class="nv">%h</span><span class="p">{</span><span class="nv">@keys-to-extract</span><span class="p">}</span> <span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">k</span><span class="p">;</span> <span class="c1"># same as :k :delete</span>
</code></pre></div><p>会返回真正从散列中删除的键。</p>
<p>只指定返回类型的副词，不能被组合，因为诸如 <code>:kv :p</code>、或 <code>:v :k</code> 就没有意义。</p>
<p>下面的这些副词组合被看做是合法的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">kv</span>            <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">key</span><span class="o">/</span><span class="nb">values</span> <span class="k">of</span> <span class="nc">actually</span> <span class="n">deleted</span> <span class="nb">keys</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">kv</span>           <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">key</span><span class="o">/</span><span class="nb">values</span> <span class="k">of</span> <span class="nb">all</span> <span class="nb">keys</span> <span class="n">attempted</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">p</span>             <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">pairs</span> <span class="k">of</span> <span class="nc">actually</span> <span class="n">deleted</span> <span class="nb">keys</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">p</span>            <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">pairs</span> <span class="k">of</span> <span class="nb">all</span> <span class="nb">keys</span> <span class="n">attempted</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">k</span>             <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="n">actually</span> <span class="n">deleted</span> <span class="nb">keys</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">k</span>            <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">all</span> <span class="nb">keys</span> <span class="n">attempted</span> <span class="nb">to</span> <span class="nb">delete</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">v</span>             <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">values</span> <span class="k">of</span> <span class="nc">actually</span> <span class="n">deleted</span> <span class="nb">keys</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">v</span>            <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">values</span> <span class="k">of</span> <span class="nb">all</span> <span class="nb">keys</span> <span class="n">attempted</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">exists</span>        <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="n">Bools</span> <span class="n">indicating</span> <span class="nb">keys</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">exists</span>       <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="n">Bools</span> <span class="n">indicating</span> <span class="nb">keys</span> <span class="n">did</span> <span class="nb">not</span> <span class="n">exist</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">exists</span> <span class="p">:</span><span class="s">kv</span>    <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">list</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,</span><span class="nb">True</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">exists</span> <span class="p">:</span><span class="s">kv</span>   <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">list</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,</span><span class="nb">False</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">exists</span> <span class="p">:!</span><span class="s">kv</span>   <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">list</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,</span><span class="nb">Bool</span> <span class="n">whether</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">exists</span> <span class="p">:!</span><span class="s">kv</span>  <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">list</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,!</span><span class="nb">Bool</span> <span class="n">whether</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">exists</span> <span class="p">:</span><span class="s">p</span>     <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/</span><span class="nb">True</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">exists</span> <span class="p">:</span><span class="s">p</span>    <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/</span><span class="nb">False</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:</span><span class="s">exists</span> <span class="p">:!</span><span class="s">p</span>    <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/</span><span class="nb">Bool</span> <span class="n">whether</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">delete</span> <span class="p">:!</span><span class="s">exists</span> <span class="p">:!</span><span class="s">p</span>   <span class="nb">delete</span><span class="o">,</span> <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/!</span><span class="nb">Bool</span> <span class="n">whether</span> <span class="nb">key</span> <span class="n">existed</span>
<span class="p">:</span><span class="s">exists</span> <span class="p">:</span><span class="s">kv</span>            <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,</span><span class="nb">True</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
<span class="p">:!</span><span class="s">exists</span> <span class="p">:</span><span class="s">kv</span>           <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,</span><span class="nb">False</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
<span class="p">:</span><span class="s">exists</span> <span class="p">:!</span><span class="s">kv</span>           <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,</span><span class="nb">Bool</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
<span class="p">:!</span><span class="s">exists</span> <span class="p">:!</span><span class="s">kv</span>          <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">,!</span><span class="nb">Bool</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
<span class="p">:</span><span class="s">exists</span> <span class="p">:</span><span class="s">p</span>             <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/</span><span class="nb">True</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
<span class="p">:!</span><span class="s">exists</span> <span class="p">:</span><span class="s">p</span>            <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/</span><span class="nb">False</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
<span class="p">:</span><span class="s">exists</span> <span class="p">:!</span><span class="s">p</span>            <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/</span><span class="nb">Bool</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
<span class="p">:!</span><span class="s">exists</span> <span class="p">:!</span><span class="s">p</span>           <span class="k">return</span> <span class="nb">pairs</span> <span class="k">with</span> <span class="nb">key</span><span class="o">/!</span><span class="nb">Bool</span> <span class="k">for</span> <span class="nb">key</span> <span class="n">exists</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/subscript" term="subscript" label="subscript" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/adverb" term="adverb" label="adverb" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[从正则表达式到 Grammar(第一部分)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-14-play-audio-at-given-volume/?utm_source=atom_feed" rel="related" type="text/html" title="以指定音量随机播放音频文件" />
            
                <id>https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>From Regex to Grammar Part One</blockquote><h2 id="into-the-breach">Into the Breach</h2>
<p>假设我们 的日志文件中有一个时间戳 <strong>2016-02-06T14:36+02:00</strong>, 我们使用智能匹配:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="mi">2016</span><span class="sr">-</span><span class="mo">02</span><span class="sr">-</span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="p">:</span><span class="na">36</span><span class="o">+</span><span class="mo">02</span><span class="p">:</span><span class="na">00</span><span class="p">/;</span>
</code></pre></div><p>这会报错:</p>
<blockquote>
<p>Unrecognized regex metacharacter - (must be quoted to match literally)</p>
</blockquote>
<p>在 Raku 的正则表达式中任何非字母数字字符(&lsquo;a&rsquo;..&lsquo;z&rsquo;, &lsquo;A&rsquo;..&lsquo;Z&rsquo;, 0..9)都必须用引号引起来:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="mi">2016</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mi">36</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">00</span><span class="p">/;</span>
</code></pre></div><p>现在我们得到等价的奇怪的表达式:</p>
<pre><code>｢2016-01-29T13:25+01:00｣
</code></pre><p>这仅仅告诉我们, <code>~~</code> 智能匹配操作符匹配了一些文本, 这就是它匹配到的文本。<strong>｢｣</strong> 是日语引号标记, 故意和剩余的文本区分开来。</p>
<p>在 Raku 中, 默认打印出带有明确标记的匹配对象, 它准确地告诉你匹配从哪里开始, 到哪里结束。</p>
<h2 id="归纳">归纳</h2>
<p>我们想让该正则表达式更具普遍性, 例如匹配 2016 年的日志:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="mi">2015</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="mi">2016</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mi">36</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">00</span><span class="p">/;</span>
</code></pre></div><p>但是这还会匹配到我们不想要的东西, 例如  &lsquo;/post/2015/02&rsquo; 或者甚至 &lsquo;/number/120153&rsquo;。因为 <code>|</code>的优先级没有字符间的连接优先级高。所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">[</span><span class="mi">2015</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="mi">2016</span><span class="p">]</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mi">36</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">00</span><span class="p">/;</span>
</code></pre></div><p>问题解决, 但是我们想匹配 &lsquo;[ 1997 | 1998 | 1999 | 2000&hellip; 2015 ]&rsquo; 这些呢？</p>
<h3 id="learning-shorthnd">Learning Shorthnd</h3>
<p>匹配4位数字的年份好了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">02</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="mo">06</span><span class="sr">T</span><span class="mi">14</span><span class="o">..</span><span class="ni">.</span><span class="p">/;</span>
</code></pre></div><p>其它需要数字的地方也可以使用 <code>\d</code> 这种便捷形式的数字:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> - </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="p">/;</span>
</code></pre></div><p><code>'+' &lt;digits&gt; : &lt;digits&gt;</code> 只会匹配 <code>+01</code> 和 <code>+12</code> 之间的时区, 还有其它在 <code>-11</code> 到 <code>-01</code> 之间的时区, 所以我们使用 <code>|</code> 来匹配 &lsquo;+&rsquo; 或 &lsquo;-&rsquo;, 像这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> - </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="p">/;</span>
</code></pre></div><p>基本正确了, 但是由于历史原因, 时区还能是一个字母 <code>Z</code>, 所以, 还有一处要修改:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> - </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="o">|</span><span class="sr"> Z </span><span class="p">]</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><h2 id="重构">重构</h2>
<p>但是那个 <strong><code>[ '+' ... Z ]</code></strong> 表达式太长了, 能重构就更好了。<strong>regex</strong> 对象来拯救我们了, 它帮助我们清理代码。</p>
<p><strong>regex</strong> 对象看起来很像匹配表达式, 除了它使用花括号来告诉从哪开始, 到哪结束:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">Timezone</span> <span class="p">{</span><span class="sr"> Z </span><span class="o">|</span><span class="sr"> </span><span class="p">[&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">};</span>
<span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> T </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Timezone</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><p><code>&lt;..&gt;</code> 从外表上看把重构后的表达式和主文本分开了, 而让 Timezone 表达式分离意味着我们能在代码中的任何地方使用它了。事实上我们可以重构其它的正则:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">Date</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d\d\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Time</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr">              </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Timezone</span> <span class="p">{</span><span class="sr"> Z </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\d\d</span><span class="sr"> </span><span class="p">};</span>

<span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Date</span><span class="p">&gt;</span><span class="sr"> T </span><span class="p">&lt;</span><span class="nf">Time</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Timezone</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><p>让所有这些 <code>\d\d</code> 坐在一块儿有些碍眼, 所以我们再重构下:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">Integer</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">};</span>

<span class="k">my</span> <span class="k">regex</span> <span class="nf">Date</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr">     </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Time</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr">                   </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">Timezone</span> <span class="p">{</span><span class="sr"> Z </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">]</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">:</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Integer</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">};</span>

<span class="nb">say</span> <span class="nv">$logfile</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Date</span><span class="p">&gt;</span><span class="sr"> T </span><span class="p">&lt;</span><span class="nf">Time</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Timezone</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/;</span>
</code></pre></div><p><a href="http://theperlfisher.blogspot.jp/2016/02/from-regular-expressions-to-grammars-pt.html">http://theperlfisher.blogspot.jp/2016/02/from-regular-expressions-to-grammars-pt.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/regex" term="regex" label="regex" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[从正则表达式到 Grammar(第二部分)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-14-play-audio-at-given-volume/?utm_source=atom_feed" rel="related" type="text/html" title="以指定音量随机播放音频文件" />
            
                <id>https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>From Regex to Grammar</blockquote><p>如果你是正则表达式新人(至少当它们用于 Raku 中时), 那我建议你从这个系列的<a href="http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt.html">第一部分</a>开始。那些掌握了一定正则表达式的人可以跳过<a href="http://theperlfisher.blogspot.ro/2016/02/from-regular-expressions-to-grammars-pt_20.html">上周</a>的文章。现在, 继续演示!</p>
<h2 id="上周轶事">上周轶事</h2>
<p>我们开始开发一个接收诸如:</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Hey, did you konw a = &#34;</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">+</span> <span class="s2">&#34;?&#34;</span><span class="p">);</span>
</code></pre></div><p>Javascript 表达式的 Raku 编译器, 并把这段代码转换为 <a href="http://raku.org/">Rakudo</a> 那样的编译器能运行的 Raku 代码。在我们开始之前, 想想转换后的 Raku 代码看起来是什么样的可能会是个好主意。如果你已经知道了 Perl 5, 那么你应该熟悉这样的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">say</span> <span class="s">&#34;Hey, did you konw a = &#34;</span> <span class="o">~</span> <span class="nv">$a</span> <span class="o">~</span> <span class="s">&#34;?&#34;</span><span class="p">;</span>
</code></pre></div><p>我们将需要确保我们的正则表达式捕获到了 Javascript 的要素。如果你还记得上一次, 我们使用这样一组正则表达式来捕获我们的文本:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                             </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">var a = 3; console.log(&#34;Hey, did you konw a = &#34; + a + &#34;?&#34;);</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">rule</span> <span class="p">{</span> <span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>  <span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">};</span>
</code></pre></div><p>如果你把这段代码放到一个 Raku 源文件中并运行它, 那么它的输出第一次看起来可能会有点奇怪:</p>
<pre><code>｢var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );｣
 Assignment-Expression =&gt; ｢var a = 3｣
    Variable =&gt; ｢a ｣
    Number =&gt; ｢3｣
 Function-Call =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣
    String =&gt; ｢&quot;Hey, did you know a = &quot; ｣
    Variable =&gt; ｢a ｣
    String =&gt; ｢&quot;?&quot; ｣
</code></pre><p>如果你愿意暂时忽略 「」 标记, 你会看到匹配被缩进了, 几乎像资源管理器窗口一样, <code>&lt;Assignment-Expression&gt;</code> 作为目录, <code>Variable</code> 和 <code>Number</code> 作为目录里面的文件。实际上, 那离真相不远了。当我看到这种结构时, 我发现使用一点添加的语法能帮助我们像这样来观察它:</p>
<pre><code>$/ =&gt; ｢var a = 3; console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; );｣
 &lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣
    &lt;Variable&gt; =&gt; ｢a ｣
    &lt;Number&gt; =&gt; ｢3｣
 &lt;Function-Call&gt; =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣
    &lt;String&gt; =&gt; ｢&quot;Hey, did you know a = &quot; ｣
    &lt;Variable&gt; =&gt; ｢a ｣
    &lt;String&gt; =&gt; ｢&quot;?&quot; ｣
</code></pre><p>这几乎让怎么打印出文本变得更容易, 并在我们的正则表达式中指出了一个小问题。我们来打印给变量 <em>a</em> 所赋的数字, 从这儿开始。第一行告诉我们目录的根, 或者匹配树是 <code>$/</code>。如果你在测试文件的末尾添加上 <code>say $/;</code> 并返回它, 那么你会看到整个表达式被打印出了 2 次。那一定意味着 <code>$/</code> 就是整个匹配。</p>
<p>每向下推进一层就是把 <code>=&gt;</code> 箭头的左侧的东西添加到 <code>$/</code> 的右边。把之前的 <code>say</code> 语句修改为 <code>say  $/&lt;Assignment-Expression&gt;;</code>, 并看看输出发生了什么改变。它现在看起来应该像这样:</p>
<pre><code>｢var a = 3｣
  Variable =&gt; ｢a ｣
  Number =&gt; ｢3｣
</code></pre><p>让我们把把标记(不可见)添加进来, 所以我们能知道到了哪里&hellip;</p>
<pre><code>$/&lt;Assignment-Expression&gt; =&gt; ｢var a = 3｣
  &lt;Variable&gt; =&gt; ｢a ｣
  &lt;Number&gt; =&gt; ｢3｣
</code></pre><p>我们现在能看到我们的目标, 数字 3, 仅仅实在更下面的一层。和上次一样, 我们能够添加表达式左侧的东西, 所以我们就动手吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;;</span>
  <span class="p">｢</span><span class="s">3</span><span class="p">｣</span>
</code></pre></div><p>我们几乎得到我们想要的了。「」 挡道, 所以我们在这儿把值转换回数字。我把转换(cast)用引号扩起来, 因为它不是 <code>C/C++</code> 程序员那样认为的&quot;casting&quot;。我们想做的大约等价于 <code>sscanf(str,&quot;%d&quot;,&amp;num)</code>, 但是在 Raku 中, 这个操作符更加简单:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">+</span><span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;;</span> <span class="c1"># 3</span>
</code></pre></div><p>如果不深入更多细节, 那么 <code>$/</code> 是一个里面藏着隐式数字、字符串和布尔值的对象。前面添加的 <code>+</code> 把隐藏在 <code>$/</code> 对象中的数字显示出来了。</p>
<h2 id="从-javascript-到-perl">从 Javascript 到 Perl</h2>
<p>我们离从 Javascript 生成 Raku 代码不远了。让我们使用上面所学的开始我们的第一个语句, 赋值语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span>
      <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>

<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div><p>我们仅仅使用了 7 行 Raku 就把代码从一种语言转换为另外一种语言。并且大部分的 Raku 代码都是可重用的, 因为字符串, 数字, 和 <code>Javascript/C/Java</code> 风格的变量名在大部分语言之间是通用的。</p>
<p>上次, 我们学习了怎么使用正则表达式来创建匹配。这次我们学会了怎么使用我们说匹配到的东西, 还有怎么在 <em>say</em> 语句中找出我们想要的东西。 不可见的匹配标记相当有用, 我可能会写一个模块来把它们放回到匹配表达式中, 那应该不难。</p>
<p>那个方案有一个问题, 如果我们看一下 <code>&lt;Function-Call&gt;</code> 匹配, 会很容易发现那个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; )</span><span class="p">｣</span>
  <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">&#34;Hey, did you know a = &#34; </span><span class="p">｣</span>
  <span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">a </span><span class="p">｣</span>
  <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="o">=&gt;</span> <span class="p">｢</span><span class="s">&#34;?&#34; </span><span class="p">｣</span>
</code></pre></div><p>当我们写了 <code>say $/&lt;Function-Call&gt;&lt;String&gt;;</code> 时, 我们会获取哪个 <code>&lt;String&gt;?</code> 在你运行这段代码之前, 先猜测一下。会是第一个吗, 因为一旦匹配对象被创建,  Raku 就不会把它替换掉? 会是最后一个吗, 因为最后一个&quot;覆盖&quot;了第一个? 编译器会仅仅&quot;感到困惑&quot;然后什么也不打印吗? 运行一下看看!</p>
<p>它实际上以一个列表的形式把两个匹配都返回了, 所以你可以引用任何一个。 我们的不可见标记现在看起来长这样:</p>
<pre><code>$/&lt;Function-Call&gt; =&gt; ｢console.log( &quot;Hey, did you know a = &quot; + a + &quot;?&quot; )｣
  &lt;String&gt;[0] =&gt; ｢&quot;Hey, did you know a = &quot; ｣
  &lt;Variable&gt; =&gt; ｢a ｣
  &lt;String&gt;[1] =&gt; ｢&quot;?&quot; ｣
</code></pre><p>所以, 如果我们想打印第一个字符串, 我们可以写上 <code>say $/&lt;Function-Call&gt;&lt;String&gt;[0];</code> 并得到含有时髦的日语标记的「&ldquo;Hey, did you know a = &quot; 」。幸运的是有一种便捷方式来避免那些日语标记, 就像数字 3 中的那样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">~</span><span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
 <span class="p">&#34;</span><span class="s2">Hey, did you know a = </span><span class="p">&#34;</span>
</code></pre></div><p><strong>~</strong> 操作符使匹配字符串化, 就像 <code>+</code> 让返回的匹配数字化一样。所以你可能自己把最后一行写作:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span>
  <span class="p">&#39;</span><span class="s1"> $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span>
  <span class="nv">$&lt;Function-Call&gt;&lt;String&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hey, did you know a = </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$a</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">?</span><span class="p">&#34;;</span>
</code></pre></div><p>我们已经把我们的两行 Javascript 代码编译成 Raku 代码了。</p>
<h2 id="重构">重构</h2>
<p>现在已经能工作了, 但是有很多重复。目前我们得到是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">rule</span> <span class="nf">Variable</span>               <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">String</span>                 <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Assignment-Expression</span>  <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Function-Call</span>          <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>

<span class="p">&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="k">rule</span> <span class="p">{</span> <span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">}</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span>  <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span>  <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
</code></pre></div><p>那些 rules 看起来相当好,  <code>&lt;String&gt;</code> 和 <code>&lt;Variable&gt;</code> 的重复也是不可避免的。 但是看看 <code>say</code> 语句, 你会看到 <code>&lt;Assignment-Expression&gt;</code> 和 <code>&lt;Function-Call&gt;</code> 重复了自身好几次。避免这种重复的一种方法是创建一个临时变量, 但是那可能会变得丑陋。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$assignment-expression</span> <span class="o">=</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$assignment-expression</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span>  <span class="nv">$assignment-expression</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
</code></pre></div><p>相反, 我们利用 Raku 的子例程签名, 并且重用 <code>$/</code> 变量名以使我们能重用上面所写的代码, 然后拿掉 <code>&lt;Assignment-Expression&gt;</code> 部分。 我会把子例程的名字命名为 rule 的名字, 只是为了直接了当。(你会在之后看到为什么这样做。)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span>  <span class="nf">assignment-expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">);</span>
</code></pre></div><p>让我们对 <code>&lt;Function-Call&gt;</code> 也做同样的事情, 创建一个含有 <code>$/</code> 子例程签名的同名函数。 它现在写在一行里面就很整洁了, 并且只重复 <em><!-- raw HTML omitted --></em> 部分, 因为它不得不重复。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
     <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">);</span>
</code></pre></div><h2 id="对象化">对象化</h2>
<p>一路上我做了相当多的选择, 让我们到达这里。这就是我们上次重构的地方:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          };
</span><span class="sr">my rule String                </span><span class="p">{</span> <span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">-[ &#34; ]</span><span class="p">&gt;</span><span class="o">+</span> <span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span>                                            <span class="p">}</span><span class="sr">;
</span><span class="sr">my rule Assignment-Expression </span><span class="p">{</span> <span class="n">var</span> <span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span>                                  <span class="p">}</span><span class="sr">;
</span><span class="sr">my rule Function-Call         </span><span class="p">{</span> <span class="n">console</span> <span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span> <span class="nb">log</span> <span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span> <span class="p">}</span><span class="sr">;
</span><span class="sr">
</span><span class="sr"></span><span class="p">&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">~~</span><span class="sr"> rule </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">sub assignment-expression</span><span class="p">(</span><span class="sr"> </span><span class="ni">$</span><span class="sr">/ </span><span class="p">)</span><span class="sr"> </span><span class="p">{</span>
    <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
<span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">sub function-call</span><span class="p">(</span><span class="sr"> </span><span class="ni">$</span><span class="sr">/ </span><span class="p">)</span><span class="sr"> </span><span class="p">{</span>
    <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
<span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">say assignment-expression</span><span class="p">(</span><span class="sr"> </span><span class="ni">$</span><span class="sr">/</span><span class="p">&lt;</span><span class="nf">Assignment-Expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">)</span><span class="sr">;
</span><span class="sr">say function-call</span><span class="p">(</span><span class="sr"> </span><span class="ni">$</span><span class="sr">/</span><span class="p">&lt;</span><span class="nf">Function-Call</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">)</span><span class="sr">;
</span></code></pre></div><p>这就是我们的回报。我们先捡起最后那两个 <code>say</code> 语句。 我们还没有给顶层 rule 一个名字, 所以我们就叫它&hellip; 好吧, 现在还是叫 &lsquo;top&rsquo; 吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="o">~</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">}</span>
</code></pre></div><h2 id="收回你的吐槽">收回你的吐槽</h2>
<p>我们暂时还没有对处于文件顶层的 rules 做太多处理, 所以让我们开始工作吧。 在 Raku 中, 就一般编程而言, 把你的代码打包复用是不错的注意。而 Raku 让我们使用 <code>class</code> 关键字将我们的程序打包, 我们拥有的那些 rules 从任何意义上来说实际上不是&quot;代码&rdquo;。而它们能够用于代码中, 并且我们确实使用了它们, 它们自身实际上并没有做出任何决定。</p>
<p>所以我们不应该使用 <code>class</code> 关键字来把它们打包到一块。相反, 有另外一种便捷的类型用于把一堆正则表达式和 rules 打包到一块儿, 它叫做 <code>grammar</code>。</p>
<p>它的语法就像声明一个「rule」 那样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Javascript</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>      

    <span class="k">rule</span> <span class="nf">TOP</span>                   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Assignment-Expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Function-Call</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr">              </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div><p>你会注意到, 我们给我们的顶层 rule 也起了个名字, 并且暂时把它叫做 「TOP」 吧。 如果你正在家独自玩耍, 你可能已经做出更改并想知道 「&lsquo;var a = 3;&hellip;&rsquo; ~~ rule { &hellip; }」 是怎么起作用的, 因为键入诸如 「&lsquo;var a = 3;&hellip;&rsquo; ~~ JavaScript;」这样的东西可能不会那么有作用。</p>
<p>Grammars 就像类一样, 在里面它们实际上是一块可能的代码。 它们本身不会工作, 它们必须从潜在的转换为动态的代码。我们可以像你在类中做的那样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$JavaScript</span> <span class="o">=</span> <span class="n">JavaScript</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</code></pre></div><p>现在我们拥有了一个可以工作的变量。 现在, 让我们来使用它。所有的 Grammar 类都有一个内置的 「parse()」 方法, 以使我们能得到 grammar 中的正则表达式。 我们来修改我们的匹配语句以利用 parse() 方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$JavaScript</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;);</span>
</code></pre></div><p>我们的代码应该又能工作了。</p>
<h2 id="接收动作">接收动作</h2>
<p>现在我们已经把我们所有的匹配的东西打包到一个小型的类里面了, 如果我们能对那些子例程做同样的处理将会很棒。 我们在这儿试试, 把我们的子例程放到它们自己的命名空间中, 就像我们对 rule 做的那样。 我们必须从 「sub」 修改为 「method」, 而我们的 「top」 方法将会使用 「self.」 去调用其它方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">)</span> <span class="o">~</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>就像之前那样, 我们可以在一行里面创建 Actions 对象:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">Actions</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
</code></pre></div><p>并且调用 top 几乎像我们之前做的那样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$actions</span><span class="o">.</span><span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">);</span>
</code></pre></div><p>我们已经修改了很多东西了, 所以我们来看看到哪了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">JavaScript</span> <span class="p">{</span>
  <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>
  <span class="k">rule</span> <span class="nf">TOP</span>                   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Assignment-Expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Function-Call</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr">              </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">my</span> <span class="nv">$j</span> <span class="o">=</span> <span class="n">JavaScript</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>

<span class="nv">$j</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;);</span>

<span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">top</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="nb">self</span><span class="o">.</span><span class="nf">assignment-expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">)</span> <span class="o">~</span>
      <span class="nb">self</span><span class="o">.</span><span class="nf">function-call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">Actions</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$actions</span><span class="o">.</span><span class="nf">top</span><span class="p">(</span><span class="nv">$/</span><span class="p">);</span>
</code></pre></div><p>不用担心, 我们快要到了。既然我们有了一个单独的类来处理 Actions, 我们把方法重命名为 Grammar 中所匹配的 rule 的名字, 以使我们不会忘记它们是什么。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">Function-Call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~$</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span> <span class="p">)</span> <span class="o">~</span>
        <span class="nb">self</span><span class="o">.</span><span class="nf">Function-Call</span><span class="p">(</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span> <span class="p">)</span>

    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>更进一步, 我们还有最后一点魔法能够利用。 我们将把 <code>$javascript</code> 和 <code>$actions</code> 对象像这样组合在一块。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$javascript</span><span class="o">.</span><span class="nb">parse</span><span class="p">(&#39;</span><span class="s1">...</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="nv">$actions</span><span class="p">)</span> <span class="p">);</span>
</code></pre></div><p>「:actions(&hellip;)」 给 「parse()」方法声明的可选参数。我们正告诉正则表达式引擎, 任何时候, 像 <code>&lt;Function-Call&gt;</code> 或 <code>&lt;TOP&gt;</code> 这样的 rule 匹配时, 我们会在我们的类中让它调用对应的同名方法。</p>
<p>这几乎是按原样工作的, 但是如果你运行修改后的代码,  你会发现解析返回了原来的匹配对象, 带着日语引用标记。所以看起来好像我们又回到了原地。不完全是。</p>
<p>继续, 我们在其中之一的方法中添加一个临时的 <code>&quot;say 'Hello';&quot;</code> 语句, 仅仅是为了确认它们正被调用。这是正则引擎正在工作并且可能正解析它所 going over 的一个重要证据。 你甚至可以使用某些我们上面已经学到的技巧然后写上 「<code>say $/&lt;Variable&gt;;</code>」 来查看匹配是否正像你想的那样运行。继续运行并玩玩, 做完的时候再回到这儿。</p>
<h2 id="混合信号mixed-signals">混合信号(Mixed Signals)</h2>
<p>正发生的是方法正被调用, 但是它们的输出被丢弃。我们来捕获输出然后使用 grammar 的最后一个特性, 抽象语法树。现在,  这可能会勾起坐在教室里看黑板上画出的盒子和线段的场景, 但是也没有那么糟糕了。我们已经看到了一个, 实际上 <strong>say()</strong> 的输出就是一个 AST。</p>
<p>我们来看下其它语法树, 我们在后台创建的那个。在 &ldquo;$javascript.parse(&hellip;)&rdquo; 调用的末尾添加上 「.ast」, 这会给我们展示我们自己创建的语法树。</p>
<p>如果你这样做了, 你会看到它打印了(Any), 这通常等价于「匹配失败」, 单是我们从之前的测试中知道匹配没有失败。所以这儿发生了什么? 当我们的方法运行的时候, 它们返回输出, 但是 Raku 不知道怎么处理这些输出, 或者说它不知道把输出安装到它所创建的 AST 中的哪个位置。</p>
<p>关键是一个叫做「make」的小东西。在方法的开头, 把这个添加到过去我们放置「say」的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">make</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">Function-Call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">make</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">make</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>还有, 因为 Raku 为我们调用方法, 我们不需要自己来调用 <code>self.Function-Call(...)</code>, 我们需要做的全部工作就是查看 <code>Function-Call(...)</code> 返回给我们的语法树。最终我们做到了。一个完整, 虽然微小的编译器。为了防止你在编辑时迷失, 这儿有一个最终的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">JavaScript</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">Number</span>                <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Variable</span>              <span class="p">{</span><span class="sr"> </span><span class="se">\w</span><span class="o">+</span><span class="sr">                                                          </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">String</span>                <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr"> &#34; </span><span class="p">]&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr">                                            </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr">                                  </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">Function-Call</span>         <span class="p">{</span><span class="sr"> console </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> log </span><span class="p">&#39;</span><span class="s1">(</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">)</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">};</span>
    <span class="k">rule</span> <span class="nf">TOP</span>                   <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Assignment-Expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">Function-Call</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span><span class="sr">              </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">Assignment-Expression</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="p">&#39;</span><span class="s1">my $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> = </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Number</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">Function-Call</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="p">&#39;</span><span class="s1">say </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ $</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Variable</span><span class="p">&gt;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> ~ </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">String</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span> <span class="nv">$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Assignment-Expression</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span> <span class="o">~</span> <span class="nv">$/</span><span class="p">&lt;</span><span class="s">Function-Call</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">ast</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$j</span> <span class="o">=</span> <span class="n">JavaScript</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">Actions</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$j</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span>
   <span class="p">&#39;</span><span class="s1">var a = 3; console.log( &#34;Hey, did you know a = &#34; + a + &#34;?&#34; );</span><span class="p">&#39;</span><span class="o">,</span>
   <span class="p">:</span><span class="s">actions</span><span class="p">(</span><span class="nv">$a</span><span class="p">))</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
</code></pre></div><h2 id="到哪里去">到哪里去</h2>
<p>一个简单但整洁的更改是你可以扩展 Assignment-Expression 来既接收数字又接收字符串。上次我们谈论了 rules 中的轮试,所以这个提示应该足够让你开始了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">rule</span> <span class="nf">Assignment-Expression</span> <span class="p">{</span><span class="sr"> var </span><span class="p">&lt;</span><span class="nf">Variable</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">(&lt;</span><span class="nf">Number</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">String</span><span class="p">&gt;)</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>你必须修改下 Assignment-Expression 方法以使它起作用。或者你可以狡猾一点然后发现( <code>&lt;Number&gt; | &lt;String&gt;</code> ) 可以转换为它自己的小的普通的 &ldquo;Term&rdquo; rule, &ldquo;rule Term { <!-- raw HTML omitted --> | <!-- raw HTML omitted --> }&rdquo;, 然后添加一个 action &ldquo;method Term($/) { make $/<!-- raw HTML omitted --> or $/<!-- raw HTML omitted -->}&rdquo; 而只在 Assignment-Expression 中修改一个东西。</p>
<p><a href="http://theperlfisher.blogspot.fr/2016/02/from-regular-expressions-to-grammars-pt_28.html">http://theperlfisher.blogspot.fr/2016/02/from-regular-expressions-to-grammars-pt_28.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/regex" term="regex" label="regex" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[以指定音量随机播放音频文件]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-06-14-play-audio-at-given-volume/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-06-14-play-audio-at-given-volume/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Play Audio at Given Volume</blockquote><p>以指定音量随机播放音频文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">%v</span><span class="p">;</span>                                 <span class="c1"># hash to hold data</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">filename</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+?</span><span class="sr"> \</span><span class="ni">.</span><span class="se">\S\S\S</span><span class="sr"> </span><span class="p">};</span> <span class="c1"># filenames end in .???</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">volume</span>      <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">};</span>          <span class="c1"># any digits for volume</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">extra</span>       <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> </span><span class="se">\S</span><span class="sr"> </span><span class="p">};</span>        <span class="c1"># anything following that</span>
<span class="k">my</span> <span class="nv">$mixer</span>          <span class="o">=</span> <span class="p">&#39;</span><span class="s1">mixer</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$player</span>         <span class="o">=</span> <span class="p">&#39;</span><span class="s1">mplayer -vf dsize=600:-2 -geometry +200-10 </span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$lockfile</span>       <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/tmp/myplayer</span><span class="p">&#39;;</span>

<span class="nv">$lockfile</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">spurt</span><span class="p">(</span> <span class="vg">$*PID</span> <span class="p">);</span>          <span class="c1"># store the process ID so other process can kill this one</span>
<span class="k">END</span> <span class="p">{</span> <span class="nv">$lockfile</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">unlink</span><span class="p">;</span> <span class="p">}</span>          <span class="c1"># remove the lockfile at end</span>

<span class="k">for</span> <span class="nv">$=finish</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>                  <span class="c1"># loop through the lines below &#39;=begin finish&#39;</span>
    <span class="nb">last</span> <span class="k">if</span> <span class="o">/</span><span class="n">STOP</span><span class="o">/</span><span class="p">;</span>                   <span class="c1"># stop at a STOP line</span>
    <span class="k">if</span> <span class="k">m</span><span class="p">/</span><span class="sr">     </span><span class="p">(&lt;</span><span class="nf">filename</span><span class="p">&gt;)</span><span class="sr">
</span><span class="sr">          </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="p">(&lt;</span><span class="nf">volume</span><span class="p">&gt;)</span><span class="sr">
</span><span class="sr">          </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">(&lt;</span><span class="nf">extra</span><span class="p">&gt;</span><span class="o">?</span><span class="p">)</span><span class="sr"> </span><span class="p">/</span> <span class="p">{</span>          <span class="c1"># use the regexes/tokens</span>
        <span class="k">my</span> <span class="p">(</span> <span class="nv">$m</span><span class="o">,</span> <span class="nv">$v</span><span class="o">,</span> <span class="nv">$e</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">$/</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span> <span class="c1"># get captured values from $/</span>
        <span class="k">if</span> <span class="nv">$m</span> <span class="ow">and</span> <span class="nv">$v</span> <span class="p">{</span>                <span class="c1"># if there&#39;s a filename and volume</span>
            <span class="nv">%v</span><span class="p">{</span><span class="nv">$m</span><span class="p">}&lt;</span><span class="s">v</span><span class="p">&gt;</span> <span class="o">~=</span> <span class="nv">$v</span><span class="p">;</span>          <span class="c1">#   store it in the hash</span>
            <span class="nv">%v</span><span class="p">{</span><span class="nv">$m</span><span class="p">}&lt;</span><span class="s">e</span><span class="p">&gt;</span> <span class="o">~=</span> <span class="nv">$e</span> <span class="o">//</span> <span class="p">&#39;&#39;;</span>    <span class="c1">#   with any extra arguments</span>
        <span class="p">}}}</span> <span class="c1"># lisp-y to save lines</span>

<span class="k">for</span> <span class="nv">%v</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$m</span> <span class="p">{</span>           <span class="c1"># loop randomly through keys</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Playing </span><span class="nv">$m</span><span class="p">&#34;;</span>
    <span class="nb">print</span> <span class="k">qq</span><span class="sa">x</span><span class="p">{</span><span class="s2"> </span><span class="nv">$mixer</span><span class="s2">  </span><span class="nv">%v</span><span class="p">{</span><span class="nv">$m</span><span class="p">}&lt;</span><span class="s">v</span><span class="p">&gt;</span><span class="s2">      </span><span class="p">};</span>  <span class="c1"># set the volume</span>
    <span class="nb">print</span> <span class="k">qq</span><span class="sa">x</span><span class="p">{</span><span class="s2"> </span><span class="nv">$player</span><span class="s2"> </span><span class="nv">%v</span><span class="p">{</span><span class="nv">$m</span><span class="p">}&lt;</span><span class="s">e</span><span class="p">&gt;</span><span class="s2"> &#34;</span><span class="nv">$m</span><span class="s2">&#34; </span><span class="p">};</span>  <span class="c1"># play the file</span>
<span class="p">}</span>

<span class="k">=begin</span><span class="sd"> </span><span class="k">finish</span><span class="sd">
</span><span class="sd">300.avi 77
</span><span class="sd">Crystal Skull Rifftrax.avi 77 -aid 2
</span><span class="sd">Star Trek 5.avi 77
</span><span class="sd">Star Trek 7.avi
</span><span class="sd">aeon-flux.avi 93
</span><span class="sd"></span><span class="k">=end finish</span></code></pre></div><p>改进版：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#! /usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@mixer</span>    <span class="o">=</span> <span class="p">&#39;</span><span class="s1">mixer</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">@player</span>   <span class="o">=</span> <span class="p">&lt;</span><span class="s"> m6player -vf dsize=600:-2 -geometry +200-10 </span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$lockfile</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/tmp/myplayer</span><span class="p">&#39;;</span>

<span class="nv">$lockfile</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">spurt</span><span class="p">(</span> <span class="vg">$*PID</span> <span class="p">);</span>

<span class="k">END</span> <span class="p">{</span> <span class="nv">$lockfile</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">unlink</span><span class="p">;</span> <span class="p">}</span>

<span class="k">my</span> <span class="k">token</span> <span class="nf">filename</span>    <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+?</span><span class="sr"> \</span><span class="ni">.</span><span class="se">\S\S\S</span><span class="sr"> </span><span class="p">};</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">volume</span>      <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">};</span>
<span class="k">my</span> <span class="k">regex</span> <span class="nf">extra</span>       <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">*</span><span class="sr"> </span><span class="p">};</span>

<span class="k">my</span> <span class="nv">%song-data</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">$=finish</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>
    <span class="nb">last</span> <span class="k">if</span> <span class="o">/^</span> \<span class="k">s</span><span class="p">*</span><span class="sr"> STOP </span><span class="se">\s</span><span class="p">*</span><span class="s2"> $/;
</span><span class="s2">    next unless  m/ \s</span><span class="p">*</span> <span class="p">&lt;</span><span class="s">filename</span><span class="p">&gt;</span> \<span class="k">s</span><span class="err">+</span> <span class="p">&lt;</span><span class="sr">volume</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="s">extra</span><span class="p">&gt;</span> <span class="o">/</span><span class="p">;</span>
    <span class="c1"># $&lt;extra&gt; is short for $/{&#39;extra&#39;}</span>
    <span class="nv">%song-data</span><span class="p">{</span><span class="o">~</span><span class="nv">$&lt;filename&gt;</span><span class="p">}&lt;</span><span class="s">v e</span><span class="p">&gt;</span> <span class="o">=</span> <span class="o">+</span><span class="nv">$&lt;volume&gt;</span><span class="o">,</span> <span class="o">[</span><span class="nv">$&lt;extra&gt;</span><span class="o">.</span><span class="nb">words</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># uses sub-signature unpacking</span>
<span class="k">for</span> <span class="nv">%song-data</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span> <span class="p">:</span><span class="s">key</span><span class="p">(</span><span class="nv">$m</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">value</span><span class="p">(</span><span class="nv">$</span><span class="p">)</span> <span class="p">(</span><span class="o">:</span><span class="nv">$v</span><span class="o">,:</span><span class="nv">@e</span><span class="p">))</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Playing </span><span class="nv">$m</span><span class="p">&#34;;</span>
    <span class="nb">print</span> <span class="nb">run</span><span class="p">(</span> <span class="nv">@mixer</span><span class="o">,</span>  <span class="nv">$v</span><span class="o">,</span>     <span class="p">:</span><span class="s">out</span> <span class="p">)</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">slurp-rest</span><span class="o">.</span><span class="nb">indent</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="nb">print</span> <span class="nb">run</span><span class="p">(</span> <span class="nv">@player</span><span class="o">,</span> <span class="nv">@e</span><span class="o">,</span> <span class="nv">$m</span><span class="o">,</span> <span class="p">:</span><span class="s">out</span> <span class="p">)</span><span class="o">.</span><span class="nf">out</span><span class="o">.</span><span class="nb">slurp-rest</span><span class="o">.</span><span class="nb">indent</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">=begin</span><span class="sd"> </span><span class="k">finish</span><span class="sd">
</span><span class="sd">300.avi 77
</span><span class="sd">Crystal Skull Rifftrax.avi 77 -aid 2
</span><span class="sd">Star Trek 5.avi 77
</span><span class="sd">Star Trek 7.avi
</span><span class="sd">aeon-flux.avi 93
</span><span class="sd"></span><span class="k">=end finish</span></code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/regex" term="regex" label="regex" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/audio" term="audio" label="audio" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[使用 Grammar 解析文本: 一个例子]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-07-11-an-example-of-parsing-text-in-grammar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>An Example of Parsing Text in Grammar</blockquote><ul>
<li>解析<code>[ ]</code> 里面的数据：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Grammar::Debugger</span><span class="p">;</span>

<span class="k">grammar</span> <span class="nc">Lines</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="ni">$</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token line </span><span class="p">{</span>
        \<span class="o">[</span>
        <span class="p">&lt;</span><span class="s">student</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">%</span> <span class="p">&lt;</span><span class="s">semicolon</span><span class="p">&gt;</span>
        \<span class="o">]</span>
        \<span class="n">n</span>                   <span class="c1"># 换行 \n 是最容易被忽略的地方</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    token student </span><span class="p">{</span>
       <span class="p">&lt;</span><span class="s">myname</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">%</span> <span class="p">&lt;</span><span class="s">comma</span><span class="p">&gt;</span>   <span class="c1"># 分隔符也可以是一个 subrule</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    token myname </span><span class="p">{</span>
        <span class="p">&lt;</span><span class="s">[A..Za..z-]</span><span class="p">&gt;</span><span class="o">+</span>       <span class="c1"># 字符类的写法 &lt;[...]&gt;</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    token comma </span><span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">,</span><span class="p">&#39;</span> \<span class="k">s</span><span class="err">+</span>              <span class="err">#</span> <span class="err">逗号,</span> <span class="err">分号</span> <span class="err">不能裸露出现在</span> <span class="err">token</span> <span class="err">中</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">    token semicolon </span><span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">;</span><span class="p">&#39;</span> \<span class="k">s</span><span class="err">+</span>
    <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">}
</span><span class="sr">
</span><span class="sr">my </span><span class="nv">$parse</span><span class="sr"> </span><span class="o">=</span><span class="sr"> Lines</span><span class="ni">.</span><span class="sr">parsefile</span><span class="p">(&#39;</span><span class="s1">test.txt</span><span class="p">&#39;)</span><span class="sr">;
</span><span class="sr">say </span><span class="nv">$parse</span><span class="sr">;
</span></code></pre></div><p>test.txt 的内容如下：</p>
<pre><code>[Lue, Fan]
[Lou, Man-Li]
[Tian, Mijie; Zhou, Lin; Zou, Xiao; Zheng, Qiaoji; Luo, Lingling; Jiang, Na; Lin, Dunmin]
</code></pre><p>下面的 Grammar 用于解析一个字符串, 由于 tokens 不能回溯, 所以当解析 <code>$str</code> 时使用了 Grammar 的继承, 重写了 university 这个 token:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$string</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">[Wang, Zhiguo; Zhao, Zhiguo] Hangzhou Normal Univ, Ctr Cognit &amp; Brain Disorders, Hangzhou, Zhejiang, Peoples R China; [Wang, Zhiguo; Theeuwes, Jan] Vrije Univ Amsterdam, Dept Cognit Psychol, Amsterdam, Netherlands</span><span class="p">&#34;;</span>

<span class="k">grammar</span> <span class="nc">University::Grammar</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span>             <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">university</span><span class="p">&gt;</span><span class="sr"> </span><span class="ni">$</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">university</span>      <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">bracket</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">info</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">; </span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">bracket</span>         <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">studentname</span><span class="p">&gt;</span><span class="sr">  </span><span class="p">&#39;</span><span class="s1">] </span><span class="p">&#39;</span><span class="sr">      </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">studentname</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nv">stdname</span><span class="o">=.</span><span class="nf">info</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">; </span><span class="p">&#39;</span><span class="sr">      }
</span><span class="sr">    token info            </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">field</span><span class="p">&gt;</span><span class="o">+</span> <span class="nv">%</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span>              <span class="p">}</span><span class="sr">
</span><span class="sr">    token field           </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">-[,\]\[;\n]</span><span class="p">&gt;</span><span class="o">+</span>               <span class="p">}</span><span class="sr">
</span><span class="sr">}
</span><span class="sr">
</span><span class="sr"></span><span class="c1"># grammar 像类一样可以继承, 里面的 token 可以被重写
</span><span class="c1"></span><span class="sr">grammar MyUniversity  is University</span><span class="o">:</span><span class="p">:</span><span class="na">Grammar</span><span class="sr"> </span><span class="p">{</span>
    <span class="k">token</span> <span class="nf">university</span>      <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">info</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">; </span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Zhejiang Univ, Coll Environm &amp; Resources Sci, Dept Resource Sci, Hangzhou 310029, Peoples R China; La Trobe Univ, Dept Agr Sci, Bundoora, Vic 3083, Australia; Hangzhou Normal Coll, Fac Life Sci, Hangzhou, Peoples R China</span><span class="p">&#34;;</span>

<span class="k">my</span> <span class="nv">$parsed</span> <span class="o">=</span> <span class="n">University::Grammar</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$string</span><span class="p">);</span>
<span class="c1"># my $parsed = MyUniversity.parse($str);</span>

<span class="k">for</span> <span class="nv">@</span><span class="p">(</span><span class="nv">$parsed</span><span class="p">&lt;</span><span class="s">university</span><span class="p">&gt;&lt;</span><span class="s">info</span><span class="p">&gt;)</span> <span class="k">-&gt;</span> <span class="nv">$f</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$f</span><span class="p">&lt;</span><span class="s">field</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[使用 Grammar 解析日期]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-09-15-use-grammar-to-parse-date/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-16-a-mutable-grammar-for-raku/?utm_source=atom_feed" rel="related" type="text/html" title="A Mutable Grammar for Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-02-05-raku-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-01-raku-core-hacking-grammatical-babble/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 核心魔改: Grammar 的胡言乱语" />
                <link href="https://ohmyweekly.github.io/notes/2015-04-27-from-regex-to-grammar-part-one/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第一部分)" />
                <link href="https://ohmyweekly.github.io/notes/2015-10-29-from-regex-to-grammar/?utm_source=atom_feed" rel="related" type="text/html" title="从正则表达式到 Grammar(第二部分)" />
            
                <id>https://ohmyweekly.github.io/notes/2015-09-15-use-grammar-to-parse-date/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Use Grammar to Parse Date</blockquote><h3 id="描述">描述</h3>
<p>下面的日期, 有些使用了 <code>M D Y</code> 格式, 有些使用了 <code>Y M D</code> 格式, 还使用了任意分隔符! 请把这些散乱的文本解析成合适的 ISO 8601 (<code>YYYY-MM-DD</code>) 格式化日期。</p>
<p>假设只有以 4 个数字开头的日期使用 <code>Y M D</code> 格式, 其它的使用 <code>M D Y</code> 格式。</p>
<h3 id="输入样本">输入样本</h3>
<pre><code>2/13/15
1-31-10
5 10 2015
2012 3 17
2001-01-01
2008/01/07
</code></pre><h3 id="输出样本">输出样本</h3>
<pre><code>2015-02-13
2010-01-31
2015-05-10
2012-03-17
2001-01-01
2008-01-07
</code></pre><h3 id="扩展挑战-中级">扩展挑战 [中级]</h3>
<p>使用 <code>2014-12-24</code> 作为相对日期的基准。</p>
<p>当添加 <code>days</code>(天数) 时, 要考虑到每月会有不同的天数, 忽略闰年。</p>
<p>当添加月和年时, 使用整个 <code>units</code>, 以至于:</p>
<p>one month before october 10 is september 10</p>
<p>one year after 2001-04-02 is 2002-04-02</p>
<p>one month after january 30 is february 28 (not march 1)</p>
<h3 id="sallys-inputs">Sally&rsquo;s inputs:</h3>
<pre><code>tomorrow
2010-dec-7
OCT 23
1 week ago
next Monday
last sunDAY
1 year ago
1 month ago
last week
LAST MONTH
10 October 2010
an year ago
2 years from tomoRRow
1 month from 2016-01-31
4 DAYS FROM today
9 weeks from yesterday
</code></pre><h3 id="sallys-expected-outputs">Sally&rsquo;s expected outputs:</h3>
<pre><code>2014-12-25
2010-12-01
2014-10-23
2014-12-17
2014-12-29
2014-12-21
2013-12-24
2014-11-24
2014-12-15
2014-11-24
2010-10-10
2013-12-24
2016-12-25
2016-02-28
2014-12-28
2015-02-25
</code></pre><p>smls 大神给出了完整的 grammar：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$today</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">2014</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">24</span><span class="p">);</span>

<span class="k">grammar</span> <span class="nc">MessyDate</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr">    </span><span class="p">&lt;</span><span class="nf">date</span><span class="p">&gt;</span><span class="sr">                 </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;date&gt;</span><span class="o">.</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">duration</span><span class="p">&gt;</span><span class="sr"> ago         </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">earlier</span><span class="o">:</span> <span class="o">|</span><span class="nv">$&lt;duration&gt;</span><span class="o">.</span><span class="k">made</span>     <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">duration</span><span class="p">&gt;</span><span class="sr"> from </span><span class="p">&lt;</span><span class="nf">date</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;date&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">.</span><span class="nb">later</span><span class="o">:</span> <span class="o">|</span><span class="nv">$&lt;duration&gt;</span><span class="o">.</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">rule</span> <span class="nf">date</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">month</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">(&lt;</span><span class="nf">sep</span><span class="p">&gt;</span><span class="o">?</span><span class="p">)</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">day</span><span class="p">&gt;</span><span class="sr">   </span><span class="p">[</span><span class="nv">$0</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">year</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr">
</span><span class="sr">            </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">day</span><span class="p">&gt;</span><span class="sr">   </span><span class="p">(&lt;</span><span class="nf">sep</span><span class="p">&gt;</span><span class="o">?</span><span class="p">)</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">month</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">[</span><span class="nv">$0</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">year</span><span class="p">&gt;]</span><span class="o">?</span><span class="sr">
</span><span class="sr">            </span><span class="o">||</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">year</span><span class="p">&gt;</span><span class="sr">  </span><span class="p">(&lt;</span><span class="nf">sep</span><span class="p">&gt;</span><span class="o">?</span><span class="p">)</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">month</span><span class="p">&gt;</span><span class="sr">  </span><span class="nv">$0</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">day</span><span class="p">&gt;</span><span class="sr">    </span><span class="p">]</span><span class="sr">
</span><span class="sr">          </span><span class="p">{</span> <span class="k">make</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="nv">$&lt;year&gt;</span><span class="o">.</span><span class="k">made</span><span class="o">//</span><span class="nv">$today</span><span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="o">|</span><span class="nv">$&lt;month day&gt;</span><span class="o">».</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> today          </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span>     <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> yesterday      </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> tomorrow       </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> last </span><span class="p">&lt;</span><span class="nf">weekday</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">-</span> <span class="p">(</span><span class="nv">$today</span><span class="o">.</span><span class="nb">day-of-week</span> <span class="o">-</span> <span class="nv">$&lt;weekday&gt;</span><span class="o">.</span><span class="k">made</span><span class="p">)</span> <span class="nv">%</span> <span class="mi">7</span> <span class="o">||</span> <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> next </span><span class="p">&lt;</span><span class="nf">weekday</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span> <span class="o">+</span> <span class="p">(</span><span class="nv">$&lt;weekday&gt;</span><span class="o">.</span><span class="k">made</span> <span class="o">-</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">day-of-week</span><span class="p">)</span> <span class="nv">%</span> <span class="mi">7</span> <span class="o">||</span> <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> last </span><span class="p">&lt;</span><span class="nf">unit</span><span class="p">&gt;</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">earlier</span><span class="o">:</span> <span class="o">|</span><span class="p">(</span><span class="nv">$&lt;unit&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> next </span><span class="p">&lt;</span><span class="nf">unit</span><span class="p">&gt;</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="nv">$today</span><span class="o">.</span><span class="nb">later</span><span class="o">:</span>   <span class="o">|</span><span class="p">(</span><span class="nv">$&lt;unit&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    rule duration </span><span class="p">{</span>
        <span class="p">&lt;</span><span class="s">count</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="s">unit</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">make</span> <span class="nv">$&lt;unit&gt;</span><span class="o">.</span><span class="s">made</span> <span class="o">=&gt;</span> <span class="nv">$&lt;count&gt;</span><span class="o">.</span><span class="k">made</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token year </span><span class="p">{</span>
        <span class="o">|</span> <span class="p">&lt;</span><span class="s">number(4)</span><span class="p">&gt;</span>        <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;number&gt;</span>       <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">..</span><span class="mi">49</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">2000</span> <span class="o">+</span> <span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">50</span><span class="o">..*</span><span class="p">)&gt;</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">1900</span> <span class="o">+</span> <span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token month </span><span class="p">{</span>
        <span class="o">|</span> <span class="p">&lt;</span><span class="s">number(1..2, 1..12)</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Jan</span><span class="p">[</span><span class="sr">uary</span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Feb</span><span class="p">[</span><span class="sr">ruary</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">2</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Mar</span><span class="p">[</span><span class="sr">ch</span><span class="p">]</span><span class="o">?</span><span class="sr">     </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">3</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Apr</span><span class="p">[</span><span class="sr">il</span><span class="p">]</span><span class="o">?</span><span class="sr">     </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">4</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> May          </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">5</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Jun</span><span class="p">[</span><span class="sr">e</span><span class="p">]</span><span class="o">?</span><span class="sr">      </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">6</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Jul</span><span class="p">[</span><span class="sr">y</span><span class="p">]</span><span class="o">?</span><span class="sr">      </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Aug</span><span class="p">[</span><span class="sr">ust</span><span class="p">]</span><span class="o">?</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">8</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Sep</span><span class="p">[</span><span class="sr">tember</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span>  <span class="mi">9</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Oct</span><span class="p">[</span><span class="sr">ober</span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">{</span> <span class="k">make</span> <span class="mi">10</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Nov</span><span class="p">[</span><span class="sr">ember</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">11</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Dec</span><span class="p">[</span><span class="sr">ember</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">12</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token day </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">number(1..2, 1..31)</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;number&gt;</span> <span class="p">}</span><span class="sr"> }
</span><span class="sr">
</span><span class="sr">    token weekday </span><span class="p">{</span>
        <span class="o">|</span> <span class="p">:</span><span class="s">i</span> <span class="n">Mon</span><span class="o">[</span><span class="nb">day</span><span class="o">]?</span>    <span class="p">{</span> <span class="k">make</span> <span class="mi">1</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Tue</span><span class="p">[</span><span class="sr">sday</span><span class="p">]</span><span class="o">?</span><span class="sr">   </span><span class="p">{</span> <span class="k">make</span> <span class="mi">2</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Wed</span><span class="p">[</span><span class="sr">nesday</span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">3</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Thu</span><span class="p">[</span><span class="sr">rsday</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">4</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Fri</span><span class="p">[</span><span class="sr">day</span><span class="p">]</span><span class="o">?</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="mi">5</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Sat</span><span class="p">[</span><span class="sr">urday</span><span class="p">]</span><span class="o">?</span><span class="sr">  </span><span class="p">{</span> <span class="k">make</span> <span class="mi">6</span> <span class="p">}</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">:</span><span class="na">i</span><span class="sr"> Sun</span><span class="p">[</span><span class="sr">day</span><span class="p">]</span><span class="o">?</span><span class="sr">    </span><span class="p">{</span> <span class="k">make</span> <span class="mi">7</span> <span class="p">}</span><span class="sr">
</span><span class="sr">    }
</span><span class="sr">
</span><span class="sr">    token sep   </span><span class="p">{</span> <span class="p">&lt;</span><span class="s">[-/.\h]</span><span class="p">&gt;</span> <span class="p">}</span><span class="sr"> 
</span><span class="sr">    token count </span><span class="p">{</span> <span class="p">(&lt;</span><span class="s">[0..9]</span><span class="p">&gt;</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span> <span class="k">make</span> <span class="o">+</span><span class="nv">$0</span> <span class="p">}</span><span class="sr">  </span><span class="o">|</span><span class="sr">  an</span><span class="o">?</span><span class="sr"> </span><span class="p">{</span> <span class="k">make</span> <span class="mi">1</span> <span class="p">}</span><span class="sr"> }
</span><span class="sr">    token unit  </span><span class="p">{</span> <span class="p">:</span><span class="s">i</span> <span class="p">(</span><span class="nb">day</span><span class="o">|</span><span class="nb">week</span><span class="o">|</span><span class="nb">month</span><span class="o">|</span><span class="nb">year</span><span class="p">)</span> <span class="k">s</span><span class="err">?</span> <span class="p">{</span><span class="sr"> make </span><span class="nv">$0</span><span class="ni">.</span><span class="sr">lc </span><span class="p">}</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="p">)</span>        <span class="p">{</span><span class="sr">  </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">}</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="o">,</span> <span class="nv">$test</span><span class="p">)</span> <span class="p">{</span><span class="sr"> </span><span class="p">(&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">})</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="p">}&gt;</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nb">lines</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="n">MessyDate</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">.</span><span class="k">made</span> <span class="o">//</span> <span class="p">&#34;</span><span class="s2">failed to parse &#39;</span><span class="nv">$_&#39;</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>[...]</code> 是非捕获分组</li>
<li><code>&lt;[...]&gt;</code> 是 Raku 中的字符类</li>
<li><code>&lt;number(4)&gt;</code> 是扩展的 <code>&lt;...&gt;</code> 语法, 实际上是方法调用</li>
</ul>
<p>在 grammar 中, 有两个 regex 的变体, <code>rule</code> 和 <code>token</code>。rule 默认不会回溯。<code>rule</code> 与 <code>token</code> 的一个重要区别是, <code>rule</code> 这样的正则采取了 <code>:sigspace</code> 修饰符。 <code>rule</code> 实际上是</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">regex</span> <span class="p">:</span><span class="s">ratchet</span> <span class="p">:</span><span class="s">sigspace</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>的简写。<code>ratchet </code>这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的! 而 <code>:sigspace</code> 表明正则中的空白是有意义的, 而 <code>token</code> 实际上是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">regex</span> <span class="p">:</span><span class="s">ratchet</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>的简写。 所以在 token 中, 若不是显式的写上 <code>\s</code>、<code>\h</code>、<code>\n</code> 等空白符号, 其它情况下就好像空白隐身了一样, 虽然你写了, 但是编译器却视而不见。</p>
<p><code>//</code> 在左侧匹配失败时会在右侧提供一个默认值。</p>
<p><code>&lt;number(4)&gt;</code>  和 <code>&lt;number(2, 0..49)&gt;</code> 中使用了扩展了的 <code>&lt;...&gt;</code> 元语法。 标识符(例如左面的 number)后面的第一个字符决定了闭合尖括号之前剩余文本的处理。它的底层语义是函数或方法调用, 所以, 如果标识符后面的第一个字符是左圆括号, 那么它要么是方法调用, 要么是函数调用:</p>
<p><code>&lt;number(4)&gt;</code> 等价于 <code>&lt;number=&amp;number(4)&gt;</code></p>
<p><code>&lt;number(2, 0..49)&gt;</code> 等价于 <code>&lt;number=&amp;number(2, 0..49)&gt;</code></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="p">)</span>        <span class="p">{</span><span class="sr">  </span><span class="p">&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">}</span><span class="sr"> </span><span class="p">}</span>
<span class="k">multi</span> <span class="k">token</span> <span class="nf">number</span> <span class="p">(</span><span class="nv">$digits</span><span class="o">,</span> <span class="nv">$test</span><span class="p">)</span> <span class="p">{</span><span class="sr"> </span><span class="p">(&lt;[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]&gt;</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="p">{</span><span class="nv">$digits</span><span class="p">})</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">?</span><span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="p">}&gt;</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>在扩展的 <code>&lt;...&gt;</code> 语法中, 一个前置的 <code>?{</code> 或 <code>!{</code> 标示着代码断言:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&lt;</span><span class="s">[0..9]</span><span class="p">&gt;</span> <span class="o">**</span> <span class="p">{</span><span class="nv">$digits</span><span class="p">})</span> <span class="o">&lt;?</span><span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="p">}</span><span class="o">&gt;</span>
</code></pre></div><p>等价于：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># + 强制后面的$0为数值上下文, 以匹配 $test 中的数字</span>
<span class="p">(&lt;</span><span class="s">[0..9]</span><span class="p">&gt;</span> <span class="o">**</span> <span class="p">{</span><span class="nv">$digits</span><span class="p">})</span> <span class="p">{</span> <span class="o">+</span><span class="nv">$0</span> <span class="o">~~</span> <span class="nv">$test</span> <span class="ow">or</span> <span class="nb">fail</span> <span class="p">}</span>
</code></pre></div><p>上面的两句代码, 具名 <code>regex</code>, <code>token</code>, 或 <code>rule</code> 是一个子例程, 所以可以传递参数给具名 token。</p>
<p>这从标准输入里读取散乱的日期并把对应的 ISO 日期写到标准输出。</p>
<p>它能解析任务描述中的所有日期（包含扩展）, 还有 - 然而, 在它们中我得到 4 个不同的结果。请弄清它们是否是错误的, 并且为什么是错的:</p>
<p>2010-dec-7 &ndash;&gt; 我得到  2010-12-07 而不是 2010-12-01</p>
<p>last week &ndash;&gt; 我得到 2014-12-17 而不是 2014-12-15</p>
<p>1 month from 2016-01-31 &ndash;&gt; 我得到  2016-02-29 而不是 2016-02-28</p>
<p>9 weeks from yesterday &ndash;&gt; 我得到  2015-02-24 而不是 2015-02-25</p>
<p>有人在评论中问他 <code>make/made</code> 是类中的方法吗？</p>
<p>是的, 它们是 Match 类的方法。</p>
<h3 id="match-objects注意-object-是复数">Match objects(注意 object 是复数)</h3>
<p>每个 regex match(并且通过扩展, 每个 grammar token match)的结果被表示为一个 Match 对象。</p>
<p>通过这个对象你能访问各种信息片段:</p>
<ul>
<li>匹配到的字符串</li>
<li>关于输入字符串匹配的开始和结束位置</li>
<li>每个位置捕获和具名捕获的sub-matches</li>
<li>与这个匹配有关的 AST 片段, 如果有的话</li>
</ul>
<h3 id="ast-片段">AST 片段</h3>
<p>在 <code>token/rule</code> 里面调用 <code>make</code>, 设置将会与当前匹配关联的 &ldquo;AST 片段&rdquo;。然后, 你可以通过在当前结果 Match 对象身上调用 <code>.made</code> 方法来获取那个关联数据。</p>
<p>这正是自由形式的插槽, 允许你使用 Match 对象存储任何你想要的东西并在以后检索它, 尽管显而易见这意味着像我那样创建一个 AST。</p>
<h3 id="在-grammar-中创建-ast">在 grammar 中创建 &ldquo;AST&rdquo;</h3>
<p>在我的 grammar 中每个 <code>token/rule</code> 使用 <code>.made</code> 来取得它的 sub-rule 匹配构建的数据片段, 把它们组合成一个更大的数据片段, 这是为了让它的 parent rule 能检索。等等。</p>
<p>我在每个 token/rule 里面使用这些语法简写来引用 sub-matches 的 Match 对象:</p>
<ul>
<li><code>$0</code> 引用 sub-match（由一个 <code>()</code> 捕获组导致） 的第一个位置处的 Match 对象。</li>
<li><code>$&lt;date&gt;</code> 引用一个名字为 <code>date</code> 的具名 sub-match 的 Match 对象(通过 <code>&lt;date&gt;</code> 递归引用名为 date 的 <code>token</code> 导致).</li>
</ul>
<p><a href="https://www.reddit.com/r/dailyprogrammer/comments/3wshp7/20151214_challenge_245_easy_date_dilemma/">https://www.reddit.com/r/dailyprogrammer/comments/3wshp7/20151214_challenge_245_easy_date_dilemma/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[使用 Raku 的 subsets 和 multi 辨别年龄]]></title>
            <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="在 Raku 中怎么为已存在的类添加方法" />
            
                <id>https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>An Example of Raku Subset and Multi</blockquote><p>举个例子, 假设 person 有一个 age 属性. 我能写一个 <code>multimethod</code>, 让它接收一个 person 作为参数, 并返回这样的结果吗:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">return</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span>  <span class="k">if</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">return</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span>  <span class="k">if</span> <span class="mi">16</span> <span class="o">&lt;=</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="mi">66</span><span class="p">;</span>
<span class="k">return</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="k">if</span> <span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-r" data-lang="r"><span class="n">class</span> <span class="n">Person</span> <span class="p">{</span>
    <span class="n">has</span> <span class="n">Int</span> <span class="o">$</span><span class="n">.age</span><span class="p">;</span>
    <span class="n">has</span> <span class="n">Str</span> <span class="o">$</span><span class="n">.name</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这仅仅定义了一个拥有两个属性, 叫做 Person 的类. age 必须是 Int 型, name 必须是 Str 型. <code>.</code> 语法会生成一个只读访问器, 以使我们能从类的外部访问 getter 方法.</p>
<p>现在我们来定义一个 <code>age-group</code> multi 来告诉一个 person 属于哪个 age-group:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>  <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="nv">$person</span><span class="p">)</span>                      <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><p><code>where</code>从句给参数添加了一个<code>约束</code>, 这个约束告诉参数必须匹配这个参数右边的东西.这用于区别将要选取的 multi. <code>where</code>从句可以是一个 regex, 类型, 一个确切的值, 一个断言 block,或者一些其它东西.</p>
<p><code>*.age &lt; 16</code> 部分可能看起来更让人迷惑. 星号是什么? 星号是一个特殊的值, 叫做 Whatever. 它通常在给定情况下满足你的需求. 在智能匹配中, 它总是匹配, 所以你可以在 <code>given/when</code> block 中将它用作默认值. 但是 Whatever 最有用的地方之一是创建匿名 block. 对于大部分操作符, 如果你在 Whatever 上执行它们, 它会产生一个匿名 block 并使用它们的参数执行操作符. 如果一个表达式中有多个 Whatever, 则生成的匿名 block 会有多个参数对应于相应的 Whatever 位置.</p>
<p>例如, <code>* + 1</code> 产生一个 block,使参数的值加1. <code>* + *</code> 产生一个 block 使它的两个参数相加. 这个例子中, 我们调用 Whatever 的 <code>age</code>方法, 并询问它是否小于 16. 我们能用其它几种方式达到同样的效果, 但是更啰嗦:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">-&gt;</span> <span class="nv">$person</span>    <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span> <span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="p">}</span>
</code></pre></div><p>但是对于像这种简单的操作, Whatever 通常比其它方式更易读也更简洁. 不幸的是, 在参数列表的 where 从句中, 你需要使用括号括起很多复杂的表达式, 包括 Whatever block.</p>
<p>现在让我们在 Rakudo 的 REPL 中试试它吧:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">timmy</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">age</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="nb">child</span>
<span class="o">&gt;</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">john</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">age</span><span class="p">(</span><span class="mi">23</span><span class="p">))</span>
<span class="n">adult</span>
<span class="o">&gt;</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">name</span><span class="p">&lt;</span><span class="s">ezekiel</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:</span><span class="s">age</span><span class="p">(</span><span class="mi">89</span><span class="p">))</span>
<span class="n">senior</span>
</code></pre></div><p>目前为止, 很好. 但是如果我们意外地传递了一个 age 而不是 Person 给 age-group 呢?</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="n">age-group</span> <span class="mi">15</span>
<span class="nb">Method</span> <span class="p">&#39;</span><span class="s1">age</span><span class="p">&#39;</span> <span class="nb">not</span> <span class="n">found</span> <span class="k">for</span> <span class="nb">invocant</span> <span class="k">of</span> <span class="k">class</span> <span class="nc">&#39;Int&#39;</span>
</code></pre></div><p>我们能指定只有 Person 对于 age-group 是合法的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="o">*.</span><span class="nf">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span> <span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><p>这正确地处理了 Person 问题. 调用带有 age 参数的 age-group 会怎样呢?</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="n">age-group</span> <span class="mi">15</span>
<span class="n">No</span> <span class="n">applicable</span> <span class="nb">candidates</span> <span class="n">found</span> <span class="nb">to</span> <span class="n">dispatch</span> <span class="nb">to</span> <span class="k">for</span> <span class="p">&#39;</span><span class="s1">age-group</span><span class="p">&#39;</span><span class="o">.</span> <span class="n">Available</span> <span class="nb">candidates</span> <span class="n">are:</span>
<span class="o">:</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">({</span> <span class="o">...</span> <span class="p">}))</span>
<span class="o">:</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">({</span> <span class="o">...</span> <span class="p">}))</span>
<span class="o">:</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span><span class="p">)</span>
</code></pre></div><p>看起来更好. 假如我们允许询问 age 所属的 age-group 呢?</p>
<p>我们能重写 age-group 的 Person 变体, 接收 Int 类型的 age, 并写一个单个的 Person 变体来调用 age-group:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span> <span class="k">where</span> <span class="p">(</span><span class="o">*</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>  <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span> <span class="k">where</span> <span class="p">(</span><span class="o">*</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span><span class="p">)</span>                  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="n">age-group</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="p">}</span>
</code></pre></div><p>这对于每个 Person 例子都有效, 还有它们的 ages.</p>
<p>现在,让我们使用 <code>age-group</code> 定义一个叫做 <code>print-name</code> 的 <code>multi</code> 来分发.
根据 <code>age-group</code> 分发最明显的方法是使用 where 从句.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="nf">age-group</span><span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;))</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Little </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="nf">age-group</span><span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;))</span> <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nb">name</span>            <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Person</span> <span class="nv">$person</span> <span class="k">where</span> <span class="p">(</span><span class="nf">age-group</span><span class="p">(</span><span class="nv">$person</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;)){</span> <span class="p">&#34;</span><span class="s2">Old Man </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;}</span>
</code></pre></div><p>双引号字符串中的 <code>{$person.name}</code> 将 block 的结果插值到字符串中.</p>
<p>让我们再试试:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; print-name Person.new<span class="o">(</span>:name&lt;timmy&gt;, :age<span class="o">(</span>10<span class="o">))</span>
Little Timmy
&gt; print-name Person.new<span class="o">(</span>:name&lt;john&gt;, :age<span class="o">(</span>23<span class="o">))</span>
John
&gt; print-name Person.new<span class="o">(</span>:name&lt;ezekiel&gt;, :age<span class="o">(</span>89<span class="o">))</span>
Old Man Ezekiel
</code></pre></div><p>那很棒. 但是如果我们有更多的基于 person 的 <code>age-group</code> 的 multis 要分发呢? 难道我们真的每次都要写出 <code>(Person $person where (age-group($person) eq &quot;child&quot;))</code> 这样的代码吗? 不, 我们不需要, 感谢 subset 类型.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">subset</span> <span class="nc">Child</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">Adult</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="k">-&gt;</span> <span class="nv">$person</span> <span class="p">{</span> <span class="mi">16</span> <span class="o">&lt;=</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">66</span> <span class="p">};</span>
<span class="k">subset</span> <span class="nc">Senior</span> <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="o">*.</span><span class="nf">age</span> <span class="o">&gt;=</span> <span class="mi">66</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Child</span> <span class="nv">$person</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Little </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Adult</span> <span class="nv">$person</span><span class="p">)</span>  <span class="p">{</span> <span class="nv">$person</span><span class="o">.</span><span class="nb">name</span>             <span class="p">}</span>
<span class="k">multi</span> <span class="nf">print-name</span><span class="p">(</span><span class="n">Senior</span> <span class="nv">$person</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Old Man </span><span class="p">{</span><span class="nv">$person</span><span class="o">.</span><span class="nb">name</span><span class="p">}&#34;</span> <span class="p">}</span>
</code></pre></div><p>由于 Rakudo 在处理含有组合的链式比较操作符的 Whatever 时有一个 bug, 我们不得不为 Adult 写一个显式的 block.</p>
<p>这个 bug 现已修复, 所以:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">subset</span> <span class="nc">Adult</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span> <span class="k">-&gt;</span> <span class="nv">$person</span> <span class="p">{</span> <span class="mi">16</span> <span class="o">&lt;=</span> <span class="nv">$person</span><span class="o">.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">66</span> <span class="p">};</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">subset</span> <span class="nc">Adult</span>  <span class="k">of</span> <span class="nc">Person</span> <span class="k">where</span>  <span class="mi">16</span> <span class="o">&lt;=</span> <span class="o">*.</span><span class="nf">age</span> <span class="o">&lt;</span> <span class="mi">66</span><span class="p">;</span>
</code></pre></div><p>这个新版本的 <code>print-name</code> 与之前旧版本产生同样的结果. 现在我们能从 <code>Child/Adult/Senior</code> 的角度重写 <code>age-group</code> :</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Child</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">child</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Adult</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#34;</span><span class="s2">adult</span><span class="p">&#34;</span>  <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="n">Senior</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">senior</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">age-group</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$age</span><span class="p">)</span> <span class="p">{</span> <span class="n">age-group</span> <span class="n">Person</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">:</span><span class="nv">$age</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p><code>:$age</code> 是 <code>:age($age)</code> 的简写方式.</p>
<p>又一次, 我们有了产生想要的结果的更清晰的代码, 多亏了 multiple 分发和 subset 类型.</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[在 Raku 中为自定义的类添加下标]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-08-18-add-subscripts-for-custom-class-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-05-18-subscripts-adverbs/?utm_source=atom_feed" rel="related" type="text/html" title="下标副词" />
            
                <id>https://ohmyweekly.github.io/notes/2015-08-18-add-subscripts-for-custom-class-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Add Subscripts for Custom Class in Raku</blockquote><h3 id="为自定义的类添加下标subscripts">为自定义的类添加下标(subscripts)</h3>
<p>假如你定义了一个类, 你想把类的实例用作散列那样, 可以索引其中的元素, 那么你需要让你得自定义遵守 Associative 接口, 并重写 <code>AT-KEY</code>、<code>EXISTS-KEY</code>、<code>DELETE-KEY</code>、<code>push</code> 等跟散列有关的方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">HTTPHeader</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">HTTPHeader</span> <span class="k">does</span> <span class="nb">Associative</span>  <span class="p">{</span>

    <span class="k">has</span> <span class="nv">%!fields</span> <span class="nb">handles</span> <span class="p">&lt;</span><span class="s">self.AT-KEY self.EXISTS-KEY self.DELETE-KEY self.push list kv keys values</span><span class="p">&gt;;</span>
    <span class="k">method</span> <span class="nb">Str</span> <span class="p">{</span> <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nb">hash</span><span class="o">.</span><span class="nb">fmt</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">exists</span> <span class="p">}</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">delete</span> <span class="p">}</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nb">push</span> <span class="p">(</span><span class="o">*</span><span class="nv">@_</span><span class="p">)</span>              <span class="p">{</span> <span class="nv">%!fields</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">@_</span>                   <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">normalize-key</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$key</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/</span><span class="o">,</span> <span class="o">*.</span><span class="nb">tc</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># titileCase 驼峰式的键</span>

    <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$element</span> <span class="o">:=</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">};</span>

        <span class="nb">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
            <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">()</span> <span class="p">{</span> <span class="nv">$element</span> <span class="p">}</span>,

            <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$element</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">given</span> <span class="nv">$value</span><span class="o">».</span><span class="nb">split</span><span class="p">(/&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span>
                    <span class="k">when</span> <span class="mi">1</span>  <span class="p">{</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>    <span class="c1"># a single value is stored as a string</span>
                    <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Array</span> <span class="p">}</span>  <span class="c1"># multiple values are stored as an array</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">my</span> <span class="nv">$header</span> <span class="o">=</span> <span class="n">HTTPHeader</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$header</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>  <span class="c1">#-&gt; (HTTPHeader)</span>
<span class="p">&#34;&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

<span class="nv">$header</span><span class="p">&lt;</span><span class="s">Accept</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">text/plain</span><span class="p">&#34;;</span>
<span class="nv">$header</span><span class="p">{&#39;</span><span class="s1">Accept-</span><span class="p">&#39;</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">Charset Encoding Language</span><span class="p">&gt;}</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">utf-8 gzip en</span><span class="p">&gt;;</span>
<span class="nv">$header</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">Accept-Language</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">fr</span><span class="p">&#34;);</span>  <span class="c1"># like .push on a Hash</span>

<span class="nb">say</span> <span class="nv">$header</span><span class="o">.</span><span class="nb">hash</span><span class="o">.</span><span class="nb">fmt</span><span class="p">;</span>
<span class="p">&#34;&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
<span class="c1"># say $header.Str; # 同上</span>

<span class="nb">say</span> <span class="nv">$header</span><span class="p">&lt;</span><span class="s">Accept-Language</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$header</span><span class="p">&lt;</span><span class="s">Accept-Charset</span><span class="p">&gt;;</span>
</code></pre></div><p>输出：</p>
<pre><code>(HTTPHeader)

Accept	text/plain
Accept-Charset	utf-8
Accept-Encoding	gzip
Accept-Language	en fr

(en fr)
utf-8
</code></pre><p>同样, 你也可以使用数组下标, 只要你重写相应地方法。</p>
<p>关于为自定义的类添加下标这个问题,  stackoverflow 上的回答是不需要在 handles 后面所跟的方法中添加 <code>self</code>。 他的解释如下:</p>
<h2 id="为自定义的类添加下标subscriptshttpstackoverflowcomquestions36773986how-to-add-subscripts-to-my-custom-class-in-perl-6"><a href="http://stackoverflow.com/questions/36773986/how-to-add-subscripts-to-my-custom-class-in-perl-6">为自定义的类添加下标(subscripts)</a></h2>
<p>在自定义类上实现关联式下标(associative subscripting)。</p>
<h3 id="通过代理实现">通过代理实现</h3>
<p>Raku 通过在实现了集合类型的对象身上调用良定义的方法来实现关联式下标和位置下标（对于内置类型）。通过在 <code>%!fields</code> 属性后面添加 <code>handles</code> 特性(trait),  你就把这些方法调用传递给了 <code>%!fields</code> - 它作为一个散列, 会知道怎么来处理那些方法。</p>
<h3 id="灵活的键">灵活的键</h3>
<blockquote>
<p>However, HTTP header field names are supposed to be case-insensitive (and preferred in camel-case). We can accommodate this by taking the *-KEY and push methods out of the handles list, and implementing them separately&hellip;</p>
</blockquote>
<p>把所有的键处理方法代理给内部的散列意味着你的键得到了散列那样的插值 - 意味着它们将是大小写无关的因为散列的键是大小写无关的。为了避免那, 你把所有跟键有关的方法从 <em>handles</em> 子句中拿出并自己实现那些方法。在例子中, 键在被索引到 <code>%!fields</code> 让键变成大小写无关之前先进行了键的「标准化」。</p>
<h3 id="灵活的值">灵活的值</h3>
<p>例子中的最后一部分展示了当值存入到散列那样的容器中时你如何控制值的插值。到目前为止, 通过赋值给这个自定义容器的实例提供的值要么是一个字符串, 要么是一个字符串的数组。额外的控制是通过移除定义在灵活的键中的  <strong>AT-KEY</strong> 方法来达成的并提供一个 <strong><a href="https://doc.raku.org/type/Proxy">Proxy</a></strong> 对象来代替它。如果你给容器赋值, 那么代理人对象的 <strong>STORE</strong> 方法会被调用并且那个方法会扫描所提供的字符串值中的 <code>&quot;, &quot;</code>（注意空格是必要的）。如果找到会接收那个字符串值作为几个字符串值的说明书。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">HTTPHeader</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">HTTPHeader</span> <span class="k">does</span> <span class="nb">Associative</span>  <span class="p">{</span>

    <span class="k">has</span> <span class="nv">%!fields</span>  <span class="nb">handles</span> <span class="p">&lt;</span><span class="s">list kv keys values</span><span class="p">&gt;;</span>
    <span class="k">method</span> <span class="nb">Str</span> <span class="p">{</span> <span class="nb">say</span> <span class="nb">self</span><span class="o">.</span><span class="nb">hash</span><span class="o">.</span><span class="nb">fmt</span><span class="p">;</span> <span class="p">}</span>


    <span class="k">multi</span> <span class="k">method</span> <span class="nb">EXISTS-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">exists</span> <span class="p">}</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nb">DELETE-KEY</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span>       <span class="p">{</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">}:</span><span class="s">delete</span> <span class="p">}</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nb">push</span> <span class="p">(</span><span class="o">*</span><span class="nv">@_</span><span class="p">)</span>              <span class="p">{</span> <span class="nv">%!fields</span><span class="o">.</span><span class="nb">push</span><span class="o">:</span> <span class="nv">@_</span>                   <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">normalize-key</span> <span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$key</span><span class="o">.</span><span class="nb">subst</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/</span><span class="o">,</span> <span class="o">*.</span><span class="nb">tc</span><span class="o">,</span> <span class="p">:</span><span class="s">g</span><span class="p">)</span> <span class="p">}</span>

    <span class="k">method</span> <span class="nb">AT-KEY</span> <span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="nv">$key</span><span class="p">)</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$element</span> <span class="o">:=</span> <span class="nv">%!fields</span><span class="p">{</span><span class="n">normalize-key</span> <span class="nv">$key</span><span class="p">};</span>

        <span class="nb">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
            <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">()</span> <span class="p">{</span> <span class="nv">$element</span> <span class="p">}</span>,

            <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">method</span> <span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$element</span> <span class="o">=</span> <span class="nb">do</span> <span class="k">given</span> <span class="nv">$value</span><span class="o">».</span><span class="nb">split</span><span class="p">(/&#39;</span><span class="s1">,</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">flat</span> <span class="p">{</span>
                    <span class="k">when</span> <span class="mi">1</span>  <span class="p">{</span> <span class="o">.[</span><span class="mi">0</span><span class="o">]</span> <span class="p">}</span>    <span class="c1"># a single value is stored as a string</span>
                    <span class="k">default</span> <span class="p">{</span> <span class="o">.</span><span class="nb">Array</span> <span class="p">}</span>  <span class="c1"># multiple values are stored as an array</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="k">my</span> <span class="nv">$header</span> <span class="o">=</span> <span class="n">HTTPHeader</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$header</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>  <span class="c1">#-&gt; (HTTPHeader)</span>
<span class="p">&#34;&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

<span class="nv">$header</span><span class="p">&lt;</span><span class="s">Accept</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">text/plain</span><span class="p">&#34;;</span>
<span class="nv">$header</span><span class="p">{&#39;</span><span class="s1">Accept-</span><span class="p">&#39;</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">Charset Encoding Language</span><span class="p">&gt;}</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">utf-8 gzip en</span><span class="p">&gt;;</span>
<span class="nv">$header</span><span class="o">.</span><span class="nb">push</span><span class="p">(&#39;</span><span class="s1">Accept-Language</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">fr</span><span class="p">&#34;);</span>  <span class="c1"># like .push on a Hash</span>

<span class="nb">say</span> <span class="nv">$header</span><span class="o">.</span><span class="nb">hash</span><span class="o">.</span><span class="nb">fmt</span><span class="p">;</span>
<span class="p">&#34;&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
<span class="c1"># say $header.Str; # 同上</span>

<span class="nb">say</span> <span class="nv">$header</span><span class="p">&lt;</span><span class="s">Accept-Language</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$header</span><span class="p">&lt;</span><span class="s">Accept-Charset</span><span class="p">&gt;;</span>
</code></pre></div><p>输出：</p>
<pre><code>(HTTPHeader)

Accept	text/plain
Accept-Charset	utf-8
Accept-Encoding	gzip
Accept-Language	en fr

(en fr)
utf-8
</code></pre><p>同样, 你也可以使用数组下标, 只要你重写相应地方法。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/subscript" term="subscript" label="subscript" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[在 Raku 中怎么为已存在的类添加方法]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-11-20-guess-who/?utm_source=atom_feed" rel="related" type="text/html" title="Guess Who" />
                <link href="https://ohmyweekly.github.io/notes/2015-06-10-list-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="List in Raku" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-28-the-s-operator-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 S/// 操作符" />
                <link href="https://ohmyweekly.github.io/notes/2015-12-11-twigils-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的 twigil" />
                <link href="https://ohmyweekly.github.io/notes/2016-01-04-an-example-of-raku-subset-and-multi/?utm_source=atom_feed" rel="related" type="text/html" title="使用 Raku 的 subsets 和 multi 辨别年龄" />
            
                <id>https://ohmyweekly.github.io/notes/2015-11-11-add-a-method-to-an-existing-class-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Add a Method to an Existing Class in Raku</blockquote><h2 id="raku-中怎么为已存在的类添加方法">Raku 中怎么为已存在的类添加方法</h2>
<p>Int 类有一个方法叫做 <code>is-prime</code>, 我想为 <code>Int</code> 类型添加其它的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">MyInt</span> <span class="k">is</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">is-even</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">False</span> <span class="k">if</span> <span class="nb">self</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">True</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="n">MyInt</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="mi">138</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$n</span><span class="o">.</span><span class="nf">is-even</span><span class="p">;</span>
</code></pre></div><p>通过类的继承也是一种方法, 但是不是我想要的。Swift 中可以通过扩展来实现, Raku 中有一个 <code>add_method</code> 方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">add_method</span><span class="p">(</span><span class="n">Metamodel::MethodContainer:</span> <span class="nv">$obj</span><span class="o">,</span> <span class="nv">$name</span><span class="o">,</span> <span class="nv">$code</span><span class="p">)</span>
</code></pre></div><p>这会给元类(meta class)添加一个方法, 使用 <code>$name</code> 作为调用的方法名。这只会在类型被组合前使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">is-even</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">False</span> <span class="k">if</span> <span class="nb">self</span> <span class="nv">%</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">True</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>

<span class="nb">say</span> <span class="mi">137</span><span class="o">.</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="nb">Int</span><span class="o">.^</span><span class="nb">methods</span><span class="p">;</span>
</code></pre></div><p>如果我调用 <code>Int.^methods</code> 时, <code>is-even</code> 没有出现。但是上面的代码能被调用并起作用了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">fac</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">()</span> <span class="k">returns</span> <span class="nb">Int:D</span> <span class="p">{</span>
     <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
     <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="nb">self</span>  <span class="p">{</span><span class="nv">$sum</span> <span class="o">*=</span> <span class="nv">$_</span><span class="p">};</span> <span class="k">return</span> <span class="nv">$sum</span><span class="p">;</span>
<span class="p">});</span>

<span class="mi">1</span><span class="o">.</span><span class="nf">fac</span> <span class="c1"># 1</span>
<span class="mi">5</span><span class="o">.</span><span class="nf">fac</span> <span class="c1"># 120</span>
</code></pre></div><p><code>method</code> 后面的圆括号是方法的签名：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">Int</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">power</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">method</span> <span class="p">(</span><span class="nb">Int</span> <span class="nv">$num</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nb">self</span> <span class="o">**</span> <span class="nv">$num</span><span class="p">;</span>
<span class="p">});</span>

<span class="mi">2</span><span class="o">.</span><span class="nf">power</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># 8</span>
<span class="mi">2</span><span class="o">.</span><span class="nf">power</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># 1024</span>
</code></pre></div><h2 id="词法方法">词法方法</h2>
<p>我可以让方法不依附于任何类, 并且能在对象上调用该方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">&amp;is-even</span> <span class="o">=</span> <span class="k">method</span> <span class="p">(</span><span class="nb">Int:D</span> <span class="o">:</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">};</span>
</code></pre></div><p>这构建了一个 <code>Callable</code>（查看以下 <code>&amp;is-even.WHAT</code>）。 在签名中, 我把它约束为一个定义了的 Int 类型的值(<code>Int:D</code>), 但是没有给它名字。我在类型约束后面添加冒号来说明第一个参数是调用者。现在我能把这个方法应用到任何我想要的对象上:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">137</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="mi">138</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span><span class="o">.&amp;</span><span class="nf">is-even</span><span class="p">;</span>  <span class="c1"># works, although inside is-even blow up</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[在 Raku 中执行有超时的外部程序]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-05-14-execute-an-external-program-with-timeout-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-05-14-execute-an-external-program-with-timeout-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Execute an External Program With Timeout in Raku</blockquote><p>Proc::Async 允许我们异步地执行外部程序。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$proc</span> <span class="o">=</span> <span class="nb">Proc::Async</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">curl</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">-s</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">-o</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">index.html</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">http://www.cpan.org</span><span class="p">&#34;);</span>
<span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nb">await</span> <span class="nv">$proc</span><span class="o">.</span><span class="k">start</span><span class="p">;</span>
</code></pre></div><p>我们可以在 Proc::Async 中使用超时吗? Proc::Async 没有正式支持该功能，但是我们可以很容易地实现它。看一下这个：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Proc::Async::Timeout</span> <span class="k">is</span> <span class="nb">Proc::Async</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.timeout</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
    <span class="k">method</span> <span class="k">start</span><span class="p">(</span><span class="nv">$self:</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">callsame</span> <span class="k">unless</span> <span class="nv">$.timeout</span><span class="p">;</span>

        <span class="k">my</span> <span class="nv">$killer</span> <span class="o">=</span> <span class="nb">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="nv">$.timeout</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$self</span><span class="o">.</span><span class="nb">kill</span> <span class="p">};</span>
        <span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="nb">callsame</span><span class="p">;</span>

        <span class="nb">Promise</span><span class="o">.</span><span class="nb">anyof</span><span class="p">(</span><span class="nv">$promise</span><span class="o">,</span> <span class="nv">$killer</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$promise</span><span class="o">.</span><span class="nb">result</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$proc</span> <span class="o">=</span> <span class="n">Proc::Async::Timeout</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">perl</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">-E</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">sleep 5; warn &#39;end&#39;</span><span class="p">&#34;);</span>
<span class="nv">$proc</span><span class="o">.</span><span class="nf">timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nb">await</span> <span class="nv">$proc</span><span class="o">.</span><span class="k">start</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">maybe timeout</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$res</span><span class="o">.</span><span class="nb">signal</span><span class="p">;</span>
</code></pre></div><p>你甚至可以这样做：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$start</span> <span class="o">=</span> <span class="nb">Proc::Async</span><span class="o">.^</span><span class="nb">methods</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="o">*.</span><span class="nb">name</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">start</span><span class="p">&#34;);</span>

<span class="nv">$start</span><span class="o">.</span><span class="nb">wrap</span><span class="o">:</span> <span class="k">method</span> <span class="p">(</span><span class="nv">$self:</span> <span class="o">:</span><span class="nv">$timeout</span><span class="o">,</span> <span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">callwith</span><span class="p">(</span><span class="nv">$self</span><span class="o">,</span> <span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="k">unless</span> <span class="nv">$timeout</span><span class="p">;</span>

    <span class="k">my</span> <span class="nv">$killer</span> <span class="o">=</span> <span class="nb">Promise</span><span class="o">.</span><span class="nb">in</span><span class="p">(</span><span class="nv">$timeout</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$self</span><span class="o">.</span><span class="nb">kill</span> <span class="p">};</span>
    <span class="k">my</span> <span class="nv">$promise</span> <span class="o">=</span> <span class="nb">callwith</span><span class="p">(</span><span class="nv">$self</span><span class="o">,</span> <span class="o">|</span><span class="n">c</span><span class="p">);</span>
    
    <span class="nb">Promise</span><span class="o">.</span><span class="nb">anyof</span><span class="p">(</span><span class="nv">$promise</span><span class="o">,</span> <span class="nv">$killer</span><span class="p">)</span><span class="o">.</span><span class="nb">then</span><span class="o">:</span> <span class="p">{</span> <span class="nv">$promise</span><span class="o">.</span><span class="nb">result</span> <span class="p">};</span>
<span class="p">};</span>

<span class="nb">say</span> <span class="nb">await</span> <span class="nb">Proc::Async</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">perl</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">-E</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">sleep 3; say &#34;end&#34;</span><span class="p">&#39;)</span><span class="o">.</span><span class="k">start</span><span class="p">(</span><span class="s">timeout</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div><p>哇，哇！如果你发现了更酷的方法，请告诉我。</p>
<p><a href="http://ks0608.hatenablog.com/entry/2016/05/17/001826">http://ks0608.hatenablog.com/entry/2016/05/17/001826</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/proc" term="proc" label="proc" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[在 Raku 中自定义存取器]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-05-19-how-to-write-custom-accessor-methods-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-05-19-how-to-write-custom-accessor-methods-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>How to Write Custom Accessor Methods in Raku</blockquote><h2 id="how-does-one-write-custom-accessor-methods-in-raku">How does one write custom accessor methods in Raku?</h2>
<p>我有一个类:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Wizard</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.mana</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>我可以这样做:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="n">Wizard</span> <span class="nv">$gandalf</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
<span class="nv">$gandalf</span><span class="o">.</span><span class="nf">mana</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
</code></pre></div><p>我想在不放弃使用 <code>$gandalf.mana = 150;</code> 的情况下, 在 <code>setter</code> 里面做一些检查。换句话说, 我不想这样写: <code>$gandalf.setMana(150)</code>。 如果程序尝试设置一个负值的话, 就退出。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Wizard</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$!mana</span><span class="p">;</span>

    <span class="k">method</span> <span class="nf">mana</span><span class="p">()</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span>
            <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$!mana</span> <span class="p">}</span>,
            <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$</span>, <span class="nv">$mana</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">It&#39;s over 9000!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="p">(</span><span class="nv">$mana</span> <span class="o">//</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">9000</span><span class="p">;</span>
                <span class="nv">$!mana</span> <span class="o">=</span> <span class="nv">$mana</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="n">Wizard</span> <span class="nv">$gandalf</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$gandalf</span><span class="o">.</span><span class="nf">mana</span><span class="p">;</span>
<span class="nv">$gandalf</span><span class="o">.</span><span class="nf">mana</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$gandalf</span><span class="o">.</span><span class="nf">mana</span><span class="p">;</span>
</code></pre></div><p><code>Pxoxy</code> 是一种拦截对存储进行读写调用, 并做一些非默认行为的方式。在解析像 <code>$gandalf.mana = $gandalf.mana + 5</code> 这种表达式的时候, Raku 会自动调用 <code>FETCH</code> 和 <code>STORE</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Baby</span> <span class="p">{</span>
    <span class="c1"># use . instead of ! for better `.raku` representation  </span>
    <span class="k">has</span> <span class="nb">Int</span> <span class="nv">$.mana</span><span class="p">;</span> 

    <span class="c1"># overwrite the method the attribute declaration added</span>
    <span class="k">method</span> <span class="nf">mana</span> <span class="p">()</span> <span class="k">is</span> <span class="k">rw</span> <span class="p">{</span>
        <span class="nb">Proxy</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
            <span class="s">FETCH</span> <span class="o">=&gt;</span> <span class="k">-&gt;</span> <span class="nv">$</span> <span class="p">{</span> <span class="nv">$!mana</span> <span class="p">}</span>,
            <span class="s">STORE</span> <span class="o">=&gt;</span> <span class="k">-&gt;</span> <span class="nv">$</span>, <span class="nb">Int</span> <span class="nv">$new</span> <span class="p">{</span>
                <span class="nb">die</span> <span class="p">&#39;</span><span class="s1">invalid mana</span><span class="p">&#39;</span> <span class="k">unless</span> <span class="nv">$new</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1"># placeholder for a better error</span>
                <span class="nv">$!mana</span> <span class="o">=</span> <span class="nv">$new</span><span class="p">;</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="n">Baby</span> <span class="nv">$baby</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
<span class="nv">$baby</span><span class="o">.</span><span class="nf">mana</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">$baby</span><span class="o">.</span><span class="nf">mana</span><span class="p">;</span>
<span class="nv">$baby</span><span class="o">.</span><span class="nf">mana</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9</span><span class="p">;</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/accessor" term="accessor" label="accessor" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[扩展 Raku 中的类型]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-11-25-there-is-more-than-one-way-to-extend-it/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-11-25-there-is-more-than-one-way-to-extend-it/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>There Is More Than One Way to Extend It</blockquote><h1 id="扩展-raku-中的类型">扩展 Raku 中的类型</h1>
<h2 id="使用继承">使用继承</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">BetterInt</span> <span class="k">is</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">even</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="n">BetterInt</span> <span class="nv">$x</span> <span class="o">.=</span> <span class="nb">new</span><span class="o">:</span> <span class="mi">42</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nf">even</span><span class="p">;</span>

<span class="nv">$x</span> <span class="o">.=</span> <span class="nb">new</span><span class="o">:</span> <span class="mi">71</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nf">even</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">$x</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># True</span>
<span class="c1"># False</span>
<span class="c1"># 113</span>
</code></pre></div><p><code>my BetterInt $x</code> 约束 <code>$x</code> 只能包含  <em>BetterInt</em> 或它的子类这种类型的对象。<code>.= new: 42</code> 等价于 <code>= BetterInt.new: 42</code>。
下面的子例程期望接收一个 <em>Int</em> 型的参数，但是你给它传递一个 <em>BetterInt</em> 类型的参数它会很高兴:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">\$x is </span><span class="nv">$x</span><span class="p">&#34;}</span>

<span class="k">my</span> <span class="n">BetterInt</span> <span class="nv">$x</span> <span class="o">.=</span> <span class="nb">new</span><span class="o">:</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">foo</span> <span class="nv">$x</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># $x is 42</span>
</code></pre></div><h2 id="but-but-but">But&hellip; But&hellip; But&hellip;</h2>
<p>另外一个选择是掺合进一个角色(role)。<em>but</em> 中缀操作符创建对象的一份拷贝并为该对象添加一个方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span> <span class="k">but</span> <span class="k">role</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">even</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nf">even</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># True</span>
</code></pre></div><p>当然角色不一定是内联的。这儿有另外一个例子使用了一个预定义的角色并且还展示了我们的对象确实被拷贝了一份：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">Better</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">better</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">Yes, I am better</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.attr</span> <span class="k">is</span> <span class="k">rw</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$original</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="p">:</span><span class="s">attr</span><span class="p">&lt;</span><span class="s">original</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$copy</span>     <span class="o">=</span> <span class="nv">$original</span> <span class="k">but</span> <span class="nc">Better</span><span class="p">;</span>
<span class="nv">$copy</span><span class="o">.</span><span class="nf">attr</span>   <span class="o">=</span> <span class="p">&#39;</span><span class="s1">copy</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="nv">$original</span><span class="o">.</span><span class="nf">attr</span><span class="p">;</span>  <span class="c1"># still &#39;original&#39;</span>
<span class="nb">say</span> <span class="nv">$copy</span><span class="o">.</span><span class="nf">attr</span><span class="p">;</span>      <span class="c1"># this one is &#39;copy&#39;</span>

<span class="nb">say</span> <span class="nv">$copy</span><span class="o">.</span><span class="nf">better</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$original</span><span class="o">.</span><span class="nf">better</span><span class="p">;</span> <span class="c1"># fatal error: can&#39;t find method</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># original</span>
<span class="c1"># copy</span>
<span class="c1"># Yes, I am better</span>
<span class="c1"># Method &#39;better&#39; not found for invocant of class &#39;Foo&#39;</span>
<span class="c1">#   in block &lt;unit&gt; at test.p6 line 18</span>
</code></pre></div><p>这看起来挺不错的，但是对于我们原来的目标来说，这个方法还是相当弱的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">42</span> <span class="k">but</span> <span class="k">role</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">even</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nf">even</span><span class="p">;</span> <span class="c1"># True</span>
<span class="nv">$x</span> <span class="o">=</span> <span class="mi">72</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">.</span><span class="nf">even</span><span class="p">;</span> <span class="c1"># No such method!</span>
</code></pre></div><p>那个角色被混合进我们容器里面存储的对象中了；所以一旦我们在容器中放进了一个新的值，或高级点的东西，那么 <em>.even</em> 方法就不见了，除非我们再次把那个角色混合进来。</p>
<h2 id="子例程">子例程</h2>
<p>你知道你可以把子例程当做方法用嘛？ 你接收那个对象作为子例程的第一个位置参数并且你甚至能继续使用链式方法调用，但是不能把那些链子分解成多行：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">even</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">};</span>
<span class="nb">say</span> <span class="mi">42</span><span class="o">.&amp;</span><span class="nf">even</span><span class="o">.</span><span class="nb">uc</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># TRUE</span>
</code></pre></div><p>这确实是为核心类型添加额外功能的一种得体方式。我们的子例程定义中的 <code>$^a</code> 引用第一个参数（我们在调用的那个对象）并且整个子例程也可以被写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">}</span>
</code></pre></div><h2 id="飞龙在天">飞龙在天</h2>
<p>不管<a href="http://shop.oreilly.com/product/9780596517748.do">Javaccript 的那些人们怎么跟你说</a>, 然而扩充原生类型是危险的。因为你正影响程序的所有部分。甚至看不到你的扩充的模块也受到影响。</p>
<p>现在我有权告诉你，我跟你说过，你工作的核电厂融化了，让我们看看一些代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Foo.pm6</span>
<span class="k">unit</span> <span class="k">module</span> <span class="nn">Foo</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">fob</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="mi">42</span><span class="o">.</span><span class="nf">even</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># Bar.pm6</span>
<span class="k">unit</span> <span class="k">module</span> <span class="nn">Bar</span><span class="p">;</span>

<span class="k">use</span> <span class="nb">MONKEY-TYPING</span><span class="p">;</span>

<span class="k">augment</span> <span class="k">class</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">even</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># test.p6</span>
<span class="k">use</span> <span class="nn">Foo</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Bar</span><span class="p">;</span>

<span class="nb">say</span> <span class="mi">72</span><span class="o">.</span><span class="nf">even</span><span class="p">;</span>
<span class="n">fob</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># True</span>
<span class="c1"># True</span>
</code></pre></div><p>所有的行为都发生在 <em>Bar.pm6</em> 中。首先，我们写了一行 <em>use MONKEY-TYPING</em> 声明，它告诉我们正在做一些危险的行为。然后我们在类 <strong>class Int</strong> 的前面使用了 <em>augment</em> 关键字以扩充这个已经存在的类。我们的扩充添加了一个叫 <em>even</em> 的方法以告诉我们那个 Int 是否是偶数。</p>
<p>所有的整数都可以使用 <em>even</em> 方法了，这虽然达到了我们的要求但是有点危险。</p>
<h2 id="我邪恶了">我邪恶了</h2>
<p>我们来扩充 <a href="http://docs.raku.org/type/Cool">Cool 类型</a>以涵盖所有的西文排版行长单位：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">MONKEY-TYPING</span><span class="p">;</span>

<span class="k">augment</span> <span class="k">class</span> <span class="nb">Cool</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">even</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">}</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">72</span><span class="o">.</span><span class="nf">even</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">72</span><span class="p">&#39;</span><span class="o">.</span><span class="nf">even</span><span class="o">,</span> <span class="no">pi</span><span class="o">.</span><span class="nf">even</span><span class="o">,</span> ½<span class="o">.</span><span class="nf">even</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># Method &#39;even&#39; not found for invocant of class &#39;Int&#39;</span>
<span class="c1"># in block &lt;unit&gt; at test.p6 line 8</span>
</code></pre></div><p>糟糕，程序奔溃了！原因是在我们扩充 <strong>Cool</strong> 类型的时候，派生自 <strong>Cool</strong> 的所有类型已经成型了(composed)。所以为了让它能工作，我们必须使用 <code>.^compose</code> 元对象协议方法来重新构成它们：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">MONKEY-TYPING</span><span class="p">;</span>

<span class="k">augment</span> <span class="k">class</span> <span class="nb">Cool</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">even</span> <span class="p">{</span> <span class="nb">self</span> <span class="nv">%%</span> <span class="mi">2</span> <span class="p">}</span>
<span class="p">}</span>

<span class="o">.^</span><span class="nb">compose</span> <span class="k">for</span> <span class="nb">Int</span><span class="o">,</span> <span class="nb">Num</span><span class="o">,</span> <span class="nb">Rat</span><span class="o">,</span> <span class="nb">Str</span><span class="o">,</span> <span class="nb">IntStr</span><span class="o">,</span> <span class="nb">NumStr</span><span class="o">,</span> <span class="nb">RatStr</span><span class="p">;</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">72</span><span class="o">.</span><span class="nf">even</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">72</span><span class="p">&#39;</span><span class="o">.</span><span class="nf">even</span><span class="o">,</span> <span class="no">pi</span><span class="o">.</span><span class="nf">even</span><span class="o">,</span> ½<span class="o">.</span><span class="nf">even</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># True</span>
<span class="c1"># True</span>
<span class="c1"># False</span>
<span class="c1"># False</span>
</code></pre></div><p>它现在能工作了！Int, Num, Rat, Str, IntStr, NumStr, RatStr 类型拥有了 <code>.even</code> 方法(注意：这些不是继承自 Cool 的仅有的类型)! 这既邪恶又让人吃惊。</p>
<h2 id="结论">结论</h2>
<p>当扩充 Raku 的核心类型或其它任意类的功能时，你有几种选择。</p>
<ul>
<li>使用 <strong>is Class</strong> 子类</li>
<li>使用 <strong>but Role</strong> 混合一个角色</li>
<li>使用 <code>$objec.&amp;sub</code> 调用子例程作为方法使用</li>
<li>使用  augment（注意安全）</li>
</ul>
<p><a href="http://blogs.perl.org/users/zoffix_znet/2016/04/extra-typical-perl-6.html">http://blogs.perl.org/users/zoffix_znet/2016/04/extra-typical-perl-6.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/but" term="but" label="but" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/compose" term="compose" label="compose" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[找到两个文件中共有的行]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-06-18-find-the-common-lines-in-two-files/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-06-18-find-the-common-lines-in-two-files/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Find the Common Lines in Two Files</blockquote><h2 id="找出两个文件中共有的行-顺序无关紧要">找出两个文件中共有的行, 顺序无关紧要</h2>
<p>在 Perl 5 里, 你可以这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"><span class="ch">#!/usr/bin/env perl</span>
<span class="k">use</span> <span class="mf">5.010</span><span class="p">;</span> <span class="k">use</span> <span class="nn">warnings</span><span class="p">;</span> <span class="k">use</span> <span class="nn">strict</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">%filea</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">do</span> <span class="p">{</span> <span class="nb">open</span> <span class="k">my</span> <span class="nv">$fa</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s">&#39;filea&#39;</span> <span class="ow">or</span> <span class="nb">die</span> <span class="vg">$!</span><span class="p">;</span> <span class="sr">&lt;$fa&gt;</span> <span class="p">};</span>
<span class="k">my</span> <span class="nv">%fileb</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">do</span> <span class="p">{</span> <span class="nb">open</span> <span class="k">my</span> <span class="nv">$fb</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s">&#39;fileb&#39;</span> <span class="ow">or</span> <span class="nb">die</span> <span class="vg">$!</span><span class="p">;</span> <span class="sr">&lt;$fb&gt;</span> <span class="p">};</span>
<span class="k">for</span><span class="p">(</span> <span class="nb">keys</span> <span class="nv">%filea</span> <span class="p">){</span>
    <span class="k">print</span> <span class="k">if</span> <span class="nv">$fileb</span><span class="p">{</span><span class="nv">$_</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div><p>在 Raku 中就长这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">@a</span> <span class="o">:=</span> <span class="p">&#34;</span><span class="s2">filea</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@b</span> <span class="o">:=</span> <span class="p">&#34;</span><span class="s2">fileb</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="p">;</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nb">keys</span><span class="p">(</span> <span class="nv">@a</span> <span class="o">∩</span> <span class="nv">@b</span> <span class="p">);</span>
</code></pre></div><p>因为  Raku 中的&quot;惰性列表”, 底层实现能把工作分割成不同的任务并行执行, 然后在需要结果的时候返回给它们。所以, 这种情况下, <code>@a</code> 和 <code>@b</code> 的填充可以同时运行.但是要点是, 如果你有耗费时间, 不彼此依赖的操作, 或者函数 A 要传递一个 item 列表给函数 B, 这些操作可能并行执行, 提高速度, 你不需要做任何线程相关的东西。非常赞!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/set" term="set" label="set" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[探索 Raku 中的签名(第二部分)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-08-29-exploring-raku-signatures-part-two/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-08-29-exploring-raku-signatures-part-two/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Exploring Raku Signatures Part Two</blockquote><p>在我们探索 Raku 签名的<a href="http://friedo.com/blog/2016/01/exploring-perl-6-signatures-part-1">第一部分</a>中, 我们了解了怎么使用 Raku 强大而灵活的类型系统来约束具名参数和位置参数是如何被传递给子例程和方法的。我们还涉及了怎么使用 <em>slurp</em> 签名来创建能接收任意具名和位置参数列表的可变函数。</p>
<p>Raku 的签名系统提供了更多。在这篇文章中我们将验证其中更高级的特性, 它们让 Raku 的调用语义更强大。</p>
<h2 id="class-约束">Class 约束</h2>
<p>你可以使用签名来指定传递进函数中的参数的类型约束。你使用的类型可以是任意类名。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span> <span class="nb">Numeric</span> <span class="nv">$foo</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$bar</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">my string is </span><span class="nv">$bar</span><span class="s2"> and my number is </span><span class="nv">$foo</span><span class="p">&#34;</span>
<span class="p">}</span>
</code></pre></div><p>这个签名要求我们传递 <strong>Numeric</strong> 和 <strong>Str</strong> 类型的参数。但是因为 Raku 的内置类型实际上就是类(classes), 并且因为 <strong>Numeric</strong> 拥有几个子类型, 我们可以传递进任何数字类型, 它都能工作:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">foo</span><span class="p">(</span><span class="mi">42</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">blah</span><span class="p">&#34;);</span>
<span class="nf">foo</span><span class="p">(</span><span class="mf">42.99</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">yoohoo</span><span class="p">&#34;);</span>
<span class="nf">foo</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">9</span><span class="no">i</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">hellooooooo</span><span class="p">&#34;);</span>
<span class="c1"># etc</span>
</code></pre></div><p>我们自己定义的类中签名的工作原理也一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.prop</span> <span class="k">is</span> <span class="k">rw</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">inspect-a-foo</span><span class="p">(</span> <span class="n">Foo</span> <span class="nv">$my-foo</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">this foo&#39;s property is </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$my-foo</span><span class="o">.</span><span class="nf">prop</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$f</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span> <span class="s">prop</span> <span class="o">=&gt;</span> <span class="mi">42</span> <span class="p">);</span>
<span class="nf">inspect-a-foo</span><span class="p">(</span><span class="nv">$f</span><span class="p">);</span>
<span class="c1"># this foo&#39;s property is 42</span>
</code></pre></div><p>在上面的例子中,  子例程 <em>inspect-a-foo</em> 只会接收 <strong>Foo</strong> 类型的参数, 或者 <strong>Foo</strong> 的子类。</p>
<h2 id="带有-where-block-的特异性">带有 <strong>where</strong> block 的特异性</h2>
<p>通过在签名中使用 <em>where</em> 子句, Raku 允许我们更进一步的限制子例程的参数。<em>where</em> 子句接收任何 code block, 这个 <code>code block</code> 必须返回一个 true 值以使类型约束通过。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$positive</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$positive</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">我很确信 </span><span class="nv">$positive</span><span class="s2"> 是正的!</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">bar</span><span class="p">(</span> <span class="n">Foo</span> <span class="nv">$foo</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$foo</span><span class="o">.</span><span class="nf">prop</span><span class="o">.</span><span class="nb">isa</span><span class="p">(</span> <span class="nb">Int</span> <span class="p">)</span> <span class="ow">and</span> <span class="nv">$foo</span><span class="o">.</span><span class="nf">prop</span> <span class="o">&gt;</span> <span class="mi">40</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">这个 Foo 的属性是一个大于 40 的整数</span><span class="p">&#34;</span>
<span class="p">}</span>
</code></pre></div><p>可以指定多个 <em>where</em> 子句来约束多个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nf">quadrant2</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">}</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">at the point (</span><span class="nv">$x</span><span class="s2">, </span><span class="nv">$y</span><span class="s2">)</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">quadrant2</span><span class="p">(</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="p">);</span>
<span class="c1"># Constraint type check failed for parameter &#39;$x&#39;</span>
<span class="nf">quadrant2</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<span class="c1"># Constraint type check failed for parameter &#39;$y&#39;</span>
<span class="nf">quadrant2</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span> <span class="p">);</span>
<span class="c1"># at the point (-1, 1)</span>
</code></pre></div><p>约束块儿(Constraint blocks)甚至不需要是 <em>blocks</em>。事实上, 任何 <strong>Callable</strong> 类都可以。因此, 你可以很容易地获得功能函数的约束检测, 它们能在多个不同的子例程之间循环利用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">is-positive</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$n</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="p">}</span>
<span class="k">sub</span> <span class="nf">is-negative</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$n</span> <span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="p">}</span>
<span class="k">sub</span> <span class="nf">is-zero</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$n</span> <span class="p">)</span>     <span class="p">{</span> <span class="nv">$n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>

<span class="k">sub</span> <span class="nf">quadrant1</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="nf">is-positive</span><span class="p">(</span> <span class="nv">$x</span> <span class="p">)</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="nf">is-positive</span><span class="p">(</span> <span class="nv">$y</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">quadrant2</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="nf">is-negative</span><span class="p">(</span> <span class="nv">$x</span> <span class="p">)</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="nf">is-positive</span><span class="p">(</span> <span class="nv">$y</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">quadrant3</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="nf">is-negative</span><span class="p">(</span> <span class="nv">$x</span> <span class="p">)</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="nf">is-negative</span><span class="p">(</span> <span class="nv">$y</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">quadrant4</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="nf">is-positive</span><span class="p">(</span> <span class="nv">$x</span> <span class="p">)</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="nf">is-negative</span><span class="p">(</span> <span class="nv">$y</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">x-axis</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="nf">is-zero</span><span class="p">(</span> <span class="nv">$y</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">y-axis</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="nf">is-zero</span><span class="p">(</span> <span class="nv">$x</span> <span class="p">)</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">origin</span><span class="p">(</span> <span class="nb">Real</span> <span class="nv">$x</span> <span class="k">where</span> <span class="nf">is-zero</span><span class="p">(</span> <span class="nv">$x</span> <span class="p">)</span><span class="o">,</span> <span class="nb">Real</span> <span class="nv">$y</span> <span class="k">where</span> <span class="nf">is-zero</span><span class="p">(</span> <span class="nv">$y</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="return-types">Return Types</h2>
<p>每个 Raku 子例程也能指定它自己的返回值类型作为签名的一部分。这可以使用 <em>returns</em> 关键字来显式地指定, 但是我更喜欢用快捷形式的 <code>--&gt;</code> 操作符, 它在签名自身之内。下面声明的两个子例程是等价的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">are-they-equal</span><span class="p">(</span> <span class="nb">Str</span> <span class="nv">$foo</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$bar</span> <span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="nv">$foo</span> <span class="ow">eq</span> <span class="nv">$bar</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">are-they-equal</span><span class="p">(</span> <span class="nb">Str</span> <span class="nv">$foo</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$bar</span> <span class="k">--&gt;</span> <span class="nb">Bool</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$foo</span> <span class="ow">eq</span> <span class="nv">$bar</span>
<span class="p">}</span>
</code></pre></div><p>毫无疑问地, 如果返回错误的类型 Raku 会抛出错误。</p>
<h2 id="自省">自省</h2>
<p>Raku 中子例程是一等对象。但是 Raku 带来了一大堆新的内省工具, 包含询问子例程的签名信息的能力。每个子例程的签名实际上就是 <strong>Signature</strong> 类的一个对象。我们能找出子例程的元数和返回值类型。我们甚至能够在签名中抓取一个 <strong>Parameter</strong> 对象的列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">are-they-equal</span><span class="p">(</span> <span class="nb">Str</span> <span class="nv">$foo</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$bar</span> <span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="nv">$foo</span> <span class="ow">eq</span> <span class="nv">$bar</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">&amp;are-they-equal</span><span class="o">.</span><span class="nb">signature</span><span class="o">.</span><span class="nb">arity</span><span class="p">;</span>    <span class="c1"># 2</span>
<span class="nb">say</span> <span class="nv">&amp;are-they-equal</span><span class="o">.</span><span class="nb">signature</span><span class="o">.</span><span class="k">returns</span><span class="p">;</span>  <span class="c1"># (Bool)</span>

<span class="k">my</span> <span class="nv">@params</span> <span class="o">=</span> <span class="nv">&amp;are-they-equal</span><span class="o">.</span><span class="nb">signature</span><span class="o">.</span><span class="nb">params</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@params</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">name</span><span class="p">;</span>      <span class="c1"># $foo</span>
<span class="nb">say</span> <span class="nv">@params</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">type</span><span class="p">;</span>      <span class="c1"># (Str)</span>
<span class="nb">say</span> <span class="nv">@params</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">sigil</span><span class="p">;</span>     <span class="c1"># $</span>
</code></pre></div><p>总之, Raku 的签名很好很强大。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/signature" term="signature" label="signature" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[散列也是容器]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-06-28-hash-is-also-containers/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-06-28-hash-is-also-containers/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Hash Is Also Containers</blockquote><h2 id="散列也是容器">散列也是容器</h2>
<p>假设我们想计算某个东西的出现次数, 我们通常的做法是弄一个 &ldquo;seen-hash&rdquo; 散列。有时候我们有一组待查询的键, 其中有些键可能不在我们所扫描的数据中。那是一种特殊情况, 但是 Raku 能够完美地解决, 因为散列也是容器, 因此我们能够拥有默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$words</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Hashes are containers too</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">lc</span><span class="p">;</span>
<span class="k">constant</span> <span class="no">alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>

<span class="k">my</span> <span class="nv">%seen</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="nv">%seen</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">++</span> <span class="k">for</span> <span class="nv">$words</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>
<span class="nb">put</span> <span class="p">&#34;</span><span class="nv">$_:</span><span class="s2"> </span><span class="nv">%seen</span><span class="p">{</span><span class="nv">$_</span><span class="p">}&#34;</span> <span class="k">for</span> <span class="n">alphabet</span><span class="p">;</span>
</code></pre></div><p>输出结果:</p>
<pre><code>a: 3
b: 0
c: 1
d: 0
e: 3
f: 0
g: 0
h: 2
i: 1
j: 0
k: 0
l: 0
m: 0
n: 2
o: 3
p: 0
q: 0
r: 2
s: 3
t: 2
u: 0
v: 0
w: 0
x: 0
y: 0
z: 0
</code></pre><p><code>$words</code> 中没有出现的特殊字符由 <code>is default(0)</code> 处理了。</p>
<p>默认值可以被精心设计。我们来弄一个在数值上下文中为默认值为 0 但是在字符串上下文中为默认值为 NULL 并且总是被定义的一个散列。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%seen</span> <span class="k">of</span> <span class="nb">Int</span> <span class="k">is</span> <span class="k">default</span><span class="p">(</span><span class="mi">0</span> <span class="k">but</span> <span class="k">role</span> <span class="nc">::</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">Str</span><span class="p">()</span> <span class="p">{&#39;</span><span class="s1">NULL</span><span class="p">&#39;}</span> <span class="p">});</span>
<span class="nb">say</span> <span class="nv">%seen</span><span class="p">&lt;</span><span class="s">not-there</span><span class="p">&gt;</span><span class="o">,</span> <span class="nv">%seen</span><span class="p">&lt;</span><span class="s">not-there</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">defined</span><span class="o">,</span> <span class="nb">Int</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">%seen</span><span class="p">&lt;</span><span class="s">not-there</span><span class="p">&gt;);</span>

<span class="c1"># OUTPUT</span>
<span class="c1"># «NULLTrue0␤»</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/container" term="container" label="container" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[给数字添加千分位符]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-12-14-add-separator/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-07-14-the-king-of-list-manipulation/?utm_source=atom_feed" rel="related" type="text/html" title="rotor: 列表操作之王" />
            
                <id>https://ohmyweekly.github.io/notes/2015-12-14-add-separator/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-11T00:00:00+08:00</published>
            <updated>2021-07-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Add Separator</blockquote><h2 id="使用链式函数调用">使用链式函数调用</h2>
<p>考虑最简单的一种情况, 不带小数点的数字:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">1234567890</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">reverse</span><span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="p">:</span><span class="s">partial</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">join</span><span class="p">(&#39;&#39;))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">reverse</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;&#39;)</span>  
<span class="c1"># 1,234,567,890</span>
</code></pre></div><p>使用 <code>\\</code> 转义空白, 使代码对齐:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">1234567890</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span>\
            <span class="o">.</span><span class="nb">reverse</span>\
            <span class="o">.</span><span class="nb">rotor</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span><span class="p">:</span><span class="s">partial</span><span class="p">)</span>\
            <span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">join</span><span class="p">(</span>‘’<span class="p">))</span>\
            <span class="o">.</span><span class="nb">join</span><span class="p">(</span>‘<span class="o">,</span>’<span class="p">)</span>\
            <span class="o">.</span><span class="nb">comb</span>\
            <span class="o">.</span><span class="nb">reverse</span>\
            <span class="o">.</span><span class="nb">join</span><span class="p">(</span>‘’<span class="p">)</span>\
            <span class="o">.</span><span class="nb">say</span><span class="p">;</span>

</code></pre></div><h2 id="使用正则表达式">使用正则表达式</h2>
<h2 id="使用-grammar">使用 Grammar</h2>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rotor" term="rotor" label="rotor" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Grammar Generating Grammar]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-04-15-grammar-generating-grammar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-04-15-grammar-generating-grammar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Grammar Generating Grammar</blockquote><p>现在你可能已经习惯了 Raku 中到处出现的前缀 &ldquo;meta&rdquo;。<strong>Metaclasses</strong>, <strong>Metaobjects</strong>, <strong>Metaoperators</strong>, 还有迷一般的 Meta-Object 协议。听起来一点也不可怕, 你都见过了不是吗？今天, 在 Raku Advent Calendar 上, 我们将进行完全的 <strong>meta</strong> 化(full meta)。我们将拥有能解析 grammar 的 grammar, 然后生成将用于解析 grammar 的 grammar。</p>
<p>Grammar 无疑是 Raku 的杀手级功能。我们拥有了正则表达式曾经没有的东西: 可读性、可组合性当然还有解析 Raku 自身的能力。— 如果这不能展示它的强大, 那我不知道什么能够!</p>
<p>为预定义好的 grammar(例如以 <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">Bachus-Naur</a> 形式)写解析器总是有点无趣, 几乎和复制粘贴一样。如果你曾经坐下来重头开始写一个解析器(或者期间温习一遍那本优秀的&quot;让我们构建一个编译器&quot;图书), 你可能会意识到模式是如此相似:从你的 grammar 中拿出单个 rule, 为它写一个子例程, 让它调用(可能是递归的)其它类似的为其它 grmmars rules 定义的子例程, 清洗, 重复。现在我们有了Raku grammar! 在这个新世界中, 我们不必为每个 token 写上子例程来完成工作了。 现在我们写 <strong>grammar</strong> 类, 里面放上 <em>tokens</em>、<em>rules</em>、<em>regexes</em> 标志。在标志里写正则表达式(或代码)并引用(可能是递归的) Raku gramamr 中的其它标志。如果你曾经使用过这些东西, 你肯定会意识到 Raku 中的 grammar 是多么的方便。</p>
<p>但是假如我们已经有了一个 grammar, 例如之前提到过的 BNF? 我们所做的就是小心地把已经存在的 grammar(实际上在我们头脑中解析它)重新键入到一个新的 Raku  Grammar 中以代表同样的一个东西, 但是那确实有一个可作为可执行代码的优势。对大多数人来说, 那都不是事儿。我们不是普通人, 我们是程序员。我们拥有资源。它们会让这些 grammar 变得有意义。</p>
<p>绝妙的是 Raku grammar 和语言的其它元素没什么两样。grammar 就像类那样也是头等公民, 可以内省, 扩展。实际上, 你可以查看编译器源代码自身, 你会注意到 <a href="https://github.com/rakudo/rakudo/blob/nom/src/Raku/Metamodel/GrammarHOW.nqp">grammar 就是一种特定种类的类</a>。它们遵守和类一样的规则, 允许我们就地创建 grammar, 就地给 grammar 添加 tokens, 最终完结这个 gramamr 以拥有一个合适的能实例化的类对象。现在既然我们能解析 BNF grammar(因为它们就是普通的文本)并从代码中创建 Raku grammar, 让我们把这些片段放在一起并写点能手动把 BNF gramamr 转化为 Raku grammar 的东西。</p>
<h4 id="解析-bnf-grammar-的-grammar">解析 BNF grammar 的 grammar</h4>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Grammar::BNF</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">rule</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">rule</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&lt;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">rule-name</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&gt;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">::=</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">expression</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line-end</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">expression</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">list-of-terms</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">+</span><span class="nv">%</span><span class="sr"> </span><span class="p">[</span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">|</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;]</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">term</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">literal</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&lt;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">rule-name</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&gt;</span><span class="p">&#39;</span><span class="sr">
</span><span class="sr">    </span><span class="p">}</span>

    <span class="k">token</span> <span class="nf">list-of-terms</span> <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">term</span><span class="p">&gt;</span><span class="sr"> </span><span class="o">+</span><span class="nv">%</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr">                </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">rule-name</span>     <span class="p">{</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&gt;</span><span class="p">]&gt;</span><span class="o">+</span><span class="sr">                           </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">opt-ws</span>        <span class="p">{</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr">                               </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">line-end</span>      <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">opt-ws</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr">                  </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">literal</span>       <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;</span><span class="p">]&gt;</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">&#34;</span><span class="p">&#39;</span><span class="sr"> </span><span class="o">|</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">&#39;</span><span class="p">&#34;</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#39;</span><span class="p">]&gt;</span><span class="o">*</span><span class="sr"> </span><span class="p">&#34;</span><span class="s2">&#39;</span><span class="p">&#34;</span><span class="sr"> </span><span class="p">}</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>最上层的 3 个 token 发生了有意思的事情。<em>rule</em> 是 BNF grammar 的核心构造块: 一个 <code>&lt;symbol&gt; ::=  &lt;expression&gt;</code> 块儿, 后面跟着一个换行符。整个 grammar 就是一列 rule。每个表达式是一列项、或可能的和它们的备选分支。每个项要么是一个字面值, 或一个由尖括号包围的标志名。足够了! 那涵盖了解析部分。让我们看一下生成自身。我们的确有一种&quot;为 grammar 中的每个 token 做某事&quot;的机制, 以 <strong>Actions</strong>的形式, 让我们继续并使用它:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">class</span> <span class="nc">Actions</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">BNFGrammar</span><span class="p">&#39;;</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$grmr</span> <span class="o">:=</span> <span class="n">Metamodel::GrammarHOW</span><span class="o">.</span><span class="nb">new_type</span><span class="p">(</span><span class="o">:</span><span class="nv">$.name</span><span class="p">);</span>
        <span class="nv">$grmr</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(&#39;</span><span class="s1">TOP</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nb">EVAL</span> <span class="p">&#39;</span><span class="s1">token { &lt;</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$&lt;rule&gt;</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">ast</span><span class="o">.</span><span class="nb">key</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">&gt; }</span><span class="p">&#39;);</span>
        <span class="k">for</span> <span class="nv">$&lt;rule&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$rule</span> <span class="p">{</span>
            <span class="nv">$grmr</span><span class="o">.^</span><span class="nb">add_method</span><span class="p">(</span><span class="nv">$rule</span><span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="nv">$rule</span><span class="o">.</span><span class="nb">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nv">$grmr</span><span class="o">.^</span><span class="nb">compose</span><span class="p">;</span>
        <span class="k">make</span> <span class="nv">$grmr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">expression</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="nb">EVAL</span> <span class="p">&#39;</span><span class="s1">token { </span><span class="p">&#39;</span> <span class="o">~</span> <span class="o">~</span><span class="nv">$/</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1"> }</span><span class="p">&#39;;</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="k">rule</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">~</span><span class="nv">$&lt;rule-name&gt;</span> <span class="o">=&gt;</span> <span class="nv">$&lt;expression&gt;</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>TOP</strong> 方法毫无疑问是最魔幻和最恐怖的, 所以擒贼先擒王, 其它小喽啰就无关紧要了。基本上, <em>TOP</em> 那儿发生了三件事:</p>
<ul>
<li>1、我们创建了一个新的 grammar, 作为一个新的 Raku 类型</li>
<li>2、我们使用 <code>^add_method</code> 方法为 grammar 添加 token</li>
<li>3、我们使用 <code>^compose</code> 方法定型该 grammar</li>
</ul>
<p>虽然 Raku 指定名为 <strong>TOP</strong> 的 token 是解析开始的地方, 在 BNF 中第一个 rule 总是开始点。为了彼此适应,  我们精巧地制作了一个假的 <strong>TOP</strong> token, 它正是调用了 BNF grammar 中指定的第一个 rule。不可避免地, 恐怖又令人失望的 <strong>EVAL</strong> 引起了我们的注意, 就像它说了&quot;这儿发生了可怕的事情&quot; 一样。它那样说并不是完全错误的, 但是因为我们没有其它程序化构建单独正则的方法, 我们不得不接受这点不适。</p>
<p><strong>TOP</strong> 之后我们继续为我们的 grammar 添加 BNF rule 的剩余部分, 这一次保留它们原来的名字, 然后 <code>^compose</code> 整个东西, 最后让它(make)成为解析的结果: 一个做好的解析类。</p>
<p>在 <em>expression</em> 方法中我们把解析过的 BNF 元素粘贴到一块以产生合法的 Raku 代码。这变得特别容易, 因为那俩个单独的标志带有空格, 使用管道符号来轮试备选分支, 并使用尖括号包围标志名。目前为止, 一个 rule 看起来像这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&lt;</span><span class="s">foo</span><span class="p">&gt;</span> <span class="o">::=</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&lt;</span><span class="s">baz</span><span class="p">&gt;</span>
</code></pre></div><p>我们求值(EVAL)的 Raku 代码变为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&lt;</span><span class="s">baz</span><span class="p">&gt;</span> <span class="p">}</span>
</code></pre></div><p>因为我们已经在我们代码的 grammar 部分检测我们解析的 BNF 是正确的, 没有什么能够阻止我们传递解析整个表达式字面值到我们的代码中并使用一个 <code>token  { }</code> 来包裹它, 所以让我们继续。</p>
<p>最后, 对于我们解析的每一个 BNF rule, 我们产生了一个很不错的 <em>Pair</em>, 所以我们的 <strong>TOP</strong> 方法很愉快地处理它们中的每个。</p>
<p>看起来我们好像在这儿结束了, 但是仅仅是为了方便使用者, 让我们写一个更好的方法, 接收一个 BNF grammar, 并为我们生成一个准备好使用的类型对象。我们记得, grammar 就是类, 所以我们没有什么能阻止我们直接为我们的 gramamr 添加它:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Grammar::BNF</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">method</span> <span class="nf">generate</span><span class="p">(</span><span class="nv">$source</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">BNFGrammar</span><span class="p">&#39;)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$actions</span> <span class="o">=</span> <span class="n">Actions</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$ret</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$source</span><span class="o">,</span> <span class="o">:</span><span class="nv">$actions</span><span class="p">)</span><span class="o">.</span><span class="nb">ast</span><span class="p">;</span>
        <span class="k">return</span> <span class="nv">$ret</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这儿看起来很不错! 在你开始往你自己的项目中复制粘贴所有这些之前, 记得 <a href="https://github.com/tadzik/Grammar-BNF/">Grammar::BNF</a> 是一个可在 <a href="http://modules.raku.org/">Raku Module Ecosystem</a>获得的 Raku 模块, 使用你喜欢的模块管理器安装。</p>
<p>假设你确实花费时间查看了开头的 post, 你可能会记得我许诺过我们将有 grammar(第一条)来解析 grammar(第二条), 然后生成 grammar(第三条), 使用生成的 grammar 来解析 grammar(第四条)。目前为止， 我们已经看到过 BNF::Grammar  grammar(那是第一条), 并解析一个 BNF grammar(那是第二条), 以类对象的形式来生成 Raku grammar(第三条)。 就这些。我们仍旧缺乏最后一部分, 使用整个东西来解析 grammar。 我们只完成了 75% 的 meta 化, 今天足够了。为什么现在停止? 为什么不拿一个 BNF grammar , 使用 Raku grammar 来解析 grammar, 使用 Raku BNF grammar 的结果来解析我们原来的 BNF Grammar? 那不是很好吗？是的, 那很好, 我们只是留了一个练习给你。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/grammar" term="grammar" label="grammar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Junction in Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-22-junctions-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-22-junctions-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Junction in Raku</blockquote><p><a href="https://en.wikipedia.org/wiki/Erwin_Schr%C3%B6dinger">薛定谔欧文</a>应该是喜欢 Raku 的, 因为他的著名的<a href="https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat">薛定谔的猫</a>可以用 Raku 的 <a href="https://docs.raku.org/type/Junction">Junction</a>表达:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$cat</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">dead</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&#39;</span><span class="s1">alive</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">cat is both dead and alive</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$cat</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">dead</span><span class="p">&#39;</span> <span class="ow">and</span> <span class="nv">$cat</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">alive</span><span class="p">&#39;;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># cat is both dead and alive</span>
</code></pre></div><p>这里面发生了什么事情? 我会告诉你全部的!</p>
<h2 id="anyone-游戏">Anyone 游戏?</h2>
<p>拿最简单的来说, Junction 允许你把一堆值当作单个值。例如, 你可以使用 <code>any</code> Junction 来测试一个变量是否等于所给定值中的任意一个:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">it matches!</span><span class="p">&#39;</span> <span class="k">if</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&#39;</span><span class="s1">bar</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&#39;</span><span class="s1">ber</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">single-digit prime</span><span class="p">&#39;</span> <span class="k">if</span> <span class="mi">5</span> <span class="o">==</span> <span class="nb">any</span> <span class="o">^</span><span class="mi">9</span><span class="o">.</span><span class="nb">grep</span><span class="o">:</span> <span class="o">*.</span><span class="nb">is-prime</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span> <span class="o">^</span><span class="mi">100</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">it&#39;s in there!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="mi">42</span> <span class="o">==</span> <span class="nv">@values</span><span class="o">.</span><span class="nb">any</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># it matches!</span>
<span class="c1"># single-digit prime</span>
<span class="c1"># it&#39;s in there!</span>
</code></pre></div><p>要从一堆值中创建一个 <code>any</code> Junction, 你可以使用 <code>|</code> 中缀操作符、调用 <code>any</code> 函数或者使用 <code>.any</code> 方法。上面的条件会返回 True 如果 Junction 中的任意一个(<code>any</code>) 值匹配所给定的值的话。事实上, 没有人能阻止你在两端都使用 Junction:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@one</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@two</span> <span class="o">=</span> <span class="mi">5</span><span class="o">..</span><span class="mi">15</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">There&#39;s overlap!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">@one</span><span class="o">.</span><span class="nb">any</span> <span class="o">==</span> <span class="nv">@two</span><span class="o">.</span><span class="nb">any</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># there&#39;s overlap!</span>
</code></pre></div><p>运算符会返回 True 如果 <code>@one</code> 中的任意一个值(<code>any</code>) 在数值上等于 <code>@two</code> 中的任意一个值(<code>any</code>)的话。这个语法糖很甜, 但是我们还可以做的更多。</p>
<h2 id="all-for-one-and-any-for-none">All for One and Any for None</h2>
<p><code>any</code> Junction 唯一一个你能获得的 Junction。你还可以选择 <code>all</code>、<code>any</code>、<code>one</code> 和 <code>none</code>。当在布尔上下文中时, 它们的意思就像下面这样; 构建 Junction 的函数/方法名和 Junction 自身的名字一样并且下面还列出了构建 Junction 的中缀操作符:</p>
<ul>
<li><code>all</code> — 所有的值都被计算为 True(使用中缀 <code>&amp;</code>)</li>
<li><code>any</code> — 至少其中的一个值被计算为 True(使用中缀 <code>|</code>)</li>
<li><code>one</code> — 正好其中有一个值被计算为 True(使用中缀 <code>^</code>)</li>
<li><code>none</code> — 没有一个值被计算为 True(没有可用的中缀)</li>
</ul>
<p>使用 <code>all</code> JUnction 时要特别注意:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">all primes</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">@values</span><span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="o">*.</span><span class="nb">is-prime</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">@moar-values</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">also all primes</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">@moar-values</span><span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="o">*.</span><span class="nb">is-prime</span><span class="p">;</span>
</code></pre></div><p>即使它没有值的时候也会返回 True, 这可能不是你想要的。在那些情况下, 你可以使用:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@moar-values</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">also all primes</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">@moar-values</span> <span class="ow">and</span> <span class="nv">@moar-values</span><span class="o">.</span><span class="nb">all</span> <span class="o">~~</span> <span class="o">*.</span><span class="nb">is-prime</span><span class="p">;</span>
</code></pre></div><h2 id="call-me-baby">Call Me, Baby</h2>
<p>你可以把 Junction 用作并不期望 Junction 的子例程的参数。那么会发生什么呢? 对于每一个 Junctioned 的值, 那个子例程都会被调用一次, 并且返回值会是一个 Junction：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">caculate-things</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> is prime</span><span class="p">&#34;</span>          <span class="k">if</span> <span class="nv">$n</span><span class="o">.</span><span class="nb">is-prime</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> is an even number</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> is pretty big</span><span class="p">&#34;</span>     <span class="k">if</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mf">1e6</span><span class="p">;</span>
    <span class="nv">$n</span>²<span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@values</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mf">1e10</span><span class="o">.</span><span class="nb">Int</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">EXACTLY ONE square is larger than 1e10</span><span class="p">&#39;</span>
    <span class="k">if</span> <span class="mf">1e10</span> <span class="o">&lt;</span> <span class="n">calculate-things</span> <span class="nv">@values</span><span class="o">.</span><span class="nb">one</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># 5 is a prime</span>
<span class="c1"># 42 is an even number</span>
<span class="c1"># 10000000000 is an even number</span>
<span class="c1"># 10000000000 is pretty big</span>
<span class="c1"># EXACTLY ONE square is larger than 1e10</span>
</code></pre></div><p>暴露的副作用可能有点太过神奇并且你可能不想在生产代码中看到它, 但是使用一个子例程来修改原来的 Junctioned 化的值是相当能接受的。执行一个数据库查询来获取&quot;实际的&quot;值并且在之后计算那个条件怎么样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">DBIish</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$dbh</span> <span class="o">=</span> <span class="n">DBIish</span><span class="o">.</span><span class="nb">connect</span><span class="o">:</span> <span class="p">&#39;</span><span class="s1">SQLite</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">database</span><span class="p">&lt;</span><span class="s">test.db</span><span class="p">&gt;;</span>

<span class="k">sub</span> <span class="nb">lookup</span> <span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">given</span> <span class="nv">$dbh</span><span class="o">.</span><span class="nf">prepare:</span> <span class="p">&#39;</span><span class="s1">SELECT id, text FROM stuff WHERE id = ?</span><span class="p">&#39;</span> <span class="p">{</span>
        <span class="o">.</span><span class="nf">execute:</span> <span class="nv">$id</span><span class="p">;</span>
        <span class="o">.</span><span class="nf">allrows</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">//</span> <span class="p">&#39;&#39;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@ids</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">yeah, it got it, bruh</span><span class="p">&#39;</span> <span class="k">if</span> <span class="p">&#39;</span><span class="s1">meow</span><span class="p">&#39;</span> <span class="ow">eq</span> <span class="nb">lookup</span> <span class="nv">@ids</span><span class="o">.</span><span class="nb">any</span><span class="p">;</span>

<span class="c1"># OUTPUT (the database has a row with id = 5 and text = &#39;meow&#39;):</span>
<span class="c1"># yeah, it got it, bruh</span>
</code></pre></div><h2 id="我们一直在期盼你-请坐">我们一直在期盼你, 请坐</h2>
<p>那个游戏变化了当你的子例程正好期望一个 Junction 作为参数的时候。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">do-stuff</span> <span class="p">(</span><span class="nb">Junction</span> <span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">value is even</span><span class="p">&#39;</span>  <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">value is prime</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">$n</span><span class="o">.</span><span class="nb">is-prime</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">value is large</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mf">1e10</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">do-stuff</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mf">1e11</span><span class="o">.</span><span class="nb">Int</span><span class="p">)</span><span class="o">.</span><span class="nb">one</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">---</span><span class="p">&#39;;</span>
<span class="n">do-stuff</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mf">1e11</span><span class="o">.</span><span class="nb">Int</span><span class="p">)</span><span class="o">.</span><span class="nb">any</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># value is large</span>
<span class="c1"># ---</span>
<span class="c1"># value is even</span>
<span class="c1"># value is prime</span>
<span class="c1"># value is large</span>
</code></pre></div><p>当我们提供了一个 <code>one</code> Junction 时, 只有正好满足给定值中的其中一个条件才会被触发。当我们提供一个 <code>any</code> Junction 时, 满足条件的任何一个给定值都会触发。</p>
<p>但是! 你没有必要非等着世界为你分发 Junction。你自己制造一个怎么样呢, 还能在测试条件时节省代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">do-stuff</span> <span class="p">(</span><span class="o">*</span><span class="nv">@v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nv">@v</span><span class="o">.</span><span class="nb">one</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> is even</span><span class="p">&#34;</span>  <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> is prime</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$n</span><span class="o">.</span><span class="nb">is-prime</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> is large</span><span class="p">&#34;</span> <span class="k">if</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mf">1e10</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">do-stuff</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mf">1e11</span><span class="o">.</span><span class="nb">Int</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">---</span><span class="p">&#39;;</span>
<span class="n">do-stuff</span> <span class="mi">42</span><span class="p">;</span>

<span class="c1"># OUTPUT:</span>
<span class="c1"># one(2, 3, 100000000000) is large</span>
<span class="c1"># ---</span>
<span class="c1"># one(42) is even</span>
</code></pre></div><h2 id="没有人想过将来吗">没有人想过将来吗?</h2>
<p>还有一个小秘密: Junction 被设计为时<a href="https://en.wikipedia.org/wiki/Automatic_parallelization">自动线程化</a>的(即 auto-threaded)。尽管在写这篇文章的时候它们只会使用仅仅一个线程, 你不应该依赖它们能以任何可预测的顺序被执行。自动线程化会在 2018 年的某个时间被实现, 所以保持关注&hellip; 你不必做任何事情, 你的值得自动线程化的复杂 Junctioned 化的操作可能会在几年之内变得更快。</p>
<h2 id="结论">结论</h2>
<p>Raku 的 Junction 是值的叠加态, 它允许你测试多个值就像它们是一个值一样。除了提供非常短并且易读的语法, Junction 还允许你使用子例程变换叠加值或者使用副作用。</p>
<p>你还可以生成显式操作 Junction 的子例程或者把提供的多个值转换成 Junction 以简化代码。</p>
<p>最后, Junction 被设计为能使用所有你计算机所提供的可用能力并且在不久的将来会做成自动线程化。</p>
<p>Junction 很精彩, 使用它们, 玩的开心!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/junction" term="junction" label="junction" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的捕获]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-04-01-capture-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-04-01-capture-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Capture in Raku</blockquote><p><a href="http://doc.raku.org/type/Capture">Capture</a> 的定义:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nb">Capture</span> <span class="k">does</span> <span class="nb">Positional</span> <span class="k">does</span> <span class="nb">Associative</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>Capture 是一个用于给 code 对象传递参数的容器。Captures 是签名的另一面 — Captures 在调用方定义实参, 而签名(Signatures) 在被调用方定义形式参数。</p>
<p>当你调用 <code>print $a, $b</code> 时, <code>$a, $b</code> 这部分就是一个 Capture。<code>$a, $b</code> 在这儿是实参。</p>
<p>Captures 包含一个 list-like 部分的位置参数和一个 hash-like 部分的具名参数。对于具名参数, Captures 使用一种略微不同的语法而不是普通的 List。有两种简单的方法生成一个具名参数：</p>
<ul>
<li>使用一个未引起的键命名一个形参, 后面跟着 <code>=&gt;</code>, 然后跟着参数</li>
<li>使用以形参命名的冒号对儿字面量</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">unique</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">as</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nb">abs</span> <span class="nv">$_</span> <span class="p">};</span> <span class="c1"># 1</span>, <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span>
<span class="c1"># ... is the same thing as:</span>
<span class="nb">say</span> <span class="nb">unique</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="p">:</span><span class="s">as</span><span class="p">({</span> <span class="nb">abs</span> <span class="nv">$_</span> <span class="p">});</span>  <span class="c1"># 1, -2, 3</span>
<span class="c1"># Be careful not to quote the name of a named parameter:</span>
<span class="nb">say</span> <span class="nb">unique</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">as</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nb">abs</span> <span class="nv">$_</span> <span class="p">};</span> <span class="c1"># 1, -2, 2, 3, &#34;as&#34; =&gt; { ... }</span>
</code></pre></div><p>单个独立的 Capture 也能被生成, 存储, 然后供之后使用。 在项(term)那儿前置一个反斜线 <code>\</code> 能生成一个字面的 Capture。通常, 这个 term 会是一个 terms 的列表, 在这个列表里面, 任何 Pair 字面值会被放在 Capture 的具名部分, 而其它 terms 会被放在Capture 的位置(positional) 部分。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> \<span class="p">(</span><span class="mi">42</span><span class="p">);</span>          <span class="c1"># 带有一个 positional 部分的 Capture        </span>
<span class="nv">$c</span> <span class="o">=</span> \<span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;);</span> <span class="c1"># 带有两个 positional 部分和一个具名部分的 Capture</span>
</code></pre></div><p>要使用这样的 Capture, 在函数调用里你可以在这个 Capture 前面使用 <code>|</code> , 那么它看起来会像这个 Capture 中的所有值都被作为实参直接传递这个函数了 — 具名参数作为具名参数传递, 而位置参数会作为位置参数传递。 只要你愿意, 你可以重用这个 Capture 任意次, 甚至使用不同的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> \<span class="p">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">);</span>
<span class="nb">reverse</span><span class="p">(</span><span class="o">|</span><span class="nv">$c</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># 3 2 4</span>
<span class="nb">sort</span><span class="p">(</span><span class="mi">5</span><span class="o">,|</span><span class="nv">$c</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>  <span class="c1"># 2 3 4 5</span>
</code></pre></div><p>在签名( Signature) 里面, 可以在不含符号的形参那儿前置一个竖线 <code>|</code> 来创建一个 Capture。这会把余下的参数列表打包到那个形参中：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">f</span><span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="o">|</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">f</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>
<span class="c1"># c  is  \(2, 3, a =&gt; 4, b =&gt; 5)</span>
</code></pre></div><p>请注意，Capture 仍然是列表，因为它们可能包含容器，而不只是值:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> \<span class="p">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">$b</span><span class="o">,</span><span class="mi">3</span><span class="p">);</span>
<span class="nb">sort</span><span class="p">(</span><span class="o">|</span><span class="nv">$c</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>        <span class="c1"># 1 2 3 4</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="nb">sort</span><span class="p">(</span><span class="o">|</span><span class="nv">$c</span><span class="p">)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>        <span class="c1"># 2 3 4 6</span>
</code></pre></div><h3 id="capture-方法from-mu">Capture 方法(From Mu)</h3>
<p>定义为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">Capture</span><span class="p">(</span><span class="n">Mu:D:</span> <span class="k">--&gt;</span> <span class="nb">Capture:D</span><span class="p">)</span>
</code></pre></div><p>返回与调用者的公共属性相对应的命名参数的 <a href="https://docs.raku.org/type/Capture">Capture</a>：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.foo</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.bar</span> <span class="o">=</span> <span class="mi">70</span><span class="p">;</span>
    <span class="k">method</span> <span class="nf">bar</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">something else</span><span class="p">&#39;</span> <span class="p">}</span>
<span class="p">}</span><span class="o">.</span><span class="nb">new</span><span class="o">.</span><span class="nb">Capture</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

<span class="c1"># OUTPUT: «\(:bar(&#34;something else&#34;), :foo(42))␤» </span>
</code></pre></div><h3 id="cpature-方法from-list">Cpature 方法(from List)</h3>
<p>定义为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nb">Capture</span><span class="p">(</span><span class="k">--&gt;</span> <span class="nb">Capture:D</span><span class="p">)</span>
</code></pre></div><p>返回一个 <a href="https://docs.raku.org/type/Capture">Capture</a>，其中列表中的每个 <a href="https://docs.raku.org/type/Pair">Pair</a>（如果有）已转换为命名参数（使用Pair string的键）。列表中的所有其他元素按照它们被发现的顺序转换为位置参数，即列表中的第一个非 Pair item 成为第一个位置参数，其获得索引 0，第二个非 pair item 成为第二个位置参数，索引为 1 等。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$list</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">17</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$capture</span> <span class="o">=</span> <span class="nv">$list</span><span class="o">.</span><span class="nb">Capture</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$capture</span><span class="o">.</span><span class="nb">keys</span><span class="p">;</span> <span class="c1"># OUTPUT: «(0 1 a b)␤» </span>
<span class="nf">my-sub</span><span class="p">(</span><span class="o">|</span><span class="nv">$capture</span><span class="p">);</span> <span class="c1"># RESULT: «7, 5, 2, 17» </span>
 
<span class="k">sub</span> <span class="nf">my-sub</span><span class="p">(</span><span class="nv">$first</span><span class="o">,</span> <span class="nv">$second</span><span class="o">,</span> <span class="o">:</span><span class="nv">$a</span><span class="o">,</span> <span class="o">:</span><span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$first</span><span class="s2">, </span><span class="nv">$second</span><span class="s2">, </span><span class="nv">$a</span><span class="s2">, </span><span class="nv">$b</span><span class="p">&#34;</span>
<span class="p">}</span>
</code></pre></div><p>一个更高级的例子是所返回的 <code>Capture</code> 与 <a href="https://docs.raku.org/type/Signature">签名</a> 进行智能匹配。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$list</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">17</span><span class="p">);</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$list</span><span class="o">.</span><span class="nb">Capture</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="o">==</span> <span class="mi">7</span><span class="o">,</span><span class="nv">$</span><span class="o">,:</span><span class="nv">$a</span><span class="o">,:</span><span class="nv">$b</span><span class="p">);</span> <span class="c1"># OUTPUT: «True␤» </span>
 
<span class="nv">$list</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="s">b</span> <span class="o">=&gt;</span> <span class="mi">17</span><span class="p">);</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$list</span><span class="o">.</span><span class="nb">Capture</span> <span class="o">~~</span> <span class="o">:</span><span class="p">(</span><span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="o">==</span> <span class="mi">7</span><span class="o">,</span><span class="nv">$</span><span class="o">,:</span><span class="nv">$a</span><span class="o">,:</span><span class="nv">$b</span><span class="p">);</span> <span class="c1"># OUTPUT: «False␤» </span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/capture" term="capture" label="capture" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的操作符]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-16-operator-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-16-operator-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Operator in Raku</blockquote><h2 id="操作符httpsdocsrakuorglanguageoperators"><a href="https://docs.raku.org/language/operators">操作符</a></h2>
<h3 id="操作符优先级">操作符优先级</h3>
<p>在像 <code>1 + 2 * 3</code> 这样的表达式中, <code>2 * 3</code> 被首先计算, 因为中缀操作符  <code>*</code> 的优先级比 <code>+</code> 的优先级高。下面的表中总结了 Perl  6 中  的优先级级别, 从最牢固到最松散：</p>
<pre><code>A	Level	           Examples
N	Terms	           42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array
L	方法后缀	        .meth .+ .? .* .() .[] .{} .&lt;&gt; .«» .:: .= .^ .:
N	自增	              ++ --
R	求幂	              **
L	Symbolic unary	   ! + - ~ ? | || +^ ~^ ?^ ^
L	乘法	              * / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm
L	加法	              + - +| +^ ~| ~^ ?| ?^
L	重复	              x xx
X	连结                ~
X	Junctive and	   &amp;
X	Junctive or	       | ^
L	Named unary	       temp let
N	Structural infix   but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^
C	Chaining infix	   != == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv
X	Tight and	       &amp;&amp;
X	Tight or	       || ^^ // min max
R	Conditional	       ?? !! ff fff
R	Item assignment	   = =&gt; += -= **= xx= .=
L	Loose unary	       so not
X	Comma operator	   , :
X	List infix	       Z minmax X X~ X* Xeqv ...
R	List prefix	       print push say die map substr ... [+] [*] any Z=
X	Loose and	       and andthen
X	Loose or	       or xor orelse
X	Sequencer	       &lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;
N	Terminator	       ; {...}, unless, extra ), ], }
</code></pre><p>下面使用的两处 <code>!</code> 符号一般代表任何一对儿拥有相同优先级的操作符, 上表指定的二元操作符的结合性解释如下(其中 A 代表结合性, associativities )：</p>
<pre><code>A	Assoc	Meaning of $a ! $b ! $c
L	left	($a ! $b) ! $c
R	right	$a ! ($b ! $c)
N	non	    ILLEGAL
C	chain	($a ! $b) and ($b ! $c)
X	list	infix:&lt;!&gt;($a; $b; $)
</code></pre><p>对于一元操作符, 这解释为:</p>
<pre><code>A	Assoc	Meaning of !$a!
L	left	(!$a)!
R	right	!($a!)
N	non	    ILLEGAL
</code></pre><p>下面描述的操作符, 默认假定为 left 结合性。</p>
<h3 id="操作符种类">操作符种类</h3>
<p>操作符能出现在相对于 term 的几个位置处：</p>
<pre><code>+term	        prefix         (后缀)
term1 + term2	infix          (中缀)
term++	        postfix        (后缀)
(term)	        circumfix      (环缀)
term1[term2]	postcircumfix  (后环缀)
</code></pre><p>每个操作符也可以用作子例程。这样的子例程的名字由操作符的种类, 然后后跟一个冒号, 再加上一组引号结构, 引号结构中是组成操作符的符号(s):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">)</span>                           <span class="c1"># same as 1 + 2</span>
<span class="n">circumfix:</span><span class="p">«</span><span class="s2">( )</span><span class="p">»(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;)</span>            <span class="c1"># same as (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), 目前编译错误。</span>
<span class="n">circumfix:</span><span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">raku</span><span class="o">.</span><span class="nb">say</span>   <span class="c1"># [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]</span>
</code></pre></div><p>作为一种特殊情况, listop(列表操作符)既能作为 term 又能作为前缀。子例程调用是最常见的列表操作符。其它情况包括元运算中缀操作符 <code>[+]| 1, 2, 3</code> 和 <code>prefix</code> 等 stub 操作符。</p>
<p>定义自定义操作符在 <a href="http://doc.raku.org/language/functions#Defining_Operators"> /language/functions#Defining_Operators.</a>  中有涉及。</p>
<h3 id="term-优先级">Term 优先级</h3>
<h4 id="环缀--">环缀 &lt; &gt;</h4>
<p>引起单词的结构, 以空白隔开内容。如果单词看起来像数字字面量或 <code>Pair</code> 字面量, 那么它会被转为合适的数字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>  <span class="c1"># b</span>
</code></pre></div><h3 id="环缀---1">环缀 ( )</h3>
<p>分组操作符。</p>
<p>在参数列表中, 在参数周围放上圆括号防止了参数被解释为具名参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">p</span><span class="p">(</span><span class="o">:</span><span class="nv">$a</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">named</span><span class="p">&#39;</span>      <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">p</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span>   <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">positional</span><span class="p">&#39;</span> <span class="p">}</span>
<span class="n">p</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1"># named</span>
<span class="n">p</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>     <span class="c1"># positional</span>
</code></pre></div><h3 id="环缀---2">环缀 { }</h3>
<p>Block 或 散列构造器。</p>
<p>如果 <code>{}</code> 里面的内容看起来像一组 pairs 并且没有 <code>$_</code> 或其它占位符参数, 就返回一个散列, 这个散列由逐项逐项的 Pair 组成。</p>
<p>否则就返回一个 Block。</p>
<p>注意, 这个结构没有重新解析内容; 而里面的内容总是被解析为一组句子（例如, 像一个 block）, 并且如果后面的分析表明它需要被解析成一个散列, 那么 block 就会被执行并强转为散列。</p>
<h3 id="环缀---3">环缀 [ ]</h3>
<p>数组构造器。在列表上下文中返回一个不会展平的 item 化的数组。</p>
<h2 id="方法后缀优先级">方法后缀优先级</h2>
<h3 id="后环缀--">后环缀 [ ]</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">postcircumfix:</span><span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;(</span><span class="nv">@container</span><span class="o">,</span> <span class="o">**</span><span class="nv">@index</span><span class="o">,</span>
                        <span class="o">:</span><span class="nv">$k</span><span class="o">,</span> <span class="o">:</span><span class="nv">$v</span><span class="o">,</span> <span class="o">:</span><span class="nv">$kv</span><span class="o">,</span> <span class="o">:</span><span class="nv">$p</span><span class="o">,</span> <span class="o">:</span><span class="nv">$exists</span><span class="o">,</span> <span class="o">:</span><span class="nv">$delete</span><span class="p">)</span>
</code></pre></div><p><code>:$k</code> 会创建一个 Pair, 它是散列中的一个条目。键是 <code>k</code>, 键值为 <code>$kv</code>。所以, <code>$k</code> 等价于 <code>k</code> =&gt; <code>$k</code></p>
<p>访问 <code>@container</code>  中的一个或多个元素, 即数组索引操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alphabet</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>                   <span class="c1">#-&gt; a</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>                   <span class="c1">#-&gt; b</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>                 <span class="c1">#-&gt; z</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span><span class="p">:</span><span class="s">exists</span><span class="p">;</span>          <span class="c1">#-&gt; False</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">15</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">17</span><span class="o">,</span> <span class="mi">11</span><span class="o">].</span><span class="nb">join</span><span class="p">;</span>  <span class="c1">#-&gt; perl</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">23</span> <span class="o">..</span> <span class="o">*].</span><span class="nb">raku</span><span class="p">;</span>        <span class="c1">#-&gt; (&#34;x&#34;, &#34;y&#34;, &#34;z&#34;)</span>

<span class="nv">@alphabet</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">B</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">C</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">@alphabet</span><span class="o">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="o">].</span><span class="nb">raku</span>            <span class="c1">#-&gt; (&#34;a&#34;, &#34;B&#34;, &#34;C&#34;, &#34;d&#34;)</span>
</code></pre></div><p>查看 <a href="http://doc.raku.org/language/subscripts">Subscripts</a> 获取关于该操作符行为的更详细的解释, 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---1">后环缀 { }</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">postcircumfix:</span><span class="p">&lt;</span><span class="s">{ }</span><span class="p">&gt;(</span><span class="nv">%container</span><span class="o">,</span> <span class="o">**</span><span class="nv">@key</span><span class="o">,</span>
                        <span class="o">:</span><span class="nv">$k</span><span class="o">,</span> <span class="o">:</span><span class="nv">$v</span><span class="o">,</span> <span class="o">:</span><span class="nv">$kv</span><span class="o">,</span> <span class="o">:</span><span class="nv">$p</span><span class="o">,</span> <span class="o">:</span><span class="nv">$exists</span><span class="o">,</span> <span class="o">:</span><span class="nv">$delete</span><span class="p">)</span>
</code></pre></div><p>访问 <code>%container</code> 的一个或多个元素, 即散列索引操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">banana</span><span class="p">&#34;};</span>               <span class="c1">#-&gt; yellow</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;}</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">strawberry</span><span class="p">&#34;}:</span><span class="s">exists</span><span class="p">;</span>    <span class="c1">#-&gt; False</span>

<span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">banana</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">lime</span><span class="p">&#34;}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">yellowish</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;;</span>
<span class="nv">%color</span><span class="p">{&#34;</span><span class="s2">cherry</span><span class="p">&#34;}:</span><span class="s">delete</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">;</span>  <span class="c1">#-&gt; banana =&gt; yellowish, kiwi =&gt; green, lime =&gt; green</span>
</code></pre></div><p>查看后环缀 <code>&lt; &gt;</code> 和后环缀 <code>« »</code> 作为便捷形式, 查看 <code>Subscripts</code> 获取这个操作符行为的更详细解释, 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---2">后环缀 &lt; &gt;</h3>
<p>后环缀 <code>{ }</code> 的简写形式, 它会引起它的参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">banana</span><span class="p">&gt;;</span>             <span class="c1">#-&gt; yellow</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">cherry kiwi</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">&lt;</span><span class="s">strawberry</span><span class="p">&gt;:</span><span class="s">exists</span><span class="p">;</span>  <span class="c1">#-&gt; False</span>
</code></pre></div><p>这不是一个真正的操作符, 它仅仅是一个在编译时把 <code>&lt; &gt;</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---3">后环缀 « »</h3>
<p>后环缀 <code>{ }</code> 的简写形式。它会引起它的参数, 并且 <code>« »</code> 中能进行变量插值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%color</span> <span class="o">=</span> <span class="s">kiwi</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;</span>, <span class="s">banana</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">yellow</span><span class="p">&#34;</span>, <span class="s">cherry</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">red</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$fruit</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">kiwi</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="nv">%color</span><span class="p">«</span><span class="s2">cherry </span><span class="nv">$fruit</span><span class="p">»</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>   <span class="c1">#-&gt; (&#34;red&#34;, &#34;green&#34;)</span>
</code></pre></div><p>这不是一个真正的操作符, 它仅仅是一个在编译时把 <code>« »</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---4">后环缀 ( )</h3>
<p>调用操作符。把调用者当作 <code>Callable</code> 并引用它, 它使用圆括号之间的表达式作为参数。</p>
<p>注意, 标识符后面直接跟着一对儿圆括号总是被解析为子例程调用。</p>
<p>如果你想要你的对象响应该调用操作符, 你需要实现 <code>CALL-ME</code> 方法。</p>
<h3 id="postfix-">postfix .</h3>
<p>该操作符用于调用一个方法, <code>$invocant.method</code>。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--1">postfix .=</h3>
<p>可变的方法调用。<code>$invocant.=method</code>, 脱去语法糖后就是 <code>$invocant = $invocant.method</code>, 这与 <a href="http://doc.raku.org/routine/op%3D">op=.</a> 类似。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--2">postfix .^</h3>
<p>元方法调用。<code> $invocant.^method</code> 在 <code>$invocant</code> 的元类身上调用方法。脱去语法糖后, 它就是 <code>$invocant.HOW.method($invocant, ...)</code>。查看 <a href="http://doc.raku.org/type/HOW">HOW</a> 获取更多信息。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--3">postfix .?</h3>
<p>有可能被调用的方法调用。如果有名为 <code>method</code> 的方法, <code>$invocant.?method</code> 就在 <code>$invocant</code> 上调用 <code>method</code> 方法。否则它就返回 <code>Nil</code>。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--4">postfix .+</h3>
<p><code>$invocant.+method </code> 从 <code>$invocant</code> 身上调用所有叫做 <code>method</code> 的方法。如果没有找到这个名字的方法, 就会死掉。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--5">postfix .*</h3>
<p><code>$invocant.*method</code> 从 <code>$invocant</code> 身上调用所有叫做 <code>method</code> 的方法。</p>
<p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-postfix">postfix .postfix</h3>
<p>大多数情况下, 可以在后缀或后环缀前面放上一个点：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span>
<span class="nv">@a</span><span class="o">.[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span> <span class="c1"># Same</span>
</code></pre></div><p>这对于视觉清晰或简洁很有帮助。例如, 如果对象的属性是一个函数, 在属性名后面放置一对儿圆括号会变成方法调用的一部分。所以要么使用两对儿圆括号, 要么在圆括号前面放上一个点来阻止方法调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Operation</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.symbol</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">&amp;.function</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$addition</span> <span class="o">=</span> <span class="n">Operation</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">symbol</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;</span><span class="o">,</span> 
                             <span class="p">:</span><span class="s">function</span><span class="p">{</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="p">});</span>
<span class="nb">say</span> <span class="nv">$addition</span><span class="o">.</span><span class="nf">function</span><span class="p">()(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1"># 3</span>
</code></pre></div><p>或者:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$addition</span><span class="o">.</span><span class="nf">function</span><span class="o">.</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1"># 3</span>
</code></pre></div><p>然而, 如果后缀是一个标识符, 那么它会被解释为一个普通的方法调用。</p>
<pre><code>1.i # No such method 'i' for invocant of type 'Int'
</code></pre><p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-prefix">postfix .:<!-- raw HTML omitted --></h3>
<p>前缀能够像方法那样, 使用冒号对儿标记法来调用。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">++</span><span class="nv">$a</span><span class="p">;</span>     <span class="c1"># 2</span>
<span class="nb">say</span> <span class="nv">$a</span><span class="o">.:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;;</span> <span class="c1"># 3</span>
</code></pre></div><p>技术上讲, 这不是一个操作符, 而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--6">postfix .::</h3>
<p>一个类限定的方法调用, 用于调用一个定义在父类或 role 中的方法, 甚至在子类中重新定义了之后。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">baz</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Foo</span> <span class="k">is</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">baz</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">nope</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">Foo</span><span class="o">.</span><span class="nf">Bar::baz</span><span class="p">;</span> <span class="c1"># 42</span>
</code></pre></div><h2 id="自增优先级">自增优先级</h2>
<h3 id="prefix-">prefix ++</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数增加 1, 并返回增加后的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">++</span><span class="nv">$x</span><span class="p">;</span>    <span class="c1"># 4</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>      <span class="c1"># 4</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法, 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<h3 id="prefix---">prefix &ndash;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">--</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数减少 1, 并返回减少后的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="o">--</span><span class="nv">$x</span><span class="p">;</span>       <span class="c1"># 2</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 2</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法, 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<h3 id="postfix--7">postfix ++</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">++</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数增加 1, 并返回 <code>unincremented</code> 的那个值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>       <span class="c1"># 3</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 4</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法, 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<p>注意这并不一定返回它的参数。例如, 对于未定义的值, 它返回 0:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="o">++</span><span class="p">;</span>       <span class="c1"># 0</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 1</span>
</code></pre></div><h3 id="postfix---">postfix &ndash;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">--</span><span class="p">&gt;(</span><span class="nv">$x</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把它的参数减少 1, 并返回 <code>undecremented</code> 的那个值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x--</span><span class="p">;</span>       <span class="c1"># 3</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># 2</span>
</code></pre></div><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法, 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<p>注意这并不一定返回它的参数。例如, 对于未定义的值, 它返回 0:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$x--</span><span class="p">;</span>       <span class="c1"># 0</span>
<span class="nb">say</span> <span class="nv">$x</span><span class="p">;</span>         <span class="c1"># -1</span>
</code></pre></div><h2 id="求幂优先级">求幂优先级</h2>
<h3 id="infix-">infix **</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">**</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">right</span><span class="p">&gt;</span>
</code></pre></div><p>求幂操作符把它的两个参数都强制转为 <code>Numeric</code> , 然后计算, 右侧为幂。</p>
<p>如果 <code>**</code> 右边是一个非负整数, 并且左侧是任意精度类型(Int, FatRat), 那么计算不会损失精度。</p>
<h2 id="象形一元操作符的优先级">象形一元操作符的优先级</h2>
<h3 id="prefix--1">prefix ?</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool。注意, 这会使 Junctions 失效。</p>
<h3 id="prefix--2">prefix !</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>否定的布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool, 并返回结果的否定值。注意, 这会使 Junctions 失效。</p>
<h3 id="prefix--3">prefix +</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型。</p>
<h3 id="prefix--">prefix -</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>否定的 Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型, 并返回结果的否定值。</p>
<h3 id="prefix--4">prefix ~</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
</code></pre></div><p>字符串上下文操作符。</p>
<p>通过在参数身上调用 <code>Str</code> 方法强制把参数转为 <code>Str</code> 类型。</p>
<h3 id="prefix--5">prefix |</h3>
<p>将 Capture, Enum, Pair, List, EnumMap 和 Hash 展平到参数列表中。</p>
<p>（在 Rakudo 中, 这不是作为一个合适的操作符来实现的, 而是编译器中的一种特殊情况, 这意味着它只对参数列表有效, 而非在任意代码中都有效。）</p>
<h3 id="prefix--6">prefix +^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+^</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>整数按位取反。</p>
<p>将参数强转为 Int 类型并对结果按位取反, 假设两者互补。</p>
<h3 id="prefix--7">prefix ?^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?^</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>布尔按位取反。</p>
<p>将参数强转为 Bool, 然后按位反转, 这使它和 prefix:&lt;!&gt;  一样。</p>
<h3 id="prefix--8">prefix ^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span>
</code></pre></div><p>upto 操作符.</p>
<p>强制把它的参数转为 Numeric, 生成一个从 0 直到（但是排除） 参数为止的范围。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">^</span><span class="mi">5</span><span class="p">;</span>         <span class="c1"># 0..^5</span>
<span class="k">for</span> <span class="o">^</span><span class="mi">5</span> <span class="p">{</span> <span class="p">}</span>      <span class="c1"># 5 iterations</span>
</code></pre></div><h2 id="乘法优先级">乘法优先级</h2>
<h3 id="infix--1">infix *</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">*</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>把两边的参数都强转为 Numeric 并把它们相乘。结果是一个更宽的类型。查看 Numeric 获取更详细信息。</p>
<h3 id="infix--2">infix /</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">/</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>把两边的参数都强制为 Numeric, 并用左边除以右边的数。整数相除返回 Rat, 否则返回&quot;更宽类型&quot;的结果。</p>
<h3 id="infix-div">infix div</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">div</span><span class="p">&gt;(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>整除。向下取整。</p>
<h3 id="infix--3">infix %</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">%</span><span class="p">&gt;(</span><span class="nv">$x</span><span class="o">,</span> <span class="nv">$y</span><span class="p">)</span> <span class="k">return</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>模操作符。首先强制为 Numeric。</p>
<p>通常, 下面的等式是成立的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$x</span> <span class="nv">%</span> <span class="nv">$y</span> <span class="o">==</span> <span class="nv">$x</span> <span class="o">-</span> <span class="nb">floor</span><span class="p">(</span><span class="nv">$x</span> <span class="o">/</span> <span class="nv">$y</span><span class="p">)</span> <span class="o">*</span> <span class="nv">$y</span>
</code></pre></div><h3 id="infix--4">infix %%</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">%%</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>整除操作符, 如果 <code>$a % $b == 0</code> 则返回 True.</p>
<h3 id="infix-mod">infix mod</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">mod</span><span class="p">&gt;(</span><span class="nb">Int:D</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Int:D</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>整数取模操作符。返回整数取模操作的剩余部分。</p>
<h3 id="infix--5">infix +&amp;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+&amp;</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>Numeric 按位 <code>AND</code>。把两个参数都强转为 Int 并执行按位 AND 操作, 假定两者是互补的。</p>
<h3 id="infix--6">infix +&lt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2"> +&lt; </span><span class="p">&gt;&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>向左移动整数个位。</p>
<h3 id="infix--7">infix +&gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;&lt;</span><span class="s2"> +&gt; </span><span class="p">&gt;&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>向右移动整数个位。</p>
<h3 id="infix-gcd">infix gcd</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gcd</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数都为 Int 并返回最大公分母（greatest common denominator）。</p>
<h3 id="infix-lcm">infix lcm</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lcm</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数为 Int 并返回最小公倍数(least common multiple)</p>
<h2 id="加法优先级">加法优先级</h2>
<h3 id="infix--8">infix +</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>强制两个参数为 Numeric 并把它们相加。</p>
<h3 id="infix--">infix -</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">-</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Numeric:D</span>
</code></pre></div><p>强制两个参数为 Numeric 并用第一个参数减去第二个参数。</p>
<h3 id="infix--9">infix +|</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数为 Int 并执行按位 OR（包括 OR）</p>
<h3 id="infix--10">infix +^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">+^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int:D</span>
</code></pre></div><p>强制两个参数为 Int 并执行按位 XOR（不包括 OR）</p>
<h3 id="infix--11">infix ?|</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">?|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>强制两个参数为 Bool 并执行逻辑 OR（不包括 OR）</p>
<h2 id="重复操作符优先级">重复操作符优先级</h2>
<h3 id="infix-x">infix x</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">x</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
</code></pre></div><p>把 <code>$a</code> 强转为 Str , 把 <code>$b</code> 强转为 Int, 并重复字符串 <code>$b</code> 次。如果 <code>$b &lt;= 0</code> 则返回空字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">3</span><span class="p">;</span>       <span class="c1"># ababab</span>
<span class="nb">say</span> <span class="mi">42</span> <span class="nb">x</span> <span class="mi">3</span><span class="p">;</span>         <span class="c1"># 424242</span>
</code></pre></div><h3 id="infix-xx">infix xx</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">xx</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span>
</code></pre></div><p>返回一组重复的 <code>$a</code> 并计算 <code>$b</code> 次（<code>$b</code> 被强转为 Int）。如果 <code>$b &lt;= 0</code> ,则返回一个空列表。</p>
<p>每次重复都会计算左侧的值, 所以</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span> <span class="ow">xx</span> <span class="mi">5</span>
</code></pre></div><p>返回 5 个不同的数组（但是每次都是相同的内容）并且</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">rand</span> <span class="ow">xx</span> <span class="mi">3</span>
</code></pre></div><p>返回 3 个独立的伪随机数。右侧可以是 <code>*</code>, 这时会返回一个惰性的, 无限的列表。</p>
<h2 id="连结">连结</h2>
<h3 id="infix--12">infix ~</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Str:D</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>  <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">~</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强制两个参数为 Str 并连结它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">c</span><span class="p">&#39;;</span>     <span class="c1"># abc</span>
</code></pre></div><h2 id="junctive-and-all-优先级">Junctive AND (all) 优先级</h2>
<h3 id="infix--13">infix &amp;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">&amp;</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>用它的参数创建一个 <code>all</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="junctive-or-any-precedence">Junctive OR (any) Precedence</h2>
<h3 id="infix--14">infix |</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">|</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>用它的参数创建一个 <code>any</code> Junction。查看 Junctions 获取更多详情。</p>
<h3 id="infix--15">infix ^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Junction:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>用它的参数创建一个 <code>one</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="named-unary-precedence">Named Unary Precedence</h2>
<h3 id="prefix-temp">prefix temp</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">temp</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span>
</code></pre></div><p>temporizes 传入的变量作为参数, 这意味着退出作用域后它被重置为旧值。（这和 Perl 5 中的 local 操作符类似, 除了 temp 不重置值之外。）</p>
<h3 id="prefix-let">prefix let</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">let</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span>
</code></pre></div><p>假定重置：如果通过异常或 fail() 退出当前作用域, 旧值就会被恢复。</p>
<h2 id="nonchaining-binary-precedence">Nonchaining Binary Precedence</h2>
<h3 id="infix-does">infix does</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">does</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$obj</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$role</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>在运行时把 <code>$role</code> 混合进 <code>$obj</code> 中。要求 <code>$obj</code> 是可变的。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role, 它可以表现的像是一个 role, 例如枚举值。</p>
<h3 id="infix-but">infix but</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">but</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$obj</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$role</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>把 <code>$role</code> 混合进 <code>$obj</code> 并创建一个 <code>$obj</code> 的副本。因为 <code>$obj</code> 是不能修改的, 但是能使用 mixins 用于创建不可变值。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role, 它可以表现的像是一个 role, 例如枚举值。</p>
<h3 id="infix-cmp">infix cmp</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>      <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span>   <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span>    <span class="nb">Str:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>   <span class="n">Enum:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">cmp</span><span class="p">&gt;(</span><span class="nb">Version:D</span><span class="o">,</span> <span class="nb">Version:D</span><span class="p">)</span>
</code></pre></div><p>一般的, “智能的” 三路比较器。</p>
<p>比较字符串时使用字符串语义, 比较数字时使用数字语义, 比较 Pair 对象时, 先比较键, 再比较值, 等等。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$a</span> <span class="ow">eqv</span> <span class="nv">$b</span><span class="o">,</span> <span class="nb">then</span> <span class="nv">$a</span> <span class="ow">cmp</span> <span class="nv">$b</span> <span class="n">always</span> <span class="k">returns</span> <span class="n">Order::Same</span><span class="o">.</span>
<span class="nb">say</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">cmp</span> <span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">);</span>      <span class="c1"># Less</span>
<span class="nb">say</span> <span class="mi">4</span>        <span class="ow">cmp</span> <span class="mf">4.0</span><span class="p">;</span>           <span class="c1"># Same</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span>      <span class="ow">cmp</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>           <span class="c1"># More</span>
</code></pre></div><h3 id="infix-leg">infix leg</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>  <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">leg</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>字符串三路比较器。leg 是  less, equal 还有 greater 的简写形式？</p>
<p>把两个参数都强转为 <code>Str</code>, 然后按照字母次序比较。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>        <span class="nb">Less</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>        <span class="nb">Same</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>        <span class="nb">More</span>
</code></pre></div><h3 id="infix--16">infix &lt;=&gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=&gt;</span><span class="p">»(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Order:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>Numeric 三路比较器。</p>
<p>把两个参数强转为 Real, 并执行数值比较。</p>
<h3 id="infix--17">infix ..</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">..</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range。</p>
<h3 id="infix--18">infix ..^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">..^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range, 不包含末端。</p>
<h3 id="infix--19">infix ^..</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^..</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range, 不包含开始端点。</p>
<h3 id="infix--20">infix ^..^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^..^</span><span class="p">&gt;(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Range:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">none</span><span class="p">&gt;</span>
</code></pre></div><p>由参数创建一个 Range, 不包含开端和末端。</p>
<h2 id="chaining-binary-precedence">Chaining Binary Precedence</h2>
<h3 id="infix--21">infix ==</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nv">$</span><span class="o">,</span> <span class="nv">$</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc:</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Rational:D</span><span class="o">,</span> <span class="nb">Rational:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Complex:D</span><span class="o">,</span> <span class="nb">Complex:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">==</span><span class="p">&gt;(</span><span class="nb">Numeric:D</span><span class="o">,</span> <span class="nb">Numeric:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Numeric（如果必要）, 并返回 True 如果它们相等。</p>
<h3 id="infix--22">infix !=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!=</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</code></pre></div><p>强转两个参数为 Numeric（如果必要）, 并返回 True 如果它们不相等。</p>
<h3 id="infix--23">infix &lt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--24">infix &lt;=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&lt;=</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--25">infix &gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数大于第二个参数。</p>
<h3 id="infix--26">infix &gt;=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Int:D</span><span class="o">,</span> <span class="nb">Int:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Num:D</span><span class="o">,</span> <span class="nb">Num:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">&gt;=</span><span class="p">»(</span><span class="nb">Real:D</span><span class="o">,</span> <span class="nb">Real:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Real （如果必要）, 并返回 True 如果第一个参数大于或等于第二个参数。</p>
<h3 id="infix-eq">infix eq</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>  <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eq</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数等于第二个参数。</p>
<p>助记法: equal</p>
<h3 id="infix-ne">infix ne</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ne</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 False 如果第一个参数等于第二个参数。</p>
<p>助记法: not equal</p>
<h3 id="infix-gt">infix gt</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">gt</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater than</p>
<h3 id="infix-ge">infix ge</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ge</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater or equal</p>
<h3 id="infix-lt">infix lt</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">lt</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数小于第二个参数。</p>
<p>助记法: less than</p>
<h3 id="infix-le">infix le</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span> <span class="nb">Mu</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="nb">Mu</span><span class="o">,</span>   <span class="nb">Mu</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">le</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span> <span class="nb">Str:D</span><span class="p">)</span>
</code></pre></div><p>强转两个参数为 Str（如果必要）, 并返回 True 如果第一个参数小于或等于第二个参数。</p>
<p>助记法: less or equal</p>
<h3 id="infix-before">infix before</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>      <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span>   <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span>    <span class="nb">Str:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>   <span class="n">Enum:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">before</span><span class="p">&gt;(</span><span class="nb">Version:D</span><span class="o">,</span> <span class="nb">Version:D</span><span class="p">)</span>
</code></pre></div><p>一般的排序, 使用和 cmp 相同的语义。如果第一个参数小于第二个参数则返回 True。</p>
<h3 id="infix-after">infix after</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span>      <span class="nb">Any</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Real:D</span><span class="o">,</span>   <span class="nb">Real:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Str:D</span><span class="o">,</span>    <span class="nb">Str:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="n">Enum:D</span><span class="o">,</span>   <span class="n">Enum:D</span><span class="p">)</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">after</span><span class="p">&gt;(</span><span class="nb">Version:D</span><span class="o">,</span> <span class="nb">Version:D</span><span class="p">)</span>
</code></pre></div><p>一般的排序, 使用和 cmp 相同的语义。如果第一个参数大于第二个参数则返回 True。</p>
<h3 id="infix-eqv">infix eqv</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
</code></pre></div><p>等值操作符。如果两个参数在结构上相同就返回 True。例如, 相同类型（并且递归）包含相同的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="ow">eqv</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># True</span>
<span class="nb">say</span> <span class="nb">Any</span> <span class="ow">eqv</span> <span class="nb">Any</span><span class="p">;</span>                    <span class="c1"># True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="ow">eqv</span> <span class="mi">2</span><span class="p">;</span>                        <span class="c1"># False</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="ow">eqv</span> <span class="mf">1.0</span><span class="p">;</span>                      <span class="c1"># False</span>
</code></pre></div><p>对于任意对象使用默认的 eqv 操作是不可能的。例如, eqv 不认为同一对象的两个实例在结构上是相等的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">eqv</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>  <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> False</span>
</code></pre></div><p>要得到这个类的对象相等（eqv）语义, 需要实现一个合适的中缀 eqv 操作符：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">eqv</span><span class="p">&gt;(</span><span class="n">A</span> <span class="nv">$l</span><span class="o">,</span> <span class="n">A</span> <span class="nv">$r</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$l</span><span class="o">.</span><span class="nf">a</span> <span class="ow">eqv</span> <span class="nv">$r</span><span class="o">.</span><span class="nf">a</span> <span class="p">}</span>
<span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="ow">eqv</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">);</span>  <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> True</span>
</code></pre></div><h3 id="infix--27">infix ===</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">===</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">===</span><span class="p">&gt;(</span><span class="nb">Any</span><span class="o">,</span> <span class="nb">Any</span><span class="p">)</span>
</code></pre></div><p>值相等。如果两个参数都是同一个对象则返回 True。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">===</span> <span class="nv">$a</span><span class="p">;</span>              <span class="c1"># True</span>
<span class="nb">say</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span> <span class="o">===</span> <span class="n">A</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>        <span class="c1"># False</span>
<span class="nb">say</span> <span class="n">A</span> <span class="o">===</span> <span class="n">A</span><span class="p">;</span>                <span class="c1"># True</span>
</code></pre></div><p>对于值的类型,  <code>===</code> 表现的和 eqv 一样:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>            <span class="c1"># True</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">b</span><span class="p">&#39;;</span>            <span class="c1"># False</span>

<span class="c1"># different types</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">===</span> <span class="mf">1.0</span><span class="p">;</span>              <span class="c1"># False</span>
</code></pre></div><p><code>===</code> 使用 <code>WHICH</code> 方法来获取对象相等, 所以所有的值类型必须重写方法 <code>WHICH</code>。</p>
<h3 id="infix--28">infix =:=</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=:=</span><span class="p">&gt;(</span><span class="nb">Mu</span> \<span class="n">a</span><span class="o">,</span> <span class="nb">Mu</span> \<span class="n">b</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=:=</span><span class="p">&gt;(</span><span class="nb">Mu</span> \<span class="n">a</span><span class="o">,</span> <span class="nb">Mu</span> \<span class="n">b</span><span class="p">)</span>
</code></pre></div><p>容器相等。返回 True 如果两个参数都绑定到同一个容器上。如果它返回 True, 那通常意味着修改一个参数也会同时修改另外一个。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">=:=</span> <span class="nv">$b</span><span class="p">;</span>      <span class="c1"># False</span>
<span class="nv">$b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>             <span class="c1"># 1</span>
<span class="nv">$b</span> <span class="o">:=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">=:=</span> <span class="nv">$b</span><span class="p">;</span>      <span class="c1"># True</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$b</span><span class="p">;</span>             <span class="c1"># 5</span>
</code></pre></div><h3 id="infix--29">infix ~~</h3>
<p>智能匹配操作符。把左侧参数起别名为 <code>$_</code> , 然后计算右侧的值, 并在它身上调用 <code>.ACCEPTS($_)</code> 。匹配的语义由右侧操作数的类型决定。</p>
<p>这儿有一个内建智能匹配函数的摘要：</p>
<pre><code>右侧      比较语义
Mu:U	  类型检查
Str	      字符串相等
Numeric	  数值相等
Regex	  正则匹配
Callable  调用的布尔结果
Any:D	  对象相等
</code></pre><h2 id="tight-and-precedence">Tight AND Precedence</h2>
<h3 id="infix--30">infix &amp;&amp;</h3>
<p>在布尔上下文中返回第一个求值为 False 的参数, 否则返回最后一个参数。</p>
<p>注意这是短路操作符, 如果其中的一个参数计算为 false 值, 那么该参数右侧的值绝不会被计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">c</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">never called</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nf">a</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">b</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">c</span><span class="p">();</span>      <span class="c1"># 0</span>
</code></pre></div><h2 id="tight-or-precedence">Tight OR Precedence</h2>
<h3 id="infix--31">infix ||</h3>
<p>在布尔上下文中返回第一个求值为 True 的参数, 否则返回最后一个参数。</p>
<p>注意这是短路操作符, 如果其中的一个参数计算为 true 值, 那么该参数右侧的值绝不会被计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">a</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">b</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">c</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">never called</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="nb">say</span> <span class="nf">a</span><span class="p">()</span> <span class="o">||</span> <span class="nf">b</span><span class="p">()</span> <span class="o">||</span> <span class="nf">c</span><span class="p">();</span>      <span class="c1"># 1</span>
</code></pre></div><h3 id="infix--32">infix ^^</h3>
<p>返回第一个值为 true 的参数如果只有一个的话, 否则返回 Nil。只要找到两个值为 true 的参数就发生短路。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">0</span> <span class="o">^^</span> <span class="mi">42</span><span class="p">;</span>                <span class="c1"># 42</span>
<span class="nb">say</span> <span class="mi">0</span> <span class="o">^^</span> <span class="mi">42</span> <span class="o">^^</span> <span class="mi">1</span> <span class="o">^^</span> <span class="nb">die</span> <span class="mi">8</span><span class="p">;</span>  <span class="c1"># (empty line)</span>
</code></pre></div><p>注意, 这个操作符的语义可能不是你假想的那样： infix <code>^^</code> 翻到它找到的第一个 true 值, 找到第二个 true 值后永远地反转为 Nil 值, 不管还有多少 true 值。（换句话说, 它的语义是&quot;找到一个真值&quot;, 而不是布尔起奇偶校验语义）</p>
<h3 id="infix--33">infix //</h3>
<p>Defined-or  操作符。返回第一个定义了的操作数, 否则返回最后一个操作数。短路操作符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nb">Any</span> <span class="o">//</span> <span class="mi">0</span> <span class="o">//</span> <span class="mi">42</span><span class="p">;</span>         <span class="c1"># 0</span>
</code></pre></div><h3 id="infix-min">infix min</h3>
<p>返回参数的最小值。语义由 cmp 语义决定。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$foo</span> <span class="nb">min</span><span class="o">=</span> <span class="mi">0</span>  <span class="c1"># read as: $foo decreases to 0</span>
</code></pre></div><h3 id="infix-max">infix max</h3>
<p>返回参数的最大值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$foo</span> <span class="nb">max</span><span class="o">=</span> <span class="mi">0</span>  <span class="c1"># read as: $foo increases to 0</span>
</code></pre></div><h2 id="conditional-operator-precedence">Conditional Operator Precedence</h2>
<h3 id="infix---1">infix ?? !!</h3>
<p>三目操作符, 条件操作符。</p>
<p><code>$condition ?? $true !! $false</code> 计算并返回 <code>$true</code> 表达式, 如果 <code>$condition</code> 为真的话。否则计算并返回 <code>$false</code> 分支。</p>
<h3 id="infix-ff">infix ff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>触发器操作符。</p>
<p>把两个参数都跟 <code>$_</code> 进行比较（即, <code>$_ ~~ $a</code> 和 <code>$_ ~~ $b</code>）。求值为 False 直到左侧的智能匹配为真, 这时, 它求值为真, 直到右侧的智能匹配为真。</p>
<p>实际上, 左边的参数是&quot;开始”条件, 右侧的参数是”停止” 条件。这种结构一般用于收集只在特定区域的行。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$excerpt</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/END/;</span><span class="s">
</span><span class="s">Here&#39;s some unimportant text.
</span><span class="s">=begin code
</span><span class="s">    This code block is what we&#39;re after.
</span><span class="s">    We&#39;ll use &#39;ff&#39; to get it.
</span><span class="s">=end code
</span><span class="s">More unimportant text.
</span><span class="s"></span><span class="p">END</span>

<span class="k">my</span> <span class="nv">@codelines</span> <span class="o">=</span> <span class="k">gather</span> <span class="k">for</span> <span class="nv">$excerpt</span><span class="o">.</span><span class="nb">lines</span> <span class="p">{</span>
    <span class="nb">take</span> <span class="nv">$_</span> <span class="k">if</span> <span class="p">&#34;</span><span class="s2">=begin code</span><span class="p">&#34;</span> <span class="ow">ff</span> <span class="p">&#34;</span><span class="s2">=end code</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="c1"># this will print four lines,</span>
<span class="c1"># starting with &#34;=begin code&#34; and ending with &#34;=end code&#34;</span>
<span class="nb">say</span> <span class="nv">@codelines</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
</code></pre></div><p>匹配开始条件之后, 操作符会继续将停止条件与 <code>$_</code> 进行匹配, 如果成功就做相应地表现。在这个例子中, 只有第一个元素被打印了：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">AB C D B E F</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">B</span><span class="o">/</span><span class="p">;</span>  <span class="c1"># prints only &#34;AB&#34;</span>
<span class="p">}</span>
</code></pre></div><p>如果你想测试开始条件, 并且没有结束条件, <code>*</code> 能用作 “停止” 条件。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">A B C D E</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">*</span><span class="p">;</span> <span class="c1"># prints C, D, and E</span>
<span class="p">}</span>
</code></pre></div><p>对于 sed-like 版本, 在开始条件匹配成功之后, 它不会使用停止条件与 <code>$_</code> 进行匹配。</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-1">infix ^ff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^ff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 <code>ff</code> 那样工作, 除了它不会在条目匹配开始条件时返回真。（包括匹配停止条件的条目）</p>
<p>一个比较:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B and C</span>
</code></pre></div><p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-2">infix ff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">ff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 ff 那样工作, 除了它不会在条目匹配停止条件时返回真。（包括第一次匹配开始条件的条目）</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints A and B</span>
</code></pre></div><p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-3">infix ^ff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^ff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 ff 那样工作, 除了它不会在条目匹配停止条件时返回真, 也不会在条目匹配开始时返回真。（或者两者）</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">ff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^ff</span><span class="o">^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B</span>
</code></pre></div><p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff">infix fff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>执行 sed-like 那样的 flipflop 操作, 在其中, 它返回 False 直到左侧的参数与 <code>$_</code> 智能匹配, 并且在那之后返回 True 直到右侧的参数和 <code>$_</code>  智能匹配。</p>
<p>像 ff 那样工作, 除了它每次调用只尝试一个参数之外。即, 如果 <code>$_</code> 和左侧的参数智能匹配, fff 随后不会尝试将同一个 <code>$_</code> 和右侧的参数进行匹配。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">&lt;</span><span class="s">AB C D B E F</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">B</span><span class="o">/</span><span class="p">;</span>  <span class="c1"># Prints &#34;AB&#34;, &#34;C&#34;, &#34;D&#34;, and &#34;B&#34;</span>
<span class="p">}</span>
</code></pre></div><p>对于 non-sed-like 版本, 查看 <code>ff</code>.</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-1">infix ^fff</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^fff</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 fff 那样, 除了它对于左侧的匹配不返回真之外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B and C</span>
</code></pre></div><p>对于 non-sed 版本, 查看 <code>^ff</code>。</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-2">infix fff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">fff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 fff 那样, 除了它对于右侧的匹配不返回真之外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>  <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints A and B</span>
</code></pre></div><p>对于 non-sed 版本, 查看 <code>ff^</code>。</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-3">infix ^fff^</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">^fff^</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>像 fff 那样, 除了它对于左侧和右侧的匹配都不返回真之外。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@list</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">A B C</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">fff</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span>   <span class="c1"># prints A, B, and C</span>
<span class="nb">say</span> <span class="nv">$_</span> <span class="k">if</span> <span class="o">/</span><span class="n">A</span><span class="o">/</span> <span class="ow">^fff</span><span class="o">^</span> <span class="o">/</span><span class="n">C</span><span class="o">/</span> <span class="k">for</span> <span class="nv">@list</span><span class="p">;</span> <span class="c1"># prints B</span>
</code></pre></div><p>对于 non-sed 版本, 查看 <code>^ff^</code>.</p>
<p>这个操作符不能被重载, 因为它被编译器特殊处理过。</p>
<h2 id="item-assignment-precedence">Item Assignment Precedence</h2>
<h3 id="infix--34">infix =</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">=</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$a</span> <span class="k">is</span> <span class="k">rw</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$b</span><span class="p">)</span>
</code></pre></div><p>Item 赋值。</p>
<p>把 = 号右侧的值放入左侧的容器中。它真正的语义是由左侧的容器类型决定的。</p>
<p>（注意 item 赋值和列表赋值的优先级级别不同, 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符）。</p>
<h3 id="infix--35">infix =&gt;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">«</span><span class="s2">=&gt;</span><span class="p">»(</span><span class="nv">$key</span><span class="o">,</span> <span class="nb">Mu</span> <span class="nv">$value</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Pair:D</span>
</code></pre></div><p>Pair 构造器。</p>
<p>使用左侧值作为键, 右侧值作为值, 构造一个 Pair 对象。</p>
<p>注意 <code>=&gt;</code> 操作符是语法上的特例, 在这个结构中, 它允许左侧是一个未被引起的标识符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$p</span> <span class="o">=</span> <span class="s">a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nb">key</span><span class="p">;</span>         <span class="c1"># a</span>
<span class="nb">say</span> <span class="nv">$p</span><span class="o">.</span><span class="nb">value</span><span class="p">;</span>       <span class="c1"># 1</span>
</code></pre></div><p>在参数列表中, 在 <code>=&gt;</code> 左侧使用未被引起的标识符构建的 Pair 会被解释为一个具名参数。</p>
<p>查看 Terms 语言文档了解更多创建 Pair 对象的方式。</p>
<h2 id="loose-unary-precedence">Loose Unary Precedence</h2>
<h3 id="prefix-not">prefix not</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">not</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$x</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）, 并返回否定的结果。</p>
<h3 id="prefix-so">prefix so</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">prefix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">so</span><span class="p">&gt;(</span><span class="nb">Mu</span> <span class="nv">$x</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Bool:D</span>
</code></pre></div><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）, 并返回结果。</p>
<h2 id="逗号操作符优先级">逗号操作符优先级</h2>
<h3 id="infix--36">infix :</h3>
<p>就像中缀操作符 <code>,</code> 那样, <code>:</code> 用作参数分隔符, 并把它左侧的参数标记为调用者。</p>
<p>那会把函数调用转为方法调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">substr</span><span class="p">(&#39;</span><span class="s1">abc</span><span class="p">&#39;</span><span class="o">:</span> <span class="mi">1</span><span class="p">);</span> <span class="c1"># same as &#39;abc&#39;.substr(1)</span>
</code></pre></div><p>Infix <code>:</code> 只允许出现在非方法调用的第一个参数后面。在其它位置它会是语法错误。</p>
<h2 id="list-infix-precedence">List Infix Precedence</h2>
<h3 id="infix-z">infix Z</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">Z</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@lists</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</code></pre></div><p>Zip operator。</p>
<p>Z 像一个拉链那样把列表插入进来, 只要第一个输入列表耗尽就停止：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span> <span class="ow">Z</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">Z</span> <span class="p">&lt;</span><span class="s">+ -</span><span class="p">&gt;)</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>  <span class="c1"># ((1, &#34;a&#34;, &#34;+&#34;), (2, &#34;b&#34;, &#34;-&#34;)).list</span>
</code></pre></div><p><code>Z</code> 操作符也作为元操作符存在：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">200</span> <span class="ow">Z</span><span class="o">+</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">23</span><span class="p">;</span>             <span class="c1"># 142, 223</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">Z</span><span class="o">~</span> <span class="p">&#39;</span><span class="s1">x</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="mi">3</span><span class="p">;</span>    <span class="c1"># 1ax 2bx 3cx</span>
</code></pre></div><h3 id="infix-x-1">infix X</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">X</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@lists</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">List:D</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">chain</span><span class="p">&gt;</span>
</code></pre></div><p>从所有列表创建一个外积。最右边的元素变化得最迅速。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">X</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">X</span> <span class="mi">9</span>

<span class="c1"># produces   (1, &#39;a&#39;, 9), (1, &#39;b&#39;, 9), (1, &#39;c&#39;, 9),</span>
<span class="c1">#         (2, &#39;a&#39;, 9), (2, &#39;b&#39;, 9), (2, &#39;c&#39;, 9),</span>
<span class="c1">#         (3, &#39;a&#39;, 9), (3, &#39;b&#39;, 9), (3, &#39;c&#39;, 9)</span>

</code></pre></div><p>X 操作符也可以作为元操作符：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">1</span><span class="o">..</span><span class="mi">3</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&lt;</span><span class="s">a b c</span><span class="p">&gt;</span> <span class="ow">X</span><span class="o">~</span> <span class="mi">9</span>

<span class="c1"># produces   &#39;1a9&#39;, &#39;1b9&#39;, &#39;1c9&#39;,</span>

         <span class="p">&#39;</span><span class="s1">2a9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">2b9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">2c9</span><span class="p">&#39;</span><span class="o">,</span>
         <span class="p">&#39;</span><span class="s1">3a9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">3b9</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">3c9</span><span class="p">&#39;</span>
</code></pre></div><h3 id="infix--37">infix &hellip;</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">...</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">...^</span><span class="p">&gt;(</span><span class="o">**</span><span class="nv">@</span><span class="p">)</span> <span class="k">is</span> <span class="nc">assoc</span><span class="p">&lt;</span><span class="s">list</span><span class="p">&gt;</span>
</code></pre></div><p>序列操作符是一个用于产生惰性列表的普通操作符。</p>
<p>它可以有一个初始元素和一个生成器在 <code>…</code> 的左侧, 在右侧是一个端点。</p>
<p>序列操作符会使用尽可能多的参数来调用生成器。参数会从初始元素和已生成元素中获取。</p>
<p>默认的生成器是 <code>*.succ</code> 或 <code>*.pred</code>, 取决于末端怎么比较：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">4</span><span class="p">;</span>        <span class="c1"># 1 2 3 4</span>
<span class="nb">say</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1"># 4 3 2 1</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">...</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;;</span>    <span class="c1"># a b c d e</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">e</span><span class="p">&#39;</span> <span class="o">...</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>    <span class="c1"># e d c b a</span>
</code></pre></div><p><code>*</code> (Whatever) 末端生成一个无限序列, 使用的是默认的生成器 <code>*.succ</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># 1 2 3 4 5</span>
</code></pre></div><p>自定义生成器是在 <code>…</code> 操作符之前的最后一个参数。下面这个自定义生成器接收两个参数, 生成了斐波纳契数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span> <span class="p">}</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">8</span><span class="o">]</span><span class="p">;</span>    <span class="c1"># 1 1 2 3 5 8 13 21</span>
<span class="c1"># same but shorter</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...</span> <span class="o">*</span><span class="p">)</span><span class="o">[^</span><span class="mi">8</span><span class="o">]</span><span class="p">;</span>                      <span class="c1"># 1 1 2 3 5 8 13 21</span>
</code></pre></div><p>当然自定义生成器也能只接收一个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">5</span><span class="o">,</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">...</span> <span class="mi">40</span><span class="p">;</span>                       <span class="c1"># 5 10 20 40</span>
</code></pre></div><p>生成器的参数个数至少要和初始元素的个数一样多。</p>
<p>如果没有生成器, 并且有不止一个初始元素, 所有的初始元素都是数值, 那么序列操作符会尝试推导出生成器。它知道数学和几何序列。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span> <span class="o">...</span> <span class="mi">12</span><span class="p">;</span>     <span class="c1"># 2 4 6 8 10 12</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span> <span class="o">...</span> <span class="mi">32</span><span class="p">;</span>     <span class="c1"># 1 2 4 8 16 32</span>
</code></pre></div><p>如果末端不是 <code>*</code>, 它会和每个生成的元素进行智能匹配, 当智能匹配成功的时候序列就被终止。对于 <code>...</code>  操作符, 会包含最后一个元素, 对于 <code>...^</code> 操作符, 会排除最后的那个元素。</p>
<p>这允许你这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...^</span> <span class="o">*&gt;=</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div><p>来生成所有直到 100 但不包括 100 的斐波纳契数。</p>
<p><code>...</code> 操作符还会把初始值看作”已生成的元素”, 所以它们也会对末端进行检查：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$end</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nb">say</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">16</span> <span class="o">...</span> <span class="nv">$end</span><span class="p">;</span>
<span class="c1"># outputs 1 2 4</span>
</code></pre></div><h2 id="list-prefix-precedence">List Prefix Precedence</h2>
<h3 id="infix--38">infix =</h3>
<p>列表赋值。 它真正的语义是由左侧的容器类型决定的。查看 Array 和 Hash 获取普通案例。</p>
<p>item 赋值和列表赋值的优先级级别不同, 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符。</p>
<h3 id="infix--39">infix :=</h3>
<p>绑定。而 <code>$x = $y</code> 是把 <code>$y</code> 中的值放到 <code>$x</code> 里面, <code>$x := $y</code> 会让 <code>$x</code> 和 <code>$y</code> 引用同一个值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span><span class="p">;</span>
<span class="nv">$b</span><span class="o">++</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$a</span><span class="p">;</span>
</code></pre></div><p>这会输出 42, 因为 <code>$a</code> 和 <code>$b</code> 都包含了数字 42, 但是容器是不同的。</p>
<pre><code>my $a = 42;
my $b := $a;
$b++;
say $a;
</code></pre><p>这会打印 43, 因为 <code>$b</code> 和 <code>$a</code> 都代表着<code>同一个对象</code>。</p>
<h3 id="infix--40">infix ::=</h3>
<p>只读绑定. 查看 infix :=.</p>
<h3 id="listop-">listop &hellip;</h3>
<p>这是 yada, yada, yada 操作符 或 stub 操作符。如果它在子例程或类型中是唯一的语句, 它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>...</code> 语句被执行了, 它会调用 <code>&amp;fail</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--1">listop !!!</h3>
<p>如果它在子例程或类型中是唯一的语句, 它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>!!!</code> 语句被执行了, 它会调用 <code>&amp;die</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--2">listop ???</h3>
<p>如果它在子例程或类型中是唯一的语句, 它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>???</code> 语句被执行了, 它会调用 <code>&amp;warn</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h2 id="loose-and-precedence">Loose AND precedence</h2>
<h3 id="infix-and">infix and</h3>
<p>和中缀操作符 <code>&amp;&amp;</code> 一样, 除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 False 的操作数, 否则返回最后一个操作数。短路操作符。</p>
<h3 id="infix-andthen">infix andthen</h3>
<p>返回第一个未定义的参数, 否则返回最后一个参数。短路操作符。左侧的结果被绑定到 <code>$_</code> 身上, 在右侧中使用, 或者作为参数被传递, 如果右侧是一个 block 或 pointy block.</p>
<h2 id="loose-or-precedence">Loose OR Precedence</h2>
<h3 id="infix-or">infix or</h3>
<p>和中缀操作符 <code>||</code> 一样, 除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 True 的参数, 否则返回最后一个参数。短路操作符。</p>
<h3 id="infix-orelse">infix orelse</h3>
<p>和中缀操作符 <code>//</code> 一样, 除了优先级更宽松之外。</p>
<p>返回第一个定义过的参数, 否则返回最后一个参数。短路操作符。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/operator" term="operator" label="operator" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的模块]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-23-modules-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 模块" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-23-modules-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Modules in Raku</blockquote><h1 id="modules">Modules</h1>
<h2 id="exporting-and-selective-importing">Exporting and Selective Importing</h2>
<h3 id="is-export">is export</h3>
<p>packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 <code>is export</code> 特性来导出。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="k">our</span> <span class="nv">$var</span> <span class="k">is</span> <span class="k">export</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">sub</span> <span class="nf">foo</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>
<span class="k">constant</span> <span class="nv">$FOO</span> <span class="k">is</span> <span class="k">export</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">foobar</span><span class="p">&#34;;</span>
<span class="k">enum</span> <span class="n">FooBar</span> <span class="k">is</span> <span class="k">export</span> <span class="p">&lt;</span><span class="s">one two three</span><span class="p">&gt;;</span>

<span class="c1"># Packages like classes can be exported too</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{};</span>

<span class="c1"># If a subpackage is in the namespace of the current package</span>
<span class="c1"># it doesn&#39;t need to be explicitly exported</span>
<span class="k">class</span> <span class="nc">MyModule::MyClass</span> <span class="p">{};</span>
</code></pre></div><p>就像所有的 traits 一样, 如果应用到子例程(routine)上, &ldquo;is export&rdquo; 应该出现在参数列表的后面:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span> <span class="p">(</span><span class="nb">Str</span> <span class="nv">$string</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>你可以给 <code>is export</code> 传递命名参数以组织要导出的符号, 然后导入程序 (importer) 可以剔除和选择导入哪一个。有 3 个预先定义好的标签：<code>ALL</code>, <code>DEFAULT</code>, <code>MANDATORY</code>（强制的）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># lib/MyModule.pm</span>
<span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="k">sub</span> <span class="nb">bag</span>        <span class="k">is</span> <span class="k">export</span>              <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">pants</span>      <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">MANDATORY</span><span class="p">)</span>  <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">sunglasses</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">day</span><span class="p">)</span>        <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">torch</span>      <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">night</span><span class="p">)</span>      <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">underpants</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">ALL</span><span class="p">)</span>        <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nb">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>           <span class="c1">#bag, pants</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">DEFAULT</span><span class="p">;</span>  <span class="c1">#the same</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">day</span><span class="p">;</span>      <span class="c1">#pants, sunglasses</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">night</span><span class="p">;</span>    <span class="c1">#pants, torch</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">:</span><span class="s">ALL</span><span class="p">;</span>      <span class="c1">#bag, pants, sunglasses, torch, underpants</span>
</code></pre></div><h3 id="unitexport">UNIT::EXPORT::*</h3>
<p>表象之下, 其实 <code>is export</code> 是把符号添加到 <code>EXPORT</code> 命名空间中的 <code>UNIT</code> 作用域包中。例如, <code>is export(:FOO)</code> 会把目标添加到 <code>UNIT::EXPORT::FOO</code> 包中。这正是 Raku 决定导入什么所做的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">foo</span> <span class="k">is</span> <span class="k">export</span>         <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">bar</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">other</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">unit</span> <span class="k">module</span> <span class="nn">MyModule</span><span class="p">;</span>

<span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::DEFAULT</span> <span class="p">{</span>
  <span class="k">our</span> <span class="k">sub</span> <span class="nf">foo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::other</span> <span class="p">{</span>
  <span class="k">our</span> <span class="k">sub</span> <span class="nf">bar</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>多数时候, <code>is export</code> 足够用了, 但是当你想动态生成要导出的符号时, <code>EXPORT</code> 包就很有用了。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># lib/MyModule.pm</span>
<span class="k">unit</span> <span class="k">module</span> <span class="nn">MuModule</span><span class="p">;</span>

<span class="k">my</span> <span class="nb">package</span> <span class="nn">EXPORT::DEFAULT</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">&lt;</span><span class="s">zero one two three four</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$number</span><span class="o">,</span> <span class="nv">$name</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">&lt;</span><span class="s">sqrt log</span><span class="p">&gt;</span> <span class="k">-&gt;</span> <span class="nv">$func</span> <span class="p">{</span>
          <span class="n">OUR::</span><span class="p">{&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$func</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">-of-</span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$name</span> <span class="p">}</span> <span class="o">:=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nv">$number</span><span class="o">.</span><span class="p">&#34;</span><span class="nv">$func</span><span class="s2">()</span><span class="p">&#34;</span> <span class="p">};</span>
      <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">sqrt-of-four</span><span class="p">;</span> <span class="c1">#-&gt; 2</span>
<span class="nb">say</span> <span class="n">log-of-zero</span><span class="p">;</span>  <span class="c1">#-&gt; -Inf</span>
</code></pre></div><h3 id="export">EXPORT</h3>
<p>你可以用一个 <code>EXPORT</code> 子例程导出任意符号。<code>EXPORT</code> 必须返回一个 <code>Map</code>, 在 map 里面键是符号名, 键值是想要的值。符号名应该包含(如果有的话)关联类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">MyModule::Class</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">sub</span> <span class="nf">EXPORT</span> <span class="p">{</span>
  <span class="p">{</span>
      <span class="p">&#39;</span><span class="s1">$var</span><span class="p">&#39;</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span><span class="o">,</span>
      <span class="p">&#39;</span><span class="s1">@array</span><span class="p">&#39;</span>    <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">,</span>
      <span class="p">&#39;</span><span class="s1">%hash</span><span class="p">&#39;</span>     <span class="o">=&gt;</span> <span class="p">{</span> <span class="s">one</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">two</span><span class="p">&#39;</span>, <span class="s">three</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">four</span><span class="p">&#39;}</span>,
      <span class="p">&#39;</span><span class="s1">&amp;doit</span><span class="p">&#39;</span>     <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span><span class="o">,</span>
      <span class="p">&#39;</span><span class="s1">ShortName</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="n">MyModule::class</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nb">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">MyModule</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$var</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@array</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">%hash</span><span class="p">;</span>
<span class="nf">doit</span><span class="p">();</span>
<span class="nb">say</span> <span class="n">ShortName</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>  <span class="c1">#-&gt; MyModule::Class.new</span>
</code></pre></div><p>注意, <code>EXPORT</code> 不能声明在包内, 因为目前的 rakudo(2015.09) 好像把 EXPORT 当作 compunit 的一部分而非包的一部分。</p>
<p>虽然 <code>UNIT::EXPORT</code> 包处理传递给 <code>use</code> 的命名参数, 而 <code>EXPORT</code> sub 处理位置参数。如果你把位置参数传递给 <code>use</code>, 那么这些参数会被传递给 <code>EXPORT</code>。如果传递了位置参数, 那么 module 就不再需要导出默认符号了。你仍然可以伴随着你的位置参数, 通过显式地给 use 传递 <code>:DEFAULT</code> 参数来导入它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># lib/MyModule</span>

<span class="k">class</span> <span class="nc">MyModule::Class</span> <span class="p">{}</span>

<span class="k">sub</span> <span class="nf">EXPORT</span><span class="p">(</span><span class="nv">$short_name</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span>
      <span class="nb">do</span> <span class="nv">$short_name</span> <span class="o">=&gt;</span> <span class="n">MyModule::Class</span> <span class="k">if</span> <span class="nv">$short_name</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">always</span> <span class="k">is</span> <span class="k">export</span><span class="p">(:</span><span class="s">MANDATORY</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">works</span><span class="p">&#34;</span> <span class="p">}</span>

<span class="c1">#import with :ALL or :DEFAULT to get</span>
<span class="k">sub</span> <span class="nf">shy</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">you found me!</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># main.pl</span>
<span class="k">use</span> <span class="nb">lib</span> <span class="p">&#39;</span><span class="s1">lib</span><span class="p">&#39;;</span>
<span class="k">use</span> <span class="nn">MyModule</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="n">foo</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span> <span class="c1">#MyModule::Class.new</span>
<span class="nf">always</span><span class="p">();</span>      <span class="c1">#OK   - is imported</span>
<span class="nf">shy</span><span class="p">();</span>         <span class="c1">#FAIL - won&#39;t be imported</span>
</code></pre></div><h2 id="发布模块">发布模块</h2>
<p>如果你已经写了一个 Raku 模块, 你想把它分享到社区, 我们会很高兴地把它放到 Raku 模块文件夹清单中。<a href="http://modules.raku.org/">Raku modules directory</a></p>
<p>现在, 你需要使用 git 对你的模块进行版本控制。</p>
<p>这需要你有一个 Github 帐号, 以使你的模块能被从它的 Github 仓库中分享出去。</p>
<p>要分享你的模块, 按照下面说的做：</p>
<ul>
<li>
<p>创建一个以你的模块命名的工程文件夹。例如, 如果你的模块是 <code>Vortex::TotalPerspective</code>, 那么就创建一个叫做 <code>Vortex::TotalPerspective</code> 的工程文件夹。这个工程目录的名字也会被用作 Github 仓库的名字。</p>
</li>
<li>
<p>让你的工程目录看起来像这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Vortex-TotalPerspective</span><span class="o">/</span>
<span class="o">|--</span> <span class="nb">lib</span>
<span class="o">|</span>   `<span class="o">--</span> <span class="n">Vortex</span>
<span class="o">|</span>       `<span class="o">--</span> <span class="n">TotalPerspective</span><span class="o">.</span><span class="nf">pm</span>
<span class="o">|--</span> <span class="n">LICENSE</span>
<span class="o">|--</span> <span class="n">META</span><span class="o">.</span><span class="nf">info</span>
<span class="o">|--</span> <span class="n">README</span><span class="o">.</span><span class="nf">md</span>
`<span class="o">--</span> <span class="nb">t</span>
    `<span class="o">--</span> <span class="n">basic</span><span class="o">.</span><span class="nb">t</span>
</code></pre></div><p>如果你的工程包含能帮助主模块完成工作的其它模块, 它们应该被放到你的 lib 目录中像这样组织：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="nb">lib</span>
`<span class="o">--</span> <span class="n">Vortex</span>
    <span class="o">|--</span> <span class="n">TotalPerspective</span><span class="o">.</span><span class="nf">pm</span>
    `<span class="o">--</span> <span class="n">TotalPerspective</span>
        <span class="o">|--</span> <span class="n">FairyCake</span><span class="o">.</span><span class="nf">pm</span>
        `<span class="o">--</span> <span class="n">Gargravarr</span><span class="o">.</span><span class="nf">pm</span>
</code></pre></div><ul>
<li>
<p><code>README.md</code> 文件是一个 markdown 格式的文件, 它稍后会被 Github 自动渲染成 HTML</p>
</li>
<li>
<p>关于 LICENSE 文件, 如果你没有其它选择, 就是用和 Rakudo Raku 一样的 LICENSE 把。仅仅把它的原始 <a href="https://github.com/rakudo/rakudo/blob/nom/LICENSE">license</a> 复制/粘贴进你自己的 LICENSE 文件中。</p>
</li>
<li>
<p>如果你还没有任何测试, 现在你可以忽略 <code>t</code> 目录 和 <code>basic.t</code> 文件。关于如何写测试, 你可以看看其它模块是怎么使用 <code>Test</code> 的。它和 Perl'5 的 <code>Test::More</code> 很类似。</p>
</li>
<li>
<p>如果要文档化你的模块, 在你的模块中使用 <a href="http://design.raku.org/S26.html">Raku Pod</a> 标记。欢迎给模块写文档, 并且为了浏览的方便, 一旦 Raku module directory(或其它网站) 开始把 Pod 文档渲染成 HTML, 写文档尤为重要。</p>
</li>
<li>
<p>让你的 <code>META.info</code> 文件看起来像这样:</p>
</li>
</ul>
</li>
</ul>
<pre><code> {
        &quot;name&quot;        : &quot;Vortex::TotalPerspective&quot;,
        &quot;version&quot;     : &quot;0.1.0&quot;,
        &quot;description&quot; : &quot;Wonderful simulation to get some perspective.&quot;,
        &quot;author&quot;      : &quot;Your Name&quot;,
        &quot;provides&quot;    : {
            &quot;Vortex::TotalPerspective&quot; : &quot;lib/Vortex/TotalPerspective.pm&quot;
        },
        &quot;depends&quot;     : [ ],
        &quot;source-url&quot;  : &quot;git://github.com/you/Vortex-TotalPerspective.git&quot;
    }
</code></pre><p>关于选择版本号的方案, 或许使用 &ldquo;major.minor.patch&rdquo; （查看  the spec on versioning 获取详细信息 ）。如果版本号现在对你或你的用户来说不重要, 你可以给版本那儿放上一颗星(*)。</p>
<p>在 <code>provides</code> 一节, 包含进你的发布中提供的所有命名空间。</p>
<ul>
<li>把你的工程放在 git 版本控制之下, 如果你还未这样做。</li>
<li>一旦你对你的工程满意了, 在 Github 上为它创建一个仓库。必要的话,  查看 <a href="https://help.github.com/">Github&rsquo;s help docs</a>。 你的 Github 仓库的名字应该和你工程目录的名字一样。创建完 Githhub 仓库后, Github 会为你展示怎么配置你的本地仓库以获悉你的 Github 仓库。</li>
<li>把你的工程推送到 Github</li>
<li>在 IRC 频道找个人帮你展示怎么把你的模块添加到<a href="https://github.com/raku/ecosystem">ecosystem</a>, 或者让他们是否能替你添加。</li>
<li>pull 请求被接收之后, 等个把小时。如果你的模块没有出现在  <a href="http://modules.raku.org/,">http://modules.raku.org/,</a> 请到 <a href="http://modules.raku.org/log/update.log">http://modules.raku.org/log/update.log</a> 翻看log 日志文件, 以查找是否有错误。</li>
</ul>
<p>就是这样啦！感谢为 Raku 社区做贡献！</p>
<p>如果你想尝试安装你的模块, 使用熊猫 panda 安装工具, 这已经包含在 Rakudo Raku 中了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">zef</span> <span class="nb">install</span> <span class="n">Vortex::TotalPerspective</span>
</code></pre></div><p>这会下载你的模块到它自己的工作目录(~/.zef), 在那儿创建 build, 并把模块安装到 <code>~/.raku</code></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/module" term="module" label="module" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 中的特性(二)]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/?utm_source=atom_feed" rel="related" type="text/html" title="Sneaking Into a Loop" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-14-using-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Using Raku" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Features in Raku</blockquote><h2 id="set">Set</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$keywords</span> <span class="o">=</span> <span class="nb">set</span> <span class="p">&lt;</span><span class="s">if for unless while</span><span class="p">&gt;;</span> <span class="c1"># create a set</span>

<span class="k">sub</span> <span class="nf">has-keyword</span><span class="p">(</span><span class="o">*</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
        <span class="c1"># 依次检查数组中的元素是否属于集合 $keywords</span>
        <span class="k">return</span> <span class="nb">True</span> <span class="k">if</span> <span class="nv">$word</span> <span class="ow">(elem)</span> <span class="nv">$keywords</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">False</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">not</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">one</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;;</span>  <span class="c1"># False</span>
<span class="nb">say</span> <span class="n">has-keyword</span> <span class="p">&#39;</span><span class="s1">but</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">here</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">for</span><span class="p">&#39;;</span>  <span class="c1"># True</span>
</code></pre></div><h2 id="series-operator">Series Operator</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span><span class="o">=</span><span class="p">&lt;</span><span class="s">A G C T</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="nv">@a</span><span class="p">;</span>

<span class="k">for</span> <span class="mi">1</span> <span class="o">...</span> <span class="o">*</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span>  
  <span class="p">((</span> <span class="o">[</span><span class="ow">X</span><span class="o">~]</span> <span class="nv">$x</span> <span class="ow">xx</span> <span class="nv">$a</span> <span class="p">))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
  <span class="nb">last</span> <span class="k">if</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>倒序的 range:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">10</span> <span class="o">...</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h2 id="flipplop">flip/plop</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">flip_flop.txt</span><span class="p">&#39;;</span>

<span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$line</span> <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="sr">\;</span><span class="p">/</span> <span class="ow">ff</span> <span class="nv">$line</span> <span class="o">~~</span> <span class="k">m</span><span class="p">/</span><span class="ni">^</span><span class="sr">\&#34;</span><span class="p">/);</span>
<span class="p">}</span>
</code></pre></div><p><code>$line ~~ m/^\;/ ff $line ~~ m/^\&quot;/</code> 过滤掉 <code>;</code> 和 <code>&quot;</code> 之间的内容, 再对它进行取反操作就是过滤后剩下的文本。</p>
<p>flip_flop.txt 内容如下：</p>
<pre><code>; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&quot; next is subject
There is more than one way to do it
                                -- Larry Wall

We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&quot; next is subject
programming is hard,Let's go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">There is more than one way to do it
                                -- Larry Wall
We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
programming is hard,Let&#39;s go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre></div><p><code>ff</code> 操作符左右两侧的 <code>^</code> 表示排除:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">ff</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">^ff</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">ff^</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">20</span> <span class="p">{</span><span class="o">.</span><span class="nb">say</span> <span class="k">if</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">9</span> <span class="ow">^ff</span><span class="o">^</span> <span class="nv">$_</span><span class="o">==</span><span class="mi">16</span><span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>9
10
11
12
13
14
15
16
----------
10
11
12
13
14
15
16
----------
9
10
11
12
13
14
15
----------
10
11
12
13
14
15
</code></pre><h2 id="grammars">Grammars</h2>
<p>解析 CSV:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">﻿<span class="k">grammar</span> <span class="n">CSV</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">line</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\n</span><span class="o">?</span><span class="sr"> </span><span class="p">]</span><span class="o">+</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">line</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="ni">^^</span><span class="sr">            </span><span class="c1"># Beginning of a line
</span><span class="c1"></span><span class="sr">        </span><span class="p">&lt;</span><span class="nf">value</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> \, </span><span class="c1"># Any number of &lt;value&gt;s with commas in `between` them
</span><span class="c1"></span><span class="sr">        </span><span class="ni">$$</span><span class="sr">            </span><span class="c1"># End of a line
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">value</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;,</span><span class="se">\n</span><span class="p">]&gt;</span><span class="sr">     </span><span class="c1"># Anything not a double quote, comma or newline
</span><span class="c1"></span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">quoted-text</span><span class="p">&gt;</span><span class="sr"> </span><span class="c1"># Or some quoted text
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">*</span><span class="sr">              </span><span class="c1"># Any number of times
</span><span class="c1"></span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">quoted-text</span> <span class="p">{</span><span class="sr">
</span><span class="sr">        \&#34;
</span><span class="sr">        </span><span class="p">[</span><span class="sr">
</span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">&#34;\\</span><span class="p">]&gt;</span><span class="sr"> </span><span class="c1"># Anything not a &#34; or \
</span><span class="c1"></span><span class="sr">        </span><span class="o">|</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">\&#34;</span><span class="p">&#39;</span><span class="sr">     </span><span class="c1"># Or \&#34;, an escaped quotation mark
</span><span class="c1"></span><span class="sr">        </span><span class="p">]</span><span class="o">*</span><span class="sr">         </span><span class="c1"># Any number of times
</span><span class="c1"></span><span class="sr">        \&#34;
</span><span class="sr">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1"># method parse($str, :$rule = &#39;TOP&#39;, :$actions) returns Match:D</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Valid CSV file!</span><span class="p">&#34;</span> <span class="k">if</span> <span class="n">CSV</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/ </span><span class="s">);
</span><span class="s">    Year,Make,Model,Length
</span><span class="s">    1997,Ford,E350,2.34
</span><span class="s">    2000,Mercury,Cougar,2.38
</span><span class="s">    </span><span class="p">EOCSV</span>

<span class="nb">say</span> <span class="n">CSV</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/,</span><span class="s"> &#39;line&#39;, :$actions );
</span><span class="s">    Year,Make,Model,Length
</span><span class="s">    1997,Ford,E350,2.34
</span><span class="s">    2000,Mercury,Cougar,2.38
</span><span class="s">    </span><span class="p">EOCSV</span>
</code></pre></div><p>解析天气数据:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">StationDataParser</span> <span class="p">{</span>
    <span class="k">token</span> <span class="nf">TOP</span>          <span class="p">{</span><span class="sr"> </span><span class="ni">^</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">keyval</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">observations</span><span class="p">&gt;</span><span class="sr"> </span><span class="ni">$</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">keyval</span>       <span class="p">{</span><span class="sr"> </span><span class="nv">$&lt;key&gt;</span><span class="o">=</span><span class="p">[&lt;</span><span class="o">-</span><span class="p">[</span><span class="sr">=</span><span class="p">]&gt;</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">=</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="nv">$&lt;val&gt;</span><span class="o">=</span><span class="p">[</span><span class="se">\N</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">observations</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">Obs:</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="se">\n</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">observation</span><span class="p">&gt;</span><span class="o">+</span><span class="sr">             </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">observation</span>  <span class="p">{</span><span class="sr"> </span><span class="nv">$&lt;year&gt;</span><span class="o">=</span><span class="p">[</span><span class="se">\d</span><span class="o">+</span><span class="p">]</span><span class="sr"> </span><span class="se">\h</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">temp</span><span class="p">&gt;</span><span class="o">+</span><span class="sr"> </span><span class="nv">%%</span><span class="sr"> </span><span class="p">[</span><span class="se">\h</span><span class="o">*</span><span class="p">]</span><span class="sr"> </span><span class="se">\n</span><span class="sr">    </span><span class="p">}</span>
    <span class="k">token</span> <span class="nf">temp</span>         <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span><span class="o">?</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr">                          </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">StationData</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$.name</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$.country</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.data</span><span class="p">;</span>

    <span class="k">submethod</span> <span class="nb">BUILD</span><span class="p">(</span><span class="o">:</span><span class="nv">%info</span> <span class="p">(:</span><span class="s">Name</span><span class="p">(</span><span class="nv">$!name</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">Country</span><span class="p">(</span><span class="nv">$!country</span><span class="p">)</span><span class="o">,</span> <span class="o">*</span><span class="nv">%</span><span class="p">)</span><span class="o">,</span> <span class="o">:</span><span class="nv">@!data</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">StationDataActions</span> <span class="p">{</span>
    <span class="k">method</span> <span class="nf">TOP</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="n">StationData</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span>
            <span class="s">info</span> <span class="o">=&gt;</span> <span class="nv">$&lt;keyval&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span><span class="o">.</span><span class="nb">hash</span>,
            <span class="s">data</span> <span class="o">=&gt;</span> <span class="nv">$&lt;observations&gt;</span><span class="o">.</span><span class="nb">ast</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">method</span> <span class="nf">keyval</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">~</span><span class="nv">$&lt;key&gt;</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="nv">$&lt;val&gt;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">observations</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="nv">$&lt;observation&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">ast</span><span class="p">)</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span><span class="o">.</span><span class="nb">none</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">99</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nf">observation</span><span class="p">(</span><span class="nv">$/</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">make</span> <span class="o">+</span><span class="nv">$&lt;year&gt;</span> <span class="o">=&gt;</span> <span class="nv">$&lt;temp&gt;</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">Num</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">StationDataParser</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/EOCSV/,</span><span class="s"> :actions(StationDataActions)).ast
</span><span class="s">Name= Jan Mayen
</span><span class="s">Country= NORWAY
</span><span class="s">Lat=   70.9
</span><span class="s">Long=    8.7
</span><span class="s">Height= 10
</span><span class="s">Start year= 1921
</span><span class="s">End year= 2009
</span><span class="s">Obs:
</span><span class="s">1921 -4.4 -7.1 -6.8 -4.3 -0.8  2.2  4.7  5.8  2.7 -2.0 -2.1 -4.0  
</span><span class="s">1922 -0.9 -1.7 -6.2 -3.7 -1.6  2.9  4.8  6.3  2.7 -0.2 -3.8 -2.6  
</span><span class="s">2008 -2.8 -2.7 -4.6 -1.8  1.1  3.3  6.1  6.9  5.8  1.2 -3.5 -0.8  
</span><span class="s">2009 -2.3 -5.3 -3.2 -1.6  2.0  2.9  6.7  7.2  3.8  0.6 -0.3 -1.3
</span><span class="s"></span><span class="p">EOCSV</span>
</code></pre></div><h2 id="raku-examples">Raku Examples</h2>
<ul>
<li>1、生成8位随机密码</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span>  <span class="nv">@char_set</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">~</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">!</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">@</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">#</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">$</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">^</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">&amp;</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">*</span><span class="p">&#39;);</span>
<span class="nb">say</span> <span class="nv">@char_set</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;&#34;)</span> <span class="c1"># 不重复的8位密码</span>

<span class="nb">say</span> <span class="nv">@char_set</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;&#34;)</span> <span class="c1"># 可以重复</span>
</code></pre></div><ul>
<li>2、打印前5个数字</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">[^</span><span class="mi">5</span><span class="o">]</span>
<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span> <span class="o">...</span> <span class="o">[^</span><span class="mi">10</span><span class="o">]</span>  <span class="c1"># 这个会无限循环</span>
</code></pre></div><ul>
<li>
<p>3、排序</p>
</li>
<li>
<p>3.1 按数值排序</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Go</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">CMD</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Php</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Java</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">85</span><span class="p">;</span>

<span class="nv">%hash</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="p">;</span>
<span class="nv">%hash</span><span class="o">.</span><span class="nb">values</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*</span><span class="p">);</span>
</code></pre></div><ul>
<li>3.2 按分数排序散列：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%hash</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
         <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">100</span><span class="o">,</span>
             <span class="p">&#39;</span><span class="s1">Go</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">95</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">CMD</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">20</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">Php</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">80</span><span class="o">,</span>
           <span class="p">&#39;</span><span class="s1">Java</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">85</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span><span class="o">-.</span><span class="nb">value</span><span class="p">})</span><span class="o">.</span><span class="nb">hash</span><span class="o">.</span><span class="nb">keys</span> <span class="k">-&gt;</span> <span class="nv">$key</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$key</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">\t</span><span class="p">&#34;</span><span class="o">,</span> <span class="nv">%hash</span><span class="p">{&#34;</span><span class="nv">$key</span><span class="p">&#34;}</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>Python	100
Go	95
Java	85
Perl	80
Php	80
CMD	20
</code></pre><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(&#39;</span><span class="s1">xx</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">zz</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="o">*.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">))&lt;</span><span class="s">z</span><span class="p">&gt;;</span> <span class="c1"># xz yz zz</span>
</code></pre></div><p>加密：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">rot13</span> <span class="p">{</span> <span class="nv">$^s</span><span class="o">.</span><span class="nb">trans</span><span class="p">(&#39;</span><span class="s1">a..z</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">n..za..m</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">A..Z</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">N..ZA..M</span><span class="p">&#39;)</span> <span class="p">}</span>
</code></pre></div><ul>
<li>4、求 1! + 2! + 3! + 4! +5! + 6! +7! +8! +9! +10!</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">){</span> <span class="o">[*]</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$x</span> <span class="p">}</span>
<span class="nb">say</span> <span class="o">[+]</span> <span class="mi">1</span><span class="o">!,</span><span class="mi">2</span><span class="o">!,</span><span class="mi">3</span><span class="o">!,</span><span class="mi">4</span><span class="o">!,</span><span class="mi">5</span><span class="o">!,</span><span class="mi">6</span><span class="o">!,</span><span class="mi">7</span><span class="o">!,</span><span class="mi">8</span><span class="o">!,</span><span class="mi">9</span><span class="o">!,</span><span class="mi">10</span><span class="o">!</span> <span class="c1"># 4037913</span>
</code></pre></div><ul>
<li>5、列出对象所有可用的方法</li>
</ul>
<p>使用元对象协议， 即 <code>对象名.^methods</code></p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="p">&#34;</span><span class="s2">JZY</span><span class="p">&#34;</span><span class="o">.^</span><span class="nb">methods</span>
</code></pre></div><blockquote>
<p>BUILD Int Num chomp chop substr pred succ match ords lines samecase samespace tr
im-leading trim-trailing trim words encode wordcase trans indent codes path WHIC
H Bool Str Stringy DUMP ACCEPTS Numeric gist perl comb subst split</p>
</blockquote>
<ul>
<li>6、 匿名子例程</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">sub</span><span class="p">(</span><span class="nv">$a</span><span class="p">){</span> <span class="nv">$a</span><span class="o">+</span><span class="mi">2</span> <span class="p">};</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{</span> <span class="nv">$a</span><span class="o">+</span><span class="mi">2</span> <span class="p">};</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
<span class="k">my</span> <span class="nv">$x</span> <span class="o">=</span> <span class="o">*</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span><span class="nb">say</span> <span class="nv">$x</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="mi">4</span>
</code></pre></div><ul>
<li>7、字符串翻转与分割</li>
</ul>
<pre><code>&gt; 1223.flip
3221
&gt; 'abcd'.flip
dcba
&gt; 1234.comb
1 2 3 4
&gt; 1234.comb(/./)
1 2 3 4
&gt; 'abcd'.comb
a b c d
</code></pre><ul>
<li>8、有这么一个四位数 A，其个位数相加得到 B，将 B 乘以 B 的反转数后得到 A，请求出这个数字。</li>
</ul>
<p>举例， 1458 就符合这个条件，1+4+5+8 ＝ 18， 18 ＊ 81 ＝1458</p>
<p>请找出另一个符合上面条件的四位数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="o">^</span><span class="mi">37</span><span class="p">)</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
  <span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="nv">$_</span> <span class="o">*</span> <span class="o">.</span><span class="nb">flip</span><span class="p">;</span>
  <span class="mi">1000</span> <span class="o">&lt;</span> <span class="nv">$r</span> <span class="ow">and</span> <span class="nv">$_</span> <span class="o">==</span> <span class="o">[+]</span> <span class="nv">$r</span><span class="o">.</span><span class="nb">comb</span> <span class="ow">and</span> <span class="nb">say</span> <span class="nv">$r</span>
<span class="p">}</span>
</code></pre></div><p><code>^37</code> 产生一个范围  0 .. ^37, 就是 0到36之前的数，在表达式中代表 B</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$b</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1000</span><span class="o">..^</span><span class="mi">10000</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
  <span class="nv">$b</span><span class="o">=[+]</span> <span class="nv">$i</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>
  <span class="nb">say</span> <span class="nv">$i</span> <span class="k">if</span> <span class="nv">$b</span><span class="o">*</span><span class="nv">$b</span><span class="o">.</span><span class="nb">flip</span> <span class="o">==</span> <span class="nv">$i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>1458
1729
</code></pre><ul>
<li>9、 大小写转换</li>
</ul>
<pre><code>&gt; my $word= &quot;I Love Raku&quot;
I Love Raku
&gt; $word.wordcase()
I Love Raku
&gt; my $lowercase = &quot;i love perl 6&quot;
i love perl 6
&gt; $lowercase.wordcase()
I Love Raku
&gt; $word.samecase('A')
I LOVE PERL 6
&gt; $word.samecase('a')
i love perl 6
&gt; $word.samecase('a').wordcase()
I Love Raku
</code></pre><ul>
<li>10、 多行文本</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$string</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/THE END/;</span><span class="s">
</span><span class="s">Norway
</span><span class="s">    Oslo : 59.914289,10.738739 : 2
</span><span class="s">    Bergen : 60.388533,5.331856 : 4
</span><span class="s">Ukraine
</span><span class="s">    Kiev : 50.456001,30.50384 : 3
</span><span class="s">Switzerland
</span><span class="s">    Wengen : 46.608265,7.922065 : 3
</span><span class="s"></span><span class="p">THE END</span>

<span class="nb">say</span> <span class="nv">$string</span><span class="p">;</span>
</code></pre></div><ul>
<li>11、 超运算符与子例程</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">1 2 3 4</span><span class="p">&gt;;</span>

<span class="k">sub</span> <span class="nf">by2</span><span class="p">(</span><span class="nv">$n</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="nv">$n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">power2</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">».&amp;</span><span class="nf">by2</span><span class="o">».&amp;</span><span class="nf">power2</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># 4 16 36 64</span>
</code></pre></div><p>为什么是 <code>&amp;function</code> 呢：</p>
<blockquote>
<p>the name of the by2 function is &amp;by2, just as the name of the foo scalar is $foo and the name of the foo array is @foo</p>
</blockquote>
<ul>
<li>12、 如何在 Raku 中执行外部命令并捕获输出</li>
</ul>
<pre><code>&gt; my $res = qqx{mkdir 123456}

# 或使用 qx{ }
&gt; my $res = qx{mkdir 112233}
</code></pre><ul>
<li>13、Does Raku support something equivalent to Perl5&rsquo;s <strong>DATA</strong> and <strong>END</strong> sections?</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">=foo</span><span class="sd"> This is a Pod block. A single line one. This Pod block&#39;s name is &#39;foo&#39;.
</span><span class="sd"></span>
<span class="k">=begin</span><span class="sd"> </span><span class="k">qux</span><span class="sd">
</span><span class="sd">This is another syntax for defining a Pod block.
</span><span class="sd">It allows for multi line content.
</span><span class="sd">This block&#39;s name is &#39;qux&#39;.
</span><span class="sd"></span><span class="k">=end qux</span>

<span class="k">=data</span><span class="sd"> A data block -- a Pod block with the name &#39;data&#39;.
</span><span class="sd"></span>
<span class="c1"># Data blocks are P6&#39;s version of P5&#39;s __DATA__.</span>
<span class="c1"># But you can have multiple data blocks:</span>

<span class="k">=begin</span><span class="sd"> </span><span class="k">data</span><span class="sd">
</span><span class="sd">Another data block.
</span><span class="sd">This time a multi line one.
</span><span class="sd"></span><span class="k">=end data</span>

<span class="nv">$=pod</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">name</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">data</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">contents</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">contents</span><span class="o">.</span><span class="nb">say</span><span class="p">);</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">-</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="mi">45</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@$=pod</span> <span class="p">{</span>
  <span class="k">if</span> <span class="o">.</span><span class="nb">name</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">data</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="o">.</span><span class="nb">contents</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">contents</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>14、生成含有26个英文字母和下划线的 junction</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">any</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">_</span><span class="p">&#39;);</span>
</code></pre></div><ul>
<li>15、判断一个字符是否在某个集合中</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span>  <span class="nb">so</span> <span class="nb">any</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;)</span> <span class="o">∈</span> <span class="nb">set</span><span class="p">(&#34;</span><span class="s2">12a34</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">comb</span><span class="p">)</span>
</code></pre></div><p>&ldquo;12a34&rdquo;.comb 会把字符串分割为单个字符，返回一个字符数组。</p>
<ul>
<li>16、生成 IP 地址范围</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">192.168.10.</span><span class="p">&#34;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span>
</code></pre></div><ul>
<li>17、 生成 OC 中的测试数组</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="p">&#34;</span><span class="s2">@</span><span class="p">&#34;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">&#39;</span><span class="s1">&#34;Perl</span><span class="p">&#39;</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="nb">list</span> <span class="p">«</span><span class="s2">~</span><span class="p">»</span> <span class="p">&#39;</span><span class="s1">&#34;,</span><span class="p">&#39;</span>
</code></pre></div><pre><code>@&quot;Perl&quot;1&quot;,
@&quot;Perl&quot;2&quot;,
@&quot;Perl&quot;3&quot;,
@&quot;Perl&quot;4&quot;,
@&quot;Perl&quot;5&quot;,
…
</code></pre>
<ul>
<li>18、我想以 AGCT 4 种字母为基础生成字符串。</li>
</ul>
<p>比如希望长度为1，输出A,G,C,T。</p>
<p>如果长度为2，输出 AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT。这样的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="p">&#34;&#34;</span>             <span class="c1"># 长度为1</span>
<span class="p">(</span><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span><span class="p">)</span>           <span class="c1"># 长度为2</span>
<span class="p">(</span><span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span><span class="p">)</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span>     <span class="c1"># 长度为3</span>
<span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@a</span> <span class="c1"># 长度为4</span>
</code></pre></div><pre><code>&gt; my @a=&lt;A G C T&gt;
A G C T
&gt; my $x=@a
A G C T
&gt; $x xx 2
A G C T A G C T
&gt; $x xx 3
A G C T A G C T A G C T
&gt; ($x xx 3).WHAT
(List)
&gt; $x.WHAT
(Array)

&gt; ([X~] $x xx 2).join(',')
AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT
</code></pre><p>惰性操作符：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span><span class="o">=</span><span class="p">&lt;</span><span class="s">A G C T</span><span class="p">&gt;;</span>
<span class="k">my</span> <span class="nv">$x</span><span class="o">=</span><span class="nv">@a</span><span class="p">;</span>  <span class="c1"># 或者使用 $x = @(&#39;A&#39;,&#39;G&#39;,&#39;C&#39;,&#39;T&#39;)</span>
<span class="k">for</span> <span class="mi">1</span> <span class="o">...^</span> <span class="o">*</span> <span class="k">-&gt;</span> <span class="nv">$a</span> <span class="p">{((</span><span class="o">[</span><span class="ow">X</span><span class="o">~]</span> <span class="nv">$x</span> <span class="ow">xx</span> <span class="nv">$a</span><span class="p">))</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;</span><span class="s1">,</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span><span class="nb">last</span> <span class="k">if</span> <span class="nv">$a</span><span class="o">==</span><span class="mi">4</span><span class="p">;};</span>
</code></pre></div><h2 id="best-of-raku">Best Of Raku</h2>
<ul>
<li>Command Line 命令行</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#               Perl 5                                     Raku</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">bananas are good\n</span><span class="p">&#34;;</span>                     <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">bananas are good</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">$quotes</span><span class="p">{</span>\&#34;<span class="n">me</span>\&#34;<span class="p">}</span><span class="s2">\n</span><span class="p">&#34;;</span>          <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">%quotes</span><span class="p">{&#34;</span><span class="s2">me</span><span class="p">&#34;}</span><span class="s2">.</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">$quotes</span><span class="p">{</span>\&#34;<span class="n">me</span>\&#34;<span class="p">}</span><span class="s2">\n</span><span class="p">&#34;;</span>          <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">and I said: </span><span class="nv">%quotes</span><span class="p">&lt;</span><span class="s">me</span><span class="p">&gt;</span><span class="s2">.</span><span class="p">&#34;;</span>
 <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">What is ... </span><span class="p">&#34;;</span>                           <span class="nv">$result</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">What is ... </span><span class="p">&#34;;</span>
 <span class="nb">chomp</span><span class="p">(</span><span class="nv">$result</span> <span class="o">=</span> <span class="o">&lt;&gt;</span><span class="p">);</span>
</code></pre></div><ul>
<li>File IO</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="nv">$content</span> <span class="o">=</span> <span class="nb">do</span> <span class="p">{</span> <span class="nb">local</span> <span class="nv">$/</span><span class="p">;</span>                       <span class="nv">$content</span> <span class="o">=</span> <span class="nb">slurp</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$FH</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span> <span class="p">&lt;</span><span class="s">$FH</span><span class="p">&gt;</span>
 <span class="p">};</span>

<span class="nb">chomp</span><span class="p">(</span><span class="nv">@content</span> <span class="o">=</span> <span class="nb">do</span> <span class="p">{</span>                            <span class="nv">@content</span> <span class="o">=</span> <span class="nb">lines</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$FH</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">poetry.txt</span><span class="p">&#34;;</span> <span class="p">&lt;</span><span class="s">$FH</span><span class="p">&gt;</span>
<span class="p">});</span>
</code></pre></div><ul>
<li>Automatic multithreading</li>
</ul>
<p>Applying operations to junctions and arrays is now syntactically compact and readable.
Raku will create threads where appropriate to use multiple processors, cores or hyperthreading for high level language SIMD concurrent processing.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="k">my</span> <span class="nv">$sum</span><span class="p">;</span>                                        <span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="o">[+]</span> <span class="nv">@numbers</span><span class="p">;</span>
 <span class="nv">$sum</span> <span class="o">+=</span> <span class="nv">$_</span> <span class="k">for</span> <span class="nv">@numbers</span><span class="p">;</span>
 <span class="k">for</span> <span class="p">(</span><span class="mi">0</span> <span class="o">..</span> <span class="nv">$</span><span class="c1">#factor1) {                          @product = @factor1 &gt;&gt;*&lt;&lt; @factor2;</span>
   <span class="nv">$product</span><span class="o">[</span><span class="nv">$</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$factor1</span><span class="o">[</span><span class="nv">$</span><span class="o">]</span> <span class="o">*</span> <span class="nv">$factor2</span><span class="o">[</span><span class="nv">$_</span><span class="o">]</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><p>The Perl 5 code is a simplification, of course Raku &ldquo;does the right thing&rdquo; when the arrays have different lengths.</p>
<ul>
<li>比较</li>
</ul>
<p>Here are junctions, then chained comparison operators.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>        <span class="k">if</span> <span class="nv">$a</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="o">|</span> <span class="mi">7</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="ow">and</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                   <span class="k">if</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="o">&lt;</span> <span class="mi">12</span>    <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="nv">$a</span> <span class="ow">and</span> <span class="nv">$a</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                  <span class="k">if</span> <span class="nv">$a</span> <span class="o">~~</span> <span class="mi">4</span><span class="o">^..</span><span class="mi">12</span>   <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="nv">$a</span> <span class="o">=</span> <span class="nb">defined</span> <span class="nv">$b</span> <span class="o">?</span> <span class="nv">$b</span> <span class="o">:</span> <span class="nv">$c</span><span class="p">;</span>                      <span class="nv">$a</span> <span class="o">=</span> <span class="nv">$b</span> <span class="o">//</span> <span class="nv">$c</span><span class="p">;</span>
</code></pre></div><p>The defined-OR operator eases lot of cases where Perl 5 newbies could fall into traps.</p>
<ul>
<li>Case 结构</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">  <span class="c1">#            Perl 5                                      Raku</span>
                                                     <span class="k">given</span> <span class="nv">$a</span> <span class="p">{</span>
 <span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> <span class="p">}}</span>                      <span class="k">when</span> <span class="mi">2</span> <span class="o">|</span> <span class="mi">5</span>  <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">elsif</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">7</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">8</span> <span class="ow">or</span> <span class="nv">$a</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{}</span>   <span class="k">when</span> <span class="mi">6</span> <span class="o">..</span> <span class="mi">9</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">elsif</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">=~</span> <span class="o">/</span><span class="n">g</span><span class="o">/</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                               <span class="k">when</span> <span class="p">&#39;</span><span class="s1">g</span><span class="p">&#39;</span>    <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">else</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                                            <span class="k">default</span>     <span class="p">{</span><span class="o">...</span><span class="p">}</span>
                                                     <span class="p">}</span>
</code></pre></div><p>That new construct (backported to 5.10) is clear to read, very versatile and when used in combination with junctions, becomes even clearer.</p>
<ul>
<li>强大的循环</li>
</ul>
<p>List iteration via for is now much more versatile.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">15</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                         <span class="k">for</span> <span class="o">^</span><span class="mi">16</span> <span class="k">-&gt;</span> <span class="nv">$i</span>        <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">for</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$i</span><span class="o">=</span><span class="mi">15</span><span class="p">;</span> <span class="nv">$i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="nv">$i-2</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>                <span class="k">for</span> <span class="mi">15</span><span class="o">,*-</span><span class="mi">2</span><span class="o">...</span><span class="mi">1</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$key</span> <span class="p">(</span><span class="nb">keys</span> <span class="nv">%hash</span><span class="p">)</span> <span class="p">{</span>                      <span class="k">for</span> <span class="nv">%hash</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$key</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
   <span class="nb">print</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2"> =&gt; </span><span class="nv">$hash</span><span class="p">{</span><span class="nv">$key</span><span class="p">}</span><span class="s2">\n</span><span class="p">&#34;;</span> <span class="o">...</span>              <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$key</span><span class="s2"> =&gt; </span><span class="nv">$value</span><span class="p">&#34;;</span> <span class="o">...</span>
 <span class="k">for</span> <span class="k">my</span> <span class="nv">$i</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="nv">$</span><span class="c1">#a) {                            for zip(@a; @b; @c) -&gt; $a, $b, $c {...}</span>
   <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="nv">@a</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nv">@b</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$c</span> <span class="o">=</span> <span class="nv">@c</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="p">;</span> <span class="o">...</span>
</code></pre></div><ul>
<li>子例程中的具名参数</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#            Perl 5                                     Raku</span>
 <span class="k">sub</span> <span class="nf">routine</span> <span class="p">{</span>                                   <span class="k">sub</span> <span class="nf">routine</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="o">,</span> <span class="o">*</span><span class="nv">@rest</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
   <span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$b</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">@rest</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><ul>
<li>Objects with auto generated new and getters and setters</li>
</ul>
<p>Simple Object creation is now as easy as it gets.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"> <span class="c1">#              Perl 5                                     Raku</span>
 <span class="nb">package</span> <span class="nn">Heart::Gold</span><span class="p">;</span>                            <span class="k">class</span> <span class="nc">Heart::Gold</span> <span class="p">{</span>
                                                   <span class="k">has</span> <span class="nv">$.speed</span><span class="p">;</span>
 <span class="k">sub</span> <span class="nb">new</span> <span class="p">{</span>                                         <span class="k">method</span> <span class="nf">stop</span> <span class="p">{</span> <span class="nv">$.speed</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
   <span class="nb">bless</span> <span class="p">{</span><span class="s">speed</span> <span class="o">=&gt;</span> <span class="mi">0</span> <span class="p">}</span>, <span class="nb">shift</span><span class="p">;</span>                   <span class="p">}</span>  
 <span class="p">}</span>
                                                 <span class="k">my</span> <span class="n">Heart::Gold</span> <span class="nv">$hg1</span> <span class="o">.=</span> <span class="nb">new</span><span class="p">;</span>
 <span class="k">sub</span> <span class="nf">speed</span> <span class="p">{</span>                                     <span class="nv">$hg1</span><span class="o">.</span><span class="nf">speed</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$self</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>                             <span class="k">my</span> <span class="nv">$hg2</span> <span class="o">=</span> <span class="nv">$hg1</span><span class="o">.</span><span class="nb">clone</span><span class="p">;</span>
   <span class="k">my</span> <span class="nv">$speed</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nb">defined</span> <span class="nv">$speed</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$speed</span> <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span> <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">sub</span> <span class="nf">stop</span> <span class="p">{</span>
   <span class="k">my</span> <span class="nv">$self</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
   <span class="nv">$self-</span><span class="o">&gt;</span><span class="p">{</span><span class="n">speed</span><span class="p">}</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><h2 id="raku-variable">Raku Variable</h2>
<ul>
<li>Variable Types</li>
</ul>
<p>Raku (as Perl 5) knows 3 basic types of variables: Scalars (single values), Arrays (ordered and indexed lists of several values) and Hashes (2 column table, with ID and associated value pairs). They can be easily distinguished, because in front of their name is a special character called sigil (latin for sign). It&rsquo;s the $ (similar to S) for Scalars, @ (like an a) for Arrays and a % (kv pair icon) for a Hash. They are now invariant (not changing), which means for instance, an array vaiable starts always with an @, even if you just want a slice of the content.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$scalar</span>
<span class="nv">@array</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>              <span class="c1"># $array[1]   in Perl 5</span>
<span class="nv">@array</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span>            <span class="c1"># @array[1,2] in Perl 5</span>
<span class="nv">%hash</span>
<span class="nv">%hash</span><span class="p">{&#39;</span><span class="s1">ba</span><span class="p">&#39;}</span>            <span class="c1"># $hash{&#39;ba&#39;} in Perl 5</span>
<span class="nv">%hash</span><span class="p">{&#39;</span><span class="s1">ba</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">da</span><span class="p">&#39;</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">bim</span><span class="p">&#39;}</span> <span class="c1"># @hash{&#39;ba&#39;,&#39;da&#39;,&#39;bim&#39;} in Perl 5</span>
</code></pre></div><p>The sigils also mark distinct namespaces, meaning: in one lexical scope you can have 3 different variables named $stuff, @stuff and %stuff. These sigils can also be used as an operator to enforce a context in which the following data will be seen.</p>
<p>The fourth namespace is for subroutines and similar, even if you don&rsquo;t usually think of them as variables. It&rsquo;s sigil &amp; is used to refer to subroutines without calling them.</p>
<p>All special namespaces from Perl 5 (often marked with special syntax), like tokens (<strong>PACKAGE</strong>), formats, file or dir handles, or builtins are now regular variables or routines.</p>
<p>Because all variables contain objects, they have methods. In fact, all operators, including square or curly bracket subscripts, are just methods of an object with a fancy name.</p>
<p>The primary sigil can be followed by a secondary sigil, called a twigil, which indicates a special scope for that variable.</p>
<h3 id="scalar">Scalar</h3>
<p>This type stores one value, usually a reference to something: a value of a data type, a code object, an object or a compound of values like a pair, junction, array, hash or capture. The scalar context is now called item context, hence the scalar instruction from Perl 5 was renamed to item.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$CHAPTER</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>              <span class="c1"># first comment!</span>
<span class="nv">$bin</span> <span class="o">=</span> <span class="mb">0b11</span><span class="p">;</span>               <span class="c1"># same value in binary format</span>
<span class="nv">$pi</span> <span class="o">=</span> <span class="mf">3.14159_26535_89793</span><span class="p">;</span> <span class="c1"># the underscores just ease reading</span>
<span class="nv">$float</span> <span class="o">=</span> <span class="mf">6.02e-23</span><span class="p">;</span>         <span class="c1"># floating number in scientific notation</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Welcome all!</span><span class="p">&#39;;</span>    <span class="c1"># single quoted string</span>

<span class="c1"># double quoted string, does eval $pi to it&#39;s content</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> What is </span><span class="nv">$pi</span><span class="s2">?</span><span class="p">&#34;;</span>
<span class="nv">$text</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">&#39;EOT&#39;;</span><span class="s">         # heredoc string
</span><span class="s">
</span><span class="s">    handy for multiline text
</span><span class="s">    like HTML templates or email
</span><span class="s">
</span><span class="s"></span><span class="p">EOT</span>
<span class="nv">$handle</span> <span class="o">=</span> <span class="nb">open</span> <span class="nv">$file_name</span><span class="p">;</span> <span class="c1"># file handle</span>
<span class="c1"># an object from a class with a nested namespace</span>
<span class="nv">$object</span> <span class="o">=</span> <span class="n">Class::Name</span><span class="o">.</span><span class="nb">new</span><span class="p">();</span>
<span class="nv">$condition</span> <span class="o">=</span> <span class="mi">3</span><span class="o">|</span><span class="mi">5</span><span class="o">|</span><span class="mi">7</span><span class="p">;</span>                <span class="c1"># a junction, a logical conjunction of values</span>
<span class="nv">$arrayref</span> <span class="o">=</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">21</span><span class="o">]</span><span class="p">;</span> <span class="c1"># an array stored as a single item</span>

<span class="c1"># a hash stored as a single item</span>
<span class="nv">$hashref</span> <span class="o">=</span> <span class="p">{&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span>      <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">damian</span><span class="p">&#39;</span>  <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">larrys evil henchman</span><span class="p">&#39;};</span>
<span class="c1"># pointing to a callable</span>
<span class="nv">$coderef</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="nf">do_something_completely_diffenent</span><span class="p">(</span><span class="nv">@_</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div><p>(For info on some of those terms: comment, binary format, the underscores ease reading, scientific notation, single-quoted string, double-quoted string, heredoc string, file handle, class, junction, list of values, hash, callable.)</p>
<p>Unlike Perl 5, references are automatically dereferenced to a fitting context. So you could use these $arrayrefs and $hashrefs similarly to an array or hash, making $ the universal variable prefix, pretty much like in PHP. The primary difference is that $ prefixed lists are not flattened in lists.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$a</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># just one iteration</span>
<span class="k">for</span> <span class="nv">@a</span> <span class="p">{</span> <span class="p">}</span>          <span class="c1"># three iterations</span>
</code></pre></div><h3 id="scalar-methods">Scalar Methods</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$chapter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">undefine</span> <span class="nv">$chapter</span><span class="p">;</span>
<span class="nb">defined</span> <span class="nv">$a</span><span class="p">;</span> <span class="c1"># false, returns 0</span>
</code></pre></div><ul>
<li>Array</li>
</ul>
<p>An array is an ordered and indexed list of scalars. If not specified otherwise, they can be changed, expanded and shortened anytime and used as a list, stack, queue and much more. As in Haskell, lists are processed lazily, which means: the compiler looks only at the part it currently needs. This way Raku can handle infinite lists or do computation on lists that have not been computed yet. The lazy command enforces this and the eager command forces all values to be computed.</p>
<p>The list context is forced with a @() operator or list() command. That&rsquo;s not autoflattening like in Perl 5 (automatically convert a List of Lists into one List). If you still want that, say flat(). Or say lol() to explicitly prevent autoflattening.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@primes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># an array gets filled like in Perl 5</span>
<span class="nv">@primes</span> <span class="o">=</span>  <span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span> <span class="p">;</span> <span class="c1"># same thing, since unlike P5 round braces just do group</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">2 3 5 7 11 13 17 19 23</span><span class="p">&gt;;</span> <span class="c1"># ditto, &lt;&gt; is the new qw()</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="p">);</span> <span class="c1"># same array object just sits in $primes, $primes[0] is 2</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="nb">item</span> <span class="nv">@primes</span><span class="p">;</span>             <span class="c1"># same thing, more explicit</span>
<span class="nv">$primes</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span><span class="p">;</span>                       <span class="c1"># just 2, first element of the Parcel</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                        <span class="c1"># array with one element</span>
<span class="nv">@primes</span> <span class="o">=</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">23</span><span class="o">]</span><span class="p">;</span> <span class="c1"># array with one element (List of Lists - LoL)</span>
<span class="nv">@dev</span>    <span class="o">=</span> <span class="p">{&#39;</span><span class="s1">dan</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">parrot</span><span class="p">&#39;};</span>      <span class="c1"># array with one element (a Hash)</span>
<span class="nv">@data</span>   <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="o">],[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="o">],[</span><span class="mi">11</span><span class="o">..</span><span class="mi">15</span><span class="o">]</span><span class="p">;</span>  <span class="c1"># Array of Arrays (LoL)</span>
<span class="nv">@list</span>   <span class="o">=</span> <span class="n">lol</span> <span class="nv">@data</span><span class="p">;</span>                <span class="c1"># no change</span>
<span class="nv">@list</span>   <span class="o">=</span> <span class="nb">flat</span> <span class="nv">@data</span><span class="p">;</span>               <span class="c1"># returns 1..15</span>
</code></pre></div><ul>
<li>Array Slices</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@primes</span>                       <span class="c1"># all values as list</span>
<span class="nv">@primes</span><span class="o">.</span><span class="nb">values</span>                <span class="c1"># same thing</span>
<span class="nv">@primes</span><span class="o">.</span><span class="nb">keys</span>                  <span class="c1"># list of all indices</span>
<span class="p">&#34;</span><span class="nv">@primes</span><span class="o">[]</span><span class="p">&#34;</span>                   <span class="c1"># insert all values in a string, uses [] to distinguish from mail adresses</span>
<span class="nv">$prime</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get the first prime</span>
<span class="nv">$prime</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[*-</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># get the last one</span>
<span class="nv">@some</span> <span class="o">=</span> <span class="nv">@primes</span><span class="o">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>        <span class="c1"># get several</span>
<span class="nv">$cell</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get 8, third value of second value (list)</span>
<span class="nv">$cell</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>           <span class="c1"># same thing, shorten syntax</span>
<span class="nv">@numbers</span> <span class="o">=</span> <span class="nv">@data</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>          <span class="c1"># get a copy of the second subarray (6..10)</span>
<span class="nv">@copy</span> <span class="o">=</span> <span class="nv">@data</span><span class="p">;</span>                <span class="c1"># shallow copy of the array</span>
</code></pre></div><ul>
<li>Array Methods</li>
</ul>
<p>Some of the more important things you can do with lists. All the methods can also used like ops in &ldquo;elems @array;&rdquo;</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">?</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># boolean context, Bool::True if array has any value in it, even if it&#39;s a 0</span>
<span class="o">+</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># numeric context, number of elements (like in Perl 5 scalar @a)</span>
<span class="o">~</span> <span class="nv">@array</span><span class="p">;</span>              <span class="c1"># string context, you get content of all cells, stringified and joined, same as &#34;@primes[]&#34;</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>          <span class="c1"># same as + @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">end</span><span class="p">;</span>            <span class="c1"># number of the last element, equal to @array.elems-1</span>
<span class="nv">@array</span><span class="o">.</span><span class="nf">cat</span><span class="p">;</span>            <span class="c1"># same ~ @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#39;&#39;);</span>       <span class="c1"># also same result, you can put another string as parameter that gets between all values</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">unshift</span><span class="p">;</span>        <span class="c1"># prepend one value to the array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span>          <span class="c1"># remove the first value and return it</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">push</span><span class="p">;</span>           <span class="c1"># add one value on the end</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">pop</span><span class="p">;</span>            <span class="c1"># remove one value from the end and return it</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">splice</span><span class="p">(</span><span class="nv">$pos</span><span class="o">,</span><span class="nv">$n</span><span class="p">);</span><span class="c1"># starting at $pos remove $n values and replace them with values that follow those two</span>
</code></pre></div><ul>
<li>parameters</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@array</span><span class="o">.</span><span class="nb">delete</span><span class="p">(</span><span class="nv">@ind</span><span class="p">);</span>   <span class="c1"># delete all cells with indices in @ind</span>
<span class="nv">@array</span><span class="o">.</span><span class="nf">exists</span><span class="p">(</span><span class="nv">@ind</span><span class="p">);</span>   <span class="c1"># Bool::True if all indices of @ind have a value (can be 0 or &#39;&#39;)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">);</span>     <span class="c1"># return $n (default is 1) randomly selected values, without duplication</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="o">[</span><span class="nv">$n</span><span class="o">]</span><span class="p">);</span>     <span class="c1"># return $n (default is 1) randomly selected values, duplication possible (like roll dice)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>        <span class="c1"># all elements in reversed order</span>
<span class="c1"># returns a list where $n times first item is taken to last</span>
<span class="c1"># position if $n is positive, if negative the other way around</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$n</span><span class="p">);</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="nv">$coderef</span><span class="p">);</span> <span class="c1"># returns a list sorted by a user-defined criteria, default is alphanumerical sorting</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">min</span><span class="p">;</span>            <span class="c1"># numerical smallest value of that array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">max</span><span class="p">;</span>            <span class="c1"># numerical largest value of that array</span>
<span class="nv">$a</span><span class="o">,</span><span class="nv">$b</span><span class="o">=</span> <span class="nv">@array</span><span class="o">.</span><span class="nb">minmax</span><span class="p">;</span>  <span class="c1"># both at once, like in .sort,  .min, or .max, a sorting algorithm can be provided</span>

<span class="nv">@array</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="nv">$coderef</span><span class="p">);</span>  <span class="c1"># high oder map function, runs $coderef with every value as $_ and returns the list or results</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="nv">$cr</span><span class="p">);</span>  <span class="c1"># kind of map, but creates a hash, where keys are the results of $cr and values are from @array</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">categorize</span><span class="p">(</span><span class="nv">$cr</span><span class="p">);</span><span class="c1"># kind of classify, but closure can have no (Nil) or several results, so a key can have a list of values</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span><span class="nv">$_</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">});</span>   <span class="c1"># high order grep, returns only these elements that pass a condition ($cr returns something positive)</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">first</span><span class="p">(</span><span class="nv">$coder</span><span class="p">);</span>  <span class="c1"># kind of grep, return just the first matching value</span>
<span class="nv">@array</span><span class="o">.</span><span class="nb">zip</span><span class="p">;</span>            <span class="c1"># join arrays by picking first element left successively from here and then there</span>
<span class="n">There</span> <span class="k">is</span> <span class="nc">even</span> <span class="n">a</span> <span class="n">whole</span> <span class="k">class</span> <span class="k">of</span> <span class="nc">metaoperators</span> <span class="n">that</span> <span class="n">work</span> <span class="n">upon</span> <span class="n">lists</span><span class="o">.</span>
</code></pre></div><ul>
<li>Hash</li>
</ul>
<p>In Raku a Hash is an unordered list of Pairs. A Pair is a single key =&gt; value association and appears in many places of the language syntax. A hash allows lookup of values by key using {} or &lt;&gt; syntax.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%dev</span> <span class="o">=</span>  <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">STD</span><span class="p">&#34;</span><span class="o">=&gt;</span><span class="p">&#39;</span><span class="s1">larry</span><span class="p">&#39;;</span>
<span class="nv">%dev</span> <span class="o">=</span> <span class="p">:</span><span class="s">rakudo</span><span class="p">(&#39;</span><span class="s1">jnthn</span><span class="p">&#39;)</span><span class="o">,</span> <span class="p">:</span><span class="s">testsuite</span><span class="p">(&#39;</span><span class="s1">moritz</span><span class="p">&#39;);</span>            <span class="c1"># adverb (pair) syntax works as well</span>
<span class="nv">%dev</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">audreyt</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pugs</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pm</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">pct</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">larry</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">STD</span><span class="p">&#34;);</span>  <span class="c1"># lists get autoconverted in hash context</span>
<span class="nv">%compiler</span> <span class="o">=</span> <span class="s">Parrot</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">Rakudo</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">jnthn</span><span class="p">&#39;}</span>, <span class="s">SMOP</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">Mildew</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">ruoso</span><span class="p">&#39;};</span>       <span class="c1"># hash of hashes (HoH)</span>
</code></pre></div><ul>
<li>Hash Slices</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">{&#39;</span><span class="s1">key</span><span class="p">&#39;};</span>      <span class="c1"># just give me the value related to that key, like in P5</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;</span><span class="s">pm</span><span class="p">&gt;;</span>         <span class="c1"># &lt;&gt; autoquotes like qw() in P5</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;&lt;</span><span class="nv">$name</span><span class="p">&gt;&gt;;</span>    <span class="c1"># same thing, just with eval</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">{&#39;</span><span class="s1">key1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">key2</span><span class="p">&#39;};</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;</span><span class="s">key1 key2</span><span class="p">&gt;;</span>
<span class="nv">@values</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">&lt;&lt;</span><span class="s2">key1 key2 </span><span class="nv">$key3</span><span class="p">&gt;&gt;;</span>
<span class="nv">%compiler</span><span class="p">&lt;</span><span class="s">Parrot</span><span class="p">&gt;&lt;</span><span class="s">Rakudo</span><span class="p">&gt;;</span> <span class="c1"># value in a HoH, returns &#39;jnthn&#39;</span>
<span class="nv">%compiler</span><span class="p">&lt;</span><span class="s">SMOP</span><span class="p">&gt;;</span>           <span class="c1"># returns the Pair: Mildew =&gt; &#39;ruoso&#39;</span>

<span class="nv">%dev</span>   <span class="p">{&#39;</span><span class="s1">audrey</span><span class="p">&#39;};</span>         <span class="c1"># error, spaces between varname and braces (postcircumfix operator) are no longer allowed</span>
<span class="nv">%dev</span>\  <span class="p">{&#39;</span><span class="s1">allison</span><span class="p">&#39;};</span>        <span class="c1"># works, quote the space</span>
<span class="nv">%dev</span>   <span class="o">.</span><span class="p">&lt;</span><span class="s">dukeleto</span><span class="p">&gt;;</span>        <span class="c1"># error</span>
<span class="nv">%dev</span>\ <span class="o">.</span><span class="p">{&#39;</span><span class="s1">patrick</span><span class="p">&#39;};</span>        <span class="c1"># works too, &#34;long dot style&#34;, because it&#39;s an object in truth</span>
</code></pre></div><ul>
<li>Hash Methods</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">?</span> <span class="nv">%dev</span>                     <span class="c1"># bool context, true if hash has any pairs</span>
<span class="o">+</span> <span class="nv">%dev</span>                     <span class="c1"># numeric context, returns number of pairs(keys)</span>
<span class="o">~</span> <span class="nv">%dev</span>                     <span class="c1"># string context, nicely formatted 2 column table using \t and \n</span>

<span class="nv">$table</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">;</span>             <span class="c1"># same as ~ %dev</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>                  <span class="c1"># stringified, but only $key and $value are separated by \t</span>
<span class="nv">@pairs</span> <span class="o">=</span> <span class="nv">%dev</span><span class="p">;</span>             <span class="c1"># list of all containing pairs</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">pairs</span>                 <span class="c1"># same thing in all context</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">elems</span>                 <span class="c1"># same as + %dev or + %dev.pairs</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">keys</span>                  <span class="c1"># returns a list of all keys</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">values</span>                <span class="c1"># list of all values</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">kv</span>                    <span class="c1"># flat list with key1, value1, key 2 ...</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">invert</span>                <span class="c1"># reverse all key =&gt; value relations</span>
<span class="nv">%dev</span><span class="o">.</span><span class="nb">push</span> <span class="p">(</span><span class="nv">@pairs</span><span class="p">)</span>         <span class="c1"># inserts a list of pairs, if a key is already present in %dev, both values gets added to an array</span>
</code></pre></div><ul>
<li>Callable</li>
</ul>
<p>Internally subroutines, methods and alike are variables with the sigil &amp; and stored in a fourth namespace. Unlike Perl 5, all subroutines can be overwritten or augmented with user defined routines. Of course scalars can also contain routines.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">&amp;function</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>         <span class="c1"># store subroutine in callable namespace</span>
<span class="nf">function</span><span class="p">();</span>                      <span class="c1"># call/run it</span>

<span class="nv">$coderef</span> <span class="o">=</span> <span class="k">sub</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>          <span class="c1"># store it in a scalar</span>
<span class="nv">$coderef</span><span class="p">(</span><span class="nv">$several</span><span class="o">,</span> <span class="nv">$parameter</span><span class="p">);</span>  <span class="c1"># run that code</span>
</code></pre></div><ul>
<li>Data Types</li>
</ul>
<p>In contrast to variable types (container types) every value has a type too. These are organized internally as classes or roles and can be categorized into 3 piles: the undefined, immutable, and the mutable types.</p>
<p>You can assign one of these types to scalar, array, or hash variables, which enforces the contents to be that type.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$a</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">Int</span> <span class="nv">@a</span><span class="p">;</span>  <span class="c1"># array of Int</span>
</code></pre></div><ul>
<li>Pair</li>
</ul>
<p>Pairs are new and their syntax is used nearly everywhere in the language where there is an association between a name and a value.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$pair</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">jakub</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">helena</span><span class="p">&#39;;</span>  <span class="c1"># &#34;=&gt;&#34; is the pair constructor</span>
<span class="nv">$pair</span> <span class="o">=</span> <span class="p">:</span><span class="s">jakub</span><span class="p">(&#39;</span><span class="s1">helena</span><span class="p">&#39;);</span>     <span class="c1"># same in adverbial notation</span>
<span class="nv">$pair</span> <span class="o">=</span> <span class="p">:</span><span class="s">jakub</span><span class="p">&lt;</span><span class="s">helena</span><span class="p">&gt;;</span>       <span class="c1"># same using &lt;&gt;, the new qw()</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">key</span>                     <span class="c1"># returns &#39;jakub&#39;</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">value</span>                   <span class="c1"># returns &#39;helena&#39;</span>
<span class="nv">$pair</span><span class="o">.</span><span class="nb">isa</span><span class="p">(</span><span class="nb">Pair</span><span class="p">)</span>               <span class="c1"># Bool::True</span>
</code></pre></div><ul>
<li>Capture</li>
</ul>
<p>Captures are also a new type, which holds the parameters a routine gets. Because Perl now knows both positional and named parameters, it is a mixture of a list and array.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$cap</span> <span class="o">=</span> \<span class="p">(</span><span class="nv">@a</span><span class="o">,</span><span class="nv">$s</span><span class="o">,</span><span class="nv">%h</span><span class="o">,</span><span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">);</span>    <span class="c1"># creating a capture, &#34;\&#34; was free since there are no references anymore</span>
<span class="o">|</span><span class="nv">$cap</span>                         <span class="c1"># flatten into argument list (without |, it will pass it as a single value)</span>
<span class="o">||</span><span class="nv">$cap</span>                        <span class="c1"># flatten into semicolon list (meant for variadic functions that take list of lists)</span>
</code></pre></div><p>One important difference between a capture and a compound structure of lists and hashes: While assignments with = will copy the complete content of the named variables, this is not so in the case of a capture. When I change sinthelastexample, thecontentofcap changes too, because when parameters to a routine are variables, they are also interpolated in the moment the routine is called, not when it&rsquo;s defined.</p>
<ul>
<li>
<p>Assignment and Binding</p>
</li>
<li>
<p>Assignment</p>
</li>
</ul>
<p>As rightfully expected, assignments are done with the equal sign. But unlike Perl 5 you always get a copy of the right side data assigned to the left, no matter how nested the data structure was (lists of lists eg). You never get in Raku a reference with =. The only exception may be seen captures.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@original</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">],[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$copy</span> <span class="o">=</span> <span class="nv">@original</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span> <span class="c1"># $copy points to [1,2]</span>
<span class="nv">@original</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">fresh stuff</span><span class="p">&#39;;</span> <span class="c1"># $copy[0] holds still 1</span>
</code></pre></div><ul>
<li>Binding</li>
</ul>
<p>Since every variable in Raku is a reference, programmers can use binding to get 2 variables that point to the same memory location.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$original</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nv">$original</span> <span class="o">:=</span> <span class="nv">$mirror</span><span class="p">;</span>       <span class="c1"># normal binding, done on runtime</span>
<span class="nv">$original</span> <span class="o">::=</span> <span class="nv">$mirror</span><span class="p">;</span>      <span class="c1"># same thing, but done during compile time</span>
<span class="nv">$original</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">$mirror</span><span class="p">;</span>                <span class="c1"># prints 3</span>
<span class="nv">$original</span> <span class="o">=:=</span> <span class="nv">$mirror</span>       <span class="c1"># true, because they&#39;re bound together</span>
<span class="nv">$original</span> <span class="o">===</span> <span class="nv">$mirror</span>       <span class="c1"># also true, because content and type are equal</span>
</code></pre></div><ul>
<li>FP oriented</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">none</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="o">.[*-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">given</span> <span class="o">[</span>\<span class="o">+]</span> <span class="p">&#39;</span><span class="s1">\\</span><span class="p">&#39;</span> <span class="o">«</span><span class="ow">leg</span><span class="o">«</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">comb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> </span><span class="p">{</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">is</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">is not</span><span class="p">&#34;</span> <span class="p">}</span><span class="s2"> well-balanced</span><span class="p">&#34;</span>
</code></pre></div><ul>
<li>String munging</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$_</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">()</span> <span class="k">while</span> <span class="k">s</span><span class="p">:</span><span class="na">g</span><span class="p">/&#39;</span><span class="s1">[]</span><span class="p">&#39;//;</span>
    <span class="nv">$_</span> <span class="ow">eq</span> <span class="p">&#39;&#39;;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">[ ]</span><span class="p">&gt;</span><span class="o">.</span><span class="nb">roll</span><span class="p">(</span><span class="nv">$n</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> is</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1"> not</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nb">not</span> <span class="nf">balanced</span><span class="p">(</span><span class="nv">$s</span><span class="p">))</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2"> well-balanced</span><span class="p">&#34;;</span>
</code></pre></div><ul>
<li>Parsing with a grammar</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">BalBrack</span> <span class="p">{</span> <span class="k">token</span> <span class="nf">TOP</span> <span class="p">{</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">[</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">TOP</span><span class="p">&gt;</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">}</span> <span class="p">}</span>

<span class="k">my</span> <span class="nv">$n</span> <span class="o">=</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Number of bracket pairs: </span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">[</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nv">$n</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">]</span><span class="p">&#39;</span> <span class="ow">xx</span> <span class="nv">$n</span><span class="p">)</span><span class="o">.</span><span class="nb">pick</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$s</span><span class="s2"> </span><span class="p">{</span> <span class="n">BalBrack</span><span class="o">.</span><span class="nb">parse</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">is</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">is not</span><span class="p">&#34;</span> <span class="p">}</span><span class="s2"> well-balanced</span><span class="p">&#34;;</span>
</code></pre></div><ul>
<li>凯撒加密</li>
</ul>
<p>实现一个凯撒加密， 编码和解码都要有</p>
<p>key 是一个 1 到 25 之间的整数</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@alpha</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A</span><span class="p">&#39;</span> <span class="o">..</span> <span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;;</span>

<span class="k">sub</span> <span class="nf">encrypt</span> <span class="p">(</span> <span class="nv">$key</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span><span class="o">,</span> <span class="nv">$plaintext</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$plaintext</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="nv">@alpha</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@alpha</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">decrypt</span> <span class="p">(</span> <span class="nv">$key</span> <span class="k">where</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span><span class="o">,</span> <span class="nv">$cyphertext</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$cyphertext</span><span class="o">.</span><span class="nb">trans</span><span class="p">(</span> <span class="nv">@alpha</span><span class="o">.</span><span class="nb">rotate</span><span class="p">(</span><span class="nv">$key</span><span class="p">)</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@alpha</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$original</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">THE FIVE BOXING WIZARDS JUMP QUICKLY</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$en</span> <span class="o">=</span> <span class="nf">encrypt</span><span class="p">(</span> <span class="mi">13</span><span class="o">,</span> <span class="nv">$original</span> <span class="p">);</span>
<span class="k">my</span> <span class="nv">$de</span> <span class="o">=</span> <span class="nf">decrypt</span><span class="p">(</span> <span class="mi">13</span><span class="o">,</span> <span class="nv">$en</span> <span class="p">);</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$original</span><span class="o">,</span> <span class="nv">$en</span><span class="o">,</span> <span class="nv">$de</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">OK</span><span class="p">&#39;</span> <span class="k">if</span> <span class="nv">$original</span> <span class="ow">eq</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">map</span> <span class="p">{</span> <span class="o">.&amp;</span><span class="nf">decrypt</span><span class="p">(</span><span class="o">.&amp;</span><span class="nf">encrypt</span><span class="p">(</span><span class="nv">$original</span><span class="p">))</span> <span class="p">}</span><span class="o">,</span> <span class="mi">1</span><span class="o">..</span><span class="mi">25</span> <span class="p">);</span>
</code></pre></div><pre><code>Output:
THE FIVE BOXING WIZARDS JUMP QUICKLY
GUR SVIR OBKVAT JVMNEQF WHZC DHVPXYL
THE FIVE BOXING WIZARDS JUMP QUICKLY
OK
</code></pre>
<ul>
<li>日期格式化</li>
</ul>
<p>使用 &ldquo;2007-11-10&rdquo; 和 &ldquo;Sunday, November 10, 2007&rdquo; 日期格式显式当前日期:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">DateTime</span><span class="o">:</span><span class="p">:</span><span class="s">Utils</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="nb">DateTime</span><span class="o">.</span><span class="nb">now</span><span class="p">;</span>

<span class="nb">say</span> <span class="nf">strftime</span><span class="p">(&#39;</span><span class="s1">%Y-%m-%d</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$dt</span><span class="p">);</span>
<span class="nb">say</span> <span class="nf">strftime</span><span class="p">(&#39;</span><span class="s1">%A, %B %d, %Y</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$dt</span><span class="p">);</span>
</code></pre></div><ul>
<li>阶乘</li>
</ul>
<p>n 的阶乘定义为 <code>n*(n-1)*(n-2)…*1</code>, 零的阶乘为1.</p>
<p>定义一个函数返回一个数字的阶乘。</p>
<ul>
<li>使用自定义后缀操作符</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nb">postfix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">!</span><span class="p">&gt;(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">[*]</span> <span class="mi">2</span><span class="o">..</span><span class="nv">$n</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="mi">5</span><span class="o">!</span>
</code></pre></div><ul>
<li>[*]</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="o">[</span>\<span class="o">*]</span> <span class="mi">1</span><span class="o">..*</span><span class="p">;</span>
<span class="nb">say</span> <span class="nv">@a</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><p>标量容器中存储的对象不会在 flattening 上下文中插值，即使那个对象是可迭代的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">@a</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span> <span class="c1"># 5次迭代</span>
</code></pre></div><p>输出:</p>
<pre><code>1
2
3
4
5
</code></pre><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nv">@a</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">$s</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># 3次迭代</span>
</code></pre></div><p>输出:</p>
<pre><code>1
2
3 4 5
</code></pre><p>这里，<code>$s</code> 和 <code>@a</code> 指向同一个数组对象，但是标量容器的出现阻止 <code>$s</code> 被展开到 for 循环中。</p>
<p>.list 和 .flat 方法能被用于还原展开行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">$s</span><span class="o">.</span><span class="nb">list</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span> <span class="p">}</span>    <span class="c1"># 5次遍历</span>
<span class="k">for</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nv">@</span><span class="p">(</span><span class="nv">$s</span><span class="p">)</span>   <span class="p">{</span> <span class="o">.</span><span class="nb">say</span>  <span class="p">}</span>   <span class="c1"># 5次遍历，@()会强制为列表上下文</span>
</code></pre></div><p>输出:</p>
<pre><code>1
2
3
4
5
</code></pre><p>相反，<code>.item</code> 方法和 <code>$()</code> 能用于防止插值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">@a</span><span class="p">;</span>           <span class="c1"># @b 有5个元素</span>
<span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">@a</span><span class="o">.</span><span class="nb">item</span><span class="p">;</span>      <span class="c1"># @c 有3个元素</span>
<span class="k">my</span> <span class="nv">@c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="nv">$</span><span class="p">(</span><span class="nv">@a</span><span class="p">);</span>        <span class="c1"># 同上</span>

<span class="nb">say</span> <span class="o">+</span><span class="nv">@c</span><span class="p">;</span> <span class="c1"># 3</span>
</code></pre></div><ul>
<li>Feed operators</li>
</ul>
<p>feed 操作符是完全懒惰的，意味着在使用者要求任何元素之前不会执行任何操作。这就是</p>
<pre><code class="language-rraku" data-lang="rraku">my @a &lt;== grep { ... } &lt;== map { ... } &lt;== grep { ... } &lt;== 1, 2, 3
</code></pre><p>是完全懒惰的。</p>
<ul>
<li>Grammars</li>
</ul>
<p>文法是一种强大的工具, 用于拆解文本,并通常返回数据结构
例如, Raku 是使用 Raku 风格的文法解析和执行的.
对普通 Raku 用户来说,一个更实用的例子就是 JSON::Simple 模块, 这个模块能反序列化任何有效的 JSON 文件, 反序列化代码还写了不到 100 行, 简单,可扩展.</p>
<p>词法允许你组织正则, 就像类允许你组织普通代码的方法一样.</p>
<h2 id="命名正则">命名正则</h2>
<p>命名正则有特殊的语法, 与<strong>子例程</strong>的定义类似:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">number</span> <span class="p">{</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">[</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="se">\d</span><span class="o">+</span><span class="sr"> </span><span class="p">]</span><span class="o">?</span><span class="sr"> </span><span class="p">}</span>
</code></pre></div><p>这个例子中, 我们必须使用 <strong>my</strong> 关键词指定这个正则是词法作用域的, 因为 <strong>命名正则</strong> 通常用在 词法中.
给正则命名后有利于在其他地方<code>复用</code>正则:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">32.51</span><span class="p">&#34;</span>    <span class="o">~~</span> <span class="nv">&amp;number</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">15 + 4.5</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">&gt;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">+</span><span class="p">&#39;</span><span class="sr"> </span><span class="se">\s</span><span class="o">*</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">number</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">/</span>
</code></pre></div><p>首先说下, 使用 <code>regex/token/rule</code> 定义了一个正则表达式后怎么去调用它。就像调用一个子例程那样, 使用 <code>&amp;</code> 符号:
<code>&amp;</code> 后面跟正则表达式的名字,  即 <code>&amp;regex_name</code>。</p>
<p>regex 不是命名正则仅有的标识符 &ndash; 实际上, 它用的不多. 大多数时候, 用的最多的是 <code>token</code> 和 <code>rule</code> 标识符. 它们都是<code>不能回溯</code>的, 这意味着正则引擎在匹配失败时不会备份和重试. 这通常是你想要的, 但不是对所有场合都合适:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">regex</span> <span class="nf">works-but-slow</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span>
<span class="k">my</span> <span class="k">token</span> <span class="nf">fails-but-fast</span> <span class="p">{</span><span class="sr"> </span><span class="ni">.</span><span class="o">+</span><span class="sr"> q </span><span class="p">}</span>

<span class="c1"># Tokens 不会沿原路返回, 这让它们更快地失败!</span>
<span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Tokens won\&#39;t backtrack, which makes them fail quicker!</span><span class="p">&#39;;</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;works-but-slow</span><span class="p">;</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="nb">so</span> <span class="nv">$s</span> <span class="o">~~</span> <span class="nv">&amp;fails-but-fast</span><span class="p">;</span> <span class="c1"># False, the entire string get taken by the .+</span>
</code></pre></div><p><code>token</code> 和 <code>rule</code> 标识符的不同之处在于 <code>rule</code> 标识符让 <code>Regex</code> 的 <code>:sigspace</code> 起作用了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">token</span> <span class="nf">non-space-y</span> <span class="p">{</span><span class="sr"> once upon a time </span><span class="p">}</span>
<span class="k">my</span> <span class="k">rule</span> <span class="nf">space-y</span>      <span class="p">{</span><span class="sr"> once upon a time </span><span class="p">}</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">onceuponatime</span><span class="p">&#39;</span>    <span class="o">~~</span> <span class="nv">&amp;non-space-y</span><span class="p">;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">once upon a time</span><span class="p">&#39;</span> <span class="o">~~</span> <span class="nv">&amp;space-y</span><span class="p">;</span>
</code></pre></div><h2 id="action-classes">Action Classes</h2>
<p>实际上, 命名正则甚至能接受额外的参数, 它使用的语法跟子例程参数列表的语法一样.</p>
<p>​写一个程序打印从 1  到 100 的整数，但是对 3 的倍数打印 &ldquo;Fizz&rdquo;, 对 5 的倍数打印 &ldquo;Buzz&rdquo;, 对于即是 3 的倍数，又是 5 的倍数的打印 &ldquo;FizzBuzz&rdquo;.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span> <span class="p">{</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&amp;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">FizzBuzz</span><span class="p">&#39;;</span> <span class="p">}</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">3</span>       <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;;</span>     <span class="p">}</span>
    <span class="k">when</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">5</span>       <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;;</span>     <span class="p">}</span>
    <span class="k">default</span>            <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span>           <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>Or abusing multi subs:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#39;</span><span class="s1">FizzBuzz</span><span class="p">&#39;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">5</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;</span>     <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$</span> <span class="k">where</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">3</span><span class="p">)</span>  <span class="p">{</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;</span>     <span class="p">}</span>
<span class="k">multi</span> <span class="k">sub</span> <span class="nf">fizzbuzz</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$number</span> <span class="p">)</span>        <span class="p">{</span> <span class="nv">$number</span>    <span class="p">}</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">)</span><span class="o">».</span><span class="nv">&amp;fizzbuzz</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>Most concisely:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">3</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$_</span> <span class="nv">%%</span> <span class="mi">5</span> <span class="o">||</span> <span class="nv">$_</span> <span class="k">for</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div><p>And here&rsquo;s an implementation that never checks for divisibility:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">.</span><span class="nb">say</span> <span class="k">for</span>
    <span class="p">((&#39;&#39;</span> <span class="ow">xx</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Fizz</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span> <span class="ow">Z</span><span class="o">~</span>
    <span class="p">(&#39;&#39;</span> <span class="ow">xx</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Buzz</span><span class="p">&#39;)</span> <span class="ow">xx</span> <span class="o">*</span><span class="p">)</span> <span class="ow">Z</span><span class="o">||</span><span class="err">1</span> <span class="o">..</span> <span class="mi">100</span><span class="p">;</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 圣诞月历 2012]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-04-15-raku-calendar-2012/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 圣诞月历 - 2014" />
            
                <id>https://ohmyweekly.github.io/notes/2015-04-15-raku-calendar-2012/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Calendar 2012</blockquote><h2 id="一个日历">一个日历</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">constant</span> <span class="nv">@months</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">January February March April May June July August September October November December</span><span class="p">&gt;;</span>
<span class="k">constant</span> <span class="nv">@days</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Su Mo Tu We Th Fr Sa</span><span class="p">&gt;;</span>

<span class="k">sub</span> <span class="nf">center</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$text</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$width</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$prefix</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$width</span> <span class="o">-</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">chars</span><span class="p">)</span> <span class="ow">div</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$suffix</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1"> </span><span class="p">&#39;</span> <span class="nb">x</span> <span class="nv">$width</span> <span class="o">-</span> <span class="nv">$text</span><span class="o">.</span><span class="nb">chars</span> <span class="o">-</span> <span class="nv">$prefix</span><span class="o">.</span><span class="nb">chars</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$prefix</span> <span class="o">~</span> <span class="nv">$text</span> <span class="o">~</span> <span class="nv">$suffix</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="o">:</span><span class="nv">$year</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">today</span><span class="o">.</span><span class="nb">year</span><span class="o">,</span> <span class="o">:</span><span class="nv">$month</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">today</span><span class="o">.</span><span class="nb">month</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$dt</span> <span class="o">=</span> <span class="nb">Date</span><span class="o">.</span><span class="nb">new</span><span class="p">(:</span><span class="s">year</span><span class="p">(</span><span class="nv">$year</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">month</span><span class="p">(</span><span class="nv">$month</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">day</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
    <span class="k">my</span> <span class="nv">$ss</span> <span class="o">=</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">day-of-week</span> <span class="nv">%</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@slots</span> <span class="o">=</span> <span class="p">&#39;&#39;</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%2s</span><span class="p">&#34;)</span> <span class="ow">xx</span> <span class="nv">$ss</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$days-in-month</span> <span class="o">=</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">days-in-month</span><span class="p">;</span>

    <span class="k">for</span> <span class="nv">$ss</span> <span class="o">..^</span> <span class="nv">$ss</span> <span class="o">+</span> <span class="nv">$days-in-month</span> <span class="p">{</span>
        <span class="nv">@slots</span><span class="o">[</span><span class="nv">$_</span><span class="o">]</span> <span class="o">=</span> <span class="nv">$dt</span><span class="o">.</span><span class="nb">day</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%2d</span><span class="p">&#34;);</span>
        <span class="nv">$dt</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="k">my</span> <span class="nv">$weekdays</span> <span class="o">=</span> <span class="nv">@days</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%2s</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="o">:</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;;</span>
    <span class="nb">say</span> <span class="nf">center</span><span class="p">(</span><span class="nv">@months</span><span class="o">[</span><span class="nv">$month-1</span><span class="o">]</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">$year</span><span class="o">,</span> <span class="nv">$weekdays</span><span class="o">.</span><span class="nb">chars</span><span class="p">);</span>
    <span class="nb">say</span> <span class="nv">$weekdays</span><span class="p">;</span>

    <span class="k">for</span> <span class="nv">@slots</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$k</span><span class="o">,</span> <span class="nv">$v</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="p">&#34;</span><span class="nv">$v</span><span class="s2"> </span><span class="p">&#34;;</span>
        <span class="nb">print</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;</span> <span class="k">if</span> <span class="p">(</span><span class="nv">$k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="nv">%%</span> <span class="mi">7</span> <span class="ow">or</span> <span class="nv">$v</span> <span class="o">==</span> <span class="nv">$days-in-month</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="bags-and-sets">Bags and Sets</h2>
<p>过去几年, 我写了很多这种代码的变种：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span><span class="p">;</span>
<span class="k">for</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
    <span class="nv">%words</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>(此外: <code>slurp.comb(/\w+/).map(*.lc)</code> 从指定的标准输入或命令行读取文件, 遍历数据中的单词, 然后小写化该单词。 eg: raku slurp.pl score.txt)</p>
<p>Raku 引入了两种新的组合类型来实现这种功能。 在这种情况下, 半路杀出个 KeyBag 代替了 hash:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span> <span class="o">:=</span> <span class="n">KeyBag</span><span class="o">.</span><span class="nb">new</span><span class="p">;</span>
<span class="k">for</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
    <span class="nv">%words</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这种情况下, 为什么你会喜欢 KeyBag 多于散列呢, 难道是前者代码更多吗？很好, 如果你想要的是一个正整数值的散列的话, KeyBag 将更好地表达出你的意思。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%words</span><span class="p">{&#34;</span><span class="s2">the</span><span class="p">&#34;}</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">green</span><span class="p">&#34;;</span>
</code></pre></div><p>未处理过的异常：不能解析数字：green</p>
<p>然而 KeyBag 有几条锦囊妙计。首先, 四行代码初始化你的 KeyBag 不是很罗嗦, 但是 Raku 能让它全部写在一行也不会有问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span> <span class="o">:=</span> <span class="n">KeyBag</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">));</span>
</code></pre></div><p>KeyBag.new 尽力把放到它里面的东西变成 KeyBag 的内容。给出一个列表, 列表中的每个元素都会被添加到 KeyBag 中, 结果和之前的代码块是完全一样的。</p>
<p>如果你不需要在创建bag后去修改它, 你可以使用 Bag 来代替 KeyBag。不同之处是 Bag 是不会改变的；如果 %words 是一个 Bag, 则 %words{$word}++ 是非法的。如果对你的程序来说, 不变没有问题的话, 那你可以让代码更紧凑。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%words</span> <span class="o">:=</span> <span class="nb">bag</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">);</span>  <span class="c1"># 散列 %words 不会再变化</span>
</code></pre></div><p>bag 是一个有用的子例程, 它只是对任何你给它的东西上调用 Bag.new 方法。（我不清楚为什么没有同样功能的 keybag 子例程）</p>
<p>Bag 和 KeyBag 有几个雕虫小技。它们都有它们自己的 .roll 和 .pick 方法, 以根据给定的值来权衡它们的结果：</p>
<pre><code>&gt; my $bag = bag &quot;red&quot; =&gt; 2, &quot;blue&quot; =&gt; 10;
&gt; say $bag.roll(10);
&gt; say $bag.pick(*).join(&quot; &quot;);

blue blue blue blue blue blue red blue red blue
blue red blue blue red blue blue blue blue blue blue blue
This wouldn’t be too hard to emulate using a normal Array, but this version would be:
&gt; $bag = bag &quot;red&quot; =&gt; 20000000000000000001, &quot;blue&quot; =&gt; 100000000000000000000;
&gt; say $bag.roll(10);
&gt; say $bag.pick(10).join(&quot; &quot;);
blue blue blue blue red blue red blue blue blue
blue blue blue red blue blue blue red blue blue
</code></pre><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span><span class="nv">$file1</span><span class="o">,</span> <span class="nv">$file2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$words1</span> <span class="o">=</span> <span class="nb">bag</span> <span class="nb">slurp</span><span class="p">(</span><span class="nv">$file1</span><span class="p">)</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$words2</span> <span class="o">=</span> <span class="nb">set</span> <span class="nb">slurp</span><span class="p">(</span><span class="nv">$file2</span><span class="p">)</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\w</span><span class="o">+</span><span class="p">/)</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">lc</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$unique</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$words1</span> <span class="ow">(-)</span> <span class="nv">$words2</span><span class="p">);</span>

    <span class="k">for</span> <span class="nv">$unique</span><span class="o">.</span><span class="nb">list</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="o">-</span><span class="nv">$words1</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">[^</span><span class="mi">10</span><span class="o">]</span> <span class="k">-&gt;</span> <span class="nv">$word</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$word:</span><span class="s2"> </span><span class="p">{</span> <span class="nv">$words1</span><span class="p">{</span><span class="nv">$word</span><span class="p">}</span><span class="s2"> }</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>传递两个文件名, 这使得 Bag 从第一个文件中获取单词, 让 Set 从第二个文件中获取单词, 然后使用 集合差 操作符 <code>(-)</code> 来计算只在第一个文件中含有的单词, 按那些单词出现的频率排序, 然后打印出前10 个单词。</p>
<p>这是介绍 Set 的最好时机。就像你从上面猜到的一样, Set 跟 Bag 的作用很像。不同的地方在于, 它们都是散列, 而 Bag 是从Any到正整数的映射, Set 是从 Any 到 Bool::True 的映射。集合 Set 是不可改变的, 所以也有一个 可变的 KeySet。</p>
<p>在 Set 和 Bag 之间, 我们有很丰富的操作符：</p>
<pre><code>操作符	Unicode	“Texas”	结果类型

属于	∈	(elem)	Bool
不属于	∉	!(elem)	Bool
包含	∋	(cont)	Bool
不包含	∌	!(cont)	Bool

并集	∪	(|)	Set 或 Bag
交集	∩	(&amp;)	Set 或 Bag
差集	        (-)	Set

子集	⊆	(&lt;=)	Bool
非子集	⊈	!(&lt;=)	Bool
真子集	⊂	(&lt;)	Bool
非真子集	⊄	!(&lt;)	Bool

超级	⊇	(&gt;=)	Bool
非超级	⊉	!(&gt;=)	Bool
真超级	⊃	(&gt;)	Bool
非真超级	⊅	!(&gt;)	Bool

bag multiplication	⊍	(.)	Bag
bag addition	⊎	(+)	Bag
set symmetric difference (^)	Set
</code></pre><p>它们中的大多数都能不言自明。返回 Set 的操作符在做运算前会将它们的参数提升为 Set。返回 Bag 的操作符在做运算前会将它们的参数提升为 Bag。返回 Set 或 Bag 的操作符在做运算前会将它们的参数提升为 Bag, 如果它们中至少有一个是 Bag 或 KeyBag, 否则会转换为 Set；在任何一种情况下, 它们都返回提升后的类型。</p>
<pre><code>&gt; my $a = bag &lt;a a a b b c&gt;;  # bag(a(3), b(2), c)
&gt; my $b = bag &lt;a b b b&gt;;      # bag(a, b(3))

&gt; $a (|) $b;
bag(&quot;a&quot; =&gt; 3, &quot;b&quot; =&gt; 3, &quot;c&quot; =&gt; 1)

&gt; $a (&amp;) $b;
bag(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)

&gt; $a (+) $b;
bag(&quot;a&quot; =&gt; 4, &quot;b&quot; =&gt; 5, &quot;c&quot; =&gt; 1)

&gt; $a (.) $b;
bag(&quot;a&quot; =&gt; 3, &quot;b&quot; =&gt; 6)
</code></pre><p><a href="https://github.com/colomon/raku-set-bag-demo">下面是作者放在 github上的 Demo</a></p>
<p>A quick example of getting the 10 most common words in Hamlet which are not found in Much Ado About Nothing:</p>
<pre><code>&gt; raku bin/most-common-unique.pl data/Hamlet.txt data/Much_Ado_About_Nothing.txt
</code></pre><p>ham: 358
queen: 119
hamlet: 118
hor: 111
pol: 86
laer: 62
oph: 58
ros: 53
horatio: 48
clown: 47</p>
<h2 id="超棒的匿名函数">超棒的匿名函数</h2>
<p>Raku 对函数有很好的支持。Raku 令人惊叹的把函数声明包起来, 让你可以用各种方法来定义一个函数又不丢失任何特性。你可以定义参数类型、可选参数、命名参数, 甚至在子句里也可以。如果我不知道更好的理由的话, 我可能都在怀疑这是不是在补偿 Perl5 里那个相当基本的参数处理（咳咳 , <code>@_</code>, 你懂的）。
除开这些, Raku 也允许你定义没有命名的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="p">{</span><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">lol, I&#39;m so anonymous!</span><span class="p">&#34;</span> <span class="p">}</span>
</code></pre></div><p>这有什么用？你不命名它, 就没法调用它啊, 对不？错！</p>
<p>你可以保存这个函数到一个变量里。或者从另一个函数里 return 这个函数。或者传参给下一个函数。事实上, 当你不命名你的函数的时候, 你随后要运行什么代码就变得非常清晰了。就像一个可执行的 &ldquo;todo&rdquo; 列表一样。</p>
<p>现在让我们说说匿名函数可以给我们做点什么。在 Raku 里它看起来会是什么样子呢？</p>
<p>嗯, 就用最著名的排序来做例子吧。你可能想象 Raku 有一个 sort_lexicographically 函数和一个 sort_numberically 函数。不过其实没有。只有一个 sort 函数。当你需要具体用某种形式的排序时, 你就可以传递一个匿名函数给 sort 。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted_words</span>   <span class="o">=</span> <span class="nv">@words</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="o">~</span><span class="nv">$_</span> <span class="p">});</span>
<span class="k">my</span> <span class="nv">@sorted_numbers</span> <span class="o">=</span> <span class="nv">@numbers</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="o">+</span><span class="nv">$_</span> <span class="p">});</span>
</code></pre></div><p>（从技术上来说, 这是块, 不是函数。不过如果你不打算在里面使用 return 的话, 差异不大。）
当然你可以做的比这两个排序办法多多了。你可以通过鞋子大小排序, 或者最大地面速度, 或者自燃可能性的降序等等。因为你可以把任何逻辑作为一个参数传递进去。面向对象的教徒们对这种模式可非常自豪, 还专门命名为“依赖注入”。</p>
<p>想想看, map、 grep 和 reduce 都很依赖这种函数传递。我们有时候把这种传递函数给函数的做法叫“高阶编程”, 好像这是某些高手的特权似的。但其实这是一个非常有用而且可以普通使用的技能。</p>
<p>上面的示例都是在当前执行时就运行函数了。其实这里没什么限制。我们可以创建函数, 然后稍后再运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">make_surprise_for</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Sur-priiise, </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$reveal_surprise</span> <span class="o">=</span> <span class="nf">make_surprise_for</span><span class="p">(&#34;</span><span class="s2">Finn</span><span class="p">&#34;);</span>    <span class="c1">#</span>

<span class="c1"># 目前什么都没发生</span>
<span class="c1"># 等着</span>
<span class="c1"># 继续等着</span>
<span class="c1"># 等啊等啊等啊</span>
<span class="nv">$reveal_surprise</span><span class="p">();</span>        <span class="c1"># &#34;Sur-priiise, Finn!&#34;</span>
</code></pre></div><p><code>$reveal_surpirse</code> 里的函数记住了 <code>$name</code> 变量值, 虽然原始函数是在很早之前传递进去的参数。棒极了！这个效果就叫在 <code>$name</code> 变量上闭合的匿名函数。不过这里可没什么技术 - 反正很棒就是了。</p>
<p>事实上, 如果放在其他主要存储机制比如数组和散列旁边再看匿名函数本身, 这感觉是很自然的事情。所有这些都可以存储在变量里, 作为参数传递或者从函数里返回。一个匿名数组允许你保存序列给以后调用。一个匿名散列允许你存储映射给以后调用。一个匿名函数允许你存储计算或者行为给以后调用。</p>
<p>本月晚些时候, 我会写篇介绍怎样通过 Raku 的动态域来创建漂亮的 DSL-y 接口。我们可以看到匿名函数在那里是怎么发挥作用的。</p>
<h2 id="第九天最长标示匹配">第九天:最长标示匹配</h2>
<p>Raku 正则表达式偏好尽可能的匹配最长的选择。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">food and drink</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> foo </span><span class="o">|</span><span class="sr"> food </span><span class="p">/;</span>   <span class="c1"># food</span>
</code></pre></div><p>这跟 Perl5 不一样。Perl5 更喜欢上面例子中的第一个选择, 结果匹配的是 &ldquo;foo&rdquo;。
如果你希望的话, 你依然可以按照优先匹配的原则运行, 这个原则隐藏在稍长选择操作符 <code>||</code> 背后：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">food and drink</span><span class="p">&#34;</span> <span class="o">~~</span> <span class="p">/</span><span class="sr"> foo </span><span class="o">||</span><span class="sr"> food </span><span class="p">/;</span>  <span class="c1"># foo</span>
</code></pre></div><p>&hellip;就是这样。这就是最长标记匹配。 ☺ 短文完毕。</p>
<p>“喂, 等等！”你听见你绝望而惊讶的大叫了, 满足你希望让每天的 Raku 圣临历走的慢一点的愿望。“为什么说最长标记匹配很重要？谁会在意这个？”</p>
<p>我很高兴你这样问。事实证明, 最长标记匹配（简称 LTM ）在如何解析的时候和我们的直觉配合相当默契。如果你创造了一门语言, 你希望人们可以声明一个叫 forest_density 的变量而不用提及这个单词和循环里用的 for 语法冲突, LTM 可以做到。</p>
<p>我喜欢“奇怪的一致性”这个说法 - 尤其当程序语言设计的共性让大家越来越雷同的时候。这里就是一种在类和语法之间的一致性。 Raku 基本上把这种一致性发挥到了极致。让我简单的阐述下我的意思。
现在我们习惯于写一个类, 总体来看, 类差不多是长这个样子的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="p">{</span>
    <span class="k">method</span>
    <span class="k">method</span>
    <span class="k">method</span>
<span class="p">}</span>
</code></pre></div><p>奇怪的是, 语法有个非常类似的结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="p">{</span>
    <span class="k">rule</span>
    <span class="nf">rule</span>
    rule
}
</code></pre></div><p>(实际上关键词有 regex, token 和 rule, 不过当我们把他当作一个组来讨论的时候, 我们暂时统一叫做 rules)</p>
<p>我们同样习惯于派生子类（class B is A）, 然后添加或者重写方法来产生一个新旧行为在一起的组合。Pelr6 提供了 multi methods , 它允许你添加相同名字的新方法, 而且不重写原有的, 它只尝试匹配所有的到新方法而已。这个调度是由一个（通常自动生成的） proto method 处理的。它负责调度给所有合格的候选者。</p>
<p>这些是怎样用语法和角色运行起来的呢？额, 首先它从原有的里面派生出新的语法, 和派生子类一样。（事实上, 底层是 完全 相同的机制。语法不过是有个不同元类对象的类罢了。）新的角色也会重写原有的角色, 和你在方法上习惯的一样。</p>
<p>S05 有个漂亮的解析信件的示例。然后派生出来解析正式信件的语法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">grammar</span> <span class="nc">Letter</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">text</span>     <span class="p">{</span><span class="sr">    </span><span class="p">}</span>
    <span class="k">rule</span> <span class="nf">greet</span> <span class="p">{</span><span class="sr"> </span><span class="p">[</span><span class="sr">Hi</span><span class="o">|</span><span class="sr">Hey</span><span class="o">|</span><span class="sr">Yo</span><span class="p">]</span><span class="sr"> </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="se">\S</span><span class="o">+?</span><span class="p">)</span><span class="sr"> , </span><span class="ni">$$</span><span class="p">}</span>
    <span class="k">rule</span> <span class="nf">body</span>     <span class="p">{</span><span class="sr"> </span><span class="o">+?</span><span class="sr"> </span><span class="p">}</span>   <span class="c1"># note: backtracks forwards via +?</span>
    <span class="k">rule</span> <span class="nf">close</span> <span class="p">{</span><span class="sr"> Later dude, </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">grammar</span> <span class="nc">FormalLetter</span> <span class="k">is</span> <span class="nc">Letter</span> <span class="p">{</span>
    <span class="k">rule</span> <span class="nf">greet</span> <span class="p">{</span><span class="sr"> Dear </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="se">\S</span><span class="o">+?</span><span class="p">)</span><span class="sr"> , </span><span class="ni">$$</span><span class="p">}</span>
    <span class="k">rule</span> <span class="nf">close</span> <span class="p">{</span><span class="sr"> Yours sincerely, </span><span class="ni">$</span><span class="o">=</span><span class="p">(</span><span class="ni">.</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>派生出来的 FormalLetter 重写了 greet 和 close, 但是没重写 body。</p>
<p>但是这一切在 multi 方法下也能正常运行吗？我们是不是可以定义一种“原型角色”来允许我们在一个语法里用同样的名字有多种角色, 内容各不相同？比如, 我们可能希望用一个角色 term 来解析语言, 不过有很多不同的 terms：字符串、数字……而且数字可能是十进制、二进制、八进制、十六进制等……</p>
<p>Raku 语法可以包含一个原型角色, 然后你可以定义、重定义同名角色随便多少次。显然让我们回到文章最开始的 <code>/ foo | food /</code>。所有你起了相同名字的角色会编译成一个大的 alternation。</p>
<p>不仅如此 - 调用其他角色的角色, 有些可能是原型角色, 这些也会全部扁平化到一个大的 LTM 轮流选择里。实践中, 这意味着一个 term 的所有可能会一次被全部尝试一遍, 机会平等。没哪个会因为自己是先定义的所以胜出, 只有最长匹配的那个选择才胜出。</p>
<p>这个奇怪的一致性说明事实上, 在调用某个方式的时候, 最具体的方法胜出, 而且这个“最具体”必须加上引号。签名里参数描述类型越好, 方法就越具体。</p>
<p>在分析某个角色的时候, 同样是最具体的角色胜出, 不过这里“最具体”必须成功解析才行。角色描述下一步进入的文本越详细, 角色就越具体。</p>
<p>这就是奇怪的一致性。因为表面上方法和角色看起来就是完全不一样的怪兽。</p>
<p>我们真心相信我们理解了派生语法的原理并且得到了一门新的语言。 LTM 就是最合适的因为它允许新旧角色通过一个公平和可预测的办法混杂在一起。角色不是因为他们定义的前后而胜出, 而是因为它能最好的解析文本。这才是挑选精英的办法。</p>
<p>事实上, Raku 编译器自己就是这样工作的。它使用 Raku 语法解析你的程序, 这个语法是可以派生的……不管你在程序里什么时候声明了一个新操作符, 都会给你派生出一个新的语法。新操作符的解析就作为新角色加入到新语法里。然后把解析剩余程序的任务交给新的语法。你的新操作符会胜过那写相同但匹配更短的, 不过输给相同但匹配更长的。</p>
<h2 id="开开心心玩-rakudo-和-euler-项目">开开心心玩 Rakudo 和 Euler 项目</h2>
<p>Raku 实现的领先者 Rakudo , 目前还不完美, 说起性能也尤其让人尴尬。然而先行者不会问“他快么？”, 而会问“他够快么？”, 甚至是“我怎样能帮他变得更快呢？”。</p>
<p>为了说服你 Rakudo 已经能做到足够快了。我们准备尝试做一组 Euler 项目测试。其中很多涉及强行的数值计算, Rakudo 目前还不是很擅长。不过我们可没必要就此顿足：语言性能降低了, 程序员就要更心灵手巧了, 这正是乐趣所在啊。</p>
<p>所有的代码都是在 Rakudo 2012.11 上测试通过的。</p>
<p>先从一些简单的例子开始。</p>
<p>想想斐波那契序列里数值不超过四百万的元素, 计算这些值的总和。办法超级简单：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">[+]</span> <span class="nb">grep</span> <span class="o">*</span> <span class="nv">%%</span> <span class="mi">2</span><span class="o">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">*+*</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">4_000_000</span><span class="p">);</span>
</code></pre></div><p>运行时间：0.4秒</p>
<p>注意怎样使用操作符才能让代码即紧凑又保持可读性(当然这点大家肯定意见不一)。我们用了：</p>
<ul>
<li>无论如何用 <code>*</code> 创建 lambda 函数</li>
<li>用序列操作符 <code>...^</code> 来建立斐波那契序列</li>
<li>用整除操作符 <code>%%</code> 来过滤元素</li>
<li>用 <code>[+]</code> 做 reduce 操作计算和</li>
</ul>
<p>当然, 没人强制你这样疯狂的使用操作符 - 香草(vanilla)命令式的代码也没问题：</p>
<blockquote>
<p>600851475143 的最大素因数是多少？</p>
</blockquote>
<p>命令式的解决方案是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">largest-prime-factor</span><span class="p">(</span><span class="nv">$n</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">*+</span><span class="mi">2</span> <span class="o">...</span> <span class="o">*</span> <span class="p">{</span>
        <span class="k">while</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
            <span class="nv">$n</span> <span class="ow">div</span><span class="o">=</span> <span class="nv">$_</span><span class="p">;</span>
            <span class="k">return</span> <span class="nv">$_</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">&gt;</span> <span class="nv">$n</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">largest-prime-factor</span><span class="p">(</span><span class="mi">600_851_475_143</span><span class="p">);</span>
</code></pre></div><p>运行时间：2.6秒</p>
<p>注意用的 <code>is copy</code>, 因为 Raku 的绑定参数默认是只读的。还有用了整数除法 <code>div</code>, 而没用数值除法的 <code>/</code>。</p>
<p>到目前为止都没有什么特别的, 我们继续:</p>
<p>n从1到100, <!-- raw HTML omitted -->n<!-- raw HTML omitted -->C<!-- raw HTML omitted -->r<!-- raw HTML omitted --> 的值, 不一定要求不同, 有多少大于一百万的？</p>
<p>我们将使用 feed 操作符 <code>==&gt;</code> 来分解算法成计算的每一步：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="k">-&gt;</span> <span class="nv">@p</span> <span class="p">{</span> <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="nv">@p</span> <span class="ow">Z</span><span class="o">+</span> <span class="nv">@p</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="p">}</span> <span class="o">...</span> <span class="o">*</span> <span class="c1"># 生成杨辉三角</span>
<span class="o">==&gt;</span> <span class="p">(</span><span class="o">*[</span><span class="mi">0</span><span class="o">..</span><span class="mi">100</span><span class="o">]</span><span class="p">)()</span>                     <span class="c1"># 生成0到100的n行</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="o">*.</span><span class="nb">list</span>                        <span class="c1"># 平铺成一个列表</span>
<span class="o">==&gt;</span> <span class="nb">grep</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="mi">1_000_000</span>                <span class="c1"># 过滤超过1000000的数</span>
<span class="o">==&gt;</span> <span class="nb">elems</span><span class="p">()</span>                           <span class="c1"># 计算个数</span>
<span class="o">==&gt;</span> <span class="nb">say</span><span class="p">;</span>                              <span class="c1"># 输出结果</span>
</code></pre></div><p>运行时间：5.2s</p>
<p>注意使用了 <code>Z</code> 操作符和 <code>+</code> 来压缩 <code>0,@p</code> 和 <code>@p,0</code> 的两个列表。</p>
<p>这个单行生成杨辉三角的写法是从 Rosetta 代码里偷过来的。那是另一个不错的项目, 如果你对 Raku 的片段练习很感兴趣的话。</p>
<p>让我们做些更巧妙的。</p>
<p>存在一个毕达哥拉斯三元数组让 <code>a +b + c = 1000</code> 。求 a、b、c 的值。</p>
<p>暴力破解可以完成 (Polettix 的解决办法), 但是这个办法不够快（在我机器上花了11秒左右）。让我们用点代数知识把问题更简单的解决。</p>
<p>先创建一个 (a, b, c) 组成的毕达哥拉斯三元数组:</p>
<pre><code>a &lt; b &lt; c
a² + b² = c²
</code></pre><p>要求 <code>N = a + b +c</code> 就要符合：</p>
<pre><code>b = N·(N - 2a) / 2·(N - a)
c = N·(N - 2a) / 2·(N - a) + a²/(N - a)
</code></pre><p>这就自动符合了 <code>b &lt; c</code> 的条件。
而 <code>a &lt; b</code> 的条件则产生下面这个约束：</p>
<pre><code>a &lt; (1 - 1/√2)·N
</code></pre><p>我们就得到以下代码了：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">triplets</span><span class="p">(</span>\<span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nb">Int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">\u</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">\v</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>

        <span class="c1"># 检查 b = u/v 是否是整数</span>
        <span class="c1"># 如果是, 我们就找到了一个三元数组</span>
        <span class="k">if</span> <span class="n">u</span> <span class="nv">%%</span> <span class="n">v</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">\b</span> <span class="o">=</span> <span class="n">u</span> <span class="ow">div</span> <span class="n">v</span><span class="p">;</span>
            <span class="k">my</span> <span class="nv">\c</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
            <span class="nb">take</span> <span class="nv">$</span><span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="o">[*]</span> <span class="o">.</span><span class="nb">list</span> <span class="k">for</span> <span class="k">gather</span> <span class="nf">triplets</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</code></pre></div><p>运行时间：0.5s</p>
<p>注意 sigilless 变量 <code>\N</code>, <code>\a</code> …… 的声明, <code>$(...)</code> 是怎么用来把三元数组作为单独元素返回的, 用<code>$_.list</code> 的缩写 <code>.list</code> 来恢复其列表性。</p>
<p><code>&amp;triplets</code> 子例程作为生成器, 并且使用 <code>&amp;take</code> 切换到结果。相应的 <code>&amp;gather</code> 用来划定生成器的(动态)作用域, 而且它也可以放进 <code>&amp;triplets</code>, 这个可能返回一个惰性列表。</p>
<p>我们同样可以使用流操作符改写成数据流驱动的风格：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">N</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="mi">1</span><span class="o">..</span><span class="nb">Int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span> <span class="o">[</span> <span class="n">a</span><span class="o">,</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">]</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">grep</span> <span class="k">-&gt;</span> <span class="o">[</span> \<span class="n">a</span><span class="o">,</span> \<span class="n">u</span><span class="o">,</span> \<span class="n">v</span> <span class="o">]</span> <span class="p">{</span> <span class="n">u</span> <span class="nv">%%</span> <span class="n">v</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> <span class="o">[</span> \<span class="n">a</span><span class="o">,</span> \<span class="n">u</span><span class="o">,</span> \<span class="n">v</span> <span class="o">]</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\b</span> <span class="o">=</span> <span class="n">u</span> <span class="ow">div</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">\c</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
<span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>运行时间：0.5s</p>
<p>注意我们是怎样用解压签名绑定 <code>-&gt; [...]</code> 来解压传递过来的数组的。</p>
<p>使用这种特殊的风格没有什么实质的好处：事实上还很容易影响到性能, 我们随后会看到一个这方面的例子。
写纯函数式算法是个超级好的路子。不过原则上这就意味着让那些足够先进的优化器乱来（想想自动向量化和线程）。不过 Rakudo 还没到这个复杂地步。</p>
<p>但是如果我们没有聪明到可以找到这么牛叉的解决办法, 该怎么办呢？</p>
<p>求第一个连续四个整数, 他们有四个不同的素因数。</p>
<p>除了暴力破解, 我没找到任何更好的办法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="mi">2</span><span class="o">..*</span> <span class="p">{</span>
    <span class="nv">$i</span> <span class="o">=</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span> <span class="o">==</span> <span class="nv">$N</span> <span class="o">??</span> <span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!!</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="nv">$i</span> <span class="o">==</span> <span class="nv">$N</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="nv">$_</span> <span class="o">-</span> <span class="nv">$N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nb">last</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里, <code>&amp;fators</code> 返回素因数的个数, 原始的实现差不多是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">*+</span><span class="mi">2</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
            <span class="o">++</span><span class="nv">$i</span><span class="p">;</span>
            <span class="k">repeat</span> <span class="k">while</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
                <span class="nv">$n</span> <span class="ow">div</span><span class="o">=</span> <span class="nv">$_</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>运行时间：unknown (33s for N=3)</p>
<p>注意 <code>repeat while ...{...}</code> 的用法, 这是 <code>do {...} while(...);</code> 的新写法。
我们可以加上点缓存来加速程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">BEGIN</span> <span class="k">my</span> <span class="nv">%cache</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">%cache</span><span class="p">)</span> <span class="p">{</span> <span class="nv">%cache</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">*+</span><span class="mi">2</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="nb">sqrt</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nv">$n</span> <span class="nv">%%</span> <span class="nv">$_</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="nv">$n</span><span class="p">;</span>
            <span class="nv">$r</span> <span class="ow">div</span><span class="o">=</span> <span class="nv">$_</span> <span class="k">while</span> <span class="nv">$r</span> <span class="nv">%%</span> <span class="nv">$_</span><span class="p">;</span>
            <span class="k">return</span> <span class="nv">%cache</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$r</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">%cache</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>运行时间：unknown (3.5s for N=3)</p>
<p>注意用 <code>BEGIN</code> 来初始化缓存, 不管出现在源代码里哪个位置。还有用 <code>multi</code> 来启用对 <code>&amp;factors</code> 的多样调度。<code>where</code> 子句可以根据参数的值进行动态调度。</p>
<p>哪怕有缓存, 我们依然无法在一个合理的时间内回答上来原来的问题。现在我们怎么办？只能用点骗子手段了Zavolaj – Rakudo 版本的 NativeCall – 来在C语言里实现因式分解。</p>
<p>事实证明这还不够好, 所以我们继续重构剩下的代码, 添加一些原型声明：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">NativeCall</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">factors</span><span class="p">(</span><span class="nb">int</span> <span class="nv">$n</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">int</span> <span class="k">is</span> <span class="k">native</span><span class="p">(&#39;</span><span class="s1">./prob047-gerdr</span><span class="p">&#39;)</span> <span class="p">{</span> <span class="o">*</span> <span class="p">}</span>

<span class="k">my</span> <span class="nb">int</span> <span class="nv">$N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="k">my</span> <span class="nb">int</span> <span class="nv">$n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">int</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span> <span class="nv">$i</span> <span class="o">!=</span> <span class="nv">$N</span> <span class="p">{</span>
    <span class="nv">$i</span> <span class="o">=</span> <span class="nf">factors</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="o">==</span> <span class="nv">$N</span> <span class="o">??</span> <span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!!</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nv">$n</span> <span class="o">=</span> <span class="nv">$n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nv">$n</span> <span class="o">-</span> <span class="nv">$N</span><span class="p">;</span>
</code></pre></div><p>运行时间：1m2s (0.8s for N=3)</p>
<p>相比之下, 完全使用C语言实现这个算法, 运行时间在0.1秒之内。所以目前 Rakudo 还没法赢得任何一种速度测试。</p>
<p>重复一下, 用三种办法做一件事：</p>
<p>在 <code>2 ≤ a ≤ 100</code> 和 <code>2 ≤ b ≤ 100</code> 的情况下由 a<!-- raw HTML omitted -->b<!-- raw HTML omitted --> 生成的序列里有多少不一样的元素？
下面是一个很漂亮但很慢的解决办法, 可以用来验证其他办法是否正确：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span> <span class="ow">X</span><span class="o">=&gt;</span> <span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="nb">classify</span><span class="p">({</span> <span class="o">.</span><span class="nb">key</span> <span class="o">**</span> <span class="o">.</span><span class="nb">value</span> <span class="p">});</span>
</code></pre></div><p>运行时间：11s</p>
<p>注意使用 <code>X=&gt;</code> 来构造笛卡尔乘积。用对构造器 <code>=&gt;</code> 防止序列被压扁而已。</p>
<p>因为 Rakudo 支持大整数语义, 所以在计算像 100100 这种大数的时候没有精密度上的损失。</p>
<p>不过我们并不真的在意幂的值, 不过用基数和指数来唯一标示幂。我们需要注意基数可能自己本身就是前面某次的幂值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">constant</span> <span class="no">A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">constant</span> <span class="no">B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">%powers</span><span class="o">,</span> <span class="nv">%count</span><span class="p">);</span>

<span class="c1"># 找出那些是之前基数的幂的基数</span>
<span class="c1"># 分别存储基数和指数</span>
<span class="k">for</span> <span class="mi">2</span><span class="o">..</span><span class="nb">Int</span><span class="p">(</span><span class="nb">sqrt</span> <span class="n">A</span><span class="p">)</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span>
    <span class="nb">next</span> <span class="k">if</span> <span class="n">a</span> <span class="o">~~</span> <span class="nv">%powers</span><span class="p">;</span>
    <span class="nv">%powers</span><span class="p">{</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">3</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">}</span> <span class="o">=</span> <span class="n">a</span> <span class="ow">X</span><span class="o">=&gt;</span> <span class="mi">1</span><span class="o">..*</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1"># 计算重复的个数</span>
<span class="k">for</span> <span class="nv">%powers</span><span class="o">.</span><span class="nb">values</span> <span class="k">-&gt;</span> \<span class="n">p</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">..</span><span class="n">B</span> <span class="k">-&gt;</span> \<span class="nb">e</span> <span class="p">{</span>
        <span class="c1"># 上升到 \e 的幂</span>
        <span class="c1"># 根据之前的基数和对应指数分类</span>
        <span class="o">++</span><span class="nv">%count</span><span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="s">key</span> <span class="o">=&gt;</span> <span class="n">p</span><span class="o">.</span><span class="nb">value</span> <span class="o">*</span> <span class="nb">e</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 添加 +%count 作为一个需要保存的副本</span>
<span class="nb">say</span> <span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nv">%count</span> <span class="o">-</span> <span class="o">[+]</span> <span class="nv">%count</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
</code></pre></div><p>运行时间：0.9s</p>
<p>注意用序列操作符 <code>...^</code> 推断集合序列, 只要提供至少三个元素, 列表赋值 <code>%powers{...} = ...</code> 就会无休止的进行下去。</p>
<p>我们再次用数据驱动的函数式的风格重写一遍：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">cross</span><span class="p">(</span><span class="nv">@a</span><span class="o">,</span> <span class="nv">@b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@a</span> <span class="ow">X</span> <span class="nv">@b</span> <span class="p">}</span>
<span class="k">sub</span> <span class="nf">dups</span><span class="p">(</span><span class="nv">@a</span><span class="p">)</span> <span class="p">{</span> <span class="nv">@a</span> <span class="o">-</span> <span class="nv">@a</span><span class="o">.</span><span class="nf">uniq</span> <span class="p">}</span>

<span class="k">constant</span> <span class="no">A</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">constant</span> <span class="no">B</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="mi">2</span><span class="o">..</span><span class="nb">Int</span><span class="p">(</span><span class="nb">sqrt</span> <span class="n">A</span><span class="p">)</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> \<span class="n">a</span> <span class="p">{</span> <span class="p">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">3</span> <span class="o">...^</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">)</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">X</span> <span class="mi">1</span><span class="o">..*</span><span class="p">)</span><span class="o">.</span><span class="nb">tree</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nb">reverse</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="nb">hash</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="nb">values</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="nb">cross</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="n">B</span><span class="p">)</span>
<span class="o">==&gt;</span> <span class="nb">map</span> <span class="k">-&gt;</span> \<span class="n">n</span><span class="o">,</span> <span class="o">[</span>\<span class="nb">r</span><span class="o">,</span> \<span class="nb">e</span><span class="o">]</span> <span class="p">{</span> <span class="p">(</span><span class="nb">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">e</span> <span class="o">*</span> <span class="n">n</span> <span class="p">}</span>
<span class="o">==&gt;</span> <span class="nf">dups</span><span class="p">()</span>
<span class="o">==&gt;</span> <span class="p">((</span><span class="n">A</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="p">)()</span>
<span class="o">==&gt;</span> <span class="nb">say</span><span class="p">();</span>
</code></pre></div><p>运行时间：1.5s</p>
<p>注意我们怎么用 <code>&amp;tree</code> 来防止压扁的。我们可以像之前那样用 <code>X=&gt;</code> 替代 X , 不过这会让通过 <code>-&gt;  \n, [\r, \e]</code> 解构变得很复杂。</p>
<p>和预想的一样, 这个写法没像命令式的那样执行出来。怎么才能正常运行呢？这算是我留给读者的作业吧。</p>
<h2 id="解析-ipv4-地址">解析 IPv4 地址</h2>
<p>Raku 的正则现在是一种子语言了, 很多语法没有变:</p>
<pre><code>/\d+/
</code></pre><p>捕获数字：</p>
<pre><code>/(\d+)/
</code></pre><p>现在 <code>$0</code> 存储着匹配到的数字, 而不是 Perl 5 中的 <code>$1</code>. 所有的特殊变量 <code>$0</code>,<code>$1</code>,<code>$2</code> 在 Raku 里就是 <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code>. 在 Perl 5 中, <code>$0</code> 是脚本或程序的文件名, 但是这在 Raku 中变成了 <code>$*EXECUTABLE_NAME</code>。</p>
<p>如果你对获得一个正则匹配的所有捕获组感兴趣, 你可以使用 <code>@()</code>, 它是 <code>@($/)</code> 的语法糖。
<code>$/</code> 变量中的对象拥有许多关于最后一次匹配的有用信息。例如, <code>$/.from</code> 将给你匹配的起始字符串位置。
但是 <code>$0</code> 将使我们在这篇文章中走得足够远。我们用它来从一个字符串中提取单个特征。</p>
<p>修饰符现在放在前面了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">1 23 456 78.9</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="o">.</span><span class="nb">Str</span> <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/(</span><span class="se">\d</span><span class="o">+</span><span class="p">)/;</span> <span class="c1"># 1 23 456 78 9</span>
</code></pre></div><p>匹配所有看起来像这样的东西很有用, 以至于它有一个专门的 <code>.comb</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$str</span><span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="se">\d</span><span class="o">+</span><span class="p">/);</span>
</code></pre></div><p>如果你对 <code>.split</code> 很熟悉, 你可以想到 <code>.comb</code> 就是它的表哥, 它匹配 <code>.split</code> 丢弃的东西 。
Perl 5 中匹配 IPv4 地址的正则如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})</span><span class="sr">\</span><span class="ni">.</span><span class="p">(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})</span><span class="sr">\</span><span class="ni">.</span><span class="p">(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})</span><span class="sr">\</span><span class="ni">.</span><span class="p">(</span><span class="se">\d</span><span class="p">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="p">})/</span>
</code></pre></div><p>这在 Raku 中是无效的。首先, {} 块在 Raku 的 正则中是真正的代码块；它们包含 Raku 代码。第二, 在 Raku 中请使用 <code>** N..M</code> (或 <code>** N..*</code>)  代替 <code>{N,M}</code></p>
<p>在 Raku 中匹配1到3位数字的正则如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">/</span>
</code></pre></div><p>匹配 Ipv4地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> \</span><span class="ni">.</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="o">**</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)/</span>
</code></pre></div><p>那仍有点笨拙。在 Raku 的正则中, 你可以使用重复操作符 <code>%</code> , 下面是重复 <code>(\d ** 1..3)</code> 这个正则 4次, 并使用 <code>.</code> 点号作为分隔符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/</span>
</code></pre></div><p><code>%</code> 操作符是一个量词修饰符, 所以它只跟在一个像 <code>*</code> 或 <code>+</code> 或 <code>**</code> 的量词后面。上面的正则意思是 匹配 4 组数字, 在每组数字间插入一个直接量 点号 <code>.</code>。</p>
<p>你也可能注意到 <code>\.</code> 变成了 <code>'.'</code> , 它们是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Go 127.0.0.1, I said! He went to 173.194.32.32.</span><span class="p">&#34;;</span>

<span class="nb">say</span> <span class="o">.</span><span class="nb">Str</span> <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>
<span class="c1"># output: 127.0.0.1 173.194.32.32</span>
</code></pre></div><p>或者我们可以使用 <code>.comb</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Go 127.0.0.1, I said! He went to 173.194.32.32.</span><span class="p">&#34;;</span>
<span class="k">my</span> <span class="nv">@ip4addrs</span> <span class="o">=</span> <span class="o">.</span><span class="nb">comb</span><span class="p">(/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/);</span>   <span class="c1"># 127.0.0.1 173.194.32.32</span>
</code></pre></div><p>如果我们对单独的数字感兴趣：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$_</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">Go 127.0.0.1, I said! He went to 173.194.32.32.</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="o">.</span><span class="nb">list</span><span class="o">&gt;&gt;.</span><span class="nb">Str</span><span class="o">.</span><span class="nb">perl</span> <span class="k">for</span> <span class="k">m</span><span class="p">:</span><span class="na">g</span><span class="p">/</span><span class="sr"> </span><span class="p">(</span><span class="se">\d</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">)</span><span class="sr"> </span><span class="o">**</span><span class="sr"> </span><span class="mi">4</span><span class="sr"> </span><span class="nv">%</span><span class="sr"> </span><span class="p">&#39;</span><span class="s1">.</span><span class="p">&#39;</span><span class="sr"> </span><span class="p">/;</span>
<span class="c1"># output: (&#34;127&#34;, &#34;0&#34;, &#34;0&#34;, &#34;1&#34;) (&#34;173&#34;, &#34;194&#34;, &#34;32&#34;, &#34;32&#34;)</span>
</code></pre></div><h2 id="引号">引号</h2>
<p>在很多地方, Raku 都提供给你更合理的默认设置以便在大多数情况下让你的工作变得更简单有趣。引号也不例外。</p>
<p>最常见的两种引号就是单引号和双引号。单引号最简单：让你引起一个字符串。唯一的“魔法”就是你可以用反斜杠转义一个单引号。而因为反斜杠的这个作用, 你可以用 <code>\\</code> 来表示反斜杠本身了。不过其实这个做法也是没必要的, 反斜杠自己可以直接传递。下面是一组例子：</p>
<pre><code>&gt; say 'Everybody loves Magical Trevor’;
Everybody loves Magical Trevor
&gt; say 'Oh wow, it\'s backslashed!’;
Oh wow, it's backslashed!
&gt; say 'You can include a \\ like this’;
You can include a \ like this
&gt; say 'Nothing like \n is available’;
Nothing like \n is available
&gt; say 'And a \ on its own is no problem’;
And a \ on its own is no problem
</code></pre><p>双引号, 额, 从字面上看就知道了, 两倍自然更强大了。:-) 它支持反斜杠转义, 但更重要的是他支持<code>内插</code>。也就是说<code>变量</code>和<code>闭包</code>可以放进双引号里。大大的帮你节约使用连接操作符或者字符串格式定义等等的时间。</p>
<p>下面是几个简单的例子：</p>
<pre><code>&gt; say &quot;Ooh look!\nLine breaks!&quot;
Ooh look!
Line breaks!
&gt; my $who = 'Ninochka'; say &quot;Hello, dear $who&quot;
Hello, dear Ninochka
&gt; say &quot;Hello, { prompt 'Enter your name: ' }!&quot;
Enter your name: _Jonathan_
Hello, Jonathan!
</code></pre><p>上面第二个例子展示了标量内插, 第三个则展示了闭包也可以插入双引号字符串里。闭包产生的值会被字符串化然后插入字符串中。那除了 <code>$</code> 开头的呢？ 规则是这样的：所有的都可以插入, 但前提是它们被某些后环缀(译者注：postcircumfix)(也就是带下标或者扩的数组或者哈希, 可以做引用或者方法调用)允许。事实上你也可以把他们都存进标量里。</p>
<pre><code>&gt; my @beer = &lt;Chimay Hobgoblin Yeti&gt;;
Chimay Hobgoblin Yeti
&gt; say &quot;First up, a @beer[0]&quot;
First up, a Chimay
&gt; say &quot;Then @beer[1,2].join(' and ')!&quot;
Then Hobgoblin and Yeti!
&gt; say &quot;Tu je &amp;prompt('Ktore pivo chces? ')&quot;
Ktore pivo chces? _Starobrno_
Tu je Starobrno
</code></pre><p>这里你看到了一个数组元素的内插, 一个被调用了方法的数组切片的内插和一个函数调用的内插。后环缀规则意味着我们再也不会砸掉你口年的邮箱地址了(译者注：邮箱地址里有@号)。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Please spam me at blackhole</span><span class="nv">@jnthn</span><span class="s2">.net</span><span class="p">&#34;</span>
<span class="n">Please</span> <span class="n">spam</span> <span class="n">me</span> <span class="nb">at</span> <span class="n">blackhole</span><span class="nv">@jnthn</span><span class="o">.</span><span class="nf">net</span>
</code></pre></div><h3 id="选择你自己的分隔符">选择你自己的分隔符</h3>
<p>单/双引号对大多数情况下都很好用, 不过如果你想在字符串里使用这些引号的时候咋办？继续用反斜杠不是什么好主意。其实你可以自定义其他字符做为引号字符。Raku 替你选好了。<code>q</code> 和 <code>qq</code> 引号结构后面紧跟的字符就会被作为分隔符。如果这个字符有相对应的关闭符, 那么就自动查找这个（比如, 如果你用了一个开启花括号{, 那么字符串就会在闭合花括号}处结束。注意你还可以使用多字符开启符和闭合符（不过要求是相同字符重复组成的多字符））。另外, <code>q</code> 的语义等同于单引号, <code>qq</code> 的语义等同于双引号。</p>
<pre><code>&gt; say q{C'est la vie}
C'est la vie
&gt; say q{{Unmatched } and { are { OK } in { here}}
Unmatched } and { are { OK } in { here
&gt; say qq!Lottery results: {(1..49).roll(6).sort}!
Lottery results: 12 13 26 34 36 46
</code></pre><h3 id="定界符heredoc">定界符(Heredoc)</h3>
<p>所有的引号结构都允许你包含多行内容。不过, 还有更好的办法：定界文档。还是用 <code>q</code> 或者 <code>qq</code> 开始, 然后跟上 <code>:to</code> 副词来定义我们期望在文本最后某行匹配的字符。让我们通过下面这个感人的故事看看它是怎么工作的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/THE END/
</span><span class="p"></span><span class="s">    Once upon a time, there was a pub. The pub had
</span><span class="s">    lots of awesome beer. One day, a Perl workshop
</span><span class="s">    was held near to the pub. The hackers drank
</span><span class="s">    the pub dry. The pub owner could finally afford
</span><span class="s">    a vacation.
</span><span class="s">    </span><span class="p">THE END</span>
</code></pre></div><p>脚本的输出如下：</p>
<pre><code>Once upon a time, there was a pub. The pub had
lots of awesome beer. One day, a Perl workshop
was held near to the pub. The hackers drank
the pub dry. The pub owner could finally afford
a vacation.
</code></pre><p>注意输出文本并没有像源程序那样缩进。定界符会自动清楚缩进到终端的级别。如果我们用 qq , 我们也可以往定界符里插入东西。注意这些都是通过字符串的 ident 方法实现的, 但是如果你的字符串里没有内插, 我们会在编译期的时候调用 ident 作为一种优化手段。</p>
<p>你同样可以有多个定界符, 包括调用定界符里的数据的方法也是可以的（注意下面的程序就调用了 lines 方法）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$input</span><span class="o">,</span> <span class="nv">@searches</span><span class="p">)</span> <span class="o">=</span> <span class="k">q</span><span class="sa">:to</span><span class="p">/INPUT/,</span><span class="s"> q:to/SEARCHES/.lines;
</span><span class="s">    Once upon a time, there was a pub. The pub had
</span><span class="s">    lots of awesome beer. One day, a Perl workshop
</span><span class="s">    was held near to the pub. The hackers drank
</span><span class="s">    the pub dry. The pub owner could finally afford
</span><span class="s">    a vacation.
</span><span class="s">    </span><span class="p">INPUT</span>
    <span class="n">beer</span>
    <span class="n">masak</span>
    <span class="n">vacation</span>
    <span class="n">whisky</span>
    <span class="n">SEARCHES</span>

<span class="k">for</span> <span class="nv">@searches</span> <span class="k">-&gt;</span> <span class="nv">$s</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$input</span> <span class="o">~~</span> <span class="p">/</span><span class="nv">$s</span><span class="p">/</span>
        <span class="o">??</span> <span class="p">&#34;</span><span class="s2">Found </span><span class="nv">$s</span><span class="p">&#34;</span>
        <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">Didn&#39;t find </span><span class="nv">$s</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>这个程序输出是：</p>
<pre><code>Found beer
Didn't find masak
Found vacation
Didn't find whisky
</code></pre><h3 id="自定义引号结构的引号副词">自定义引号结构的引号副词</h3>
<p>单/双引号的语义, 也是 q 和 qq 的语义, 已经可以解决绝大多数情况了。不过如果你有这么种情况：你要输出内插闭包而不是标量怎么办？这时候就要用上引号副词了。它们决定你是否开启引号特性。下面是例子：</p>
<pre><code>&gt; say qq:!s&quot;It costs $10 to {&lt;eat nom&gt;.pick} here.&quot;
It costs $10 to eat here.
</code></pre><p>这里我们使用了 qq 语义, 但是关闭里标量内插, 这意味着我们可以放心往里写价钱而不用担心他会试图解析成上一次正则匹配的第十一个捕获值。注意这里使用的标准的冒号对(colonpair)语法。如果你希望从一个最基础的引号结构开始, 然后自己手动的一个个打开选项, 那么你应该使用 Q 结构。</p>
<pre><code>&gt; say Q{$*OS\n&amp;sin(3)}
$*OS\n&amp;sin(3)
&gt; say Q:s{$*OS\n&amp;sin(3)}
MSWin32\n&amp;sin(3)
&gt; say Q:s:b{$*OS\n&amp;sin(3)}
MSWin32
&amp;sin(3)
&gt; say Q:s:b:f{$*OS\n&amp;sin(3)}
MSWin32
0.141120008059867
</code></pre><p>这里我们用了无特性引号结构, 然后打开附加特性, 地一个是标量内插, 然后是反斜杠转义, 然后函数内插。注意我们同样可以选择自己希望的任何分隔符。</p>
<h3 id="引号结构是一门语言">引号结构是一门语言</h3>
<p>最后, 值得一提的是：当解析器进入引号结构的时候, 其实他是切换成解析另外一个语言了。当我们用副词构建引号结构的时候, 他只不过是把这些额外的角色混合进基础的引号语言里来开启额外的特性。好奇的童鞋可以看这里： Rakudo 怎么做到的。而当我们碰到闭包或者其他内插的时候, 解析器再临时切换回主语言。所以你可以这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">&gt;</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Hello, </span><span class="p">{</span> <span class="nb">prompt</span> <span class="p">&#34;</span><span class="s2">Enter your name: </span><span class="p">&#34;</span> <span class="p">}</span><span class="s2">!</span><span class="p">&#34;</span>
<span class="n">Enter</span> <span class="nf">your</span> <span class="nb">name</span><span class="o">:</span> <span class="n">Jonathan</span>
<span class="n">Hello</span><span class="o">,</span> <span class="n">Jonathan</span><span class="o">!</span>
</code></pre></div><p>解析器不会困惑于内插的闭包里又带有其他双引号字符串的问题。因为我们解析主语言, 然后切换到引号语言, 然后返回主语言, 然后重新再返回引号语言来解析这个程序里的字符串里的闭包里的字符串。这就是 Raku 解析器送给我们的圣诞节礼物, 俄罗斯套娃娃。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/calendar" term="calendar" label="calendar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Sneaking Into a Loop]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2015-03-16-features-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Raku 中的特性(二)" />
                <link href="https://ohmyweekly.github.io/notes/2015-03-14-using-raku/?utm_source=atom_feed" rel="related" type="text/html" title="Using Raku" />
            
                <id>https://ohmyweekly.github.io/notes/2015-03-23-sneaking-into-a-loop/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Sneaking Into a Loop</blockquote><h2 id="sneaking-into-a-loop">Sneaking into a loop</h2>
<p>Zoffix 回答了一个关于 Perl 5 的 <code>&lt;&gt;</code> 操作符的<a href="http://irclog.perlgeek.de/raku/2016-08-09#i_12993090">问题</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%10s3d</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p><code>slurp</code> 会从 STDIN 中读取整个 &ldquo;file&rdquo; 并返回一个 Str。方法 <code>Str::words</code> 会按照某种 Unicode 意义的单词把该字符串分割成一个列表。把列表强转为 Bag 则创建一个计数 Hash, 它是如下表述的快捷方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%h</span><span class="p">;</span>
<span class="nv">%h</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">++</span> <span class="k">for</span> <span class="p">&lt;</span><span class="s">peter paul marry</span><span class="p">&gt;;</span>
<span class="n">dd</span> <span class="nv">%h</span><span class="p">;</span>

<span class="c1"># OUTPUT«Hash %h = {:marry(1), :paul(1), :peter(1)}␤»</span>
</code></pre></div><p>在关联数组上调用 <code>.sort(-*.value)</code> 会按照值的降序排序并返回一个排序后的 Pairs 列表。List::fmt 会调用 Pair::fmt, 它调用 fmt 方法, <code>.key</code> 作为其第二个参数, <code>.value</code> 也作为参数。say 会会使用一个空格连接各个元素并输出到标准输出。最后一步有一点错误因为除了第一行之外的每一行前面都会有一个额外的空格。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="nv">%10s</span><span class="s2"> =&gt; </span><span class="nv">%3d</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>手动连接字符串更好。这对于简短的单行程序来说有点多了。我们需要找到最长的单词并使用 <code>.chars</code> 来获取列宽。</p>
<p>slurp 会在 <code>$*IN</code> 身上调用 <code>.slurp-rest</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="vg">$*IN</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">peter paul marry peter paul paul</span><span class="p">&gt;</span> <span class="k">but</span> <span class="k">role</span> <span class="p">{</span> <span class="k">method</span> <span class="nb">slurp-rest</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nb">Str</span> <span class="p">}</span> <span class="p">};</span>
</code></pre></div><p>这是一种 hack 因为它会在任何形式的类型检测上失败并且它除了 slurp 之外不会对任何东西起作用。还有, 实际上我们从 <code>$*IN</code> 那里解绑 STDIN。不要在工作中使用这个奇淫技巧。</p>
<p>现在我们能开心地吞噬并开始计数了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%counted-words</span> <span class="o">=</span> <span class="nb">slurp</span><span class="o">.</span><span class="nb">words</span><span class="o">.</span><span class="nb">Bag</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$word-width</span> <span class="o">=</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">%counted-words</span><span class="o">.</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</code></pre></div><p>并且继续在链子断开的地方继续。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%counted-words</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(&#34;</span><span class="s2">%</span><span class="p">{</span><span class="nv">$word-width</span><span class="p">}</span><span class="s2">s3d</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;)</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>
</code></pre></div><p>问题解决了但是很丑陋。我们把一个单行程序拆开了。我们来修复 fmt 以使它再次完整。</p>
<p>我们想要的是一个 fmt 方法, 它接收一个位置的(Positional), 一个 printf 风格的格式字符串和一个格式字符串中的 block per <code>%*</code>。还有, 我们可能需要在 self.fmt 前面放上一个分隔符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="k">multi</span> <span class="k">method</span> <span class="nb">fmt</span><span class="p">(</span><span class="n">Positional:D:</span> <span class="nv">$fmt-str</span><span class="o">,</span> 
                    <span class="o">*</span><span class="nv">@width</span> <span class="k">where</span> <span class="o">*.</span><span class="nb">all</span> <span class="o">~~</span> <span class="nb">Callable</span><span class="o">,</span>
                    <span class="o">:</span><span class="nv">$separator</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2"> </span><span class="p">&#34;){</span>
    <span class="nb">self</span><span class="o">.</span><span class="nb">fmt</span><span class="p">(</span>
        <span class="nv">$fmt-str</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">%*</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">&amp;width</span> <span class="o">=</span> <span class="nv">@width</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span> <span class="o">//</span> <span class="nb">Failure</span><span class="o">.</span><span class="nb">new</span><span class="p">(&#34;</span><span class="s2">missingh block</span><span class="p">&#34;);</span>
            <span class="p">&#39;</span><span class="s1">%</span><span class="p">&#39;</span> <span class="o">~</span> <span class="p">(</span><span class="nv">&amp;width</span><span class="o">.</span><span class="nb">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">??</span> <span class="nf">width</span><span class="p">(</span><span class="nb">self</span><span class="o">,</span> <span class="nv">$_</span><span class="p">)</span> <span class="o">!!</span> <span class="nf">width</span><span class="p">(</span><span class="nb">self</span><span class="p">))</span>
        <span class="p">})</span><span class="o">,</span> <span class="nv">$separator</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>表达式 <code>*.all ~~ Callable</code> 检查 <a href="https://docs.raku.org/type/Signature#Slurpy_(A.K.A._Variadic)_Parameters">slurp array</a>中的所有元素是否实现了 CALL-ME(那是实际被执行的方法在你执行 foo()的时候)。</p>
<p>然后我们在格式字符串上使用了 <code>subst</code> 来替换 <code>%*</code>, 替换是一个(闭包)块儿, 它每次匹配被调用一次。而且这儿我们有不错的惯用法。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">1-a 2-b 3-c</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">subst</span><span class="p">(:</span><span class="s">g</span><span class="o">,</span> <span class="p">/</span><span class="se">\d</span><span class="p">/</span><span class="o">,</span> <span class="p">{&lt;</span><span class="s">one two three</span><span class="p">&gt;</span><span class="o">[</span><span class="nv">$</span><span class="o">++]</span><span class="p">});</span>
<span class="c1"># one-a two-b three-c</span>
</code></pre></div><p>匿名状态变量 <code>$</code> 从 0  开始计数, 每次代码块执行时增 1。实际上我们在这儿做的就是移除一个循环并给 subst 偷偷加入一个额外的计数器和数组下标。或者可以说我们注册了一个迭代器到 subst 里面的循环中。有人可能会质疑 subst 应该接收一个 Seq 作为它的第二个位置参数, 它会让调用变得冗长。无论如何, 我们把洞补上了。</p>
<p>在第 11 行, 我们从吞噬数组中拿出一个元素或者在没有元素时创建一个 Failure。我们把 block 存储在一个变量中因为我们想在第 12 行中内省。如果那个 block 接收两个位置参数,we feed the topic subst is calling the block with as a 2nd parameter to our stored block. 那碰巧是一个 Match 并且对于影响所匹配的东西可能有用。在我们这个例子中我们对 <code>%*</code> 进行匹配并且当前位置由 <code>$++</code> 计数。做完那个之后我们得到了一个格式字符串, 它带有一个由用户提供的 fmt 版本的列宽参数。</p>
<p>用户提供的块儿使用一组 Pairs 调用。我们不得不深入一层以得到更大的键。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span><span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="o">.</span><span class="nb">values</span><span class="o">».</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">}</span>
</code></pre></div><p>得到第一列的列宽。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">print</span> <span class="nv">%counted-words</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">-*.</span><span class="nb">value</span><span class="p">)</span><span class="o">.&amp;</span><span class="nb">fmt</span><span class="p">(</span>
    <span class="p">&#34;</span><span class="nv">%*s3d</span><span class="p">&#34;</span><span class="o">,</span> 
    <span class="p">{</span><span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="o">.</span><span class="nb">values</span><span class="o">».</span><span class="nb">keys</span><span class="o">».</span><span class="nb">chars</span><span class="p">}</span><span class="o">,</span> 
    <span class="s">separator</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
</code></pre></div><p>那个时髦的 <code>.&amp;fmt</code> 调用是必须的因为我们免费的浮点方法不是 List 的方法。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Subset]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-19-subset/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-19-subset/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Subset</blockquote><h2 id="subset-子集">Subset 子集</h2>
<p>Subset 可用于声明某一类型的子集。</p>
<p>输入一个密码,  要求密码必须满足如下条件：</p>
<p>1、 至少 8 位
2、 必须包含大写字母、小写字母 和 数字</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">subset</span> <span class="nc">Length8</span>      <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="o">*.</span><span class="nb">chars</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">UpCase</span>       <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="nb">none</span><span class="p">(&#39;</span><span class="s1">A</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">Z</span><span class="p">&#39;)</span>  <span class="o">∈</span> <span class="o">*.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">Set</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">LowerCase</span>    <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="nb">none</span><span class="p">(&#39;</span><span class="s1">a</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">z</span><span class="p">&#39;)</span>  <span class="o">∈</span> <span class="o">*.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">Set</span><span class="p">;</span>
<span class="k">subset</span> <span class="nc">IntNumber</span>    <span class="k">of</span> <span class="nb">Str</span> <span class="k">where</span> <span class="nb">none</span><span class="p">(&#39;</span><span class="s1">0</span><span class="p">&#39;</span><span class="o">..</span><span class="p">&#39;</span><span class="s1">9</span><span class="p">&#39;)</span>  <span class="o">∈</span> <span class="o">*.</span><span class="nb">comb</span><span class="o">.</span><span class="nb">Set</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$guess</span> <span class="o">=</span> <span class="nb">prompt</span><span class="p">(&#39;</span><span class="s1">Enter your password:</span><span class="p">&#39;);</span>

<span class="k">given</span> <span class="nv">$guess</span> <span class="p">{</span>
    <span class="k">when</span> <span class="n">Length8</span>     <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">密码长度必须为 8 位 以上</span><span class="p">&#39;;</span> <span class="k">proceed</span> <span class="p">}</span>
    <span class="k">when</span>  <span class="n">UpCase</span>     <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">密码必须包括大写字母</span><span class="p">&#39;;</span>     <span class="k">proceed</span> <span class="p">}</span>
    <span class="k">when</span> <span class="n">LowerCase</span>   <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">密码必须包含小写字母</span><span class="p">&#39;;</span>     <span class="k">proceed</span> <span class="p">}</span>
    <span class="k">when</span> <span class="n">IntNumber</span>   <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">密码必须包含数字</span><span class="p">&#39;;</span>                <span class="p">}</span>   
 <span class="p">}</span>
</code></pre></div><p>该程序具有可扩展性, 要增加一种密码验证, 只有添加一个 subset 就好了, 然后在 <code>given/when</code> 里面增加一个处理。</p>
<p><code>proceed</code> 相当于 <code>continue</code>, 不像 C 里面的 falling through, Raku 里面的 proceed 在继续执行下一个 <code>when</code> 语句时会计算 when 后面的条件。所以, 只要有 proceed, 则 proceed 后面的那个条件就会被执行。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/subset" term="subset" label="subset" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[When and Where]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-15-when-and-where/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-15-when-and-where/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-10T00:00:00+08:00</published>
            <updated>2021-07-10T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>When and Where</blockquote><h2 id="when-可以用在主题化_的语句中">When 可以用在主题化(<code>$_</code>)的语句中</h2>
<p>Raku 里面有个特殊的变量叫 <code>$_</code>, 即主题化变量, the variable in question.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">(&#39;</span><span class="s1">Swift</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">PHP</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;)</span> <span class="k">-&gt;</span> <span class="nv">$item</span>  <span class="p">{</span> 
    <span class="nb">say</span> <span class="nv">$item</span> <span class="k">when</span> <span class="nv">$item</span> <span class="o">~~</span> <span class="p">/</span><span class="ni">^</span><span class="sr">P</span><span class="p">/;</span>
<span class="p">}</span> 
</code></pre></div><p>输出:</p>
<pre><code>PHP
Python
Perl
</code></pre><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">56</span><span class="o">,</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">.</span><span class="nb">say</span> <span class="k">when</span> <span class="o">*&gt;</span><span class="mi">40</span> 
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>56
42
</code></pre><p>而 <em>where</em> 用于对类型进行约束:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="p">(&#39;</span><span class="s1">Swift</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">PHP</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Python</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Perl</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">42</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$item</span> <span class="k">where</span> <span class="nv">$item</span> <span class="o">~~</span> <span class="nb">Str</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$item</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输出:</p>
<pre><code>Swift                                                                               
PHP                                                                                 
Python                                                                              
Perl                                                                                    
Constraint type check failed for parameter '$item'       
</code></pre>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/where" term="where" label="where" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/when" term="when" label="when" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku 圣诞月历 - 2014]]></title>
            <link href="https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2014-12-19-raku-calendar/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-07T00:00:00+08:00</published>
            <updated>2021-07-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Calendar</blockquote><h2 id="data-munging-in-raku">Data munging in Raku</h2>
<p>案例学习: 生成成绩报告单</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">example.txt
STDOUT
Peter	B
Celine	A-
Zsófia	B+
João	F
Maryam	B+
秀英	B-
Finn	D+
Aarav	A
Emma	F
Omar	B
</code></pre></div><p>输出报告单：</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Zsófia&#39;s grade: B+
List of students with a failing grade:
  João, Emma
Distribution of grades by letter:
  A: 2 students
  B: 5 students
  D: 1 student
  F: 2 students
</code></pre></div><p>example.txt 是一个文本文件, 每行一个学生姓名和分数, 中间用空格分割。
我们希望我们的脚本能解析这样的文件并打印含有如下信息的报告：</p>
<p>学生名为 “Zsófia” 的成绩<br>
所有不及格学生的名字 (i.e. worse than D-),<br>
根据字母( 不带 <code>+</code>/<code>-</code> ) 把成绩分组。得到学生成绩的分布。</p>
<p>让我们一步步来, 添加 shebang 行:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>
</code></pre></div><p>在 Raku 中所有这些都为我们做好了。</p>
<p>读取并解析输入:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%grade</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">grades.txt</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">lines</span><span class="o">.</span><span class="nb">map</span><span class="o">:</span> <span class="p">{</span>
   <span class="k">m</span><span class="p">:</span><span class="na">s</span><span class="p">/</span><span class="ni">^</span><span class="p">(</span><span class="se">\w</span><span class="o">+</span><span class="p">)</span><span class="sr"> </span><span class="p">(&lt;[</span><span class="sr">A</span><span class="o">..</span><span class="sr">F</span><span class="p">]&gt;&lt;[</span><span class="sr">+-</span><span class="p">]&gt;</span><span class="o">?</span><span class="p">)</span><span class="ni">$</span><span class="p">/</span>
        <span class="ow">or</span> <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Can&#39;t parse line &#39;</span><span class="nv">$_&#39;</span><span class="p">&#34;;</span>
    <span class="o">~</span><span class="nv">$0</span> <span class="o">=&gt;</span> <span class="o">~</span><span class="nv">$1</span>
<span class="p">};</span>
</code></pre></div><p>在 Raku 中, 对文件名字符串调用 <a href="https://docs.raku.org/type/IO::Path">.IO</a> 方法会返回一个代表文件系统路径的对象, 我们可以继续在这个对象上调用 <a href="https://docs.raku.org/routine/lines">.lines</a> 方法, 得到文件的所有行的一个惰性列表。“Lazy” 意味着它只会从磁盘中按需读取新行, 当我们使用 <a href="https://docs.raku.org/routine/map">.map</a> 方法遍历列表元素的时候, 这样能使用单个赋值操作就能优雅地初始化一个散列。</p>
<p>我们不需要让文件句柄识别 Unicode, 也不用管文件句柄是否正确关闭, 这在 Raku 中都是默认发生的。</p>
<p><code>method: ...</code> 语法也可以写为 <code>.method(...)</code>, 前者使 map 看起来更像一个 block 语句, 并减少了括号凌乱。
<code>:s</code>(&ldquo;sigspace&rdquo;) 正则修饰符使解析 token 间的空白更优雅。但 Raku 中的字符类比 Perl 5 复杂了一丢丢。
正则捕获结果变量(<code>$0</code>, <code>$1</code>, …) 返回一个完整的 <a href="https://docs.raku.org/type/Match">Match</a> 对象 - 它为复杂使用场景增加了很多灵活性, 但是这里我们只想保留字符串, 所以使用 <a href="https://docs.raku.org/routine/~">~</a> 前置操作符字符串化了匹配对象。</p>
<p>查看数据的特定项:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Zsófia&#39;s grade: </span><span class="nv">%grade</span><span class="p">&lt;</span><span class="s">Zsófia</span><span class="p">&gt;&#34;;</span>
</code></pre></div><p>Raku 总是把散列中 <code>{ }</code> 中的东西解析为表达式, 使用 <code>&lt; &gt;</code> 表示字面值。</p>
<p>过滤数据:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">List of students with a failing grade:</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">  </span><span class="p">&#34;</span> <span class="o">~</span> <span class="nv">%grade</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span> <span class="ow">ge</span> <span class="p">&#34;</span><span class="s2">E</span><span class="p">&#34;)</span><span class="o">».</span><span class="nb">key</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">, </span><span class="p">&#34;);</span>
</code></pre></div><p>Raku 中允许我们按执行顺序把一些列方法写为链式操作。有一个重要区别：Raku 能让我们直接遍历散列的项, 散列中每一项都是一个 <a href="https://docs.raku.org/type/Pair">Pair</a> 对象(Pair 对象能使用 <a href="https://docs.raku.org/type/Pair#method_key">.key</a> 和 <a href="https://docs.raku.org/type/Pair#method_value">.value</a> 方法)。</p>
<p><code>*</code> <a href="https://docs.raku.org/type/Whatever">Whatever</a> star 用于定义一个简单的回调, 而不用写一个花括号块。
<code>».</code> <a href="https://docs.raku.org/language/operators#index-entry-hyper_%3C%3C-hyper_%3E%3E-hyper_%C2%AB-hyper_%C2%BB-Hyper_operators">hyper operator</a> 用于对 <a href="https://docs.raku.org/routine/grep">.grep</a> 返回的 Pairs 的每个 Pair 上调用 一次 .key 方法, 得出姓名列表</p>
<p>从数据中创建频率分布:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Distribution of grades by letter:</span><span class="p">&#34;;</span>
<span class="nb">say</span> <span class="p">&#34;{</span><span class="o">.</span><span class="nb">key</span><span class="p">}</span><span class="s2">: </span><span class="p">{</span><span class="o">+.</span><span class="nb">value</span><span class="p">}</span><span class="s2"> student</span><span class="p">{&#34;</span><span class="s2">s</span><span class="p">&#34;</span> <span class="k">if</span> <span class="o">.</span><span class="nb">value</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">}&#34;</span>

<span class="k">for</span> <span class="nv">%grade</span><span class="o">.</span><span class="nb">classify</span><span class="p">(</span><span class="o">*.</span><span class="nb">value</span><span class="o">.</span><span class="nb">comb</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span><span class="o">*.</span><span class="nb">key</span><span class="p">);</span>
</code></pre></div><p>计数和分组实在太常见了, Raku 提供了 <a href="https://docs.raku.org/routine/classify">.classify</a> 方法。
classify 方法里需要指定要分组的项(这里是代表 <code>%grade</code> 条目的 Pair 对象), 这些项应该根据什么规则进行分组(这里是根据第一个字母的值, 它代表分数(没有 <code>+</code>/<code>-</code>)。</p>
<p>这生成一个匿名的散列, 散列的值是匿名数组。</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">%(&#34;B&#34; =&gt; [&#34;Peter&#34; =&gt; &#34;B&#34;, &#34;Zsófia&#34; =&gt; &#34;B+&#34;, &#34;Maryam&#34; =&gt; &#34;B+&#34;,
 &#34;秀英&#34; =&gt; &#34;B-&#34;, &#34;Omar&#34; =&gt; &#34;B&#34;], &#34;A&#34; =&gt; [&#34;Celine&#34; =&gt; &#34;A-&#34;, &#34;Aarav&#34; =&gt; &#34;A&#34;], &#34;F&#34; =&gt; [&#34;João&#34; =&gt; &#34;F&#34;, &#34;Emma&#34; =&gt; &#34;F&#34;], &#34;D&#34; =&gt; [&#34;Finn&#34; =&gt; &#34;D+&#34;])
</code></pre></div><p>因为我们只对每组元素的个数感兴趣, 我们使用 <a href="https://docs.raku.org/routine/+">+</a> 前置操作符数字化每个值然后打印它, 在数组前面添加 <code>+</code> 符号会得到数组元素的个数。</p>
<p>在 term 位置上一个单独的 <code>.method</code> 方法等价于 <code>$_.method</code>, 意思是对当前循环变量调用该方法。任意代码的返回值能使用花括号 <code>{}</code> 插值到字符串中。</p>
<p><code>if</code> 语句能被用作表达式 - 当条件为 false 时, 返回空列表, 然后被字符串化为空字符串。对字符串调用不带参数的 <a href="https://docs.raku.org/routine/comb">.comb</a> 会生成该字符串的一个字符列表。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/calendar" term="calendar" label="calendar" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Using Raku]]></title>
            <link href="https://ohmyweekly.github.io/notes/2015-03-14-using-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2015-03-14-using-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-07-07T00:00:00+08:00</published>
            <updated>2021-07-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Using Raku</blockquote><h2 id="第一章-概要">第一章 概要</h2>
<p>略</p>
<h2 id="第二章-基础">第二章 基础</h2>
<p>假设有一场乒乓球比赛, 比赛结果以这种格式记录：</p>
<pre><code>Player1 Player2 | 3:2
</code></pre><p>这意味着选手1与选手2的比分为 3:2, 你需要一个脚本算出每位选手赢了几场比赛并且胜了几局。输入数据(存储在一个叫做 scores 的文件中)像下面这样：</p>
<pre><code>Beth Ana Charlie Dave
Ana Dave        | 3:0
Charlie Beth    | 3:1
Ana Beth        | 2:3
Dave Charlie    | 3:0
Ana Charlie     | 3:1
Beth Dave       | 0:3
</code></pre><p>第一行是选手清单。随后每一行记录着比赛结果。</p>
<p>这里使用 Raku 给出一种解决方案：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!/usr/bin/env raku</span>

<span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nb">open</span> <span class="p">&#39;</span><span class="s1">scores</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span> <span class="p">;</span>  <span class="c1"># get 方法读入一行, 每调用一次 get, 读取一行</span>
<span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>                   <span class="c1"># 赢得比赛次数</span>
<span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>                      <span class="c1"># 赢得比赛局数</span>

<span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>                       <span class="c1"># .lines 是惰性的</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span> <span class="c1"># 对剩下的每一行调用 split 操作</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>     <span class="c1"># 提取选手1和选手2的名字</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$r1</span><span class="o">,</span> <span class="nv">$r2</span><span class="p">)</span>          <span class="o">=</span> <span class="nv">$result</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1">:</span><span class="p">&#39;);</span> <span class="c1"># 提取比赛比分</span>

    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r1</span><span class="p">;</span>  <span class="c1"># 选手1赢得的比赛局数</span>
    <span class="nv">%sets</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$r2</span><span class="p">;</span>  <span class="c1"># 选手2赢得的比赛局数</span>

    <span class="k">if</span> <span class="nv">$r1</span> <span class="o">&gt;</span> <span class="nv">$r2</span> <span class="p">{</span> <span class="c1"># 如果每场比赛中, 选手1赢的局数多于选手2, 则选手1赢得的比赛数+1, 反之选手2的+1</span>
        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p1</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nv">%matches</span><span class="p">{</span><span class="nv">$p2</span><span class="p">}</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@sorted</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$n</span><span class="s2"> has won </span><span class="nv">%matches</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> matches and </span><span class="nv">%sets</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span><span class="s2"> sets</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>输出如下：</p>
<pre><code>Ana has won 2 matches and 8 sets
Dave has won 2 matches and 6 sets
Charlie has won 1 matches and 4 sets
Beth has won 1 matches and 4 sets
</code></pre><p>每个 Raku 程序应该以 <code>#!/usr/bin/env raku</code> 作为开始。</p>
<p>在 Raku 中, 变量名以一个魔符打头, 这个魔符是一个非字母数字符号, 诸如 <code>$</code>, <code>@</code>, <code>%</code> 或者 <code>&amp;</code>, 还有更少见的双冒号 <code>::</code>。
内置函数 <a href="https://docs.raku.org/routine/open">open</a> 打开了一个名叫 scores 的文件, 并返回一个文件句柄, 即一个代表该文件的对象。赋值符号 <code>=</code> 将句柄赋值给左边的变量, 这意味着 <code>$file</code> 现在存储着该文件句柄。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</code></pre></div><p>上边这句的右侧对存储在 <code>$file</code> 中的文件句柄调用了 <a href="https://docs.raku.org/routine/get">get</a> 方法, <code>get</code> 方法从文件中读取并返回一行, 并去掉行的末尾。<a href="https://docs.raku.org/routine/words">.words</a> 也是一个方法, 用于从 get 方法返回的字符串上。<code>.words</code> 方法将它的组件 - 它操作的字符串, 分解成一组单词, 这里即意味着不含空格的字符串。它把单个字符串 &lsquo;Beth Ana Charlie Dave&rsquo; 转换成一组字符串 &lsquo;Beth&rsquo;, &lsquo;Ana&rsquo;, &lsquo;Charlie&rsquo;, &lsquo;Dave&rsquo;。最后, 这组字符串存储在数组 <code>@names</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%matches</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%sets</span><span class="p">;</span>
</code></pre></div><p>在比分计数程序中, <code>%matches</code> 存储每位选手赢得的比赛数, <code>%sets</code> 存储每位选手赢得的比赛局数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>for 循环中 $file.lines 产生一组从文件 scores 读取的行, 从上次 $file.lines 离开的地方开始, 一直到文件末尾结束。
在第一次循环中, $line 会包含字符串 <code>Ana Dave | 3:0;</code> 在第二次循环中, $line 会包含 <code>Charlie Beth | 3:1</code>,以此类推。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
</code></pre></div><p>split此处是一个方法, 字符串 &lsquo;|&rsquo; 是它的参数。</p>
<p>第一次循环结束：</p>
<pre><code>Variable       Contents
$line           'Ana Dave | 3:0'
$pairing        'Ana Dave'
$result         '3:0'
$p1             'Ana'
$p2             'Dave'
$r1              '3'
$r2              '0'
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>这一句是排序, 先按比赛局数多少排序, 再按赢得的比赛数排序, 然后反转。打印选手名字的时候以胜负次序排序, 代码必须使用选手的分数, 而非他们的名字来进行排序。sort 方法的参数是一个代码块, 用于将数组元素（选手的名字）转换成用于排序的数据。数组的元素通过变量 <code>$_</code> 传递到代码块中。</p>
<p>最简单的使用分数排序选手的方法应该是:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">(</span> <span class="p">{</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span>
</code></pre></div><p>这是通过使用赢得比赛的次数来进行排序。然而, Ana 和 Dave都赢了两场比赛。还需要比较谁赢的的比赛局数多, 才能决定比赛的排名。</p>
<p>在双引号括起的字符串中, 标量和花括号中的变量能进行变量插值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$names</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">things</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">Do not call me $names</span><span class="p">&#39;;</span> <span class="c1"># Do not call me $names</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Do not call me </span><span class="nv">$names</span><span class="p">&#34;;</span> <span class="c1"># Do not call me things</span>
</code></pre></div><p>花括号中的数组进行插值后会变成用空格分隔的条目。花括号中的散列插值后每个散列键值对单独成为一行, 每行包含一个健, 随后是一个 tab 制表符, 然后是键值, 最后是一个新行符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Math: </span><span class="p">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}&#34;</span>     <span class="c1"># Math: 3</span>
<span class="k">my</span> <span class="nv">@people</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">Luke Matthew Mark</span><span class="p">&gt;;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The synoptics are: </span><span class="p">{</span><span class="nv">@people</span><span class="p">}&#34;</span> <span class="c1"># The synoptics are: Luke Matthew Mark</span>

<span class="nb">say</span> <span class="p">&#34;{</span><span class="nv">%sets</span><span class="p">}&#34;;</span> <span class="c1"># From the table tennis tournament</span>

<span class="c1"># Charlie 4</span>
<span class="c1"># Dave 6</span>
<span class="c1"># Ana 8</span>
<span class="c1"># Beth 4</span>
</code></pre></div><p>当数组和散列变量直接出现在双引号字符串中(并且不在花括号 <code>{}</code> 里), 它们只在它们的名字后跟着一个 postcircumfix - 一对括号, 后面跟着语句时才会进行插值。在变量名和后置环缀之间进行方法调用也是可以的(例如 <code>@flavours.sort()</code>)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@flavours</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">vanilla peach</span><span class="p">&gt;;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="p">&#34;;</span>    <span class="c1"># we have @flavours, 这里没进行插值</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">&#34;;</span> <span class="c1"># we have vanilla, 后置环缀, 变量名字后面跟着一对儿括号</span>
<span class="c1"># so-called &#34;Zen slice&#34;</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">[]</span><span class="p">&#34;;</span>  <span class="c1"># we have vanilla peach</span>

<span class="c1"># 以后置环缀结尾的方法调用</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">.</span><span class="nf">sort</span><span class="p">()&#34;;</span> <span class="c1"># we have peach vanilla</span>

<span class="c1"># 链式方法调用:</span>
<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">we have </span><span class="nv">@flavours</span><span class="o">.</span><span class="nf">sort.join</span><span class="p">(&#39;</span><span class="s1">, </span><span class="p">&#39;)&#34;;</span>
<span class="c1"># we have peach, vanilla</span>
</code></pre></div><h3 id="练习">练习</h3>
<p>例子中的第一行选手的名字是多余的, 你可以在参加比赛的选手中找出所有选手的名字！如果例子中的第一行被省略了, 你如何更改程序？提示：<code>%hash.keys</code> 返回散列 <code>%hash</code> 中的所有键。</p>
<p>答案: 移除此行：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">words</span><span class="p">;</span>
</code></pre></div><p>并且将</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">@names</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>变成:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@sorted</span> <span class="o">=</span> <span class="nv">%sets</span><span class="o">.</span><span class="nb">keys</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%sets</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">sort</span><span class="p">({</span> <span class="nv">%matches</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="p">})</span><span class="o">.</span><span class="nb">reverse</span><span class="p">;</span>
</code></pre></div><p>除了移除冗余, 你也可以用它来提醒我们, 如果一个选手没有在第一行的名字清单中被提到, 例如因为输入错误, 你该怎样修改你的程序？</p>
<p>答案: 引入另外一个散列, 合法选手的名字作为键, 当读取选手名字的时候查找该散列：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@names</span> <span class="o">=</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">get</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
<span class="k">my</span> <span class="nv">%legitimate-players</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@names</span> <span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="c1">#  -&gt; 两侧要有空格</span>
    <span class="nv">%legitimate-players</span><span class="p">{</span><span class="nv">$n</span><span class="p">}</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$file</span><span class="o">.</span><span class="nb">lines</span> <span class="k">-&gt;</span> <span class="nv">$line</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$pairing</span><span class="o">,</span> <span class="nv">$result</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> | </span><span class="p">&#39;);</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span><span class="p">)</span> <span class="o">=</span> <span class="nv">$pairing</span><span class="o">.</span><span class="nb">split</span><span class="p">(&#39;</span><span class="s1"> </span><span class="p">&#39;);</span>
    
    <span class="k">for</span> <span class="nv">$p1</span><span class="o">,</span> <span class="nv">$p2</span> <span class="k">-&gt;</span> <span class="nv">$p</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="nv">%legitimate-players</span><span class="p">{</span><span class="nv">$p</span><span class="p">}</span> <span class="p">{</span>
            <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Warning: &#39;</span><span class="nv">$p&#39;</span><span class="s2"> is not on our list!</span><span class="p">&#34;;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h2 id="第三章-操作符">第三章 操作符</h2>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$screen-width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

<span class="k">my</span> <span class="nv">$label-area-width</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$max-score</span> <span class="o">=</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">value</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$unit</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$screen-width</span> <span class="o">-</span> <span class="nv">$label-area-width</span><span class="p">)</span> <span class="o">/</span> <span class="nv">$max-score</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%- </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$label-area-width</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">s</span><span class="nv">%s</span><span class="s2">\n</span><span class="p">&#34;;</span>

<span class="k">for</span> <span class="nv">@scores</span> <span class="p">{</span>
    <span class="nb">printf</span> <span class="nv">$format</span><span class="o">,</span> <span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">X</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$unit</span> <span class="o">*</span> <span class="o">.</span><span class="nb">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中, 我们计算一下每位选手在竞标赛中赢得比赛的局数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>  
</code></pre></div><p>这一句局包含了三个不同的操作符 <code>=</code> 和 <code>=&gt;</code> 和 <code>,</code>。以字符串连接操作符 <code>~</code> 为例, <code>$string ~= &quot;text&quot;</code> 等价于 <code>$string = $string ~ &quot;text&quot;</code>。</p>
<p><code>=&gt;</code> 操作符(大键号)创建了一个键值对对象, 一个键值对存储着键和值；键在 <code>=&gt;</code> 操作符的左侧, 值在右侧。这个操作符有一个特殊的特性：编译器会把 <code>=&gt;</code> 操作符左侧的任何裸标识符解释为一个字符串。你也可以这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="s">Ana</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="s">Dave</span> <span class="o">=&gt;</span> <span class="mi">6</span>, <span class="s">Charlie</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">Beth</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>最后逗号操作符 <code>,</code> 构建了一个对象序列, 在该情况下, 所谓的对象就是键值对。</p>
<p>这三个操作符都是中缀操作符, 这意味着它在两个条目之间。</p>
<p>一个项前面可以有0个或多个前缀操作符, 所以你可以写比如 <code>4 + -5</code>。<code>+</code> 号（一个中缀操作符）的后面, 编译器期望一个项, 为了将 <code>-</code> 号解释为项 5 的一个前缀。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$label-area-width</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">[</span><span class="nb">max</span><span class="o">]</span> <span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span><span class="p">;</span>
</code></pre></div><p><code>»</code> 是一个特殊的符号, 打印不出来可以用两个大于号 <code>&gt;&gt;</code> 代替。中缀操作符 <code>max</code> 返回两个值中的较大者, 所以 <code>2 max 3</code> 返回 3。方括号包裹着一个中缀操作符让 Raku 将该中缀操作符应用到列表中的元素之间。<code>[max] 1,5,3,7</code> 和 <code>1 max 5 max 3 max 7</code> 一样, 结果都为 7。</p>
<p>同样地, <code>[+]</code> 用来计算列表元素的和, <code>[*]</code> 用来计算列表元素的积, <code>[&lt;=]</code> 用来检查一个列表的值是否按递增排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">».</span><span class="nb">key</span><span class="o">».</span><span class="nb">chars</span>
<span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="s">Ana</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="s">Dave</span> <span class="o">=&gt;</span> <span class="mi">6</span>, <span class="s">Charlie</span> <span class="o">=&gt;</span> <span class="mi">4</span>, <span class="s">Beth</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">Ana</span>     <span class="mi">8</span> <span class="n">Dave</span>  <span class="mi">6</span> <span class="n">Charlie</span>       <span class="mi">4</span> <span class="n">Beth</span>  <span class="mi">4</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">.</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Method &#39;key&#39; not found for invocant of class &#39;Array&#39;
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">&gt;&gt;.</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Ana Dave Charlie Beth
</code></pre></div><p>就像 <code>@variable.method</code> 在 <code>@variable</code> 上调用一个方法一样, <code>@array».method</code> 对 <code>@array</code> 中的每一项调用 <code>method</code> 方法, 并且返回一个返回值的列表。即 <code>@scores&gt;&gt;.key</code> 返回一个列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">&gt;&gt;.</span><span class="nb">key</span><span class="o">&gt;&gt;.</span><span class="nb">chars</span>  <span class="c1"># 每个名字含有几个字符</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">4 7 4
</code></pre></div><p>表达式 <code>[max] @scores».key».chars</code> 给出 (3,4,7,4) 中的最大值。它与下面的表达式相同：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="nv">@scores</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="nv">@scores</span><span class="o">[</span><span class="mi">2</span><span class="o">].</span><span class="nb">key</span><span class="o">.</span><span class="nb">chars</span>
<span class="nb">max</span> <span class="o">...</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">Ana</span><span class="p">&#34;</span> <span class="o">=&gt;</span> <span class="mi">8</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@scores</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">key</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Ana
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$format</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">%- </span><span class="p">&#39;</span> <span class="o">~</span> <span class="nv">$label-area-width</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2">s</span><span class="nv">%s</span><span class="s2">\n</span><span class="p">&#34;;</span>

<span class="k">for</span> <span class="nv">@scores</span> <span class="p">{</span>
    <span class="nb">printf</span> <span class="nv">$format</span><span class="o">,</span> <span class="o">.</span><span class="nb">key</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">X</span><span class="p">&#39;</span> <span class="nb">x</span> <span class="p">(</span><span class="nv">$unit</span> <span class="o">*</span> <span class="o">.</span><span class="nb">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>定义一个格式, <code>%-</code> 表示左对齐, <code>~</code> 是字符串连接操作符 <code>.for</code> 循环中, <code>@scores</code> 中的每一项被绑定给特殊变量 <code>$_</code>, <code>.key</code> 是每项的键, 即名字, <code>.value</code> 是每项的键值, 即得分。小 x 是字符串重复操作符。</p>
<h3 id="关于优先级的的一句话">关于优先级的的一句话</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>等号右侧产生一个列表（因为逗号, 操作符）, 这个列表由对儿组成(因为 <code>=&gt;</code>), 并且结果赋值给数组变量。
在 Perl5 中会这样解释:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="k">my</span> <span class="nv">@scores</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Ana</span><span class="p">&#39;)</span> <span class="o">=&gt;</span> <span class="mi">8</span>, <span class="p">&#39;</span><span class="s1">Dave</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">6</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Charlie</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Beth</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></div><p>以至于数组 <code>@scores</code> 中只有一个项, 表达式的其余部分被计算后丢弃。</p>
<p>优先级规则控制着编译器如何解释这一行。Raku 的优先级规则申明 中缀操作符 <code>=&gt;</code> 比 <code>,</code> 中缀操作符对于参数的绑定更紧, 而逗号操作符比等号赋值操作符绑定的更紧。</p>
<p>实际上有两种不同优先级的赋值操作符。当赋值操作符右侧是一个标量时, 使用较紧优先级的项赋值操作符, 否则使用较松优先级的列表赋值操作符。(如同螺丝的松紧)
比较 <code>$a = 1, $b = 2</code> 和 <code>@a = 1, 2,</code> 前者是在一个列表中赋值给两个变量, 后者是将含有两个项的一个列表赋值给一个变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>   <span class="c1"># 5 - 3.5 = 1.5</span>
<span class="nb">say</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># (-2) / 2 = -1</span>
</code></pre></div><p>Raku 中的优先级可以用圆括号改变, 但是如果圆括号直接跟在标识符的后面而不加空格的话, 则会被解释为参数列表。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span><span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># -2</span>
</code></pre></div><p>只打印出了 <code>5-7</code> 的值。</p>
<p>优先级表</p>
<table>
<thead>
<tr>
<th style="text-align:left">expression</th>
<th style="text-align:left">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(), 42.5</td>
<td style="text-align:left">(tightest precedence)</td>
</tr>
<tr>
<td style="text-align:left">42.rand</td>
<td style="text-align:left">term</td>
</tr>
<tr>
<td style="text-align:left">$x++</td>
<td style="text-align:left">method calls and postcircumfixes</td>
</tr>
<tr>
<td style="text-align:left">$x**2</td>
<td style="text-align:left">autoincrement and autodecrement</td>
</tr>
<tr>
<td style="text-align:left">?$x, !$x</td>
<td style="text-align:left">exponentiation operator</td>
</tr>
<tr>
<td style="text-align:left">+$x, ~$x</td>
<td style="text-align:left">boolean prefix</td>
</tr>
<tr>
<td style="text-align:left">2*3, 7/5</td>
<td style="text-align:left">prefix context operators</td>
</tr>
<tr>
<td style="text-align:left">1+2, 7-5</td>
<td style="text-align:left">multiplicative infix operators</td>
</tr>
<tr>
<td style="text-align:left">$a x 3</td>
<td style="text-align:left">additive infix operators</td>
</tr>
<tr>
<td style="text-align:left">$x ~&quot;.nn&quot;</td>
<td style="text-align:left">replication operators</td>
</tr>
<tr>
<td style="text-align:left">1&amp;2</td>
<td style="text-align:left">string concatenation</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">abs $x</td>
<td style="text-align:left">junctive OR</td>
</tr>
<tr>
<td style="text-align:left">$x cmp 3</td>
<td style="text-align:left">named unary prefix</td>
</tr>
<tr>
<td style="text-align:left">$x == 3</td>
<td style="text-align:left">non-chaining binary operators</td>
</tr>
<tr>
<td style="text-align:left">$x &amp;&amp; $y</td>
<td style="text-align:left">chaining binary operators</td>
</tr>
<tr>
<td style="text-align:left">$x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">$x &gt; 0 ?? 1 !! -1</td>
<td style="text-align:left">tight OR infix</td>
</tr>
<tr>
<td style="text-align:left">$x = 1</td>
<td style="text-align:left">conditional operator</td>
</tr>
<tr>
<td style="text-align:left">not $x</td>
<td style="text-align:left">item assignment</td>
</tr>
<tr>
<td style="text-align:left">1, 2</td>
<td style="text-align:left">loose unary prefix</td>
</tr>
<tr>
<td style="text-align:left">1, 2 Z @a</td>
<td style="text-align:left">comma</td>
</tr>
<tr>
<td style="text-align:left">@a = 1, 2</td>
<td style="text-align:left">list infix</td>
</tr>
<tr>
<td style="text-align:left">$x and say &ldquo;Yes&rdquo;</td>
<td style="text-align:left">list prefix, list assignment</td>
</tr>
<tr>
<td style="text-align:left">$x or die &ldquo;No&rdquo;</td>
<td style="text-align:left">loose AND infix</td>
</tr>
<tr>
<td style="text-align:left">;</td>
<td style="text-align:left">loose OR infix</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">statement terminator</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">(loosest precedence)</td>
</tr>
</tbody>
</table>
<h3 id="比较和智能匹配">比较和智能匹配</h3>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">;</span>

<span class="nb">say</span> <span class="nv">@a</span> <span class="o">===</span> <span class="nv">@a</span><span class="p">;</span> <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="nv">@a</span> <span class="o">===</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># Bool::False</span>

<span class="c1"># these use identity for value</span>
<span class="nb">say</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">3</span> <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># Bool::True</span>

<span class="k">my</span> <span class="nv">$a</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">$a</span> <span class="o">===</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># Bool::True</span>

<span class="nv">@b</span><span class="o">===</span><span class="nv">@a</span><span class="p">;</span>   <span class="c1"># False</span>
<span class="nv">@a</span> <span class="ow">eqv</span> <span class="nv">@b</span><span class="p">;</span> <span class="c1"># True</span>
<span class="p">&#39;</span><span class="s1">2</span><span class="p">&#39;</span> <span class="ow">eqv</span> <span class="mi">2</span><span class="p">;</span> <span class="c1"># False</span>
</code></pre></div><p>只有当两个对象有相同的类型和相同的结构时, eqv 操作符才返回 True。在前面定义的例子中, @a  eqv  @b 结果为 True, 因为 @a 和 @b 各自包含相同的值, 另一方面, &lsquo;2&rsquo; eqv 2 返回 &lsquo;False&rsquo; ,因为一个参数是字符串, 另一个是整数, 类型不相同。</p>
<h4 id="数字比较">数字比较</h4>
<p>使用 == 中缀操作符查看两个对象是否有相同的数字值。如果某个对象不是数字, Perl 会在比较之前尽力使其数字化。如果没有更好的方式将对象转换为数字, Perl 会使用默认的数字 0 。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">;</span>  <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">1</span><span class="p">&#39;;</span>  <span class="c1"># Bool::True</span>
<span class="nb">say</span> <span class="mi">1</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">2</span><span class="p">&#39;;</span>  <span class="c1"># Bool::False</span>
<span class="nb">say</span> <span class="mi">3</span> <span class="o">==</span> <span class="p">&#39;</span><span class="s1">3b</span><span class="p">&#39;;</span> <span class="c1"># fails</span>
</code></pre></div><p>跟数字比较相关的还有 <code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>。如果两个对象的数字值不同, 使用 <code>!=</code> 会返回 True 。</p>
<p>如果你将数组或列表作为数字, 它会计算列表中项的个数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@colors</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">red blue green</span><span class="p">&gt;;</span>

<span class="k">if</span> <span class="nv">@colors</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">It&#39;s true, </span><span class="nv">@colors</span><span class="s2"> contains 3 items</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><h4 id="字符串比较">字符串比较</h4>
<p>Raku 中使用 eq 比较字符串, 必要时会将其参数转换为字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$greeting</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">hello</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">welcome</span><span class="p">&#39;;</span>
<span class="p">}</span>
</code></pre></div><p>Table 3.2: Operators and Comparisons</p>
<table>
<thead>
<tr>
<th style="text-align:left">数字比较</th>
<th style="text-align:left">字符串比较</th>
<th style="text-align:left">意思</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">eq</td>
<td style="text-align:left">等于</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">ne</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">!==</td>
<td style="text-align:left">!eq</td>
<td style="text-align:left">不等于</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">lt</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">le</td>
<td style="text-align:left">小于或等于</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">gt</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">ge</td>
<td style="text-align:left">大于或等于</td>
</tr>
</tbody>
</table>
<p>例如, <code>'a' lt 'b'</code> 为 true, <code>'a' lt 'aa'</code> 也为 true。 != 是 <code>!==</code> 的便捷形式, 它实际是 <code>!</code> 元操作符加在 中缀操作符 <code>==</code> 之前。同样地, <code>ne</code> 和 <code>!eq</code>s 是一样的。</p>
<p>三路操作符</p>
<p>三路操作符有两个操作数, 如果左侧较小, 返回 Order::Increase , 两侧相等则返回 Order::Same, 如果右侧较小则返回 Order::Decrease。对于数字使用三路操作符 <code>&lt;=&gt;</code>,对于字符串, 使用三路操作符 <code>leg</code> （取自 lesser, equal, greater）。中缀操作符 cmp 是一个对类型敏感的三路操作符, 它像 <code>&lt;=&gt;</code> 一样比较数字, 像 leg 一样比较字符串, 并且比较键值对儿时, 先比较键, 如果键相同再比较键值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">10</span> <span class="o">&lt;=&gt;</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1"># +1</span>
<span class="nb">say</span> <span class="mi">10</span> <span class="ow">leg</span> <span class="mi">5</span><span class="p">;</span>     <span class="c1"># because &#39;1&#39; lt &#39;5&#39;</span>
<span class="nb">say</span> <span class="p">&#39;</span><span class="s1">ab</span><span class="p">&#39;</span> <span class="ow">leg</span> <span class="p">&#39;</span><span class="s1">a</span><span class="p">&#39;;</span> <span class="c1"># +1, lexicographic comparison</span>
</code></pre></div><p>三路操作符的典型用处就是用在排序中。列表中的 <code>.sort</code> 方法能使用一个含有两个值的块或一个函数, 比较它们, 并返回一个小于, 等于或大于 0 的值。 sort 方法根据该返回值进行排序：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="o">~&lt;</span><span class="n">abstract</span> <span class="n">Concrete</span><span class="o">&gt;.</span><span class="nb">sort</span><span class="p">;</span>
<span class="c1"># output: Concrete abstract</span>

<span class="nb">say</span> <span class="o">~&lt;</span><span class="n">abstract</span> <span class="n">Concrete</span><span class="o">&gt;.</span><span class="nb">sort</span><span class="o">:</span> <span class="k">-&gt;</span> <span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span> <span class="p">{</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$a</span><span class="p">)</span> <span class="ow">leg</span> <span class="nb">uc</span><span class="p">(</span><span class="nv">$b</span><span class="p">)</span> <span class="p">};</span>
<span class="c1"># output: abstract Concrete</span>
</code></pre></div><p>默认的, 比较是大小写敏感的, 通过比较它们的大写变形, 而不是比较它们的值, 这个例子使用了大小写敏感排序。</p>
<h4 id="智能匹配">智能匹配</h4>
<p>使用 <code>~~</code> 做正确的事情。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$pints-drunk</span> <span class="o">~~</span> <span class="mi">8</span> <span class="p">{</span>
   <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Go home, you&#39;ve had enough!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nv">$country</span> <span class="o">~~</span> <span class="p">&#39;</span><span class="s1">Sweden</span><span class="p">&#39;</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Meatballs with lingonberries and potato moose, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="k">unless</span> <span class="nv">$group-size</span> <span class="o">~~</span> <span class="mi">2</span><span class="o">..</span><span class="mi">4</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">You must have between 2 and 4 people to book this tour.</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>智能匹配总是根据 <code>~~</code> 右侧值的类型来决定使用哪种比较。上个例子中, 比较的是数字、字符串和范围。
智能匹配的工作方式 <code>$answer ~~ 42</code> 等价于 <code>42.ACCPETS( $answer )</code>。对 <code>~~</code> 操作符右侧的操作数调用 ACCEPTS 方法, 并将左操作数作为参数传入。</p>
<h2 id="第四章-子例程和签名">第四章 子例程和签名</h2>
<p>一个子例程就是一段执行特殊任务的代码片段。它可以对提供的数据(<code>实参</code>)操作, 并产生结果（返回值）。子例程的签名是它<code>所含的参数</code>和它产生的<code>返回值</code>的描述。从某一意义上来说, 第三章描述的操作符也是 Raku 用特殊方式解释的子例程。</p>
<h3 id="申明子例程">申明子例程</h3>
<p>子例程申明由几部分组成。首先, <code>sub</code> 表明你在申明一个子例程, 然后是可选的子例程的名称和可选的签名。子例程的主体是一个用花括号扩起来的代码块。
默认的, 子例程是本地作用域的, 就像任何使用 <code>my</code> 申明的变量一样。这意味着, 一个子例程只能在它被申明的作用域内被调用。使用 <code>our</code> 来申明子例程可以使其在当前包中可见。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span>
    <span class="k">our</span> <span class="k">sub</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">om nom nom</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">drink</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">glug glug</span><span class="p">&#34;;</span>
    <span class="p">}</span>
 <span class="p">}</span>

<span class="k">our</span> <span class="nv">&amp;eat</span><span class="p">;</span> <span class="c1"># makes the package-scoped sub eat available in this lexical scope</span>

<span class="nf">eat</span><span class="p">();</span>   <span class="c1"># om nom nom</span>
<span class="nf">drink</span><span class="p">();</span> <span class="c1"># 失败, can&#39;t drink outside of the block</span>
</code></pre></div><p>our 也能让子例程从包或模块的外部是可见的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">module</span> <span class="nn">EatAndDrink</span> <span class="p">{</span>
    <span class="k">our</span> <span class="k">sub</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">om nom nom</span><span class="p">&#34;;</span>
    <span class="p">}</span>

    <span class="k">sub</span> <span class="nf">drink</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">glug glug</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">EatAndDrink::eat</span><span class="p">();</span> <span class="c1"># om nom nom</span>
<span class="nf">EatAndDrink::drink</span><span class="p">();</span> <span class="c1"># fails, not declared with &#34;our&#34;</span>
</code></pre></div><p>你也可以<code>导出</code>一个子例程, 让它在另外的作用域内可见。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># in file Math/Trivial.pm</span>
<span class="k">module</span> <span class="nn">Math::Trivial</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="nf">double</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nv">$x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后在其它程序或模块中你可以这样写:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nn">Math::Trivial</span><span class="p">;</span> <span class="c1"># imports sub double</span>
<span class="nb">say</span> <span class="nf">double</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>    <span class="c1"># 21 is only half the truth</span>
</code></pre></div><p>Raku 的子例程都是对象。你可以将它们随意传递并存储在数据结构中。编程语言设计者常常将它们称之为 first-class 子例程；它们就像数组和散列一样作为语言的基础。</p>
<p>First-class 子例程能帮助你解决复杂的问题。例如, 为了做出一个微型的ASCII艺术舞蹈图, 你可能要建立一个散列, 键是舞蹈动作的名称, 键值是匿名散列。假使使用者能键入一系列舞蹈动作（可能是站在舞蹈平台上或其它外部输入设备）。 你怎么保持一个变量清单中都是合法的行为, 允许使用者输入, 并限制输入是一系列安全的行为呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%moves</span> <span class="o">=</span>
<span class="s">hands-over-head</span>       <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">/o\ </span><span class="p">&#39;</span>  <span class="p">}</span>,
<span class="s">bird-arms</span>             <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">|/o\| </span><span class="p">&#39;}</span>,
<span class="s">left</span>                  <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">&gt;o </span><span class="p">&#39;</span>   <span class="p">}</span>,
<span class="s">right</span>                 <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">o&lt; </span><span class="p">&#39;</span>   <span class="p">}</span>,
<span class="s">arms-up</span>               <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">\o/ </span><span class="p">&#39;</span>  <span class="p">};</span>

<span class="k">my</span> <span class="nv">@awesome-dance</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">arms-up bird-arms right hands-over-head</span><span class="p">&gt;;</span>

<span class="k">for</span> <span class="nv">@awesome-dance</span> <span class="k">-&gt;</span> <span class="nv">$move</span> <span class="p">{</span>
    <span class="nv">%moves</span><span class="p">{</span><span class="nv">$move</span><span class="p">}</span><span class="o">.</span><span class="p">();</span>  <span class="c1"># 在散列上调用方法</span>
<span class="p">}</span>
</code></pre></div><pre><code>outputs:
 \o/
|/o\|
  o&lt;
 /o\.
</code></pre>
<h3 id="adding-signatures">Adding Signatures</h3>
<p>子例程的签名执行两个任务。首先, 它申明哪个调用者可能或必须将参数传递给子例程。第二, 它申明子例程中的变量被绑定到哪些参数上。这些变量叫做参数。Raku 的签名更深入, 它们允许你限制参数的类型, 值和参数的定义, 并准确匹配复杂数据结构的某一部分。此外, 它们也允许你显式地指定子例程返回值的类型。</p>
<h4 id="基础">基础</h4>
<p>签名最简单的形式是, 绑定到输入参数上的用逗号分隔的一列变量的名字。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$pints</span><span class="p">)</span> <span class="p">{</span>
   <span class="nb">say</span> <span class="p">(</span><span class="nv">$pints</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">A pint</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="nv">$pints</span><span class="s2"> pints</span><span class="p">&#34;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="nv">$type</span><span class="s2">, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">order-beer</span><span class="p">(&#39;</span><span class="s1">Hobgoblin</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>    <span class="c1"># A pint of Hobgoblin, please.</span>
<span class="nf">order-beer</span><span class="p">(&#39;</span><span class="s1">Zlatý Bažant</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1"># 3 pints of Zlatý Bažant, please.</span>
</code></pre></div><p>这里使用的关系绑定而非赋值就是签名。默认地, 在 Raku 中, 子例程中引用到传入参数的签名的变量是只读的。这意味着你不能从子例程内部修改它们。
如果只读绑定太受限制了, 你可以将 <code>is rw</code> (rw 是 read/write 的缩写) 特性应用到参数上以降低这种限制。这个特性说明参数是可读可写的, 这允许你从子例程内部修改参数。使用的时候必须小心, 因为它会修改传入的原始对象。如果你试图传入一个字面值, 一个常量, 或其它类型的不可变对象到一个有 <code>is rw</code> 特性的参数中, 绑定会在调用时失败并抛出异常:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">make-it-more-so</span><span class="p">(</span><span class="nv">$it</span> <span class="k">is</span> <span class="k">rw</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$it</span> <span class="o">~=</span> <span class="nb">substr</span><span class="p">(</span><span class="nv">$it</span><span class="o">,</span> <span class="nv">$it</span><span class="o">.</span><span class="nb">chars</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="nb">x</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$happy</span> <span class="o">=</span> <span class="p">&#34;</span><span class="s2">yay!</span><span class="p">&#34;;</span>
<span class="nf">make-it-more-so</span><span class="p">(</span><span class="nv">$happy</span><span class="p">);</span>
<span class="nb">say</span> <span class="nv">$happy</span><span class="p">;</span> <span class="c1"># yay!!!!!!   # 原始传入对象被修改了</span>
<span class="nf">make-it-more-so</span><span class="p">(&#34;</span><span class="s2">uh-oh</span><span class="p">&#34;);</span> <span class="c1"># 失败, 不能修改一个常量</span>
</code></pre></div><p>如果你想将参数的本地副本用在子例程内部而不改变调用者的变量, 使用 <code>is copy</code> 特性：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">say-it-one-higher</span><span class="p">(</span><span class="nv">$it</span> <span class="k">is</span> <span class="nb">copy</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$it</span><span class="o">++</span><span class="p">;</span>
    <span class="nb">say</span> <span class="nv">$it</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">$unanswer</span> <span class="o">=</span> <span class="mi">41</span><span class="p">;</span>
<span class="nf">say-it-one-higher</span><span class="p">(</span><span class="nv">$unanswer</span><span class="p">);</span> <span class="c1"># 42</span>
<span class="nf">say-it-one-higher</span><span class="p">(</span><span class="mi">41</span><span class="p">);</span>        <span class="c1"># 42</span>
<span class="nb">say</span> <span class="nv">$unanswer</span><span class="p">;</span>                <span class="c1"># 41</span>
</code></pre></div><p>在诸如 <code>C/C++</code> 和 Scheme 等其它类型的编程语言中,这种广为人知的求值策略就是按值传递。当使用 <code>is copy</code> 特性时, 只有本地副本被赋值。其它任何传递给子例程的参数在调用者的作用域内保持不变。（一个不可变对象是当这个对象被创建后, 它的状态不会改变, 作为比较, 一个可变对象的状态在创建后是会被改变的）</p>
<h4 id="传递数组散列和代码">传递数组、散列和代码</h4>
<p>一个变量的魔符表明它的本意用途。在签名中, 变量的魔符也起着限制传入的参数类型的作用。例如, <code>@</code> 符号检查传入的对象行使位置角色（一个角色包含像数组和列表的类型）。如果传递的东西不能匹配这样的限制, 会引起调用失败：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">shout-them</span><span class="p">(</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$w</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="nb">uc</span><span class="p">(&#34;</span><span class="nv">$w</span><span class="s2"> </span><span class="p">&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">@last_words</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">do not want</span><span class="p">&gt;;</span>

<span class="nf">shout-them</span><span class="p">(</span><span class="nv">@last_words</span><span class="p">);</span> <span class="c1"># DO NOT WANT</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">help</span><span class="p">&#39;);</span>      <span class="c1"># 失败了, 字符串不是位置参数</span>
</code></pre></div><p>类似地, <code>%</code> 符号表明调用者必须传递一个行使关系角色的对象；即允许通过 <code>&lt;...&gt;</code> 或 <code>{...}</code> 进行索引的东西。 <code>&amp;</code> 符号要求调用者传递一个诸如匿名散列之类的行使能调用的角色的对象。在那种情况下, 你也可以不用 <code>&amp;</code> 符号调用可调用的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">do-it-lots</span><span class="p">(</span><span class="nv">&amp;it</span><span class="o">,</span> <span class="nv">$how-many-times</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">1</span><span class="o">..</span><span class="nv">$how-many-times</span> <span class="p">{</span>
        <span class="nf">it</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nf">do-it-lots</span><span class="p">(</span><span class="k">sub</span> <span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Eating a stroopwafel</span><span class="p">&#34;</span> <span class="p">}</span><span class="o">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1"># 此处是一个匿名子例程</span>
</code></pre></div><p>标量使用 <code>$</code> 符号, 并表明没有限制。什么都可以绑定在它上面, 即使它使用另外的符号绑定到一个对象上。</p>
<h4 id="插值数组和散列">插值、数组和散列</h4>
<p>有时你想从数组中填充占位参数。你可以通过在数组前添加一个垂直竖条或管道字符 ( <code>|</code> ): <code>eat(|@food)</code>, 而不是写作 <code>eat(@food[0], @food[1], @food[2], ...)</code> 等将它们吸进参数列表( <code>|</code> 像不像一个吸管, ^_^)。</p>
<p>同样地, 你可以将散列插值进具名参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-shrimps</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">:</span><span class="nv">$from</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like </span><span class="nv">$count</span><span class="s2"> pieces of shrimp from the </span><span class="nv">$from</span><span class="s2">, please</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nv">%user-preferences</span> <span class="o">=</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Northern Sea</span><span class="p">&#39;;</span>

<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">3</span><span class="o">,</span> <span class="o">|</span><span class="nv">%user-preferences</span><span class="p">);</span>
<span class="c1"># I&#39;d like 3 pieces of shrimp from the Northern Sea, please</span>
</code></pre></div><h4 id="可选参数">可选参数</h4>
<p>为使参数可选, 要么给签名的参数赋值为默认值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-steak</span><span class="p">(</span><span class="nv">$how</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">medium</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like a steak, </span><span class="nv">$how</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-steak</span><span class="p">();</span>
<span class="nf">order-steak</span><span class="p">(&#39;</span><span class="s1">well done</span><span class="p">&#39;);</span>
</code></pre></div><p>或者在参数名字的后面添加一个问号(?):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-burger</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$side</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like a </span><span class="nv">$type</span><span class="s2"> burger</span><span class="p">&#34;</span> <span class="o">~</span>
    <span class="p">(</span> <span class="nb">defined</span><span class="p">(</span><span class="nv">$side</span><span class="p">)</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2"> with a side of </span><span class="nv">$side</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;&#34;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nf">order-burger</span><span class="p">(&#34;</span><span class="s2">triple bacon</span><span class="p">&#34;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">deep fried onion rings</span><span class="p">&#34;);</span>
</code></pre></div><p>如果没有参数被传递, 参数会被绑定成一个未定义的值。<code>defined(...)</code> 函数用来检查是否有值。</p>
<h4 id="强制参数">强制参数</h4>
<p>默认地, 位置参数是必不可少的。然而, 你可以通过在参数后面追加一个感叹号来显式地指定该参数是必须的：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-drink</span><span class="p">(</span><span class="nv">$size</span><span class="o">,</span> <span class="nv">$flavor</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="nv">$size</span><span class="s2"> </span><span class="nv">$flavor</span><span class="s2">, coming right up!</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-drink</span><span class="p">(&#39;</span><span class="s1">Large</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mountain Dew</span><span class="p">&#39;);</span> <span class="c1"># OK</span>
<span class="nf">order-drink</span><span class="p">(&#39;</span><span class="s1">Small</span><span class="p">&#39;);</span>                 <span class="c1"># Error</span>
</code></pre></div><h4 id="具名实参和形参">具名实参和形参</h4>
<ul>
<li>arguments  实参</li>
<li>parameters 形参</li>
</ul>
<p>当一个子例程有很多参数时, 调用者很难记清传递参数的顺序。这种情况下, 通过名字传递参数往往更容易。这样, 参数出现的顺序就无关紧要了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nv">$type</span><span class="o">,</span> <span class="nv">$pints</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">$pints</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">A pint</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="nv">$pints</span><span class="s2"> pints</span><span class="p">&#34;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="nv">$type</span><span class="s2">, please.</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">order-beer</span><span class="p">(</span><span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Hobgoblin</span><span class="p">&#39;</span>, <span class="s">pints</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1"># A pint of Hobgoblin, please.</span>

<span class="nf">order-beer</span><span class="p">(</span><span class="s">pints</span> <span class="o">=&gt;</span> <span class="mi">3</span>, <span class="s">type</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Zlatý Bažant</span><span class="p">&#39;);</span>
<span class="c1"># 3 pints of Zlatý Bažant, please.</span>
</code></pre></div><p>你也可以指定参数只能按名字被传递（这意味着它不允许按位置传递）。这样的话, 在参数名字前加一个冒号：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">order-shrimps</span><span class="p">(</span><span class="nv">$count</span><span class="o">,</span> <span class="o">:</span><span class="nv">$from</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Northern Sea</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">I&#39;d like </span><span class="nv">$count</span><span class="s2"> pieces of shrimp from the </span><span class="nv">$from</span><span class="s2">, please</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1"># takes &#39;Northern Sea&#39;</span>
<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Atlantic Ocean</span><span class="p">&#39;);</span>
<span class="nf">order-shrimps</span><span class="p">(</span><span class="mi">22</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mediterranean Sea</span><span class="p">&#39;);</span>   <span class="c1"># 不允许, :$from is named only</span>
</code></pre></div><p>不像位置参数, 命名参数默认是可选的。在命名参数后面追加一个 <code>!</code> 号使命名参数强制性存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="nv">$base</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Vanilla</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Creating a new recipe named </span><span class="nv">$name</span><span class="s2">!</span><span class="p">&#34;</span>
<span class="p">}</span>

<span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="s">name</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Plain</span><span class="p">&#39;);</span>
<span class="nf">design-ice-cream-mixture</span><span class="p">(</span><span class="s">base</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Strawberry chip</span><span class="p">&#39;);</span> <span class="c1"># 错误</span>,<span class="n">没有指定</span> <span class="nv">$name</span>
</code></pre></div><p><strong>重命名参数</strong></p>
<p>因为按名字传递实参给形参是合理的, 形参的名字应该应该作为子例程公共 API 的一部分被考虑在内. 小心地挑选它们吧! 有时候, 使用一个名字暴露形参而使用另外一个名字绑定到变量会很方便:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">(</span><span class="nv">$supper</span><span class="p">)</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">8pm</span><span class="p">&#39;)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">We eat dinner at </span><span class="nv">$supper</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">announce-time</span><span class="p">(</span><span class="s">dinner</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;);</span> <span class="c1"># We eat dinner at 9pm</span>
</code></pre></div><p>参数可以有多个名字, 如果你的用户有些是英国人, 有些是美国人, 你可能这样写：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">paint-rectangle</span><span class="p">(</span>
    <span class="o">:</span><span class="nv">$x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$width</span> <span class="o">=</span> <span class="mi">100</span><span class="o">,</span>
    <span class="o">:</span><span class="nv">$height</span> <span class="o">=</span> <span class="mi">50</span><span class="o">,</span>
    <span class="p">:</span><span class="s">color</span><span class="p">(:</span><span class="s">colour</span><span class="p">(</span><span class="nv">$c</span><span class="p">)))</span> <span class="p">{</span>

    <span class="c1"># print a piece of SVG that represents a rectangle</span>
    <span class="nb">say</span> <span class="k">qq</span><span class="p">[</span><span class="s2">&lt;rect x=&#34;</span><span class="nv">$x</span><span class="s2">&#34; y=&#34;</span><span class="nv">$y</span><span class="s2">&#34; width=&#34;</span><span class="nv">$width</span><span class="s2">&#34; height=&#34;</span><span class="nv">$height</span><span class="s2">&#34; &gt;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># both calls work the same</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">color</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">colour</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>

<span class="c1"># of course you can still fill the other options</span>
<span class="n">paint-rectangle</span> <span class="p">:</span><span class="s">width</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">height</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">colour</span><span class="p">&lt;</span><span class="s">Blue</span><span class="p">&gt;;</span>
</code></pre></div><p><strong>可选的命名参数语法</strong></p>
<p>命名变量通常是成对的（键值对）。写一个 <code>Pairs</code> 有多种方式。各种方法的不同之处就是清晰性, 因为每种选择提供不同的引述机制。下面的三种调用是一样的意思：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">announce-time</span><span class="p">(</span><span class="s">dinner</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;);</span>
<span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">(&#39;</span><span class="s1">9pm</span><span class="p">&#39;));</span>
<span class="nf">announce-time</span><span class="p">(:</span><span class="s">dinner</span><span class="p">&lt;</span><span class="s">9pm</span><span class="p">&gt;);</span>
</code></pre></div><p>如果传递的是布尔值, 你可以省略键值对的键值：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">toggle-blender</span><span class="p">(</span> <span class="p">:</span><span class="s">enabled</span><span class="p">);</span> <span class="c1"># enables the blender 开启果汁机</span>
<span class="nf">toggle-blender</span><span class="p">(:!</span><span class="s">enabled</span><span class="p">);</span> <span class="c1"># disables the blender 关闭果汁机</span>
</code></pre></div><p>形如 <code>:name</code> 但不带值的命名参数有一个隐式的布尔真值 <code>Bool::True</code>。它的对立形式是 <code>:!name</code> , 其值是隐式的布尔假值 <code>Bool::false</code>。如果你使用变量创建了一个 <code>Pair</code>, 你可以将变量名作为 <code>Pair</code> 的键复用.</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$dinner</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">9pm</span><span class="p">&#39;;</span>
<span class="n">announce-dinner</span> <span class="o">:</span><span class="nv">$dinner</span><span class="p">;</span> <span class="c1"># same as dinner =&gt; $dinner;</span>
</code></pre></div><pre><code>                        Pair forms and their meanings.

    Shorthand      Long form                          Description
:allowed           allowed =&gt; Bool::True               Boolean flag
:!allowed          allowed =&gt; Bool::False              Boolean flag
:bev&lt;tea coffee&gt;   bev =&gt; ('tea', 'coffee')            List
:times[1, 3]       times =&gt; [1, 3]                     Array
:opts{ a =&gt; 2 }    opts =&gt; { a =&gt; 2 }                  Hash
:$var              var =&gt; $var Scalar                  variable
:@var              var =&gt; @var Array                   variable
:%var              var =&gt; %var Hash                    variable
:&amp;var              vaf =&gt; &amp;var Callable/ Subroutine    variable
</code></pre>
<p>你可以使用在任何可以使用 Pair 对象的上下文使用表中的任意一种形式. 例如, 生成散列:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># TODO: better example</span>
<span class="k">my</span> <span class="nv">$black</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%color-popularities</span> <span class="o">=</span> <span class="o">:</span><span class="nv">$black</span><span class="o">,</span> <span class="p">:</span><span class="s">blue</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">,</span> <span class="s">red</span> <span class="o">=&gt;</span> <span class="mi">18</span>, <span class="p">:</span><span class="s">white</span><span class="p">&lt;</span><span class="s">0</span><span class="p">&gt;;</span>

<span class="c1"># 与此相同：</span>
<span class="c1"># my %color-popularities =</span>
<span class="c1"># black =&gt; 12,</span>
<span class="c1"># blue =&gt; 8,</span>
<span class="c1"># red =&gt; 18,</span>
<span class="c1"># white =&gt; 0;</span>
</code></pre></div><p>最后, 通过位置而非名字传递一个已存在的 Pair 对象到子例程中, 要么把它放在圆括号中 ( 就像 (<code>:$thing</code>) ), 或者使用 <code>=&gt;</code> 操作符引起左侧的字符串: <code>&quot;thing&quot; =&gt; $thing</code>。</p>
<p><strong>参数的顺序</strong></p>
<p>当位置参数和命名参数都出现在签名中时, 所有的位置参数都要出现在命名参数之前：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">mix</span><span class="p">(</span><span class="nv">@ingredients</span><span class="o">,</span> <span class="o">:</span><span class="nv">$name</span><span class="p">)</span>    <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># OK</span>
<span class="k">sub</span> <span class="nf">notmix</span><span class="p">(</span><span class="o">:</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">@ingredients</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Error</span>
</code></pre></div><p>必须的位置参数要在可选的位置参数之前。然而, 命名参数没有这种限制。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">copy-machine</span><span class="p">(</span><span class="nv">$amount</span><span class="o">,</span> <span class="nv">$size</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">A4</span><span class="p">&#39;</span><span class="o">,</span> <span class="o">:</span><span class="nv">$color</span><span class="o">!,</span> <span class="o">:</span><span class="nv">$quality</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># OK</span>
<span class="k">sub</span> <span class="nf">fax-machine</span><span class="p">(</span><span class="nv">$amount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="nv">$number</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span> <span class="c1"># Error</span>
</code></pre></div><h4 id="slurpy-参数">Slurpy 参数</h4>
<p>有时候, 你会希望让子例程接受任何数量的参数, 并且将所有这些参数收集到一个数组中。为了达到这个目的, 给签名添加一个数组参数, 就是在数组前添加一个 <code>*</code> 号前缀：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">shout-them</span><span class="p">(</span><span class="o">*</span><span class="nv">@words</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">@words</span> <span class="k">-&gt;</span> <span class="nv">$w</span> <span class="p">{</span>
        <span class="nb">print</span> <span class="nb">uc</span><span class="p">(&#34;</span><span class="nv">$w</span><span class="s2"> </span><span class="p">&#34;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># 现在你可以传递项</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;);</span>         <span class="c1"># GO</span>
<span class="nf">shout-them</span><span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">home</span><span class="p">&#39;);</span> <span class="c1"># GO HOME</span>
</code></pre></div><p>除了集合所有的值之外, slurpy 参数会展平任何它接收到的数组, 最后你只会得到一个展平的列表, 因此：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">@words</span> <span class="o">=</span> <span class="p">(&#39;</span><span class="s1">go</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">home</span><span class="p">&#39;);</span>
<span class="nf">shout-them</span><span class="p">(</span><span class="nv">@words</span><span class="p">);</span>
</code></pre></div><p>会导致 <code>*@words</code> 参数有两个字符串元素, 而非只有单个数组元素。</p>
<p>你可以选择将某些参数捕获到位置参数中, 并让其它参数被吸进数组参数里。这种情况下, <code>slupy</code> 应该放到最后。相似地, <code>*%hash</code> slurps 所有剩下的未绑定的命名参数到散列 <code>%hash</code> 中。<code>Slurpy</code> 数组和散列允许你传递所有的位置参数和命名参数到另一个子例程中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">
<span class="k">sub</span> <span class="nf">debug-wrapper</span><span class="p">(</span><span class="nv">&amp;code</span><span class="o">,</span> <span class="o">*</span><span class="nv">@positional</span><span class="o">,</span> <span class="o">*</span><span class="nv">%named</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">Calling &#39;</span><span class="nv">&amp;code</span><span class="o">.</span><span class="nf">name</span><span class="p">()</span><span class="s2">&#39; with arguments </span><span class="p">&#34;</span>
    <span class="o">~</span> <span class="p">&#34;</span><span class="nv">@positional</span><span class="o">.</span><span class="nf">perl</span><span class="p">()</span><span class="s2">, </span><span class="nv">%named</span><span class="o">.</span><span class="nf">perl</span><span class="p">()</span><span class="s2">\n</span><span class="p">&#34;;</span>
    <span class="nb">code</span><span class="p">(</span><span class="o">|</span><span class="nv">@positional</span><span class="o">,</span> <span class="o">|</span><span class="nv">%named</span><span class="p">);</span>
    <span class="nb">warn</span> <span class="p">&#34;</span><span class="s2">... back from &#39;</span><span class="nv">&amp;code</span><span class="o">.</span><span class="nf">name</span><span class="p">()</span><span class="s2">&#39;\n</span><span class="p">&#34;;</span>
<span class="p">}</span>

<span class="nf">debug-wrapper</span><span class="p">(</span><span class="nv">&amp;order-shrimps</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="s">from</span> <span class="o">=&gt;</span> <span class="p">&#39;</span><span class="s1">Atlantic Ocean</span><span class="p">&#39;);</span>
</code></pre></div><h3 id="返回值">返回值</h3>
<p>子例程也能返回值。之前本章中的 ASCII 艺术舞蹈例子会更简单当每个子例程返回一个新字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%moves</span> <span class="o">=</span> <span class="s">hands-over-head</span> <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">/o\ </span><span class="p">&#39;</span>   <span class="p">}</span>,
            <span class="s">bird-arms</span>       <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">|/o\| </span><span class="p">&#39;</span> <span class="p">}</span>,
            <span class="s">left</span>            <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">&gt;o </span><span class="p">&#39;</span>    <span class="p">}</span>,
            <span class="s">right</span>           <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">o&lt; </span><span class="p">&#39;</span>    <span class="p">}</span>,
            <span class="s">arms-up</span>         <span class="o">=&gt;</span> <span class="k">sub</span> <span class="p">{</span> <span class="k">return</span> <span class="p">&#39;</span><span class="s1">\o/ </span><span class="p">&#39;</span>   <span class="p">};</span>

<span class="k">my</span> <span class="nv">@awesome-dance</span> <span class="o">=</span> <span class="p">&lt;</span><span class="s">arms-up bird-arms right hands-over-head</span><span class="p">&gt;;</span>

<span class="k">for</span> <span class="nv">@awesome-dance</span> <span class="k">-&gt;</span> <span class="nv">$move</span> <span class="p">{</span>
    <span class="nb">print</span> <span class="nv">%moves</span><span class="p">{</span><span class="nv">$move</span><span class="p">}</span><span class="o">.</span><span class="p">();</span>
<span class="p">}</span>

<span class="nb">print</span> <span class="p">&#34;</span><span class="s2">\n</span><span class="p">&#34;;</span>
</code></pre></div><p>子例程也能返回多个值（译者注：那不就是返回一个列表嘛）：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">menu</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">rand</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(&#39;</span><span class="s1">fish</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">white wine</span><span class="p">&#39;)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(&#39;</span><span class="s1">steak</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">red wine</span><span class="p">&#39;);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">$food</span><span class="o">,</span> <span class="nv">$beverage</span><span class="p">)</span> <span class="o">=</span> <span class="nf">menu</span><span class="p">();</span>
</code></pre></div><p>如果你把 return 语句排除在外, 则在子例程内部运行的最后一个语句产生的值被返回。这意味着前一个例子可以简化为：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">menu</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">rand</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">fish</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">white wine</span><span class="p">&#39;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">&#39;</span><span class="s1">steak</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">red wine</span><span class="p">&#39;;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">my</span> <span class="p">(</span><span class="nv">$food</span><span class="o">,</span> <span class="nv">$beverage</span><span class="p">)</span> <span class="o">=</span> <span class="nf">menu</span><span class="p">();</span>
</code></pre></div><p>记得：当子例程中的控制流极其复杂时, 添加一个显式的 return 会让代码更清晰, 所以 return 还是加上的好。
return 另外的副作用就是执行后立即退出子例程：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">create-world</span><span class="p">(</span><span class="o">*</span><span class="nv">%characteristics</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$world</span> <span class="o">=</span> <span class="n">World</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">%characteristics</span><span class="p">);</span>
    <span class="k">return</span> <span class="nv">$world</span> <span class="k">if</span> <span class="nv">%characteristics</span><span class="p">&lt;</span><span class="s">temporary</span><span class="p">&gt;;</span>

    <span class="nf">save-world</span><span class="p">(</span><span class="nv">$world</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>&hellip;并且你最好别放错你的新单词 <code>$word</code> 如果它是临时的。因为这是你要获取的仅有的一个。</p>
<h3 id="返回值的类型">返回值的类型</h3>
<p>像其它现代语言一样, Raku 允许你显式地指定子例程返回值的类型。这允许你限制从子例程中返回的值的类型。使用 <code>returns</code> 特性可以做到这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">double-up</span><span class="p">(</span><span class="nv">$i</span><span class="p">)</span> <span class="k">returns</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nv">$i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">my</span> <span class="nb">Int</span> <span class="nv">$ultimate-answer</span> <span class="o">=</span> <span class="nf">double-up</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span>  <span class="c1"># 42</span>
</code></pre></div><p>当然, 使用这个 <code>returns</code> 特性是可选的</p>
<h3 id="working-with-types">Working With Types</h3>
<p>很多子例程不能完整意义上使用任意参数工作, 但是要求参数支持确定的方法或有其它属性。这种情况下, 限制参数类型就有意义了, 诸如传递不正确值作为参数, 当调用子例程时, 这会引起 Raku 发出错误, 或者甚至在编译时, 如果编译器足够聪明来捕捉错误。</p>
<h4 id="基本类型">基本类型</h4>
<p>最简单的限制子例程接收可能的值的方法是在参数前写上类型名。例如, 一个子例程对其参数执行数值计算, 这要求它的参数类型是 Numeric：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">mean</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Numeric</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="n">mean</span> <span class="mf">2.5</span><span class="o">,</span> <span class="mf">1.5</span><span class="p">;</span>
<span class="nb">say</span> <span class="n">mean</span> <span class="p">&#39;</span><span class="s1">some</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">strings</span><span class="p">&#39;;</span>
</code></pre></div><p>产生输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Nominal type check failed for parameter &#39;$a&#39;;
expected Numeric but got Str instead
</code></pre></div><p>nominal 类型是一个人实际类型的名字, 这里是 Numeric。
如果多个参数有类型限制, 每个参数必须填充它绑定的参数限制的类型</p>
<h4 id="添加限制">添加限制</h4>
<p>有时, 类型的名字不足以描述参数的要求。这种情况下, 你可能使用 <code>where</code> 代码块添加一个额外的限制：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$area</span> <span class="k">where</span> <span class="p">{</span> <span class="nv">$area</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">})</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$area</span> <span class="o">/</span> <span class="no">pi</span><span class="p">)</span><span class="o">.</span><span class="nb">sqrt</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1"># OK</span>
<span class="nb">say</span> <span class="nf">circle-radius-from-area</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="c1"># Error</span>
</code></pre></div><p>因为这种计算只对非负面积值有意义, 该子例程的参数包含了一个限制, 对于非负值它会返回真。如果这个限制返回一个假的值, 类型检查会失败, 当有些东西调用该子例程时。</p>
<p>where 之后的代码块是可选的。Raku 通过通过智能匹配 where 后面的参数来执行检查。
例如, 它可能接受在某一确定范围中的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">set-volume</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$volume</span> <span class="k">where</span> <span class="mi">0</span><span class="o">..</span><span class="mi">11</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Turning it up to </span><span class="nv">$volume</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>或者你可以将参数限制为散列的键：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">%in-stock</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">Staropramen</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Mori</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">La Trappe</span><span class="p">&#39;</span> <span class="o">=&gt;</span> <span class="mi">9</span><span class="p">;</span>

<span class="k">sub</span> <span class="nf">order-beer</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$name</span> <span class="k">where</span> <span class="nv">%in-stock</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Here&#39;s your </span><span class="nv">$name</span><span class="p">&#34;;</span>
    <span class="nv">%in-stock</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="nv">%in-stock</span><span class="p">{</span><span class="nv">$name</span><span class="p">}</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">OH NO! That was the last </span><span class="nv">$name</span><span class="s2">, folks! :&#39;(</span><span class="p">&#34;;</span>
        <span class="nv">%in-stock</span><span class="o">.</span><span class="nb">delete</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
     <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="抽象参数和具体参数">抽象参数和具体参数</h3>
<p>下面检测变量是否定义。在 Raku 中这样写:</p>
<div class="highlight"><pre class="chroma"><code class="language-perl" data-lang="perl"> <span class="k">sub</span> <span class="nf">foo</span><span class="p">(Int:D $arg) {</span>
     <span class="c1"># Do something</span>
 <span class="p">}</span>
</code></pre></div><p>留意附加在参数类型后面的 <code>:D</code> 笑脸。这个动词表明给定的参数必须被绑定到一个具体的对象上。如果不是的话, 会抛出一个运行时异常。这就是为什么它那么高兴！作为对比, 动词 <code>:U</code> 用于表明该参数需要一个未定义的或抽象的对象。此外, 动词 <code>:_</code> 允许定义或未定义的值。实际上, 使用 <code>:_</code> 有点多余。</p>
<p>最后, 动词 <code>:T</code> 能用于表明参数只能是类型对象, 例如</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">say-foobar</span><span class="p">(</span><span class="nb">Int</span><span class="p">:</span><span class="s">T</span> <span class="nv">$arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">FOOBAR!</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="nf">say-foobar</span><span class="p">(</span><span class="nb">Int</span><span class="p">);</span>
<span class="c1"># FOOBAR!</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Roles or When One Is Many]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-06-22-roles-or-when-one-is-many/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-06-17-raku-syntax-i-miss-in-other-languages/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Syntax I Miss in Other Languages" />
                <link href="https://ohmyweekly.github.io/notes/2021-06-05-learn-raku-from-roast/?utm_source=atom_feed" rel="related" type="text/html" title="Learn Raku From Roast" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Multiple Dispatch With the New MoarVM Dispatcher" />
                <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 的标准库 Trait 之旅" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
            
                <id>https://ohmyweekly.github.io/notes/2021-06-22-roles-or-when-one-is-many/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-06-22T00:00:00+08:00</published>
            <updated>2021-06-22T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Roles or When One Is Many</blockquote><p>让 Raku 与 Perl 相当不同的一点是，<a href="https://raku.org/">Raku</a> 避免了魔法。有几个地方人们可以说，&ldquo;它神奇地发生了&rdquo;。但仔细看一下，通常会发现行为背后有相当好解释的机制。这就像看魔术师的把戏：我们总是知道有解释，而且它们肯定是符合逻辑的。</p>
<p>因此，我有个小把戏给你。看一下代码，告诉我：你在这里看到了多少个角色？</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{</span> <span class="k">has</span> <span class="nb">T</span> <span class="nv">$.a</span><span class="p">;</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="ow">R</span><span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>直观的答案当然是 1，这也是事实。但这里的部分技巧是术语的替换：在使用&quot;角色&quot;一词的地方，更准确的术语应该是&quot;角色类型对象&quot;。现在，试着猜出正确答案。而且，要确定的是，它不止一个。</p>
<h2 id="raku-魔术是如何不神奇的">Raku 魔术是如何不神奇的</h2>
<p>Raku 的最大优点之一，随着时间的推移，我越来越学会重视，就是它做任何事情都要保持逻辑性。有时这并不意味着要有直觉。有些行为一开始甚至可能使初学者感到困惑。但是，在解释时，逻辑通常是相当有说服力的。Raku 提供的一套广泛的内省工具，通常对理解它有很大帮助。在这篇文章中，我将尝试以&quot;魔术师&quot;的方式演示如何使用其中的一些工具来将一只兔子变成许多只。</p>
<p>我还将在很大程度上依赖于 <a href="https://rakudo.org/">Rakudo</a> 对 Raku 的实现，它是基于 <a href="https://vrurg.github.io/arfb-publication/02-everything-is-an-object-mop/#rakudo-nqp-runtime-vm-and-implementation-stack">NQP</a> 的，这使得在某些情况下相当容易看到 Raku 语法的幕后。顺便说一下，这也是 Raku 中的魔法量处于可忽略不计的水平的另一个原因。你们当中有多少人，我的读者，曾经研究过 Perl 或任何你最喜欢的语言的来源？如果我为自己回答，那么就是一个词：从未。尽管 C 语言是我多年来的首选语言。但现在我会坚持要求你在你的主目录下的某个地方做 git clone <a href="https://github.com/rakudo/rakudo.git">https://github.com/rakudo/rakudo.git</a>，所有其他项目都放在那里。然后，只要你遇到问题，答案很可能就在 Rakudo 项目的 src/Perl6/Metamodel 目录下的一个文件里。</p>
<h2 id="四位一体">四位一体</h2>
<p>我不得不谷歌一下这个词。从第一部《黑客帝国》电影开始，&ldquo;三位一体&quot;对我来说就很熟悉了，但对这一行中的其他词却不熟悉。是的，这个词就是这个棘手问题的答案。Raku 角色是四位一体。这篇文章将一步一步地告诉你为什么。</p>
<p>在这一点上，我想提醒的是，反省和乐库元模型的一般知识将是非常有益的。一些信息可以在本周期的前几篇文章中找到，一些可以在Raku文档中找到。</p>
<h3 id="第1步-多重性">第1步: 多重性</h3>
<p>让我们从最简单的自省开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">⇒ <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">role R[::T] { }; say R.WHAT</span><span class="p">&#39;</span>
<span class="p">(</span><span class="ow">R</span><span class="err">)</span>
</code></pre></div><p>不要和 &lsquo;⇒&rsquo; 字符混淆，这只是我最喜欢的命令行提示。</p>
<p>注意，我们只用方括号来声明角色，而不是对它调用方法。还要注意的是，这个角色报告自己只是 <code>R</code>；同样，没有涉及方括号。</p>
<p>接下来，你可能已经知道，在 Raku 中，同一个角色有可能有不同的变体。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">⇒ <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">role R[::T] { }; role R { }; say R.WHAT</span><span class="p">&#39;</span>
<span class="p">(</span><span class="ow">R</span><span class="err">)</span>
</code></pre></div><p>我们有两个声明，但仍然只使用 <code>R</code> 来调用 <code>WHAT</code>。</p>
<p>让我们换个角度，看看这个角色是如何实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku">⇒ <span class="nb">raku</span> <span class="o">-</span><span class="no">e</span> <span class="p">&#39;</span><span class="s1">role R[::T] { }; say R.HOW.^name</span><span class="p">&#39;</span>
<span class="n">Perl6::Metamodel::ParametricRoleGroupHOW</span>
</code></pre></div><p>注意名字中的 <code>Group</code> 部分。新手可能会对这个词感到困惑，只要他们只使用一个角色的变体。但是当他们到了本节第二个例子的时候，事情就开始变得比较清楚了。让我再把它们变得更加混乱。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="mi">42</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="nb">say</span> <span class="ow">R</span><span class="o">.^</span><span class="err">lookup(&#39;foo&#39;);</span>
</code></pre></div><p>你希望这段代码能输出什么？根据<a href="https://docs.raku.org/routine/lookup">文档</a>，在一个类上这样做会得到相当可预测的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="p">}</span> <span class="p">};</span> 
<span class="nb">say</span> <span class="n">Foo</span><span class="o">.^</span><span class="nb">lookup</span><span class="p">(&#34;</span><span class="s2">foo</span><span class="p">&#34;);</span> <span class="c1"># foo</span>
</code></pre></div><p>现在，忘记这个经验吧。因为对于上面的例子中的 <code>R</code>，我们会得到 <code>(Mu)</code>，意思是没有找到方法！而对于 <code>R</code>，我们会得到 <code>(Mu)</code>。</p>
<p>在这一点上，我想退一步说。如果你读了 Raku 的文档或书，做了关于角色和参数化的部分，有一个细节可能会让你觉得相当熟悉。如果这也是我要指出的&quot;东西&rdquo;，那么你就不会错了：参数化是关于参数的；有了参数，就有了签名！&quot;。现在这段代码一定是完全有意义的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="err">[Int</span><span class="o">:</span><span class="err">D</span> <span class="nv">$a</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="nv">$b</span><span class="o">]</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>角色声明中被方括号括起来的部分是一个签名，这有另一层意思，我将在后面再谈。</p>
<p>不幸的是，我在写这篇文章的时候有点超时，它应该在涉及到几个更基本的主题之后再完成。出于这个原因，我为下面的一点离题而道歉。</p>
<h2 id="多重分派">多重分派</h2>
<p>人们可以在 Raku 文档中找到这一<a href="https://docs.raku.org/language/glossary#Multi-dispatch">部分</a>。<a href="https://docs.raku.org/syntax/multi">另一节</a>阐述了其语法和功能。但我想简单地谈谈这个功能的内部实现。让我们从一个基本的声明开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">foo</span><span class="ow">(|)</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
<span class="k">multi</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">Int:D</span> <span class="nv">$i</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">multi</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">Str:D</span> <span class="nv">$s</span><span class="p">)</span> <span class="p">{}</span>
<span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span> <span class="c1"># proto sub foo (|) {*}</span>
</code></pre></div><p>正如你所看到的，<code>raku</code> 方法只报告了 <code>proto</code>。另外，如果我们对 <code>&amp;foo</code> 调用 <code>is_dispatcher</code> 方法，它将返回 <code>True</code>。好的，但是这两个 <code>multi</code> 在哪里，当我们调用 <code>foo(&quot;bar&quot;)</code> 时会发生什么？用两句话来说，Raku 首先会找到 <code>proto</code> 方法。如果它通过检查 <code>is_dispatcher</code> 的返回值识别出它是这样的，那么它就会通过调用 <code>&amp;foo.candidates</code> 来获取已知的候选列表。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="nb">candidates</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">raku</span><span class="p">)</span><span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># multi sub foo (Int:D $i) { #`(Sub|140560053018928) ... }</span>
<span class="c1"># multi sub foo (Str:D $s) { #`(Sub|140560053019072) ... }</span>
</code></pre></div><p>然后，它试图将提供的参数与每个候选者的签名绑定。如果绑定成功，则调用该候选程序（如果没有找到，则抛出一个异常）。</p>
<p>显然，在现实生活中，事情要复杂得多，但我们还不需要知道这些&hellip;&hellip;</p>
<h2 id="回到多重角色的问题上">回到多重角色的问题上</h2>
<p>有时我对不能在文章的纯文本中递归到一个子主题感到奇怪。就把这一节的标题看成是上一节的 <code>return</code> 语句&hellip;&hellip;啊，算了！不说了。</p>
<p>好吧，我的观点是什么，就是要讲述多重调度的故事？当我们看到 <code>R.HOW</code> 在类名中报告了一个 <code>Group</code>，就可以和多重调度实现中的 <code>proto</code> 相提并论了。事实上，我们调用 <code>HOW</code> 方法的类型对象 <code>R</code> 是一个伞状的实体，在其共同的名字下代表了角色的所有变体。而且，当我们把 <code>R[Int]</code> 应用于一个类时，实际发生的过程是一种多重分派，Raku 试图把方括号中的参数与角色候选者的签名相匹配。类似于我们如何列出 <code>&amp;foo</code> 的候选者，我们也可以列出 <code>R</code> 的候选者。</p>
<p>``raku
say R.^candidates.map(*.^name).join(&quot;, &ldquo;); # R, R</p>
<pre><code>
唯一不同的是，这次我们使用了一个元方法 `.^candidates`。

在这一点上，还有一个谜团没有被揭开。还记得使用 `.^lookup` 的那个例子吗？为什么它不能找到这个方法？

`Perl6::Metamodel::ParametricRoleGroupHOW` 所支持的类型对象并不是一个我们可以实际使用的角色。它既没有方法也没有属性。然而，在某些情况下，我们可能希望它假装是一个成熟的角色。为了做到这一点，它选择了一个候选角色作为默认角色，然后在其上重新分配外部请求。当有一个没有签名的候选者时（如我们的 `role R {}`），它就成为隐式默认。否则，第一个声明的有签名的候选者就会成为默认的候选者。

回到我们的例子，`R.^lookup('foo')` 失败了，因为 `role R {}` 没有声明一个有这个名字的方法。

### 第二步: 候选者

直奔主题，让我们对候选者本身进行自省。

```raku
say R.^candidates.map({ .HOW.^name }).join(&quot;, &quot;);
</code></pre><p>这看起来一定很熟悉，只是我们加入了.HOW的调用。下面是我们用它得到的东西。</p>
<pre><code>Perl6::Metamodel::ParametricRoleHOW, Perl6::Metamodel::ParametricRoleHOW
</code></pre><p>它看起来也很熟悉，除了&hellip;&hellip;是的，在类名称中没有 <code>Group</code>，我想欢迎我们的第二种角色! 实际上，我们已经知道了。如果我像这样挥舞着我的手，让我的观众分心，用&hellip;</p>
<p>哎呀，最后一句话应该是落在另一个窗口里的! 对于你，我的观众，我还有一行代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{}</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># Perl6::Metamodel::ParametricRoleHOW</span>
</code></pre></div><p>BTW，这是一个很好的例子，说明无处不在的 Raku 概念，即所有东西都是一个对象。甚至声明也是；而且，只是为了好玩。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">{</span> <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">}</span><span class="o">.^</span><span class="nb">name</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="c1"># Block</span>
</code></pre></div><p>但是我分心了&hellip;</p>
<p>所以，这里真正重要的是，当我们声明一个角色时，Raku 为我们创建一个 <code>Perl6::Metamodel::ParametricRoleHOW</code> 类的实例。每个声明都有一个独特的类的实例支持，它负责持有角色类型对象的每个细节。例如，要想知道它是否可以被参数化，可以这样做。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">is_parameterized</span><span class="p">(</span><span class="nb">Mu</span> \<span class="nb">r</span> <span class="k">--&gt;</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">?</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">signatured</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nf">is_parameterized</span><span class="p">(</span><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{});</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="nf">is_parameterized</span><span class="p">(</span><span class="k">role</span> <span class="ow">R</span> <span class="p">{});</span> <span class="c1"># False</span>
</code></pre></div><p>请注意，由于 <code>signatured</code> 是在 NQP 中实现的方法，它不知道高级类型，并返回0或1。有时情况会变得更糟糕。我上面提到的查找元方法实际上返回 <code>nqp::null()</code>，这是一种 VM 级的对象。它决不能出现在 Raku 上。因此语言把它变成了 <code>Mu</code>，这是最基本的 Raku 类。</p>
<p>关于 <code>Perl6::Metamodel::ParametricRoleHOW</code>，在这一点上没有什么可说的。但我们稍后会回到它上面去。</p>
<h3 id="第三步-不确定性">第三步: 不确定性</h3>
<p>为了更接近我们的第三种角色，我们从下面这个片段开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span> <span class="nb">Stringy</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span><span class="o">]</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">stringy</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span> <span class="nb">Numeric</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span><span class="o">]</span> <span class="p">{</span> <span class="k">method</span> <span class="nf">foo</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">numeric</span><span class="p">&#34;</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">my</span> <span class="nv">\r</span> <span class="o">=</span> <span class="k">role</span> <span class="nc">R2</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">T</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>让我们自省一下 <code>R1</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># We know there is only one role, </span>
<span class="c1"># hence .head for prettier output</span>
<span class="nb">say</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">roles</span><span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span><span class="o">.</span><span class="nb">head</span><span class="p">;</span>
<span class="c1"># R1[Int,T] of Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>输出显示了两个明显的变化。首先，角色名称现在报告了它的参数。第二，元对象现在属于 <code>Perl6::Metamodel::CurriedRoleHOW</code> 类。这是 Rakudo 在幕后做的另一种&quot;魔法&rdquo;，我将在本节中披露。</p>
<p>在上面的例子中，R2 声明最引人注目的特点是什么？事实上，在它消耗 <code>R1</code> 的地方，我们只知道第一个参数，而第二个参数仍然是一个通用参数。为了表示这种情况，我们对角色的了解是不完整的，Rakudo 使用了柯里化的角色。</p>
<p>从起源的角度来看，柯里化角色与前两种角色的关键区别在于，没有办法声明一个角色。柯里化只能是一个组的参数化的结果。而且，实际上，我很清楚，正式的组在 Raku 语法中并没有表示。但是只要它作为第一个角色声明的结果出现，我们就可以说它是由它产生的。而柯里化则完全由参数化产生。</p>
<p>也许有些令人惊讶，但在所有参数都为编译器所熟知的情况下，也可以发现柯里化的存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">R2</span><span class="o">[</span><span class="nb">Str</span><span class="o">].</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>部分原因是，当我们使用这样的角色时，我们所需要的也许是一些内省、类型检查或任何其他不需要具体对象的操作。比如说。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">foo</span><span class="p">(</span><span class="n">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="o">]</span> <span class="nv">$a</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>我们在这里需要的是 <code>foo</code> 参数，以通过对 <code>R1[Int, Str]</code> 的类型检查。因为柯里化会帮我们完成这个工作，所以 Rakudo 在这里使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">&amp;foo</span><span class="o">.</span><span class="nb">signature</span><span class="o">.</span><span class="nb">params</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="nb">type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
<span class="c1"># Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>这是因为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">R2</span><span class="o">[</span><span class="nb">Str</span><span class="o">]</span> <span class="o">~~</span> <span class="n">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="o">]</span><span class="p">;</span> <span class="c1"># True</span>
<span class="nb">say</span> <span class="n">R2</span><span class="o">[</span><span class="nb">Int</span><span class="o">]</span> <span class="o">~~</span> <span class="n">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">,</span> <span class="nb">Str</span><span class="o">]</span><span class="p">;</span> <span class="c1"># False</span>
</code></pre></div><p>但还有一个主要原因。它将在下一节中披露。</p>
<h3 id="第4步-具体性">第4步: 具体性</h3>
<p>任何角色的命运都是被一个类所吞噬。(BTW，这里的双关语也不例外。)现在是时候考虑这最后阶段了。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R2</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">role</span> <span class="nc">R3</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="k">does</span> <span class="nc">R1</span><span class="o">[</span><span class="nb">Int</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R2</span><span class="o">[</span><span class="nb">Str</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R3</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>通过反省类，我们会遇到所有的老朋友。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">C</span><span class="o">.^</span><span class="nf">roles</span>
     <span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span>
     <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># R3 of Perl6::Metamodel::ParametricRoleGroupHOW</span>
<span class="c1"># R2[Str] of Perl6::Metamodel::CurriedRoleHOW</span>
<span class="c1"># R1[Int] of Perl6::Metamodel::CurriedRoleHOW</span>
</code></pre></div><p>有趣的是，我们在这里发现了不同种类的角色的混合。其原因是浮在上面的：与 <code>R3</code> 相反，另外两个角色是参数化的。</p>
<p>但由于我喜欢迷惑听众，所以我要告诉你：这些其实不是这个类所建立的角色！这是另一个操作。</p>
<p>当然，这是另一种操作。完整的短语必须是使用这个。&ldquo;不是直接使用的角色&rdquo;。</p>
<p>当我们尝试另一种方法时，情况就会大不相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">C</span><span class="o">.^</span><span class="nb">mro</span><span class="p">(:</span><span class="s">roles</span><span class="p">)</span>
     <span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span>
     <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># C of Perl6::Metamodel::ClassHOW</span>
<span class="c1"># R3 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R2 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R1 of Perl6::Metamodel::ConcreteRoleHOW</span>
</code></pre></div><p><code>.^roles</code> 和 <code>.^mro</code> 的区别在于，前者为我们提供了用于声明类的内容；而后者则为我们提供了实际构建的内容。</p>
<p>正如 <code>HOW</code> 类的名字所暗示的，我们现在处理的是角色的具体表现。换句话说，这是一种所有细节都知道的角色，它们是为这个特定的类专门设计的。这里强调的是目的：这个过程被称为特化；而 specialize 是实现它的元模型方法的名称。</p>
<p>我还想提醒你一下上一节的最后一句话。为什么每当人们使用 <code>R[Int]</code> 或类似形式的角色参数化时，他们都要处理一个柯里化的角色，原因是完全的特化需要角色被消耗的类。稍后我将说明原因。</p>
<p>我们现在可以退一步，概述一下角色的生命周期。</p>
<ol>
<li>一个 <code>Perl6::Metamodel::ParametricRoleGroupHOW</code> 被创建。</li>
<li>一个 <code>Perl6::Metamodel::ParametricRoleHOW</code> 被创建并添加到该组。</li>
<li>一个类被声明并 <code>does</code> 这个角色。编译器尝试对角色进行参数化，如果需要参数化，<code>Perl6::Metamodel::CurriedRoleHOW</code> 就会被创建；否则就会使用原来的 <code>Perl6::Metamodel::ParametricRoleHOW</code>。</li>
<li>参数化的结果被添加到类的角色列表中。</li>
<li>当类被组成时，所有在上一步中添加的角色都被赋予了各自的参数和类的类型对象。在这一点上，我们得到了由 <code>Perl6::Metamodel::ConcreteRoleHOW</code> 支持的角色类型对象，或者换句话说，角色具体化。</li>
<li>这些具体化被添加到类中。</li>
<li>具体化是通过将其属性和方法迁移到类的类型对象中来应用的。</li>
</ol>
<p>值得注意的是，具体化被保留为独立的实体，与它们所产生的角色分开。这就是我们在上面通过使用 <code>.^roles</code> 和 <code>.^mro</code> 进行内省观察到的。它们也可以使用 <code>.^concretizations</code> 元模型方法来访问。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="n">C</span><span class="o">.^</span><span class="nf">concretizations</span>
     <span class="o">.</span><span class="nb">map</span><span class="p">({</span> <span class="o">.^</span><span class="nb">name</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> of </span><span class="p">&#34;</span> <span class="o">~</span> <span class="o">.</span><span class="nb">HOW</span><span class="o">.^</span><span class="nb">name</span> <span class="p">})</span>
     <span class="o">.</span><span class="nb">join</span><span class="p">(&#34;</span><span class="s2">\n</span><span class="p">&#34;);</span>
<span class="c1"># R3 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R2 of Perl6::Metamodel::ConcreteRoleHOW</span>
<span class="c1"># R1 of Perl6::Metamodel::ConcreteRoleHOW</span>
</code></pre></div><p>在这一点上，有两个相当大的主题仍然故意不清楚：一个角色候选人是如何被选择的？ 以及特化是做什么的？第一个问题我也许可以或多或少地完整地介绍一下。第二个问题对本文来说太复杂了，但有几个关键点绝对值得一提。</p>
<h3 id="第1a步-选择">第1a步: 选择</h3>
<p>震惊一个无辜的读者在媒体中非常流行。虽然我勉强算是个记者，但只要我把这篇文章称为文章&ndash;我有什么资格打破规则？所以，请坐好，握紧你的大脑。</p>
<p>我们开始了&hellip;&hellip;准备好了没有&hellip;&hellip;真相即将揭晓！&quot;。</p>
<p>角色是一种例程。</p>
<p>很好，开始了。我说了！我一直想说的!</p>
<p>说真的，正如经常发现的关于点击率的新闻一样，这并不完全是真的，但有一点是真的。我想让你考虑一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside the role</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">module</span> <span class="nn">Foo</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside Foo</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside the class</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="c1"># inside Foo</span>
<span class="c1"># inside the class</span>
</code></pre></div><p>我们只看到两行输出，让我们了解到类的声明与模块的行为是一样的。但不是角色。让我们在这个例子中再加一行。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ow">R</span><span class="o">.^</span><span class="err">candidates[0</span><span class="o">].^</span><span class="nf">body_block</span><span class="o">.</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
<span class="c1"># inside the role</span>
</code></pre></div><p>为什么是这样，为什么我把 <code>C</code> 作为一个参数传递，我将在下面关于特化的部分尝试回答。</p>
<p>现在我建议对主体块进行内省，但首先要在上述片段中增加一个角色的变体。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">\r</span> <span class="o">=</span> <span class="k">role</span> <span class="ow">R</span><span class="err">[</span><span class="o">::</span><span class="err">T</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span> <span class="nb">Numeric</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="nb">say</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">body_block</span><span class="o">.</span><span class="nb">raku</span><span class="p">;</span>
<span class="c1"># multi sub (::$?CLASS ::::?CLASS Mu $, ::T Mu $, ::V Numeric $) { #`(Sub|94052949943024) ... }</span>
</code></pre></div><p>现在有印象了吗？<code>sub</code> 前面的 <code>multi</code> 这个词说明了一切，我现在的工作已经减少到所需的最小的措辞。</p>
<p>当编译器建立一个角色组时，它也创建了一个多调度例程。在内部，它被称为选择器。在每一个新添加的参数化角色中，它的主体块（实际上是一个 <code>multi sub</code>）都会被抽取出来，并作为一个多重调度候选程序添加到选择器中。现在，当人们在他们的代码中写下像 <code>R[Int, Str]</code> 这样的东西时，编译器会做一个类似于选择多重调度例程候选者的过程。基于进程提供的主体块候选，它选择了该块所属的角色。</p>
<p>所以，现在当我们提到角色签名时，一定会有更多的意义。因为它是一个签名，作为一个事实。如果我把一个角色声明 <code>role R[::T, ::V] {}</code> 以某种更适合人类程序员阅读的方式重新表述，它可能看起来像。</p>
<blockquote>
<p>声明一个候选角色 <code>R</code>，其主体为块<code>sub (::T, ::V) {...}</code>。</p>
</blockquote>
<p>很好，我们现在已经解决了这个问题。但是，我细心的读者，是不是有什么事情困扰着你？上面的&quot;类似&quot;一词是不是意味着某种&hellip;&hellip;呃&hellip;&hellip;惊喜？好吧，不幸的是，候选的选择并不遵循完整的多重调度协议，因为它缺乏对命名参数的支持。这是由于类型参数化的低级实现的限制。这意味着下面的两个声明被认为是相同的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="err">[Int</span><span class="o">,</span> <span class="nb">Bool</span> <span class="o">:</span><span class="nv">$foo</span><span class="o">]</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="k">role</span> <span class="ow">R</span><span class="err">[Int</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="o">:</span><span class="nv">$bar</span><span class="o">]</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>希望当新的分派机制到达 Raku 时，情况会有所改变，但我在此不做任何承诺。</p>
<p>与此同时，你仍然可以使用这些名字，只是不要依靠它们来唯一地识别你的角色候选人。</p>
<h2 id="一个黑魔法塞恩斯">一个黑魔法塞恩斯</h2>
<p>这其实与选择候选者无关，但我不能忍受不给你看一些棘手的东西。此外，在许多小说和童话故事中，黑魔法是一种可以让你实现目标的东西，但有一个附加的价格标签。有时这个标签是相当血腥的，但这不是我的情况。实际上，我的目标和代价是一样的：我想用不同的东西来吸引你。</p>
<p>这就是要施的法术。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">\r</span> <span class="o">=</span> <span class="k">role</span> <span class="ow">R</span><span class="err">[</span><span class="o">::</span><span class="err">T</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span> <span class="nb">Numeric</span><span class="o">]</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">my</span> <span class="nv">\tenv</span> <span class="o">=</span> <span class="nb">r</span><span class="o">.^</span><span class="nf">body_block</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="n">C</span><span class="o">,</span> <span class="nb">Str</span><span class="o">,</span> <span class="nb">Int</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">\ctx</span> <span class="o">=</span> <span class="nf">nqp::atpos</span><span class="p">(</span><span class="n">tenv</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">\iter</span> <span class="o">=</span> <span class="nf">nqp::iterator</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="k">while</span> <span class="n">iter</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\elem</span> <span class="o">=</span> <span class="nf">nqp::shift</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="nb">say</span> <span class="nf">nqp::iterkey_s</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2"> =&gt; </span><span class="p">&#34;</span><span class="o">,</span> <span class="nf">nqp::iterval</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>只要主体块是一个例程，显然我们可以自己调用它。为了理解剩下的几行和所有使用的 <code>nqp:: ops</code>，人们需要参考 <a href="https://github.com/Raku/nqp/blob/master/docs/ops.markdown">NQP ops</a> 文档。</p>
<p>总之，&ldquo;咒语&quot;产生的输出可能看起来像这样。</p>
<pre><code>::?CLASS =&gt; (C)
$?ROLE =&gt; (R)
T =&gt; (Str)
$?CONCRETIZATION =&gt; (Mu)
$?PACKAGE =&gt; (R)
::?PACKAGE =&gt; (R)
V =&gt; (Int)
::?ROLE =&gt; (R)
$?CLASS =&gt; (C)
$_ =&gt; (Mu)
</code></pre><p>用两个字来说，角色体块返回一个包含两个元素的数组。第二个元素是符号名称到其具体值的映射。也就是说，在 <code>=&gt;</code> 箭头左侧的键中，你可以很容易地从角色签名中发现我们的 <code>T</code> 和 <code>V</code> 类型捕获；以及编译器常量，如 <code>::?CLASS</code> 和其他。</p>
<p>总的来说，代码返回的东西被称为内部类型环境，并被用于另一种广泛采用的机制，即泛型实例化。但这个话题肯定远远超出了本文的目的。这里确实值得一提的是，所有包含在环境中的符号实际上都是角色体词法。例如，如果我们把我的 <code>FOO = 42</code> 加入到主体中，那么上面的输出就会有以下一行加入到其中。</p>
<pre><code>FOO =&gt; 42
</code></pre><p>另外，看着这些符号，你现在甚至可以更好地理解为什么角色的特化需要一个类来消耗它。你下次在做类似的事情时可能会考虑到这一点。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">method</span> <span class="nf">foo</span><span class="p">(</span><span class="vg">::?CLASS:D</span><span class="o">:</span> <span class="o">|</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>最后我想指出的一点是 <code>$?CONCRETIZATION</code> 符号，它还没有被记录下来。它只在角色主体和角色方法中可用，并且当它可用时被绑定到角色的具体化中。这个符号主要是用于自省的目的。</p>
<h3 id="步骤4a-特化">步骤4a: 特化</h3>
<p>所以，我们有一个候选者。我们知道具体的参数。我们知道消耗它的类。因此，我们确实知道了一切，可以进行特化，并得到具体化，最终将这个角色纳入消费它的类中。</p>
<p>正如我在上面已经提到的，特化是一个相当复杂的过程。在 Rakudo 元模型的实现中，它分布在几个源文件中，并涉及到一些其他的内部机制，如通用实例化，我在上面也暗示过。我最好不要深究其中的细节，而是专注于主要的阶段。那些真正好奇的人可以从 Rakudo 编译器源文件 src/Perl6/Metamodel/ParametricRoleHOW.nqp 中的方法特化开始。</p>
<p>特化一个新的角色，首先要创建一个 <code>Perl6::Metamodel::ConcreteRoleHOW</code> 的新实例和相应的具体角色类型对象。然后调用 body block 来获得一个类型环境结构。我将重点介绍一下这个。像往常一样，我们先举一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">inside the role, class is </span><span class="p">&#34;</span><span class="o">,</span> <span class="vg">::?CLASS</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">class is composed? </span><span class="p">&#34;</span><span class="o">,</span> <span class="vg">::?CLASS</span><span class="o">.^</span><span class="nf">is_composed</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">C1</span> <span class="k">does</span> <span class="nc">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C2</span> <span class="k">does</span> <span class="nc">R</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1"># inside the role, class is C1</span>
<span class="c1"># class is composed? no</span>
<span class="c1"># inside the role, class is C2</span>
<span class="c1"># class is composed? no</span>
</code></pre></div><p>我们在这里观察到的是，角色主体已经被调用了两次，它知道它所应用的类，而且这个类还没有被组成（我在<a href="https://vrurg.github.io/arfb-publication/02-everything-is-an-object-mop/#raku-metamodel">另一篇文章</a>中介绍了一些关于类生命周期的信息）。另外，正如我已经提到的，具体化在这一点上存在。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R</span> <span class="p">{</span>
	<span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nb">name</span><span class="p">;</span> <span class="c1"># R</span>
<span class="p">}</span>
</code></pre></div><p>但它还是空的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nb">attributes</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span> <span class="c1"># 0</span>
<span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nb">methods</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>    <span class="c1"># 0</span>
</code></pre></div><p>而且，很明显，没有组成。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nv">$?CONCRETIZATION</span><span class="o">.^</span><span class="nf">is_composed</span> <span class="o">??</span> <span class="p">&#34;</span><span class="s2">yes</span><span class="p">&#34;</span> <span class="o">!!</span> <span class="p">&#34;</span><span class="s2">no</span><span class="p">&#34;;</span> <span class="c1"># no</span>
</code></pre></div><p>所有这些使得角色体成为一个好地方，可以在角色被实际消费时做需要做的事情。</p>
<p>现在，有了所有必要的信息，元模型通过实例化原始参数化或柯里化角色的属性和方法，并将它们安装到新创建的具体化中来最终完成专业化。例如这个片段的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="ow">R</span><span class="p">[</span><span class="o">:</span><span class="p">:</span><span class="s">T</span><span class="p">]</span> <span class="p">{</span> <span class="k">has</span> <span class="nb">T</span> <span class="nv">$.attr</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">C</span> <span class="ow">R</span><span class="p">[</span><span class="nb">Str</span><span class="p">]</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div><p>如果我们转储原始角色和具体化的属性，我们可能会看到类似于下面的输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">attr:</span> <span class="p">(</span><span class="nb">Attribute</span><span class="o">|</span><span class="mi">94613946040184</span> <span class="nb">T</span> <span class="nv">$!attr</span><span class="p">)</span>
<span class="nf">concretization</span> <span class="n">attr:</span> <span class="p">(</span><span class="nb">Attribute</span><span class="o">|</span><span class="mi">94613946043184</span> <span class="nb">Str</span> <span class="nv">$!attr</span><span class="p">)</span>
</code></pre></div><p>当用属性和方法完成时，任何被消耗的角色都会被实例化和具体化。例如，对于这个声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">role</span> <span class="nc">R1</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">,</span> <span class="o">:</span><span class="p">:</span><span class="s">V</span><span class="o">]</span> <span class="k">does</span> <span class="nc">R2</span><span class="o">[:</span><span class="p">:</span><span class="s">T</span><span class="o">]</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p><code>R2</code> 的具体化将被添加到 <code>R1</code> 的具体化中，然后 <code>R2</code> 的具体化将被添加到 <code>R1</code> 的具体化中。</p>
<p>最后，如果有任何父类添加到角色中，它们也会被实例化和添加。</p>
<p>当所有上述准备工作完成后，我们的具体化就被组成了。它现在已经准备好被添加到它的消费类中。</p>
<p>故事就这样结束了。</p>
<h2 id="偿还债务">偿还债务</h2>
<p>知道很久以前的承诺最终得到了兑现，真的让人松了一口气。不幸的是，为了涵盖这个主题，我已经跳过了其他一些更基本的主题。例如，让读者更好地了解多重调度、类型对象的组成，以及 Rakudo、NQP 和后端虚拟机是如何相互作用的，这对读者是有益的。如果我写了足够多的文章，并考虑把这些材料编成一本书，那么由这段文字组成的章节将被放在离书的开头更远的地方。</p>
<p>不管怎么说，我已经尽了最大的努力，远离那些还未被提及的概念，希望你在这里找到有用的信息。</p>
<p>原文链接: <a href="https://vrurg.github.io/arfb-publication/07-roles-or-when-one-is-many/">https://vrurg.github.io/arfb-publication/07-roles-or-when-one-is-many/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/role" term="role" label="Role" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Syntax I Miss in Other Languages]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-06-17-raku-syntax-i-miss-in-other-languages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-06-05-learn-raku-from-roast/?utm_source=atom_feed" rel="related" type="text/html" title="Learn Raku From Roast" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Multiple Dispatch With the New MoarVM Dispatcher" />
                <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 的标准库 Trait 之旅" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
            
                <id>https://ohmyweekly.github.io/notes/2021-06-17-raku-syntax-i-miss-in-other-languages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-06-17T00:00:00+08:00</published>
            <updated>2021-06-17T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Syntax I Miss in Other Languages</blockquote><h1 id="self-describing-code">Self-describing code</h1>
<h2 id="junctions">Junctions</h2>
<ul>
<li>Distributive</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span><span class="p">{</span><span class="nb">any</span><span class="p">(</span><span class="nv">@keys</span><span class="p">)}</span>
</code></pre></div><p>等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">any</span><span class="p">(</span><span class="nv">%hash</span><span class="p">{</span><span class="nv">@keys</span><span class="p">})</span>
</code></pre></div><ul>
<li>Boolean</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">操作符</th>
<th style="text-align:left">True if &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">any</td>
<td style="text-align:left">|</td>
<td style="text-align:left">至少一个值为真</td>
</tr>
<tr>
<td style="text-align:left">all</td>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">所有值都为真</td>
</tr>
<tr>
<td style="text-align:left">one</td>
<td style="text-align:left">^</td>
<td style="text-align:left">只有一个值为真</td>
</tr>
<tr>
<td style="text-align:left">none</td>
<td style="text-align:left"></td>
<td style="text-align:left">值都不为真</td>
</tr>
</tbody>
</table>
<p>Junctions 通常出现在布尔上下文中。例如, 在下面的例子中, <code>$value</code> 和几个值进行相等性比较。很容易写出这样的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div><p>使用 <code>any</code> Junction 会简洁不少:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="nb">any</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="nb">any</span>
</code></pre></div><p>惯用法是使用 <code>|</code> 操作符号来进行多值比较:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nv">$value</span> <span class="o">==</span> <span class="mi">1</span><span class="o">|</span><span class="mi">2</span><span class="o">|</span><span class="mi">5</span>
</code></pre></div><p>找出数组中满足条件的第一个元素, 我们首先想到的可能是, 使用 <code>for</code> 循环迭代数组, 找出满足条件的元素就立即退出循环:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$result</span> <span class="o">=</span> <span class="nb">False</span><span class="p">;</span>

<span class="k">for</span> <span class="nv">@values</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nv">$value</span> <span class="o">&gt;</span> <span class="mi">42</span> <span class="p">{</span>
        <span class="nv">$result</span> <span class="o">=</span> <span class="nb">True</span><span class="p">;</span>
        <span class="nb">last</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nv">$result</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>改用 Junction 后等价于:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nv">@values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">42</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>还可以在 Junction 上调用方法或运算符:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nb">one</span><span class="p">(</span><span class="nv">@values</span><span class="p">)</span><span class="o">.</span><span class="nb">is-prime</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nv">@values</span><span class="p">)</span> <span class="nv">%%</span> <span class="mi">3</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="named-arguments命名参数">Named arguments(命名参数)</h2>
<p>Colonpair(冒号对儿) 通常用于命名参数中:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="s">foo</span> <span class="o">=&gt;</span> <span class="mi">42</span>

<span class="k">sub</span> <span class="nf">bar</span><span class="p">(</span><span class="o">:</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">bar</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</code></pre></div><p>有几种特殊形式的冒号对儿:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">:</span><span class="s">foo</span>
<span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="nb">True</span><span class="p">)</span>

<span class="p">:!</span><span class="s">foo</span>
<span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="nb">False</span><span class="p">)</span>

<span class="p">:</span><span class="s">foo</span><span class="p">&lt;</span><span class="s">bar</span><span class="p">&gt;</span>
<span class="p">:</span><span class="s">foo</span><span class="p">(&#34;</span><span class="s2">bar</span><span class="p">&#34;)</span>
</code></pre></div><p><code>:foo</code> 与 <code>foo =&gt; True</code> 相同, <code>:!foo</code> 等价于 <code>foo =&gt; False</code>。<code>:foo&lt;bar&gt;</code> 使用了一组尖括号引起了值, 值在尖括号中不进行插值。</p>
<p>来看一个命名参数例子, 下面的代码遍历 <code>@dirs</code> 中的目录, 找出后缀名为 txt 且不为空的文件:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nb">find</span><span class="p">(</span><span class="nv">@dirs</span><span class="o">,</span> <span class="p">:</span><span class="s">file</span><span class="o">,</span> <span class="p">:</span><span class="s">ext</span><span class="p">&lt;</span><span class="s">txt</span><span class="p">&gt;</span><span class="o">,</span> <span class="p">:!</span><span class="s">empty</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$file</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>冒号对儿的值可以是变量, 但是在圆括号中再写一遍变量名就显得啰嗦:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">foo</span><span class="p">(:</span><span class="s">bar</span><span class="p">(</span><span class="nv">$bar</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">baz</span><span class="p">(</span><span class="nv">$baz</span><span class="p">)</span><span class="o">,</span> <span class="p">:</span><span class="s">quz</span><span class="p">(</span><span class="nv">$quz</span><span class="p">))</span>
</code></pre></div><p>因此, 冒号对儿提供了一种简写形式, 如果冒号后面紧跟着 <code>$</code>、<code>@</code>、<code>%</code> 和 <code>&amp;</code> 等符号, 那么冒号对儿的值就是 <code>$sth</code>、<code>@sth</code>、<code>%sth</code> 和 <code>&amp;sth</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">foo</span><span class="p">(</span><span class="o">:</span><span class="nv">$bar</span><span class="o">,</span> <span class="o">:</span><span class="nv">$baz</span><span class="o">,</span> <span class="o">:</span><span class="nv">$quz</span><span class="p">)</span>
</code></pre></div><p>这种简写形式消除了命名参数的重复。</p>
<h2 id="pointy-blocks尖号块儿">Pointy blocks(尖号块儿)</h2>
<p>All blocks are <strong>Callable</strong>, 即所有的块儿都是可调用的。</p>
<ul>
<li><code>for</code> blocks</li>
</ul>
<p><code>-&gt; $elem { ...}</code> 就是尖号块儿:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@array</span> <span class="k">-&gt;</span> <span class="nv">$elem</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><code>for</code> 循环依次把 <code>@array</code> 中的每个元素赋值给尖号块儿中的 <code>$elem</code> 变量, 然后执行尖号块儿的主体。</p>
<ul>
<li>Ordering</li>
</ul>
<p>如果 <code>foo</code> 例程有返回值且不为假, 则赋值给 <code>$value</code>, 然后执行块儿的主体:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><p>但是上面的语句在 Raku  中是不合法的, 要使用尖号块儿的方式:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="nf">foo</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="signatures签名">Signatures(签名)</h2>
<p><code>for</code> 循环可以一次迭代两个(或多个)元素。尖号块儿相当于匿名函数, 其中的 <code>$first, $second</code> 就是尖号块儿的签名。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@array</span> <span class="k">-&gt;</span> <span class="nv">$first</span><span class="o">,</span> <span class="nv">$second</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>下面的智能匹配中, 变量 <code>$1</code> 和 <code>$2</code> 有些多余:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="o">/</span> <span class="p">(</span>\<span class="k">S</span><span class="err">+</span><span class="p">)</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr"> / </span><span class="p">{</span> 
    <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$1</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$value</span> <span class="o">=</span> <span class="nv">$2</span><span class="p">;</span>
    <span class="o">...</span>
 <span class="p">}</span><span class="sr">
</span></code></pre></div><p>通过尖号块儿, 把匹配结果直接赋值给 <code>$name</code> 和 <code>$value</code>, 节省了两个变量名:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="o">/</span> <span class="p">(</span>\<span class="k">S</span><span class="err">+</span><span class="p">)</span><span class="sr"> </span><span class="se">\s</span><span class="o">+</span><span class="sr"> </span><span class="p">(</span><span class="ni">.</span><span class="o">*</span><span class="p">)</span><span class="sr"> / -</span><span class="p">&gt;</span> <span class="p">(</span><span class="nv">$name</span><span class="o">,</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><code>for</code> 尖号块儿和 <code>if</code> 尖号块儿的结构类似, 语法上非常整齐:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nf">expression</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">if</span> <span class="nf">expression</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nv">$value</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div><h2 id="whatever-code">Whatever code</h2>
<p>如果 grep 的过滤条件中有多个变量, 那么使用尖号块儿这种匿名函数比较合适:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@numbers</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="k">-&gt;</span> <span class="nv">$n</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">});</span>
</code></pre></div><p>如果过滤条件中只有一个变量, 那么形式更短的 Whatever code 更符合惯用法:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@numbers</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div><h2 id="meta-operators">Meta-operators</h2>
<ul>
<li>Reduction</li>
<li>Zip</li>
<li>Corss</li>
<li>Hyper</li>
</ul>
<p>Reduction meta operators</p>
<ul>
<li>fold/reduce an infix operator</li>
<li>Respects associativity</li>
</ul>
<p><code>reduce</code> 运算符可以用于求和:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="nb">reduce</span> <span class="p">{</span> <span class="nv">$^a</span> <span class="o">+</span> <span class="nv">$^b</span> <span class="p">}</span><span class="o">,</span> <span class="nv">@list</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$sum</span> <span class="o">=</span> <span class="o">[+]</span> <span class="nv">@list</span>
</code></pre></div><pre><code>[+]   # sum
[*]   # product
[~]   # join
[===] # all equal
[&lt;&gt;]  # ascending order
[||]  # first true value, if any
</code></pre>
<p>Zip 元运算符用于连接列表:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">Z</span><span class="o">+</span> <span class="p">(</span><span class="mi">30</span><span class="o">,</span> <span class="mi">20</span> <span class="o">,</span><span class="mi">10</span><span class="p">)</span>
<span class="c1"># (21, 22, 13)</span>
</code></pre></div><p><code>-&gt; ($a, $b)</code> 解构 Zip 后的元素:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nv">$a</span><span class="o">,</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><code>Z=&gt;</code> 运算符通常用于从两个列表中制作哈希:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">%hash</span> <span class="o">=</span> <span class="nv">@keys</span> <span class="ow">Z</span><span class="o">=&gt;</span> <span class="nv">@values</span>
</code></pre></div><p>Zip 元运算符可以写成链式的:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">Z</span> <span class="nv">@b</span> <span class="ow">Z</span> <span class="nv">@c</span>
<span class="o">[</span><span class="ow">Z</span><span class="o">]</span> <span class="nv">@list-of-lists</span>
</code></pre></div><p>Cross 是交叉运算符。使用两层 for 循环也可以实现交叉运算符的功能, 就是代码稍长:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">gather</span> <span class="k">for</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="k">-&gt;</span> <span class="nv">$i</span> <span class="p">{</span>
    <span class="k">for</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">10</span> <span class="k">-&gt;</span> <span class="nv">$j</span> <span class="p">{</span>
        <span class="nb">take</span> <span class="nv">$i</span> <span class="o">+</span> <span class="nv">$j</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>而使用交叉运算符, 一行代码搞定:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span> <span class="ow">X</span><span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">10</span>
</code></pre></div><p>添加前缀也很简单:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">&#34;</span><span class="s2">prefix-</span><span class="p">&#34;</span> <span class="ow">X</span><span class="o">~</span> <span class="nv">@list</span>
</code></pre></div><p>Hyper 运算符可以把任何运算符(中缀、前缀和后缀等)应用到列表上:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@list</span><span class="o">».</span><span class="nb">abs</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*.</span><span class="nb">abs</span><span class="p">)</span>

<span class="o">!</span><span class="p">«</span><span class="nv">@list</span><span class="s2">
</span><span class="s2"></span><span class="nv">@list</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="o">!*</span><span class="p">)</span><span class="s2">
</span><span class="s2">
</span><span class="s2"></span><span class="nv">@list</span><span class="p">»</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="o">*[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
</code></pre></div><p>欧几里得距离:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span>
</code></pre></div><p>Squared(平方)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span><span class="p">)</span><span class="o">»</span>²
</code></pre></div><p>Summed(求和)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">[+]</span> <span class="p">(</span><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span><span class="p">)</span><span class="o">»</span>²
</code></pre></div><p>Square root(求平方根)</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">sqrt</span> <span class="o">[+]</span> <span class="p">(</span><span class="nv">@a</span> <span class="ow">Z</span><span class="o">-</span> <span class="nv">@b</span><span class="p">)</span><span class="o">»</span>²
</code></pre></div><h2 id="smartmatch智能匹配">Smartmatch(智能匹配)</h2>
<p>“Is the value part of this set”</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="o">*</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="nv">$_</span> <span class="ow">eq</span> <span class="p">&#34;</span><span class="s2">foo</span><span class="p">&#34;</span> <span class="p">})</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">isa</span><span class="p">(</span><span class="n">Innt</span><span class="p">)</span> <span class="p">})</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(/</span><span class="sr">foo </span><span class="ni">.</span><span class="o">*</span><span class="sr"> bar</span><span class="p">/)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">match</span><span class="p">(/</span><span class="sr">foo </span><span class="ni">.</span><span class="o">*</span><span class="sr"> bar</span><span class="p">/)</span> <span class="p">})</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="mi">4</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="nv">$_</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="p">})</span>

<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(:</span><span class="s">is-prime</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">is-prime</span> <span class="p">})</span>
</code></pre></div><p>combine junctions(结合 Junctions):</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(:</span><span class="s">is-prime</span> <span class="o">&amp;</span> <span class="o">/</span><span class="mi">22</span><span class="o">/</span><span class="p">)</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">.</span><span class="nb">is-prime</span> <span class="o">&amp;&amp;</span> <span class="o">.</span><span class="nf">matches</span><span class="p">(/</span><span class="mi">22</span><span class="p">/)</span> <span class="p">})</span>

<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">(</span><span class="nb">none</span><span class="p">(/</span><span class="mi">22</span><span class="p">/))</span>
<span class="nv">@list</span><span class="o">.</span><span class="nb">grep</span><span class="p">({</span> <span class="o">!.</span><span class="nf">matches</span><span class="p">(/</span><span class="mi">22</span><span class="p">/)</span> <span class="p">})</span>
</code></pre></div><p>最后, 还是查找文件的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">find</span><span class="p">(</span><span class="nv">@dirs</span><span class="o">,</span>
  <span class="p">:</span><span class="s">ext</span><span class="p">(&#39;</span><span class="s1">rakumo</span><span class="p">&#39;</span><span class="o">|</span><span class="p">&#39;</span><span class="s1">pm6</span><span class="p">&#39;)</span><span class="o">,</span>
  <span class="p">:</span><span class="s">size</span><span class="p">(</span><span class="o">*</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">)</span><span class="o">,</span>
  <span class="p">:</span><span class="s">depth</span><span class="p">(</span><span class="mi">3</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span><span class="o">,</span>
  <span class="p">:</span><span class="s">contains</span><span class="p">(/</span><span class="sr">raku</span><span class="p">/)</span>
<span class="p">);</span>
</code></pre></div><p>原文链接: <a href="https://www.youtube.com/watch?v=elalwvfmYgk">https://www.youtube.com/watch?v=elalwvfmYgk</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Raku Multiple Dispatch With the New MoarVM Dispatcher]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 的标准库 Trait 之旅" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-15T00:00:00+08:00</published>
            <updated>2021-04-15T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Multiple Dispatch With the New Moarvm Dispatcher</blockquote><p>我最近写了一篇关于<a href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/">新的 MoarVM 调度机制</a>的文章，并在那篇文章中指出，我在 Raku 的多重分派语义方面还有不少需要实现的地方。从那以后，我在这个方向上取得了不小的进展。这篇文章包含了对所采取的方法的概述，以及一些非常粗略的性能测量。</p>
<h2 id="我的天啊语义太多了">我的天啊，语义太多了</h2>
<p>在 Raku 的所有分派中，多重分派是最复杂的。多重分派允许我们写一组候选者，然后根据参数的数量进行选择。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nb">ok</span><span class="p">(</span><span class="nv">$condition</span><span class="o">,</span> <span class="nv">$desc</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">(</span><span class="nv">$condition</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">ok</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">not ok</span><span class="p">&#39;)</span> <span class="o">~</span> <span class="p">&#34;</span><span class="s2"> - </span><span class="nv">$desc</span><span class="p">&#34;;</span>
<span class="p">}</span>
<span class="k">multi</span> <span class="nb">ok</span><span class="p">(</span><span class="nv">$condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">ok</span><span class="p">(</span><span class="nv">$condition</span><span class="o">,</span> <span class="p">&#39;&#39;);</span>
<span class="p">}</span>
</code></pre></div><p>或根据参数的类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">to-json</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$i</span><span class="p">)</span> <span class="p">{</span> <span class="o">~</span><span class="nv">$i</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">to-json</span><span class="p">(</span><span class="nb">Bool</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$b</span> <span class="o">??</span> <span class="p">&#39;</span><span class="s1">true</span><span class="p">&#39;</span> <span class="o">!!</span> <span class="p">&#39;</span><span class="s1">false</span><span class="p">&#39;</span> <span class="p">}</span>
</code></pre></div><p>而且不只是一个参数，而是可能有很多参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$chars</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$str</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&lt;</span> <span class="nv">$chars</span> <span class="o">??</span> <span class="nv">$str</span> <span class="o">!!</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$chars</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$after</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">with</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">index</span><span class="p">(</span><span class="nv">$after</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$pos</span> <span class="p">{</span>
        <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$pos</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nv">$str</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们可以添加 <code>where</code> 子句来区分普通类型无法捕捉的属性上的候选者。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>每当我们写出一组这样的 <code>multi</code> 候选列表时，编译器就会自动生成一个 <code>proto</code> 例程。这就是安装在符号表中的，存放候选列表的东西。然而，我们也可以写自己的 <code>proto</code>，并使用特殊的术语 <code>{*}</code> 来决定在哪一点上进行调度，如果有的话。</p>
<pre><code class="language-rakuu" data-lang="rakuu">proto mean($collection) {
    $collection.elems == 0 ?? Nil !! {*}
}

multi mean(@arr) {
    @arr.sum / @arr.elems
}

multi mean(%hash) {
    %hash.values.sum / %hash.elems
}
</code></pre><p>候选者按窄度排序（使用拓扑排序）。如果多个候选者匹配，但它们窄度相同，那么这就是一个歧义错误。否则，我们调用最窄的一个。然后，我们选择的候选者可能会使用 <code>callsame</code> 和它的朋友们来推迟到下一个最窄的候选者，后者可能也会这样做，直到我们达到最一般的匹配的候选者。</p>
<h2 id="多重分派无处不在">多重分派无处不在</h2>
<p>Raku 在很大程度上依赖于多重分派。Raku 中的大多数操作符都被编译成对多重分派子程序的调用。即使是 <code>$a+$b</code> 也会是一个多重分派。这意味着高效地进行多重分派对性能真的很重要。考虑到其语义的丰富性，这有可能有点令人担忧。不过，也有好消息。</p>
<h2 id="大多数多重调度都很无聊">大多数多重调度都很无聊</h2>
<p>我们遇到的绝大多数情况是:</p>
<ul>
<li>一个仅由参数和名义类型的数量所做的决定。</li>
<li>无 where 子句</li>
<li>无自定义 proto</li>
<li>无 callsame</li>
</ul>
<p>这并不是说其他情况不重要，它们确实相当有用，而且它们的表现也是可取的。不过，在普通情况下，我们能省则省，也是可取的。例如，我们不希望急于计算每一个单次多重调度的全部可能的候选者，因为大多数时候只有第一个才是重要的。这不仅仅是时间上的问题：回想一下，新的调度机制会在每个调用点存储调度程序，如果我们在每个调用点存储所有匹配的候选程序列表，我们也会浪费很多内存。</p>
<h2 id="我们今天怎么做">我们今天怎么做？</h2>
<p>如今 Rakuo 的情况如下:</p>
<ul>
<li>
<p>如果调度只由元数和名义类型决定，并且你不使用扁平化的参数来调用它，它可能会表现得很好，甚至可能会享受到候选者的内联和消除在慢速路径上发生的重复类型检查。这要归功于 proto 持有一个 &ldquo;dispatch cache&rdquo;，这是一个在 VM 中实现的特例机制，它使用搜索树，每个参数有一个级别。</p>
</li>
<li>
<p>如果是这种情况，但它有一个自定义的 proto，也不会太差，虽然不会发生内联，它仍然可以使用搜索树。</p>
</li>
<li>
<p>如果它使用 <code>where</code> 子句，速度会很慢，因为搜索树只处理在每一个名义类型集合中找到一个候选者，所以我们不能使用它。</p>
</li>
<li>
<p>同样的道理也适用于 <code>callsame</code>，它的速度也会很慢。</p>
</li>
</ul>
<p>实际上，今天的情况是，如果在热路径附近的任何地方，你根本不会在多重调度中使用 <code>where</code>子句（好吧，如果你知道热路径在哪里，并且知道这种调度很慢）。同理，<code>callsame</code> 也是如此，虽然那不太常触达。问题是，我们能不能用新的调度器做得更好？</p>
<h2 id="守卫类型">守卫类型</h2>
<p>我们先看看最简单的情况是如何处理的，然后再从那里开始建立。(这其实是我在实现上的做法，但同时我也有一个大概的想法，我希望最终的结果是什么)。</p>
<p>回忆一下这对候选者。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Int</span> <span class="nv">$chars</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$str</span><span class="o">.</span><span class="nb">chars</span> <span class="o">&lt;</span> <span class="nv">$chars</span> <span class="o">??</span> <span class="nv">$str</span> <span class="o">!!</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$chars</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
<span class="p">}</span>

<span class="k">multi</span> <span class="nb">truncate</span><span class="p">(</span><span class="nb">Str</span> <span class="nv">$str</span><span class="o">,</span> <span class="nb">Str</span> <span class="nv">$after</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">with</span> <span class="nv">$str</span><span class="o">.</span><span class="nb">index</span><span class="p">(</span><span class="nv">$after</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">$pos</span> <span class="p">{</span>
        <span class="nv">$str</span><span class="o">.</span><span class="nb">substr</span><span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="nv">$pos</span><span class="p">)</span> <span class="o">~</span> <span class="p">&#39;</span><span class="s1">...</span><span class="p">&#39;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="nv">$str</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后我们有一个调用 <code>truncate($message, &quot;\n&quot;)</code>，其中 <code>$message</code> 是 <code>Str</code> 类型的。在新的调度机制下，调用是使用 <code>raku-call</code> dispatcher 进行的，它识别出这是一个 <code>multi</code> 方法调度，因此委托给 <code>raku-multi</code>。(<code>multi</code> 方法调度也会在那里结束)。</p>
<p>调度的记录阶段 - 在我们第一次到达这个调用点时 - 将进行如下操作。</p>
<ol>
<li>迭代候选者</li>
<li>如果某个候选者在参数数上不匹配，就直接丢弃它。由于 <code>callsite</code> 的形状是一个常数，而且我们在每个 <code>callsite</code> 都会计算 dispatch 程序，所以我们不需要为此建立任何防护措施。</li>
<li>如果在类型匹配并且成功了，注意涉及哪些参数，需要什么样的守卫。</li>
<li>如果没有匹配或者模棱两可，就报错，不产生调度程序。</li>
<li>否则，在确定了类型守卫后，将选定的候选程序委托给 <code>raku-invoke</code> 调度程序。</li>
</ol>
<p>当我们再次到达同一个调用点时，我们可以运行调度程序，它可以快速检查参数类型是否与上次看到的参数类型相匹配，如果相匹配，我们就知道要调用哪个候选程序。这些检查非常便宜 - 比遍历所有候选者并检查每个候选者是否匹配要便宜得多。优化器以后可能会证明这些检查总是会成为事实，并消除它们。</p>
<p>因此，整个调度过程 - 至少对于这个我们只有类型和元数的简单案例 - 可以向虚拟机 &ldquo;解释&rdquo; 为 &ldquo;如果参数具有这些确切的类型，就调用这个例程&rdquo;。这和我们对方法分派所做的差不多，除了我们只关心第一个参数的类型 - 调用者 - 和方法名的值。(还记得上一篇文章中说过，如果是 <code>multi</code> 方法调度，那么方法调度和 <code>multi</code> 方法调度都会守护第一个参数的类型，但是消除了重复，所以只做一次检查)。</p>
<h2 id="这就进入了恢复之洞">这就进入了恢复之洞</h2>
<p>想出好的抽象是很难的，新的调度机制的很多挑战就在于此。Raku 有不少不同的类似调度的东西。然而，将它们全部直接编码在虚拟机中会导致很高的复杂度，这使得构建可靠的优化（甚至是可靠的未优化的实现！）具有挑战性。因此，我们的目标是研究出一套相对较小的原语，允许以这样一种方式向虚拟机 &ldquo;解释&rdquo; 调度，使其能够提供不错的性能。</p>
<p>很明显，<code>callsame</code> 是一种调度恢复，但自定义 proto 这种情况和 <code>where</code> 子句这种情况呢？事实证明，这些也都可以用调度恢复的方式整齐地表达出来（<code>where</code> 子句情况需要在虚拟机层面增加一个小的内容，到时候可能对其他事情也有用）。不仅如此，用调度恢复来编码这些特性也是相当直接的，因此应该是高效的。我们教给专门人员的关于如何更好地使用调度恢复的每一个技巧，都可以让所有使用它们实现的语言特性也受益。</p>
<h2 id="自定义-proto">自定义 proto</h2>
<p>回顾这个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">proto</span> <span class="nf">mean</span><span class="p">(</span><span class="nv">$collection</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$collection</span><span class="o">.</span><span class="nb">elems</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">??</span> <span class="nb">Nil</span> <span class="o">!!</span> <span class="p">{</span><span class="o">*</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这里，我们希望运行 proto 的主体，然后在 <code>{*}</code> 这里进行候选者的选择。相比之下，当我们没有自定义的 proto 时，我们希望简单地继续调用正确的多。</p>
<p>为了达到这个目的，我首先将 <code>multi</code> 候选者的选择逻辑从 <code>raku-multi</code> 调度器移到了 <code>raku-multi-core</code> 调度器中。然后，<code>raku-multi</code> dispatcher 会检查我们是否有一个 &ldquo;onlystar&rdquo; proto（一个不需要我们运行的 proto）。如果有，它就会立即委托给 <code>raku-multi-core</code>。如果没有，它就将调度的参数保存为恢复初始化状态，然后调用 proto。proto 的 <code>{*}</code> 被编译成一个 dispatch resumption。然后，这个 resumption 委托给 <code>raku-multi-core</code>。或者，在代码中。</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="c1"># Initial dispatch, only setting up resumption if we need to invoke the</span>
    <span class="c1"># proto.</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$callee</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">my</span> <span class="nb">int</span> <span class="nv">$onlystar</span> <span class="o">:=</span> <span class="nf">nqp::getattr_i</span><span class="p">(</span><span class="nv">$callee</span><span class="o">,</span> <span class="nb">Routine</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!onlystar</span><span class="p">&#39;);</span>
        <span class="k">if</span> <span class="nv">$onlystar</span> <span class="p">{</span>
            <span class="c1"># Don&#39;t need to invoke the proto itself, so just get on with the</span>
            <span class="c1"># candidate dispatch.</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi-core</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1"># Set resume init args and run the proto.</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-init-args</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-invoke</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="o">,</span>
    <span class="c1"># Resumption means that we have reached the {*} in the proto and so now</span>
    <span class="c1"># should go ahead and do the dispatch. Make sure we only do this if we</span>
    <span class="c1"># are signalled to that it&#39;s a resume for an onlystar (resumption kind 5).</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$track_kind</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_kind</span><span class="p">);</span>
        <span class="k">my</span> <span class="nb">int</span> <span class="nv">$kind</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg_i</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="nv">$kind</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi-core</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-get-resume-init-args</span><span class="p">&#39;));</span>
        <span class="p">}</span>
        <span class="k">elsif</span> <span class="o">!</span><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-next-resumption</span><span class="p">&#39;)</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-constant</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span>
                    <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nb">Nil</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">});</span>
</code></pre></div><h2 id="合二为一">合二为一</h2>
<p>推迟到下一个候选者（例如用 <code>callsame</code>）和因为 <code>where</code> 子句失败而尝试下一个候选者看起来非常相似：两者都涉及遍历一个可能的候选者列表。有一些细节，但它们有很多共同点，如果能在使用新的 dispatcher 实现多重分派的过程中体现出来就更好了。</p>
<p>在这之前，先说一个略显可怕的细节，当我们有 <code>where</code> 子句的时候，今天在 Rakuo 中是如何工作的。首先，调度器会做一个 &ldquo;试用绑定&rdquo;，它问一个问题：这个签名会不会绑定？要做到这一点，它必须评估所有的 <code>where</code> 子句。更糟糕的是，它还必须使用慢路径签名绑定器，它对签名进行解释，尽管我们在很多情况下可以编译它。如果候选者匹配，很好，我们选择它，然后调用它&hellip;&hellip;这将第二次运行 <code>where</code> 子句，作为编译后的签名绑定代码的一部分。这样做一点也不高效，除了在开发人员的时间上要高效得多，这也是为什么要这样做的原因。</p>
<p>总之，毋庸置疑，在我使用新的调度器重新实现时，我相当希望尽可能避免这种重复的工作和慢路径绑定。而且，令人高兴的是，一个小小的补充提供了一个解决方案。有一个 op <code>assertparamcheck</code>，任何类型的参数检查都会被编译成（无论是类型检查、<code>where</code> 子句检查等），这将触发对一个函数的调用，该函数获取参数，也就是我们试图调用的东西，然后可以通过它们来产生错误信息。诀窍是提供一种调用例程的方法，使绑定失败后，不是调用报错函数，而是离开例程，然后做一个调度恢复! 这意味着我们可以将传递 <code>where</code> 子句检查失败变成一个调度恢复，然后会走到下一个候选者，并代替它进行尝试。</p>
<h2 id="琐碎vs非琐碎">琐碎VS非琐碎</h2>
<p>这让我们得到了大部分的解决方法，但在常见的情况下，仍然存在内存和时间效率的问题，即没有恢复和没有 <code>where</code> 子句。我为这种情况创造了一个术语 &ldquo;trivial multiple dispatch&rdquo;，这使得其他情况变得 &ldquo;non-trivial&rdquo;。事实上，我甚至做了一个调度器，叫做 <code>raku-multi-non-trivial</code>! 我们有两种方式可以结束。</p>
<ol>
<li>最初尝试寻找匹配的候选者，决定了我们必须考虑 <code>where</code> 子句。一旦我们看到是这种情况，我们就会继续制作一个可能匹配的候选者的完整列表。这是一个链表（原因见我之前的文章）。</li>
<li>最初尝试寻找匹配的候选者时，发现了一个可以纯粹根据参数数和名词类型来挑选的候选者。我们就此停止，而不是试图建立一个完整的候选列表，并运行匹配的候选。在 <code>callsame</code> 的情况下，我们最终进入琐碎的调度恢复处理程序，它 - 因为这种情况现在是非琐碎的 - 建立完整的候选者列表，从它上面剪下第一项（因为我们已经运行了那项），然后委托给 <code>raku-multi-non-trivial</code>。</li>
</ol>
<p>在这个描述中失去了另一个重要的改进：今天，当有 <code>where</code> 子句时，我们完全失去了使用 MoarVM 多重调度缓存的能力，但在新的调度器下，我们在 <code>callsite</code> 存储了一个类型过滤的候选列表，然后使用廉价的类型守卫来检查它是否有效使用。</p>
<h2 id="初步结果">初步结果</h2>
<p>我做了一些基准测试，看看新的调度机制在今天 Raku 已知的几种次优情况下的表现。这些数字并不能反映出什么是可能的，因为目前专门人员对新的调度器还没有太多的了解。相反，它们反映了我们可以期望的最小改进。</p>
<p>考虑这个基准，使用一个带有 <code>where</code> 子句的 <code>multi</code> 来递归实现 factorial。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">100_000</span> <span class="p">{</span>
    <span class="nf">fac</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>这需要进行一些调整（并在环境变量下运行）以使用新的调度器；这些都是暂时的，直到我将 Rakudo 转换为默认使用新的调度器。</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span> <span class="k">where</span> <span class="nv">$n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fac</span><span class="p">(</span><span class="nv">$n</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$n</span> <span class="o">*</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fac</span><span class="o">,</span> <span class="nv">$n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">100_000</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fac</span><span class="o">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>在我的机器上，第一个运行时间为4.86秒，第二个运行时间为1.34秒。因此，在新的调度器下，运行时间只需过去的四分之一多一点 - 这已经是一个相当大的改进了。</p>
<p>一个涉及 <code>callsame</code> 的案例也很有意思。这里是没有使用新调度器的情况。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Any</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">a</span><span class="nv">$x</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nb">callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">r</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nb">callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">i</span><span class="p">&#34;</span> <span class="o">~</span> <span class="nb">callsame</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="nf">fallback</span><span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">);</span>
    <span class="nf">fallback</span><span class="p">(</span><span class="mf">4.2</span><span class="p">);</span>
    <span class="nf">fallback</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>   
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>而配合临时调整使用新的调度器:</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Any</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">a</span><span class="nv">$x</span><span class="p">&#34;</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Numeric</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">n</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">new-disp-callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Real</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">r</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">new-disp-callsame</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">fallback</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span><span class="p">)</span> <span class="p">{</span> <span class="p">&#34;</span><span class="s2">i</span><span class="p">&#34;</span> <span class="o">~</span> <span class="n">new-disp-callsame</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fallback</span><span class="o">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="no">i</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fallback</span><span class="o">,</span> <span class="mf">4.2</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;fallback</span><span class="o">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>在我的机器上，第一个运行时间为31.3s，第二个运行时间为11.5s，这意味着使用新的调度器，我们最终需要的时间只有当前 Rakudo 的三分之一多一点。</p>
<p>这些都是相当鼓舞人心的，但正如前面提到的，大部分的多重调度都是琐碎的那种，没有使用这些功能。如果我在让其他事情变得更好的路上把最常见的情况变得更糟，那就不好了。现在还不能对此进行公平的比较：琐碎的多重分派在特化器中已经受到了很多关注，而且它还不能很好地优化使用新调度器的代码。值得注意的是，在这样的例子中。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="k">m</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">m</span><span class="p">(&#34;</span><span class="s2">x</span><span class="p">&#34;);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>内嵌和其他优化会将其变成一个空循环，这是很难做到的。不过有一件事我们已经可以做了：在禁用 specializer 的情况下运行它。新的调度器版本看起来是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-nqp" data-lang="nqp"><span class="k">use</span> <span class="nb">nqp</span><span class="p">;</span>

<span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">multi</span> <span class="nf">m</span><span class="p">(</span><span class="nb">Str</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">for</span> <span class="o">^</span><span class="mi">1_000_000</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;m</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">raku-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">&amp;m</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">x</span><span class="p">&#34;);</span>
<span class="p">}</span>
<span class="nb">say</span> <span class="nb">now</span> <span class="o">-</span> <span class="k">INIT</span> <span class="nb">now</span><span class="p">;</span>
</code></pre></div><p>结果分别是0.463s和0.332s。因此，基线执行时间 - 在特化器发挥其魔力之前 - 使用新的通用调度机制比使用我们目前使用的特化多重调度缓存要少。在做测量之前，我不知道这里会有什么预期。鉴于我们要从一个已经被剖析和调整过的特化机制转到一个没有受到如此关注的新的通用机制，我已经做好了最初做得差一点的准备，如果能做到平价就好了。在70%的时间里，跑进了70%的时间，这比我预期的进步更大。</p>
<p>我期望，一旦特化器更好地理解新的调度机制，它也能把上面的内容变成一个空循环 - 不过，由于每次优化可以进行更多的迭代，这应该还是表现为新调度器的胜利。</p>
<h2 id="最后的想法">最后的想法</h2>
<p>只要增加一个相对较小的功能，新的调度机制已经可以处理大部分的 Raku 多重调度语义。此外，即使在 specializer 和 JIT 没有真正能够做好的情况下，一些微基准已经显示出3倍-4倍的提升。这是一个很好的起点。</p>
<p>在我们使用新的调度器出货 Rakudo 版本之前，还有很多工作要做。然而，多重调度是设计中剩下的最大威胁：它比其他种类的调度相当多的参与，而且很有可能一个意想不到的缺点会引发新一轮的设计工作，或者揭示出一般机制与基线未优化的情况下, 与更专业的机制相比，性能会很吃力。到目前为止，没有任何迹象表明这两种情况，我谨慎乐观地认为整体设计是差不多的。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Rust 的标准库 Trait 之旅]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-15-raku-multiple-dispatch-with-the-new-moarvm-dispatcher/?utm_source=atom_feed" rel="related" type="text/html" title="Raku Multiple Dispatch With the New MoarVM Dispatcher" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="related" type="text/html" title="Psql" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
            
                <id>https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rust-standard-library-traits/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-15T00:00:00+08:00</published>
            <updated>2021-04-15T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Raku Multiple Dispatch With the New Moarvm Dispatcher</blockquote><h1 id="rust-的标准库-trait-之旅">Rust 的标准库 Trait 之旅</h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#trait-basics">Trait Basics</a>
<ul>
<li><a href="#trait-items">Trait Items</a>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
</ul>
</li>
<li><a href="#scope">Scope</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
<li><a href="#unsafe-traits">Unsafe Traits</a></li>
</ul>
</li>
<li><a href="#auto-traits-1">Auto Traits</a>
<ul>
<li><a href="#send--sync">Send &amp; Sync</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
</li>
<li><a href="#general-traits">General Traits</a>
<ul>
<li><a href="#default">Default</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#any">Any</a></li>
</ul>
</li>
<li><a href="#formatting-traits">Formatting Traits</a>
<ul>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
</ul>
</li>
<li><a href="#operator-traits">Operator Traits</a>
<ul>
<li><a href="#comparison-traits">Comparison Traits</a>
<ul>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
</li>
<li><a href="#arithmetic-traits">Arithmetic Traits</a>
<ul>
<li><a href="#add--addassign">Add &amp; AddAssign</a></li>
</ul>
</li>
<li><a href="#closure-traits">Closure Traits</a>
<ul>
<li><a href="#fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</a></li>
</ul>
</li>
<li><a href="#other-traits">Other Traits</a>
<ul>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
<li><a href="#index--indexmut">Index &amp; IndexMut</a></li>
<li><a href="#drop">Drop</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conversion-traits">Conversion Traits</a>
<ul>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
</li>
<li><a href="#error-handling">Error Handling</a>
<ul>
<li><a href="#error">Error</a></li>
</ul>
</li>
<li><a href="#conversion-traits-continued">Conversion Traits Continued</a>
<ul>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
<li><a href="#fromstr">FromStr</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
<li><a href="#toowned">ToOwned</a></li>
</ul>
</li>
<li><a href="#iteration-traits">Iteration Traits</a>
<ul>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#fromiterator">FromIterator</a></li>
</ul>
</li>
<li><a href="#io-traits">I/O Traits</a>
<ul>
<li><a href="#read--write">Read &amp; Write</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#discuss">Discuss</a></li>
<li><a href="#notifications">Notifications</a></li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>你有没有想过，这两者之间有什么区别?</p>
<ul>
<li><code>Deref&lt;Target = T&gt;</code>, <code>AsRef&lt;T&gt;</code> 和 <code>Borrow&lt;T&gt;</code>?</li>
<li><code>Clone</code>, <code>Copy</code> 和 <code>ToOwned</code>?</li>
<li><code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code>?</li>
<li><code>TryFrom&lt;&amp;str&gt;</code> 和 <code>FromStr</code>?</li>
<li><code>FnOnce</code>, <code>FnMut</code>, <code>Fn</code> 和 <code>fn</code>?</li>
</ul>
<p>或者曾经问过自己这样的问题:</p>
<ul>
<li>在我的 trait 中, 我什么时候使用关联类型, 什么时候使用泛型类型?</li>
<li>什么是泛型的 blanket 实现?</li>
<li>subtrait 和 supertrait 是如何工作的?</li>
<li>为什么这个 trait 没有任何方法?</li>
</ul>
<p>那么这篇文章就是为你准备的! 它回答了以上所有的问题以及更多的问题。我们将一起对 Rust 标准库中所有最流行、最常用的 trait 进行快速飞越之旅!</p>
<p>你可以按顺序逐节阅读本文，也可以跳转到你最感兴趣的 trait，因为每个 trait 部分都有一个链接列表，链接到 “先决知识” 部分，你应该阅读这些链接，以便有足够的背景来理解当前部分的解释。</p>
<h2 id="trait-基础">Trait 基础</h2>
<p>We&rsquo;ll cover just enough of the basics so that the rest of the article can be streamlined without having to repeat the same explanations of the same concepts over and over as they reappear in different traits.</p>
<p>我们将只涉及足够的基础知识，以便文章的其余部分可以精简，而不必在不同的 trait 中重新出现时重复相同的概念解释。</p>
<h3 id="trait-项">Trait 项</h3>
<p>Trait 项是指作为 trait 声明一部分的任何项。</p>
<h4 id="self">Self</h4>
<p><code>Self</code> 总是指实现类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// always returns i32
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// returns implementing type
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">5</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// Self == SomeType
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SomeType</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">6</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// Self == OtherType
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">OtherType</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="函数">函数</h4>
<p>Trait 函数是任何第一个参数不使用 <code>self</code> 关键字的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// function
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 函数可以通过 trait 或实现类型按照命名空间的方式来调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">zero</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="nb">Default</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="方法">方法</h4>
<p>Trait 方法是指第一个参数使用 <code>self</code> 关键字并且类型为 <code>Self</code>、<code>&amp;Self</code>、<code>&amp;mut Self</code> 的任何函数。前面的类型也可以用 <code>Box</code>、<code>Rc</code>、<code>Arc</code> 或 <code>Pin</code> 来包装。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// methods
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_self</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_immut_self</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_mut_self</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// above methods desugared
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_self</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_immut_self</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_mut_self</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example from standard library
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以使用实现类型上的点运算符来调用方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，与函数类似，它们也可以通过 trait 或实现类型按照命名空间的方式来调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="关联类型">关联类型</h4>
<p>Trait 可以有关联类型。当我们需要在函数签名中使用 <code>Self</code> 以外的其他类型，但又希望类型由实现者选择，而不是在 trait 声明中硬编码时，这很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// any type implementing Trait can
</span><span class="c1">// choose the type of AssociatedType
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i8</span><span class="p">;</span><span class="w"> </span><span class="c1">// chooses i8
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="c1">// chooses u8
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span>::<span class="n">func</span><span class="p">(</span><span class="o">-</span><span class="mi">1_</span><span class="k">i8</span><span class="p">);</span><span class="w"> </span><span class="c1">// can only call func with i8 on SomeType
</span><span class="c1"></span><span class="w">    </span><span class="n">OtherType</span>::<span class="n">func</span><span class="p">(</span><span class="mi">1_</span><span class="k">u8</span><span class="p">);</span><span class="w"> </span><span class="c1">// can only call func with u8 on OtherType
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="泛型参数">泛型参数</h4>
<p>“泛型参数” 泛指泛型类型参数、泛型 lifetime 参数和泛型常量参数。由于这些说起来都很拗口，所以人们通常把它们缩写为 <em>&ldquo;generic types&rdquo;</em>, <em>&ldquo;lifetimes&rdquo;</em> 和 <em>&ldquo;generic consts&rdquo;</em>。由于 generic consts 没有在我们将要涉及的任何标准库 trait 中使用，所以它们不在本文的范围之内。</p>
<p>我们可以使用参数来泛型化一个 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// trait declaration generalized with lifetime &amp; type parameters
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// signature uses generic type
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">T</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// signature uses lifetime
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// signature uses generic type &amp; lifetime
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">i8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以为泛型类型提供默认值。最常用的默认值是 <code>Self</code>，但任何类型都可以。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// make T = Self by default
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// any type can be used as the default
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// omitting the generic type will
</span><span class="c1">// cause the impl to use the default
</span><span class="c1">// value, which is Self here
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">SomeType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// default value here is i32
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// the default is overridable as we&#39;d expect
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// overridable here too
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>除了对 trait 进行参数化外，还可以对单个函数和方法进行参数化。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="泛型类型-vs-关联类型">泛型类型 vs 关联类型</h4>
<p>泛型类型和关联类型都将决定权交给了实现者，让他们决定在 trait 的函数和方法中应该使用哪种具体类型，所以本节试图解释什么时候使用一种类型而不是另一种类型。</p>
<p>一般的经验法则是</p>
<ul>
<li>当每个类型只能有一个 trait 的实现时，使用关联类型。</li>
<li>当每个类型可以有许多可能的 trait 的实现时，使用泛型类型。</li>
</ul>
<p>假设我们想定义一个名为 <code>Add</code> 的 trait，它允许我们将值加在一起。下面是一个初始设计和只使用关联类型的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span>::<span class="n">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>比方说，我们想给 <code>Point</code> 添加和 <code>i32</code> 相加的能力，其中 <code>i32</code> 将和 <code>x</code> 和 <code>y</code> 成员相加。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span>::<span class="n">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这抛出:</p>
<pre><code class="language-none" data-lang="none">error[E0119]: conflicting implementations of trait `Add` for type `Point`:
  --&gt; src/main.rs:23:1
   |
12 | impl Add for Point {
   | ------------------ first implementation here
...
23 | impl Add for Point {
   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point`
</code></pre><p>由于 <code>Add</code> trait 没有任何泛型类型的参数化，我们只能对每个类型进行一次实现，这意味着我们只能为 <code>Rhs</code> 和 <code>Output</code> 选择一次类型！为了允许 <code>Point</code> 和 <code>Point</code> 相加,以及 <code>i32</code> 和 <code>Point</code> 相加，我们必须将 <code>Rhs</code> 从关联类型重构为泛型类型，这将允许我们用不同的类型参数为 <code>Rhs</code> 多次实现 <code>Point</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>比方说，我们添加了一个名为 <code>Line</code> 的新类型，它包含两个 <code>Point</code>，现在在我们的程序中，将两个 <code>Point</code> 相加应该产生一个 <code>Line</code> 而不是 <code>Point</code>。考虑到 <code>Add</code> trait 当前的设计，这是不可能的，因为 <code>Output</code> 是一个关联类型，但是我们可以通过将 <code>Output</code> 从关联类型重构为泛型类型来满足这些新的要求。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="w"> </span><span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">start</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">end</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Line</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">start</span>: <span class="nc">self</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">end</span>: <span class="nc">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>那么，上面的 <code>Add</code> trait 哪种最好呢？这真的取决于你的程序的要求! 合适的就是最好的。</p>
<h3 id="作用域">作用域</h3>
<p>Trait 项不能使用，除非该 trait 在作用域内。大多数 Rustaceans 在第一次尝试写一个用 I/O 做任何事情的程序时，都会艰难地学会这一点，因为 <code>Read</code> 和 <code>Write</code> trait 不在标准库的预加载中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;Cargo.toml&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ read_to_string not found in File
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>read_to_string(buf: &amp;mut String)</code> 由 <code>std::io::Read</code> trait 声明，并由 <code>std::fs::File</code> 结构体实现，但为了调用它，<code>std::io::Read</code> 必须在作用域内。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;Cargo.toml&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的 prelude 是标准库中的一个模块，即 <code>std::prelude::v1</code>，它在每个其他模块的顶部被自动导入，即 <code>use std::prelude::v1::*</code>。因此，下面的 trait 总是在作用域内，我们永远不需要显式导入它们，因为它们是 prelude 的一部分。</p>
<ul>
<li><a href="#asref--asmut">AsMut</a></li>
<li><a href="#asref--asmut">AsRef</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#drop">Drop</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#fnonce-fnmut--fn">Fn</a></li>
<li><a href="#fnonce-fnmut--fn">FnMut</a></li>
<li><a href="#fnonce-fnmut--fn">FnOnce</a></li>
<li><a href="#from--into">From</a></li>
<li><a href="#from--into">Into</a></li>
<li><a href="#toowned">ToOwned</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
<li><a href="#send--sync">Send</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#send--sync">Sync</a></li>
<li><a href="#display--tostring">ToString</a></li>
<li><a href="#partialord--ord">Ord</a></li>
</ul>
<h3 id="派生宏">派生宏</h3>
<p>标准库导出了一些派生宏，如果一个类型的所有成员都实现了某个 trait, 我们可以使用这些宏来快速方便地在这个类型上实现该 trait。这些派生宏以它们所实现的 trait 命名。</p>
<ul>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">Ord</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
</ul>
<p>使用示例:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// macro derives Copy &amp; Clone impl for SomeType
</span><span class="c1"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>注意：派生宏只是过程宏，可以做任何事情，没有硬性规定一定要实现一个 trait，也没有规定只有在类型的所有成员都实现一个 trait 的情况下才能工作，这些只是标准库中派生宏所遵循的约定。</p>
<h3 id="默认实现">默认实现</h3>
<p>Trait 可以为其函数和方法提供默认的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;default impl&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// use default impl for Trait::method
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// use our own impl for Trait::method
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OtherType impl&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;default impl&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">OtherType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;OtherType impl&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一些 trait 方法可以只用其他 trait 方法来实现，这就特别方便。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet_loudly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hello</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hola</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hello {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// use default impl for greet_loudly
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Hola</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hola {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// override default impl
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet_loudly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">greeting</span><span class="p">.</span><span class="n">insert_str</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;¡&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hello</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hello John&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hello</span><span class="p">.</span><span class="n">greet_loudly</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hello John!&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hola</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hola John&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hola</span><span class="p">.</span><span class="n">greet_loudly</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;¡Hola John!&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的许多 trait 为它们的许多方法提供了默认的实现。</p>
<h3 id="generic-blanket-impls">Generic Blanket Impls</h3>
<p>通用全面实现是在泛型类型而不是具体类型上的实现。为了解释为什么以及如何使用，让我们从为数字类型编写一个 <code>is_even</code> 方法开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">i8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">i8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">u8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">u8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">i16</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">i16</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// etc
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_is_even</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2_</span><span class="k">i8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4_</span><span class="k">u8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">6_</span><span class="k">i16</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>显然，这是很啰嗦的。而且，我们所有的实现几乎都是一样的。此外，如果 Rust 决定在未来添加更多的数字类型，我们必须记得回到这段代码，并用新的数字类型更新它。我们可以使用一个通用的全面实现来解决所有这些问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryInto</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Rem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// generic blanket impl
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">u8</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>::<span class="n">Error</span>: <span class="nc">Debug</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// these unwraps will never panic
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">2.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_is_even</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2_</span><span class="k">i8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4_</span><span class="k">u8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">6_</span><span class="k">i16</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Unlike default impls, which provide <em>an</em> impl, generic blanket impls provide <em>the</em> impl, so they are not overridable.
与默认实现不同，默认的实现提供了一个实现，而通用的全面实现提供了特定的实现，所以它们是不可覆盖的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryInto</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Rem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">u8</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>::<span class="n">Error</span>: <span class="nc">Debug</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">2.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">u8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">u8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这抛出:</p>
<pre><code class="language-none" data-lang="none">error[E0119]: conflicting implementations of trait `Even` for type `u8`:
  --&gt; src/lib.rs:22:1
   |
10 | / impl&lt;T&gt; Even for T
11 | | where
12 | |     T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
13 | |     u8: TryInto&lt;T&gt;,
...  |
19 | |     }
20 | | }
   | |_- first implementation here
21 | 
22 |   impl Even for u8 {
   |   ^^^^^^^^^^^^^^^^ conflicting implementation for `u8`
</code></pre><p>These impls overlap, hence they conflict, hence Rust rejects the code to ensure trait coherence. Trait coherence is the property that there exists at most one impl of a trait for any given type. The rules Rust uses to enforce trait coherence, the implications of those rules, and workarounds for the implications are outside the scope of this article.</p>
<p>这些实现重叠了，因此它们冲突，因此 Rust 拒绝了确保 trait 一致性的代码。Trait 一致性是指任何给定类型的 trait 最多存在一个实现的属性。Rust 用来强制执行 trait 一致性的规则，这些规则的含义，以及含义的变通方法都不在本文的范围内。</p>
<h3 id="subtraits--supertraits">Subtraits &amp; Supertraits</h3>
<p>&ldquo;subtrait&rdquo; 中的 &ldquo;sub&rdquo; 指的是子集，&ldquo;supertrait&rdquo; 中的 &ldquo;super&rdquo; 指的是超集。如果我们有一个这样的 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>All of the types which impl <code>Subtrait</code> are a subset of all the types which impl <code>Supertrait</code>, or to put it in opposite but equivalent terms: all the types which impl <code>Supertrait</code> are a superset of all the types which impl <code>Subtrait</code>.</p>
<p>Also, the above is just syntax sugar for:
所有实现 <code>Subtrait</code> 的类型都是所有实现 <code>Supertrait</code> 的类型的子集，或者用相反但等价的词语来表达：所有实现 <code>Supertrait</code> 的类型都是所有实现 <code>Subtrait</code> 的类型的超集。</p>
<p>另外，上面的代码只是下面这段代码的语法糖:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这是一个微妙而又重要的区别，要理解的是，约束是在 <code>Self</code> 上的，即实现 <code>Subtrait</code> 的类型，而不是在 <code>Subtrait</code> 本身。后者是没有任何意义的，因为 trait 约束只能应用于具体的类型，这些类型可以实现 trait。Trait 不能实现其他 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in supertrait&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// this looks like it might impl or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// override Supertrait::method but it
</span><span class="c1"></span><span class="w">    </span><span class="c1">// does not
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in subtrait&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// adds Supertrait::method to SomeType
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// adds Subtrait::method to SomeType
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// both methods exist on SomeType simultaneously
</span><span class="c1">// neither overriding or shadowing the other
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// ❌ ambiguous method call
</span><span class="c1"></span><span class="w">    </span><span class="c1">// must disambiguate using fully-qualified syntax
</span><span class="c1"></span><span class="w">    </span><span class="o">&lt;</span><span class="n">SomeType</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Supertrait</span><span class="o">&gt;</span>::<span class="n">method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅ prints &#34;in supertrait&#34;
</span><span class="c1"></span><span class="w">    </span><span class="o">&lt;</span><span class="n">SomeType</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Subtrait</span><span class="o">&gt;</span>::<span class="n">method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅ prints &#34;in subtrait&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Furthermore, there are no rules for how a type must impl both a subtrait and a supertrait. It can use the methods from either in the impl of the other.
此外，没有规定一个类型必须同时实现一个 subtrait 和一个 supertrait。它可以在另一个类型的实现中使用其中一个类型的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallSuperFromSub</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSuperFromSub</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSuperFromSub</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallSubFromSuper</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSubFromSuper</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSubFromSuper</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallEachOther</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallEachOther</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallEachOther</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CallSuperFromSub</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallSuperFromSub</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;, &#34;in super&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="n">CallSubFromSuper</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;, &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallSubFromSuper</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="n">CallEachOther</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;, &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallEachOther</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;, &#34;in super&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Hopefully the examples above show that the relationship between subtraits and supertraits can be complex. Before introducing a mental model that neatly encapsulates all of that complexity let&rsquo;s quickly review and establish the mental model we use for understanding trait bounds on generic types:
希望上面的例子能表明，subtrait 和 supertrait 之间的关系可能很复杂。在介绍一个能整齐地概括所有这些复杂性的心理模型之前，让我们快速回顾并建立我们用于理解泛型上的 trait 约束的心理模型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Without knowing anything about the impl of this function we could reasonably guess that <code>t.clone()</code> gets called at some point because when a generic type is bounded by a trait that strongly implies it has a dependency on the trait. The mental model for understanding the relationship between generic types and their trait bounds is a simple and intuitive one: generic types <em>depend on</em> their trait bounds.</p>
<p>Now let&rsquo;s look the trait declaration for <code>Copy</code>:
在不了解这个函数的实现的情况下，我们可以合理地猜测 <code>t.clone()</code> 在某些时候会被调用，因为当一个泛型被一个 trait 约束时，强烈地意味着它对 trait 有依赖性。理解泛型与其 trait 约束之间关系的心理模型是一个简单而直观的模型：泛型 “依赖” 其 trait 约束。</p>
<p>现在让我们看看 <code>Copy</code> 的 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{}</span><span class="w">
</span></code></pre></div><p>上面的语法看起来非常类似于在泛型类型上应用 trait 约束的语法，然而 <code>Copy</code> 根本不依赖于 <code>Clone</code>。我们前面开发的心理模型在这里并不能帮助我们。在我看来，理解 subtrait 和 supertrait 之间关系的最简单、最优雅的心理模型是：subtrait “精炼” 其 supertrait。</p>
<p>“精炼” 这个词故意保持有些模糊，因为它在不同的语境中可以有不同的含义。</p>
<ul>
<li>subtrait 可能会使它的 supertrait 的方法更加特化，速度更快，使用更少的内存，例如：<code>Copy: Clone</code></li>
<li>subtrait 可以对 supertrait 的方法的实现做出额外的保证，例如 <code>Eq: PartialEq</code>, <code>Ord: PartialOrd</code>, <code>ExactSizeIterator: Iterator</code></li>
<li>subtrait 可能使 supertrait 的方法更灵活或更容易调用，例如 <code>FnMut: FnOnce</code>, `Fn: FnMut</li>
<li>subtrait 可以扩展一个 supertrait，并添加新的方法，例如 <code>DoubleEndedIterator: Iterator</code>, <code>ExactSizeIterator: Iterator</code></li>
</ul>
<h3 id="trait-对象">Trait 对象</h3>
<p>泛型给了我们编译时的多态性，而 trait 对象给了我们运行时的多态性。我们可以使用 trait 对象来允许函数在运行时动态地返回不同的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">condition</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Has type:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// But is cast to:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Has type:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// But is cast to:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 对象还允许我们在集合中存储异构类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">f64</span>::<span class="n">consts</span>::<span class="n">PI</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Circle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">radius</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Square</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">side</span>: <span class="kt">f64</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Square</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">side</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">side</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_total_area</span><span class="p">(</span><span class="n">shapes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">shapes</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">area</span><span class="p">()).</span><span class="n">sum</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">shapes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span>: <span class="mf">1.0</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="c1">// Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Square</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">side</span>: <span class="mf">1.0</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="c1">// Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;
</span><span class="c1"></span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">PI</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">get_total_area</span><span class="p">(</span><span class="n">shapes</span><span class="p">));</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 对象是不确定大小的，所以它们必须总是在指针后面。我们可以根据类型中是否存在 <code>dyn</code> 关键字来区分具体类型和 trait 对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// regular struct
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">Struct</span><span class="w">
</span><span class="w"></span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// trait objects
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w">
</span><span class="w"></span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>并非所有的 trait 都可以转换为 trait 对象。如果一个 trait 满足这些要求，它就是对象安全的。</p>
<ul>
<li>trait 不需要 <code>Self: Sized</code>。</li>
<li>所有 trait 的方法都是对象安全的。</li>
</ul>
<p>如果 trait 方法满足这些要求，它就是对象安全的。</p>
<ul>
<li>方法需要 <code>Self: Sized</code> 或</li>
<li>该方法只在接收器位置使用 <code>Self</code> 类型。</li>
</ul>
<p>理解为什么要求是这样的，与本文其他部分无关，但如果你仍然好奇，在 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a> 中会有介绍。</p>
<h3 id="marker-traits">Marker Traits</h3>
<p>标记 trait 是没有 trait 项的 trait。它们的工作是将实现类型 “标记” 为具有某些属性，否则不可能用类型系统来表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Impling PartialEq for a type promises
</span><span class="c1">// that equality for the type has these properties:
</span><span class="c1">// - symmetry: a == b implies b == a, and
</span><span class="c1">// - transitivity: a == b &amp;&amp; b == c implies a == c
</span><span class="c1">// But DOES NOT promise this property:
</span><span class="c1">// - reflexivity: a == a
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Eq has no trait items! The eq method is already
</span><span class="c1">// declared by PartialEq, but &#34;impling&#34; Eq
</span><span class="c1">// for a type promises this additional equality property:
</span><span class="c1">// - reflexivity: a == a
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">Eq</span>: <span class="nb">PartialEq</span> <span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// f64 impls PartialEq but not Eq because NaN != NaN
</span><span class="c1">// i32 impls PartialEq &amp; Eq because there&#39;s no NaNs :)
</span></code></pre></div><h3 id="auto-traits">Auto Traits</h3>
<p>自动 trait 是指如果一个类型的所有成员都实现了这个 trait，那么这个 trait 就会被自动实现。“成员” 的含义取决于类型，例如：结构体的字段、枚举的变体、数组的元素、元组的项等等。</p>
<p>所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait。自动 trait 必须是标记 trait，这样编译器就可以为它们提供一个自动的缺省实现，如果它们有任何 trait 项，那就不可能了。</p>
<p>自动 trait 的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// implemented for types which are safe to send between threads
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// implemented for types whose references are safe to send between threads
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="unsafe-traits">Unsafe Traits</h3>
<p>Trait 可以被标记为不安全，以表明实现该 trait 可能需要不安全的代码。<code>Send</code> 和 <code>Sync</code> 都被标记为 <code>unsafe</code>，因为如果它们没有被自动实现，就意味着它一定包含一些非 <code>Send</code> 或非 <code>Sync</code> 成员，如果我们想手动标记类型为 <code>Send</code> 和 <code>Sync</code>，我们作为实现者必须格外小心，以确保没有数据竞争。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// SomeType is not Send or Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">not_send_or_sync</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// but if we&#39;re confident that our impl doesn&#39;t have any data
</span><span class="c1">// races we can explicitly mark it as Send and Sync using unsafe
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h2 id="auto-traits-1">Auto Traits</h2>
<h3 id="send--sync">Send &amp; Sync</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
<li><a href="#unsafe-traits">Unsafe Traits</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>如果一个类型是 <code>Send</code>，意味着在线程之间发送是安全的。如果一个类型是 <code>Sync</code>，这意味着在线程之间共享它的引用是安全的。更准确地说，如果且仅当 <code>&amp;T</code> 是 <code>Send</code> 时，一些类型 <code>T</code> 是 <code>Sync</code>。</p>
<p>几乎所有类型都是 <code>Send</code> 和 <code>Sync</code> 的。唯一值得注意的 <code>Send</code> 异常是 <code>Rc</code>，唯一值得注意的 <code>Sync</code> 异常是 <code>Rc</code>、<code>Cell</code> 和 <code>RefCell</code>。如果我们需要一个 <code>Rc</code> 的 <code>Send</code> 版本，我们可以使用 <code>Arc</code>。如果我们需要 <code>Cell</code> 或 <code>RefCell</code> 的 <code>Sync</code> 版本，我们可以 <code>Mutex</code> 或 <code>RwLock</code>。虽然如果我们使用 <code>Mutex</code> 或 <code>RwLock</code> 只是包裹一个原语类型，通常最好使用标准库提供的原子原语类型，如 <code>AtomicBool</code>、<code>AtomicI32</code>、<code>AtomicUsize</code> 等。</p>
<p>几乎所有的类型都是 <code>Sync</code>，这可能会让一些人感到惊讶，但是是的，即使对于没有任何内部同步的类型也是如此。这要归功于 Rust 严格的借用规则。</p>
<p>我们可以将同一数据的许多不可变的引用传递给许多线程，而且我们保证不会出现数据竞争，因为只要有任何不可变的引用存在， Rust 就会静态地保证底层数据不能被修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">greeting</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">scoped_thread</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// spawn 3 threads
</span><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="o">=</span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// greeting_ref copied into every thread
</span><span class="c1"></span><span class="w">            </span><span class="n">scoped_thread</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting_ref</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello {n}&#34;
</span><span class="c1"></span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="c1">// line below could cause UB or data races but compiler rejects it
</span><span class="c1"></span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ cannot mutate greeting while immutable refs exist
</span><span class="c1"></span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// can mutate greeting after every thread has joined
</span><span class="c1"></span><span class="w">    </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>同样，我们可以将单个可变引用传递给一些数据到一个线程，我们可以保证不会出现数据竞争，因为 Rust 静态地保证了别名的可变引用不能存在，底层数据不能通过现有的单个可变引用以外的任何东西进行修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">scoped_thread</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// greeting_ref moved into thread
</span><span class="c1"></span><span class="w">        </span><span class="n">scoped_thread</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">*</span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting_ref</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world&#34;
</span><span class="c1"></span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="c1">// line below could cause UB or data races but compiler rejects it
</span><span class="c1"></span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!!!&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ cannot mutate greeting while mutable refs exist
</span><span class="c1"></span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// can mutate greeting after the thread has joined
</span><span class="c1"></span><span class="w">    </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!!!&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world!!!&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这就是为什么大多数类型都是 <code>Sync</code> 而不需要任何显式同步。如果我们需要在多个线程中同时修改一些数据 <code>T</code>，编译器不会让我们这样做，直到我们将数据包裹在 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> 中，所以编译器强制要求在需要时使用显式同步。</p>
<h3 id="sized">Sized</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
</ul>
<p>如果一个类型是 <code>Sized</code> 的，这意味着它的字节大小在编译时是已知的，并且可以将该类型的实例放在栈上。</p>
<p>类型的大小和它的含义是一个微妙而又巨大的话题，它影响到语言的很多不同方面。它是如此重要，以至于我写了整整一篇文章，叫做 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a>，我强烈推荐任何想深入了解类型大小的人阅读。我总结一下与本文相关的几个关键内容。</p>
<ol>
<li>所有的泛型类型都会得到一个隐式的 <code>Sized</code> 约束。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example above desugared
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><ol start="2">
<li>由于所有泛型类型都有一个隐式的 <code>Sized</code> 约束，如果我们想退出这个隐式约束，我们需要使用特殊的 &ldquo;放宽约束&rdquo; 语法 <code>?Sized</code>，它目前只存在于 <code>Sized</code> trait。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// now T can be unsized
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><ol start="3">
<li>所有的 trait 都有一个隐式的 <code>?Sized</code> 约束。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example above desugared
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这是为了让 trait 对象可以实现 trait。同样，所有的琐碎细节都在 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a> 中。</p>
<h2 id="general-traits">General traits</h2>
<h3 id="default">Default</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以构建 <code>Default</code> 类型的默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// default color is black
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">g</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">b</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这对快速建立原型很有用，但在任何情况下，我们只需要一个类型的实例，而且对它是什么并不挑剔。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// just give me some color!
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这也是一个我们可能想明确地暴露给我们的函数用户的选项。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Canvas</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Circle</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Rectangle</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Canvas</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// let user optionally pass a color
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">paint</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span>: <span class="nc">Shape</span><span class="p">,</span><span class="w"> </span><span class="n">color</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// if no color is passed use the default color
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">.</span><span class="n">unwrap_or_default</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// etc
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Default</code> 在我们需要构造泛型类型的泛型语境中也很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">guarantee_length</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">min_len</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">min_len</span><span class="p">.</span><span class="n">saturating_sub</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">T</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以利用 <code>Default</code> 类型的另一种方式是使用 Rust 的结构体更新语法对结构体进行部分初始化。我们可以为 <code>Color</code> 设置一个 <code>new</code> 构造函数，将每个成员作为一个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，我们也可以使用方便的构造函数，每个构造函数只接受一个特定的结构体成员，其他结构体成员则使用默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">red</span><span class="p">(</span><span class="n">r</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">green</span><span class="p">(</span><span class="n">g</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">blue</span><span class="p">(</span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>还有一个 <code>Default</code> 的派生宏，所以我们可以像这样编写 <code>Color</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// default color is still black
</span><span class="c1">// because u8::default() == 0
</span><span class="c1"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="kt">u8</span>
<span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="clone">Clone</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">source</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以将 <code>Clone</code> 类型的不可变引用转换为自有值(owned values)，即 <code>&amp;T</code> -&gt; <code>T</code>。<code>Clone</code> 没有对这种转换的效率做出承诺，所以它可能是缓慢和昂贵的。为了快速地在一个类型上实现 <code>Clone</code>，我们可以使用派生宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">cloneable_member1</span>: <span class="nc">CloneableType1</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cloneable_member2</span>: <span class="nc">CloneableType2</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// macro generates impl below
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">cloneable_member1</span>: <span class="nc">self</span><span class="p">.</span><span class="n">cloneable_member1</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">cloneable_member2</span>: <span class="nc">self</span><span class="p">.</span><span class="n">cloneable_member2</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="c1">// etc
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Clone</code> 也可以在泛型上下文中构建一个类型的实例。下面是上一节中的一个例子，除了使用 <code>Clone</code> 而不是 <code>Default</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">guarantee_length</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">min_len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">fill_with</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">min_len</span><span class="p">.</span><span class="n">saturating_sub</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fill_with</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>人们也经常使用克隆作为逃避的方法，以避免与借用检查器打交道。管理带有引用的结构体可能很有挑战性，但我们可以通过克隆将引用变成自有值(owned values)。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// oof, we gotta worry about lifetimes 😟
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeStruct</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now we&#39;re on easy street 😎
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeStruct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们正在开发的程序的性能不是最重要的，那么我们就不需要为克隆数据而烦恼。Rust 是一种低级别的语言，暴露了很多低级别的细节，所以很容易被过早的优化所吸引，而不是真正解决手头的问题。对于许多程序来说，最好的优先顺序通常是首先建立正确性，其次是优雅性，第三是性能，只有在对程序进行剖析并确定了性能瓶颈之后才关注性能。这是很好的一般性建议，如果它不适用于你的特定程序，你就会知道。</p>
<h3 id="copy">Copy</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{}</span><span class="w">
</span></code></pre></div><p>我们复制 <code>Copy</code> 类型，例如：<code>T</code> -&gt; <code>T</code>。<code>Copy</code> 承诺复制操作将是一个简单的按位(bitwise)拷贝，所以它将是非常快速和高效的。我们不能自己实现 <code>Copy</code>，只有编译器可以提供一个实现，但是我们可以通过使用 <code>Copy</code> 派生宏，以及 <code>Clone</code> 派生宏来告诉编译器这样做，因为 <code>Copy</code> 是 <code>Clone</code> 的一个子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span></code></pre></div><p><code>Copy</code> 完善了(refine) <code>Clone</code>。<code>Clone</code> 可能是缓慢和昂贵的，但 <code>Copy</code> 保证是快速和便宜的，所以 <code>Copy</code> 只是一个快速 <code>Clone</code>。如果一个类型实现了 <code>Copy</code>，这就使得 <code>Clone</code> 的实现变得微不足道了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this is what the derive macro generates
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Copy</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// the clone method becomes just a copy
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当一个类型被移动时，实现该类型的 <code>Copy</code> 会改变其行为。默认情况下，所有类型都有“移动语义”，但是一旦一个类型实现了 `Copy'，它就会得到“复制语义”。为了解释这两者之间的区别，我们来看看这些简单的场景。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// a &#34;move&#34;, src: !Copy
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span><span class="w"> 
</span><span class="w">
</span><span class="w"></span><span class="c1">// a &#34;copy&#34;, src: Copy
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>在这两种情况下，<code>dest = src</code> 对 <code>src</code> 的内容进行简单的按位复制，并将结果移动到 <code>dest</code> 中，唯一的区别是，在“移动”的情况下，借用检查器使 <code>src</code> 变量无效，并确保它以后不会被用于其他地方，而在“复制”的情况下，<code>src</code> 仍然有效并可使用。</p>
<p>一言以蔽之。拷贝就“是”移动。移动就“是”拷贝。唯一的区别是借用检查器对它们的处理方式。</p>
<p>关于移动的一个更具体的例子，假设 <code>src</code> 是一个 <code>Vec&lt;i32&gt;</code>，其内容是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>当我们写下 <code>dest = src</code> 时，我们的结果是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>这个时候，<code>src</code> 和 <code>dest</code> 都有对相同数据的别名可变引用，这是一个大忌，所以借用检查器使 <code>src</code> 变量无效，这样它就不能再被使用而不会产生编译错误。</p>
<p>对于一个更具体的拷贝例子，假设 <code>src</code> 是一个 <code>Option&lt;i32&gt;</code>，它的内容是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>现在，当我们写下 <code>dest = src</code> 时，我们的结果是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>这些都是可以同时使用的! 因此 <code>Option&lt;i32&gt;</code> 是可以 <code>Copy</code> 的。</p>
<p>虽然 <code>Copy</code> 可以是一个自动 trait，但 Rust 语言的设计者决定让类型显式地选择复制语义，而不是在类型符合条件时默默地继承复制语义，因为后者会导致令人惊讶的混乱行为，经常导致错误。</p>
<h3 id="any">Any</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Any</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">type_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TypeId</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Rust 的多态性风格是参数化的，但如果我们想使用类似于动态类型语言的多态性风格，那么我们可以使用 <code>Any</code> trait 来模仿。我们不需要为我们的类型手动实现这个 trait，因为下面这个泛型全面实现已经覆盖了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Any</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">type_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TypeId</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">TypeId</span>::<span class="n">of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们从 <code>dyn Any</code> 中得到 <code>T</code> 的方法是通过使用 <code>downcast_ref::&lt;T&gt;()</code> 和 <code>downcast_mut::&lt;T&gt;()</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">any</span>::<span class="n">Any</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">map_any</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">any</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">point</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">any</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Point</span>::<span class="n">default</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">map_any</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 trait 很少需要使用，因为在大多数情况下，参数化多态性要优于临时多态性，后者也可以用枚举来模拟，因为枚举的类型更安全，需要的迂回更少。例如，我们可以把上面的例子写成这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Integer</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="n">Point</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">map_stuff</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">stuff</span>: <span class="nc">Stuff</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Integer</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="nb">String</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">inc</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">stuff</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="nb">String</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Point</span><span class="p">(</span><span class="n">Point</span>::<span class="n">default</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">map_stuff</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>尽管 <code>Any</code> 很少被需要，但有时使用起来还是很方便的，我们将在后面的“错误处理”部分看到。</p>
<h2 id="formatting-traits">Formatting Traits</h2>
<p>我们可以使用 <code>std::fmt</code> 中的格式化宏将类型序列化为字符串，其中最著名的是 <code>println!</code>。我们可以将格式化参数传递给格式 <code>str</code> 中使用的 <code>{}</code> 占位符，然后用来选择使用哪个 trait 实现来序列化占位符的参数。</p>
<table>
<thead>
<tr>
<th>Trait</th>
<th>Placeholder</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Display</code></td>
<td><code>{}</code></td>
<td>display representation</td>
</tr>
<tr>
<td><code>Debug</code></td>
<td><code>{:?}</code></td>
<td>debug representation</td>
</tr>
<tr>
<td><code>Octal</code></td>
<td><code>{:o}</code></td>
<td>octal representation</td>
</tr>
<tr>
<td><code>LowerHex</code></td>
<td><code>{:x}</code></td>
<td>lowercase hex representation</td>
</tr>
<tr>
<td><code>UpperHex</code></td>
<td><code>{:X}</code></td>
<td>uppercase hex representation</td>
</tr>
<tr>
<td><code>Pointer</code></td>
<td><code>{:p}</code></td>
<td>memory address</td>
</tr>
<tr>
<td><code>Binary</code></td>
<td><code>{:b}</code></td>
<td>binary representation</td>
</tr>
<tr>
<td><code>LowerExp</code></td>
<td><code>{:e}</code></td>
<td>lowercase exponential representation</td>
</tr>
<tr>
<td><code>UpperExp</code></td>
<td><code>{:E}</code></td>
<td>uppercase exponential representation</td>
</tr>
</tbody>
</table>
<h3 id="display--tostring">Display &amp; ToString</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Display</code> 类型可以被序列化为 <code>String</code>，这对程序的终端用户很友好。例如，给 <code>Point</code> 实现 <code>Display</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;({}, {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;origin: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// prints &#34;origin: (0, 0)&#34;
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// get Point&#39;s Display representation as a String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stringified_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;(0, 0)&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">stringified_point</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>除了使用 <code>format!</code> 宏来获得一个类型的显示表示为 <code>String</code> 之外，我们还可以使用 <code>ToString</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们没有必要自己去实现这个 trait。事实上，我们不能这样做，因为下面这个泛型全面实现，对于任何实现 <code>Display</code> 的类型，都自动实现 <code>ToString</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>将 <code>ToString</code> 与 <code>Point</code> 一起使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">display_point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;(0, 0)&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">point_to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;(0, 0)&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">display_equals_to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="p">),</span><span class="w"> </span><span class="n">origin</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="debug">Debug</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Debug</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Debug</code> 与 <code>Display</code> 有相同的签名。唯一的区别是，当我们使用 <code>{:?}</code> 格式符时，<code>Debug</code> 实现被调用。`Debug' 可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// derive macro generates impl below
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">f</span><span class="p">.</span><span class="n">debug_struct</span><span class="p">(</span><span class="s">&#34;Point&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#34;x&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#34;y&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">finish</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为一个类型实现 <code>Debug</code> 也允许它在 <code>dbg!</code> 宏中使用，这比 <code>println!</code> 更有利于临时应急的打印日志。它的一些优点如下:</p>
<ol>
<li><code>dbg!</code> 打印到 stderr 而不是 stdout，所以调试日志很容易与我们程序的实际 stdout 输出分开。</li>
<li><code>dbg!</code> 打印传递给它的表达式，以及表达式所评估的值。</li>
<li><code>dbg!</code> 拥有其参数的所有权，并返回这些参数，所以你可以在表达式中使用它。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">some_condition</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kc">true</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// no logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">some_condition</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// println! logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_println</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 🤦
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_condition</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"> </span><span class="c1">// just prints &#34;true&#34;
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// dbg! logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_dbg</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 😍
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">some_condition</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// prints &#34;[src/main.rs:22] some_condition() = true&#34;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>唯一的缺点是，<code>dbg!</code> 在发布版本中不会被自动剥离，所以如果我们不想在最终的可执行文件中使用它，就必须从我们的代码中手动删除它。</p>
<h2 id="operator-traits">Operator Traits</h2>
<p>Rust 中的所有运算符都与 trait 相关。如果我们想为我们的类型实现运算符，就必须实现相关的 trait。</p>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>
<h3 id="comparison-traits">Comparison Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
</tbody>
</table>
<h4 id="partialeq--eq">PartialEq &amp; Eq</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Rhs</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialEq&lt;Rhs&gt;</code> 类型可以使用 <code>==</code> 运算符检查是否与 <code>Rhs</code> 类型相等。</p>
<p>所有的 <code>PartialEq&lt;Rhs&gt;</code> 实现必须确保相等是对称的和传递的。这意味着对于所有的 <code>a</code>, <code>b</code>, 和 <code>c</code>:</p>
<ul>
<li><code>a == b</code> 意味着 <code>b == a</code> (对称性)</li>
<li><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code> (传递性)</li>
</ul>
<p>默认情况下 <code>Rhs = Self</code>，因为我们几乎总是想把一个类型的实例相互比较，而不是与不同类型的实例比较。这也自动保证了我们的实现是对称的和传递的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Rhs == Self == Point
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl automatically symmetric &amp; transitive
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型的所有成员都实现了 `PartialEq'，那么它可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Heart</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Club</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Diamond</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一旦为我们的类型实现了 <code>PartialEq</code>，我们也可以免费得到我们类型的引用之间的相等性比较，这要感谢这些泛型全面实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this impl only gives us: Point == Point
</span><span class="c1"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// all of the generic blanket impls below
</span><span class="c1">// are provided by the standard library
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;Point == &amp;Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;mut Point == &amp;Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;Point == &amp;mut Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;mut Point == &amp;mut Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>由于这个 trait 是泛型化的，我们可以定义不同类型之间的相等性。标准库利用这一点，允许检查许多类似字符串的类型，如<code>String</code>、<code>&amp;str</code>、<code>PathBuf</code>、<code>&amp;Path</code>、<code>OsString</code>、<code>&amp;OsStr</code> 等之间的相等性。</p>
<p>一般来说，我们只应该在不同类型之间实现相等性关系，如果它们实现同一种数据，并且类型之间的唯一区别是它们如何表示数据或如何允许与数据进行交互。</p>
<p>这里有一个可爱但糟糕的例子，说明有人可能会被诱惑实现 <code>PartialEq</code> 来检查不符合上述标准的不同类型之间的相等。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Club</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Heart</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Diamond</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Rank</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Two</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Three</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Four</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Five</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Six</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Seven</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Eight</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Nine</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Ten</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Jack</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Queen</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">King</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">suit</span>: <span class="nc">Suit</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">rank</span>: <span class="nc">Rank</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s suit
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Suit</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Suit</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s rank
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rank</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rank</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Suit</span>::<span class="n">Spade</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Rank</span>::<span class="n">Ace</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这很有效，而且有点道理。一张黑桃A的牌既是A又是黑桃，如果我们要写一个处理扑克牌的库，那么我们想让它简单方便地单独检查一张牌的花色和等级是合理的。然而，我们还缺少一些东西：对称性。 我们可以 <code>Card == Suit</code> 和 <code>Card == Rank</code>，但我们不能 <code>Suit == Card</code> 或 <code>Rank == Card</code>，所以让我们解决这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// check equality of Card&#39;s suit
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Suit</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Suit</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// added for symmetry
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Card</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">suit</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s rank
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rank</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rank</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// added for symmetry
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Rank</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Card</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">rank</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们有对称性! 太好了。增加对称性只是打破了传递性！这是不可能的。哎呀。现在可以这样了：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Ace of Spades
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Suit</span>::<span class="n">Spade</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">// King of Spades
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">King</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>实现 <code>PartialEq</code> 以检查不同类型之间的相等关系的一个好例子是一个处理距离的程序，它使用不同的类型来代表不同的测量单位。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foot</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Yard</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Mile</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Mile</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Mile</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5280</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Foot</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mile</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Foot</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5280</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Mile</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Yard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Mile</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1760</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Yard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mile</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Yard</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1760</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Foot</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Yard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Foot</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Yard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Yard</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foot</span><span class="p">(</span><span class="mi">5280</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Yard</span><span class="p">(</span><span class="mi">1760</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mile</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// symmetry
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// transitivity
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Eq</code> 是一个标记 trait，是 <code>PartialEq&lt;Self&gt;</code> 的子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Eq</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>如果我们为一个类型实现 <code>Eq</code>，在 <code>PartialEq</code> 所要求的对称性和传递性的基础上，我们还保证了自反性，即 对所有 <code>a</code>, <code>a == a</code>。在这个意义上，<code>Eq</code> 完善了 <code>PartialEq</code>，因为它代表了一个更严格的相等性版本。如果一个类型的所有成员都是<code>Eq</code> 的，那么 <code>Eq</code> 实现就可以为该类型派生。</p>
<p>浮点类型是 <code>PartialEq</code> 的，但不是 <code>Eq</code> 的，因为 <code>NaN != NaN</code>。几乎所有其他的 <code>PartialEq</code> 类型都是 <code>Eq</code>，当然，除非它们包含浮点。</p>
<p>一旦一个类型实现了 <code>PartialEq</code> 和 <code>Debug</code>，我们就可以在 <code>assert_eq!</code> 宏中使用它。我们也可以比较 <code>PartialEq</code> 类型的集合。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq, Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_assert</span><span class="p">(</span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_compare_collections</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialEq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vec1</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// if T: PartialEq this now works!
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// other code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="hash">Hash</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash_slice</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Self</span><span class="p">],</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 trait 与任何运算符无关，但谈论它的最好时机是在 <code>PartialEq</code> &amp; <code>Eq</code> 之后，所以它在这里。<code>Hash</code> 类型可以使用 <code>Hasher</code> 进行散列。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hash</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">hasher</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">hasher</span><span class="p">.</span><span class="n">write_i32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">hasher</span><span class="p">.</span><span class="n">write_i32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>有一个派生宏，它生成的实现与上述相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Hash)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型同时实现了 <code>Hash</code> 和 <code>Eq</code>，这些实现必须相互一致，即对于所有的 <code>a</code> 和 <code>b</code>，如果 <code>a == b</code>，那么 <code>a.hash() == b.hash()</code>。所以我们应该总是使用派生宏来实现两者，或者手动实现两者，但不能混合使用，否则就有可能破坏上述不变性。</p>
<p>为一个类型实现 <code>Eq</code> 和 <code>Hash</code> 的主要好处是，它允许我们将该类型作为键存储在 <code>HashMap</code> 和 <code>HashSet</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashSet</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now our type can be stored
</span><span class="c1">// in HashSets and HashMaps!
</span><span class="c1"></span><span class="cp">#[derive(PartialEq, Eq, Hash)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_hashset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">points</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="partialord--ord">PartialOrd &amp; Ord</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Less</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Equal</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Greater</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Rhs</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">lt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">le</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">gt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ge</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd&lt;Rhs&gt;</code> 类型可以使用 <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, 和 <code>&gt;=</code> 运算符与 <code>Rhs</code> 类型进行比较。</p>
<p>所有的 <code>PartialOrd</code> 实现必须确保比较是不对称的和传递的。这意味着对于所有的 <code>a</code>, <code>b</code>, 和 <code>c</code>:</p>
<ul>
<li><code>a &lt; b</code> 意味着 <code>!(a &gt; b)</code> (不对称性)</li>
<li><code>a &lt; b &amp;&amp; b &lt; c</code> 意味着 <code>a &lt; c</code> (传递性)</li>
</ul>
<p><code>PartialOrd</code> 是 <code>PartialEq</code> 的一个子 trait，它们的实现必须总是相互一致。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">must_always_agree</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="p">),</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd</code> 是对 <code>PartialEq</code> 的细化，当比较 <code>PartialEq</code> 类型时，我们可以检查它们是否相等，但当比较 <code>PartialOrd</code> 类型时，我们可以检查它们是否相等，如果它们不相等，我们可以检查它们是否不相等，因为第一项小于或大于第二项。</p>
<p>默认情况下 <code>Rhs = Self</code>，因为我们几乎总是想把一个类型的实例相互比较，而不是和不同类型的实例比较。这也自动保证了我们的实现是对称的和传递的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Rhs == Self == Point
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl automatically symmetric &amp; transitive
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">ordering</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型的所有成员都实现了 <code>PartialOrd</code>，那么它可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Stoplight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Red</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Yellow</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Green</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd</code> 派生宏基于其成员的字母顺序对类型进行排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// generates PartialOrd impl which orders
</span><span class="c1">// Points based on x member first and
</span><span class="c1">// y member second because that&#39;s the order
</span><span class="c1">// they appear in the source code
</span><span class="c1"></span><span class="cp">#[derive(PartialOrd, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// generates DIFFERENT PartialOrd impl
</span><span class="c1">// which orders Points based on y member
</span><span class="c1">// first and x member second
</span><span class="c1"></span><span class="cp">#[derive(PartialOrd, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Ord</code> is a subtrait of <code>Eq</code> and <code>PartialOrd&lt;Self&gt;</code>:
<code>Ord</code> 是 <code>Eq</code> 和 <code>PartialOrd&lt;Self&gt;</code> 的子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Ord</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">min</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">max</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们为一个类型实现 <code>Ord</code>，在 <code>PartialOrd</code> 所要求的不对称性和传递性的基础上，我们还保证不对称性是完全的，即对于任何给定的 <code>a</code> 和 <code>b</code>，<code>a == b</code> 或 <code>a &gt; b</code> 中只有一个是真的。在这个意义上，<code>Ord</code> 完善了 <code>Eq</code> 和 <code>PartialOrd</code>，因为它代表了一个更严格的比较版本。如果一个类型实现了 <code>Ord</code>，我们就可以用这个实现来实现 <code>PartialOrd</code>、<code>PartialEq</code> 和 <code>Eq</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// of course we can use the derive macros here
</span><span class="c1"></span><span class="cp">#[derive(Ord, PartialOrd, Eq, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// note: as with PartialOrd, the Ord derive macro
</span><span class="c1">// orders a type based on the lexicographical order
</span><span class="c1">// of its members
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// but here&#39;s the impls if we wrote them out by hand
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">ordering</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>浮点数实现了 <code>PartialOrd</code>，但不是 <code>Ord</code>，因为 <code>NaN &lt; 0 == false</code> 和 <code>NaN &gt;= 0 == false</code> 同时为真。几乎所有其他的 <code>PartialOrd</code> 类型都是 <code>Ord</code>，当然，除非它们包含浮点数。</p>
<p>一旦一个类型被认为是 <code>Ord</code> 的，我们就可以将其存储在 <code>BTreeMap</code> 和 <code>BTreeSet</code> 中，并且可以使用 <code>sort()</code> 方法对其进行排序，以及对数组、<code>Vec</code> 和 <code>VecDeque</code> 等任何类型的切片进行解引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">BTreeSet</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now our type can be stored
</span><span class="c1">// in BTreeSets and BTreeMaps!
</span><span class="c1"></span><span class="cp">#[derive(Ord, PartialOrd, PartialEq, Eq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_btreeset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">points</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// we can also .sort() Ord types in collections!
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_sort</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">sortable</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">sortable</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortable</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="arithmetic-traits">Arithmetic Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
</tbody>
</table>
<p>仔细研究所有这些将是非常多余的。反正大多数只适用于数字类型。我们只讨论 <code>Add</code> 和 <code>AddAssign</code>，因为 <code>+</code> 操作符通常被重载来做其他事情，如向集合添加项目或将事物串联起来，这样我们就能覆盖最有趣的地方，而不会重复。</p>
<h4 id="add--addassign">Add &amp; AddAssign</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Add&lt;Rhs, Output = T&gt;</code> 类型可以和 <code>Rhs</code> 类型相加，并将产生 <code>T</code> 作为输出。</p>
<p>例子 <code>Add&lt;Point, Output = Point&gt;</code> 是针对 <code>Point</code> 实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone, Copy)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是如果我们只有对 <code>Point</code> 的引用呢？那我们还能让它们相加吗？让我们试试。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不幸的是没有。编译器会抛出异常：</p>
<pre><code class="language-none" data-lang="none">error[E0369]: cannot add `&amp;Point` to `&amp;Point`
  --&gt; src/main.rs:50:25
   |
50 |     let p3: Point = &amp;p1 + &amp;p2;
   |                     --- ^ --- &amp;Point
   |                     |
   |                     &amp;Point
   |
   = note: an implementation of `std::ops::Add` might be missing for `&amp;Point`
</code></pre><p>在 Rust 的类型系统中，对于某些类型 <code>T</code> 来说，<code>T</code>、<code>&amp;T</code> 和 <code>&amp;mut T</code> 都被视为唯一的不同类型，这意味着我们必须为它们分别提供 trait 实现。让我们为 <code>&amp;Point</code> 定义一个 <code>Add</code> 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，有些事情还是感觉不大对劲。我们有两个独立的 <code>Add</code> 实现，分别用于 <code>Point</code> 和 <code>&amp;Point</code>，它们目前做的是同样的事情，但不能保证将来也会这样做。例如，我们决定当我们把两个 <code>Point</code> 相加时，我们想创建一个包含这两个 <code>Point</code> 的 <code>Line</code>，而不是创建一个新的 <code>Point</code>，我们会像这样更新我们的 <code>Add</code> 程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">start</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">end</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// we updated this impl
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Line</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">start</span>: <span class="nc">self</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">end</span>: <span class="nc">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// but forgot to update this impl, uh oh!
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ expected Line, found Point
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们目前对 <code>&amp;Point</code> 的 <code>Add</code> 实现造成了不必要的维护负担，我们希望这个实现与 <code>Point</code> 的实现相匹配，而不必在每次改变 <code>Point</code> 的实现时都要手动更新。我们希望尽可能地保持我们的代码是 DRY（Don&rsquo;t Repeat Yourself）。幸运的是这是可以实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// updated, DRY impl
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Add</span><span class="o">&gt;</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span>::<span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rhs</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>AddAssign&lt;Rhs&gt;</code> 类型允许我们相加并分配 <code>Rhs</code> 类型给它们。Trait 声明如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为 <code>Point</code> 和 <code>&amp;Point</code> 类型的实现的例子如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">AddAssign</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;&amp;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span>::<span class="n">add_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rhs</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="闭包-traits">闭包 Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
</tbody>
</table>
<h4 id="fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然这些 trait 存在，但在稳定的 Rust 中，我们不可能为自己的类型实现这些特性。我们唯一能创建的实现这些 trait 的类型是闭包。根据闭包从其环境中捕获的内容，决定了它是实现了 <code>FnOnce</code>、<code>FnMut</code> 还是 <code>Fn</code>。</p>
<p><code>FnOnce</code> 闭包只能被调用一次，因为它在执行中会消耗一些值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">get_range_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">range</span><span class="p">.</span><span class="n">count</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">get_range_count</span><span class="p">(),</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">get_range_count</span><span class="p">();</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>迭代器上的 <code>.count()</code> 方法会消耗迭代器，所以它只能被调用一次。因此，我们的闭包只能被调用一次。这就是为什么当我们试图第二次调用它时，会出现这个错误。</p>
<pre><code class="language-none" data-lang="none">error[E0382]: use of moved value: `get_range_count`
 --&gt; src/main.rs:5:5
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ----------------- `get_range_count` moved due to this call
5 |     get_range_count();
  |     ^^^^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `range` out of its environment
 --&gt; src/main.rs:3:30
  |
3 |     let get_range_count = || range.count();
  |                              ^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; src/main.rs:4:16
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ^^^^^^^^^^^^^^^
</code></pre><p><code>FnMut</code> 闭包可以被多次调用，也可以改变它从环境中捕获的变量。我们可以说 <code>FnMut</code> 闭包是执行副作用的，或者说是有状态的。下面是一个闭包的例子，它通过跟踪到目前为止看到的最小值，从迭代器中过滤出所有非升序的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">MIN</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ascending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kc">false</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="kc">true</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">],</span><span class="w"> </span><span class="n">ascending</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FnMut</code> 完善了 <code>FnOnce</code>，即 <code>FnOnce</code> 需要取得其参数的所有权，只能调用一次，但 <code>FnMut</code> 只需要取得可变的引用，可以多次调用。<code>FnMut</code> 可以在任何可以使用 <code>FnOnce</code> 的地方使用。</p>
<p><code>Fn</code> 闭包可以被多次调用，并且不改变它从环境中捕获的任何变量。我们可以说 <code>Fn</code> 闭包没有副作用或无状态。下面是一个闭包的例子，它过滤掉了所有小于它从环境中捕获的迭代器中的某个栈变量的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greater_than_9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">min</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">],</span><span class="w"> </span><span class="n">greater_than_9</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Fn</code> 细化了 <code>FnMut</code>，即 <code>FnMut</code> 需要可变的引用并可多次调用，但 <code>Fn</code> 只需要不可变的引用并可多次调用。<code>Fn</code> 可以用在任何可以使用 <code>FnMut</code> 的地方，包括可以使用 <code>FnOnce</code> 的地方。</p>
<p>如果一个闭包没有从它的环境中捕获任何东西，那么从技术上讲，它不是一个闭包，而只是一个匿名声明的内联函数，并且可以作为一个普通的函数指针被转换、使用和传递，也就是 <code>fn</code>。函数指针可以在任何可以使用 <code>Fn</code> 的地方使用，这包括可以使用 <code>FnMut</code> 和 <code>FnOnce </code>的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fn_ptr</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">add_one</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">fn_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// capture-less closure cast to fn pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">fn_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// same as add_one
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">fn_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>传递普通函数指针以代替闭包的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">absolutes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="kt">i32</span>::<span class="n">abs</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">absolutes</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="其他-trait">其他 Trait</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>
<h4 id="deref--derefmut">Deref &amp; DerefMut</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">DerefMut</span>: <span class="nc">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以使用解引用操作符 <code>*</code> 把实现了 <code>Deref&lt;Target = T&gt;</code> trait 的类型解引用为  <code>T</code> 类型。这对于智能指针类型（如 <code>Box</code> 和 <code>Rc</code>）有明显的用途。然而，我们很少看到在 Rust 代码中显式地使用解引用操作符，这是因为 Rust 的一个叫做 “强制解引用”(<em>deref coercion</em>)的特性。</p>
<p>当类型作为函数参数传递、从函数返回或作为方法调用的一部分使用时，Rust 会自动地对类型进行解引用。这就是为什么我们可以将 <code>&amp;String</code> 和 <code>&amp;Vec&lt;T&gt;</code> 传递给期望 <code>&amp;str</code> 和 <code>&amp;[T]</code> 的函数的原因，因为 <code>String</code> 实现了 <code>Deref&lt;Target = str&gt;</code>, <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target = [T]&gt;</code>。</p>
<p><code>Deref</code> 和 <code>DerefMut</code> 只应为智能指针类型而实现。人们试图误用和滥用这些 trait 的最常见方式是试图将某种 OOP 式的数据继承塞进 Rust 中。这是行不通的。Rust 不是面向对象的。让我们来看看几种不同的情况，在哪些情况下，如何以及为什么它不起作用。让我们从这个例子开始:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Weapon</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spear</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Axe</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Sword</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Soldier is just a Human with a Weapon
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Mount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Horse</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Donkey</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Cow</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Knight is just a Soldier with a Mount
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">mount</span>: <span class="nc">Mount</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Soldier</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Spell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MagicMissile</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">FireBolt</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ThornWhip</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Mage is just a Human who can cast Spells
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">spells</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Staff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Wooden</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Metallic</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Plastic</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Wizard is just a Mage with a Staff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">staff</span>: <span class="nc">Staff</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mage</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_human</span><span class="p">(</span><span class="n">human</span>: <span class="kp">&amp;</span><span class="nc">Human</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_soldier</span><span class="p">(</span><span class="n">soldier</span>: <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_knight</span><span class="p">(</span><span class="n">knight</span>: <span class="kp">&amp;</span><span class="nc">Knight</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_mage</span><span class="p">(</span><span class="n">mage</span>: <span class="kp">&amp;</span><span class="nc">Mage</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_wizard</span><span class="p">(</span><span class="n">wizard</span>: <span class="kp">&amp;</span><span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types can be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights can be used as Soldiers
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Wizards can be used as Mages
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights &amp; Wizards passed as themselves
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_knight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_wizard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>因此，乍一看，上面的内容看起来很不错！然而，在仔细研究后，很快就发现了问题。首先，强制解引用只对引用起作用，所以当我们真正想要传递所有权时，它就不起作用了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">takes_human</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types CANNOT be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">soldier</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">knight</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">mage</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">wizard</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>此外，强制解引用在泛型上下文中不起作用。比方说，我们只在人类身上实现一些 trait：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rest</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rest</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">take_rest</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Rest</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rester</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">rester</span><span class="p">.</span><span class="n">rest</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types CANNOT be used as Rest types, only Human
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，尽管强制解引用在很多地方都能工作，但并不是所有地方都能工作。它对操作数不起作用，尽管操作符只是方法调用的语法糖。比方说，我们想让 <code>Mage</code>(法师) 用 <code>+=</code> 运算符来学习 <code>Spell</code>(咒语)，这很可爱。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">spell</span>: <span class="nc">Spell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">spells</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">spell</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">,</span><span class="w"> </span><span class="n">spell</span>: <span class="nc">Spell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">spell</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">wizard</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">spell</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ wizard not coerced to mage here
</span><span class="c1"></span><span class="w">    </span><span class="n">wizard</span><span class="p">.</span><span class="n">add_assign</span><span class="p">(</span><span class="n">spell</span><span class="p">);</span><span class="w"> </span><span class="c1">// oof, we have to call it like this 🤦
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 OOP 式数据继承的语言中，方法中 <code>self</code> 的值总是等于调用该方法的类型，但在 Rust 中，<code>self</code> 的值总是等于实现该方法的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">profession</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// self will always be a Human here, even if we call it on a Soldier
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">state_profession</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m a {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">profession</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">soldier</span>: <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;servant&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;spearman&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="p">.</span><span class="n">state_profession</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;I&#39;m a servant!&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">soldier</span><span class="p">.</span><span class="n">state_profession</span><span class="p">();</span><span class="w"> </span><span class="c1">// still prints &#34;I&#39;m a servant!&#34; 🤦
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当在一个新类型上实现 <code>Deref</code> 或 <code>DerefMut</code> 时，上述的问题尤其严重。假设我们想创建一个 <code>SortedVec</code> 类型，它只是一个 <code>Vec</code>，但它总是按排序顺序排列。下面是我们如何做的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">SortedVec</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>很明显，我们不能在这里实现 <code>DerefMut&lt;Target = Vec&lt;T&gt;&gt;</code>，否则任何使用 <code>SortedVec</code> 的人都可以轻易地破坏排序的顺序。然而，实现 <code>Deref&lt;Target = Vec&lt;T&gt;&gt;</code> 肯定是安全的，对吗？试着在下面的程序中发现这个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">SortedVec</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedVec</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">sorted</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sortedClone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorted</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortedClone</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们从未为 <code>SortedVec</code> 实现 <code>Clone</code>，所以当我们调用 <code>.clone()</code> 方法时，编译器使用强制解引用来解决对 <code>Vec</code> 的方法调用，所以它返回一个 <code>Vec</code> 而不是 <code>SortedVec</code>!</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sorted</span>: <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedVec</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">sorted</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// still sorted
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// calling clone on SortedVec actually returns a Vec 🤦
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sortedClone</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorted</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortedClone</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// sortedClone no longer sorted 💀
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>总之，以上这些限制、约束或麻烦都不是 Rust 的缺点，因为 Rust 一开始就没有被设计成一种 OO 语言或支持任何 OOP 模式。</p>
<p>本节的主要启示是，不要试图用 <code>Deref</code> 和 <code>DerefMut</code> 实现来表现可爱或聪明。它们实际上只适合于智能指针类型，目前只能在标准库中实现，因为智能指针类型目前需要不稳定的特性和编译器的魔法才能工作。如果我们想要类似于 <code>Deref</code> 和 <code>DerefMut</code> 的功能和行为，那么我们实际上可能要找的是 <code>AsRef</code> 和 <code>AsMut</code>，我们将在后面讨论。</p>
<h4 id="index--indexmut">Index &amp; IndexMut</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">Idx</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">IndexMut</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span>: <span class="nc">Index</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Idx</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以将 <code>[]</code> 索引到有 <code>T</code> 值的 <code>Index&lt;T, Output = U&gt;</code> 类型，索引操作将返回 <code>&amp;U</code> 值。对于语法糖，编译器会在任何从索引操作返回的值前面自动插入一个解引用运算符 <code>*</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so
</span><span class="c1"></span><span class="w">    </span><span class="c1">// indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ❌ expected &amp;i32 found i32
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// above line actually desugars to
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ❌ expected &amp;i32 found i32
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// both of these alternatives work
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一开始有点让人困惑，因为看起来 <code>Index</code> trait 并不遵循它自己的方法签名，但实际上这只是有问题的语法糖。</p>
<p>因为 <code>Idx</code> 是一个泛型类型，<code>Index</code> trait 可以为一个给定的类型实现很多次，在 <code>Vec&lt;T&gt;</code> 的情况下，我们不仅可以使用 <code>usize</code> 对其进行索引，我们还可以使用 <code>Range&lt;usize&gt;</code> 对其进行索引，以获得切片。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[..],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">..],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了展示我们如何实现 <code>Index</code>，这里有一个有趣的例子，展示了我们如何使用一个新类型和 <code>Index</code> trait 来实现 <code>Vec</code> 的包装索引和负索引。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Index</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="kt">i128</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">i128</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">self_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i128</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">0_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">1_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">2_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">wrapping_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">3_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">4_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">5_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">neg_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">3_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">2_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">wrapping_neg_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">6_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">5_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">4_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>没有要求 <code>Idx</code> 类型必须是数字类型或 <code>Range</code>，它可以是一个枚举! 下面是一个例子，使用篮球位置索引到一个篮球队，以检索该队的球员。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Index</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">BasketballPosition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">PointGuard</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ShootingGuard</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Center</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">PowerForward</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">SmallForward</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">BasketballPlayer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">position</span>: <span class="nc">BasketballPosition</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">BasketballTeam</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">point_guard</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">shooting_guard</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">center</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">power_forward</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">small_forward</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">BasketballPosition</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BasketballTeam</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BasketballPlayer</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">position</span>: <span class="nc">BasketballPosition</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">BasketballPlayer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">PointGuard</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">point_guard</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">ShootingGuard</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">shooting_guard</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">Center</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">center</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">PowerForward</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">power_forward</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">SmallForward</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">small_forward</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="drop">Drop</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型实现了 <code>Drop</code>，那么当它超出作用域但在被销毁之前，<code>drop</code> 将在该类型上调用。我们很少需要为我们的类型实现这个功能，但是一个很好的例子是，如果一个类型持有一些外部资源，当类型被销毁时，这些资源需要被清理掉。</p>
<p>在标准库中有一个 <code>BufWriter</code> 类型，允许我们对 <code>Write</code> 类型进行缓冲写入。然而，如果 <code>BufWriter</code> 在其缓冲区的内容被刷新到底层的 <code>Write</code> 类型之前就被销毁了呢？幸好这是不可能的! <code>BufWriter</code> 实现了 <code>Drop</code> trait，所以每当它离开作用域时，<code>flush</code> 总是被调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">flush_buf</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，Rust 中的 <code>Mutex</code> 没有 <code>unlock()</code> 方法，因为它们不需要这些方法。在一个 <code>Mutex</code> 上调用 <code>lock()</code> 会返回一个 <code>MutexGuard</code>，当 <code>Mutex</code> 超出作用域时，由于它的 <code>Drop</code> 实现，它会自动解锁。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MutexGuard</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">raw_unlock</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一般来说，如果你在某些资源上实现一个抽象，在使用后需要清理，那么这就是使用 <code>Drop</code> trait 的一个很好的理由。</p>
<h2 id="转换-traits">转换 Traits</h2>
<h3 id="from--into">From &amp; Into</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>From&lt;T&gt;</code> 类型允许我们将 <code>T</code> 转换为 <code>Self</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Into&lt;T&gt;</code> 类型允许我们将 <code>Self</code> 转换为 <code>T</code>。</p>
<p>这些 trait 是一个硬币的两个不同侧面。我们只能为我们的类型实现 <code>From&lt;T&gt;</code>，因为 <code>Into&lt;T&gt;</code> 的实现是由下面这个泛型全面实现自动提供的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">U</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>::<span class="n">from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这两个  trait 存在的原因是，它允许我们以稍微不同的方式在泛型类型上编写 trait 约束(trait bound)。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="c1">// these bounds are equivalent
</span><span class="c1"></span><span class="w">    </span><span class="n">T</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">i32</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// these examples are equivalent
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">example</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">from</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">example</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>关于何时使用这两种方法并没有硬性规定，所以在每种情况下都要选择最合理的方法。现在让我们看看一些关于 <code>Point</code> 的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Into
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>实现不是对称的，所以如果我们想把 <code>Point</code> 转换成元组和数组，我们也必须显示地地添加这些。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// from (i32, i32) into Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from Point into (i32, i32)
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="n">point</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from [i32; 2] into Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from Point into [i32; 2]
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="n">point</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>From&lt;T&gt;</code> 的一个普遍用途是缩减模板代码。假设我们在程序中加入一个包含三个 <code>Point</code> 的 <code>Triangle</code> 类型，这里有许多方法可以构建它。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Triangle</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">P</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">]</span>: <span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">p1</span>: <span class="nc">p1</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">p2</span>: <span class="nc">p2</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">p3</span>: <span class="nc">p3</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// manual construction
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Point::new
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From&lt;(i32, i32)&gt; for Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Triangle::new + From&lt;(i32, i32)&gt; for Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From&lt;[Into&lt;Point&gt;; 3]&gt; for Triangle
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span>: <span class="nc">Triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对于何时、如何或为什么我们应该为我们的类型实现 <code>From&lt;T&gt;</code>，没有任何规则，所以这取决于我们对每种情况的最佳判断。</p>
<p><code>Into&lt;T&gt;</code> 的一个流行用法是使需要自有值(owned values)的函数在接受自有值或借用值时具有通用性。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// accepts:
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - String
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new1</span><span class="p">(</span><span class="n">name</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// accepts:
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - String
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - &amp;String
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - &amp;str
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - Box&lt;str&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - Cow&lt;&#39;_, str&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - char
</span><span class="c1"></span><span class="w">    </span><span class="c1">// since all of the above types can be converted into String
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new2</span><span class="o">&lt;</span><span class="n">N</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">name</span>: <span class="nc">N</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span>: <span class="nc">name</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="错误处理">错误处理</h2>
<p>谈论错误处理和 <code>Error</code> trait 的最佳时机是在讨论完 <code>Display</code>、<code>Debug</code>、<code>Any</code> 和 <code>From</code> 之后，在讨论 <code>TryFrom</code> 之前，因此错误处理部分与转换 trait 部分尴尬地一分为二。</p>
<h3 id="error">Error</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#any">Any</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Error</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">backtrace</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Backtrace</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cause</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 Rust 中，错误被返回，而不是被抛出。我们来看看一些例子。</p>
<p>由于整数类型除以0会引起 panic，如果我们想让我们的程序更安全、更明确，我们可以实现一个 <code>safe_div</code> 函数，返回一个 <code>Result</code>，就像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">DivByZero</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DivByZero</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;division by zero error&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DivByZero</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">numerator</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">denominator</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">DivByZero</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">denominator</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">DivByZero</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">numerator</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">denominator</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_safe_div</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">safe_div</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">safe_div</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">DivByZero</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于错误是返回的，而不是抛出的，所以必须显式处理，如果当前函数不能处理一个错误，它应该将其传播给调用者。传播错误的最习惯的方法是使用 <code>?</code> 操作符，它只是现在被废弃的 <code>try!</code> 宏的语法糖，它只是做这个。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="cp">$expr</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="cp">$expr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// if Ok just unwrap the value
</span><span class="c1"></span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="c1">// if Err map the err value using From and return
</span><span class="c1"></span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们想写一个将文件读成 <code>String</code> 的函数，我们可以这样写，用 <code>?</code> 将 <code>io::Error</code> 传播到它们可能出现的任何地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_file_to_string</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是，假设我们正在读取的文件实际上是一个数字列表，我们想把它们加在一起，我们会像这样更新我们的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="cm">/* What to put here? */</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是现在我们的 <code>Result</code> 的错误类型是什么？它可以返回一个 <code>io::Error</code> 或者一个 <code>ParseIntError</code>。我们将看一下解决这个问题的三种方法，从临时应急的方法开始，最后是最稳健的方法。</p>
<p>第一种方法是认识到所有实现了 <code>Error</code> 的类型也实现了 <code>Display</code>，所以我们可以将所有的错误映射到 <code>String</code>，并使用 <code>String</code> 作为我们的错误类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对每个错误进行字符串化处理的明显缺点是，我们丢弃了类型信息，这使得调用者更难处理错误。</p>
<p>上述方法的一个非显而易见的好处是我们可以定制字符串以提供更多的特定环境信息。例如，<code>ParseIntError</code> 通常字符串化为 &ldquo;invalid digit found in string&rdquo;，这是非常模糊的，没有提到无效的字符串是什么或者它试图解析成什么整数类型。如果我们要调试这个问题，这个错误信息几乎是无用的。然而，我们可以通过自己提供所有与上下文相关的信息来使其明显改善。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;failed to parse {} into i32&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>第二种方法是利用标准库中的这种泛型全面实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">E</span>: <span class="nc">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这意味着任何 <code>Error</code> 类型都可以通过 <code>?</code> 运算符隐式地转换为 <code>Box&lt;dyn error::Error&gt;</code>，所以我们可以在任何产生错误的函数的 <code>Result</code> 返回类型中把错误类型设置为 <code>Box&lt;dyn error::Error&gt;</code>，<code>?</code> 运算符将为我们完成其余的工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然更加简洁，但这似乎与之前的方法有相同的缺点，即丢弃了类型信息。这大部分是真的，但是如果调用者知道我们函数的实现细节，他们仍然可以使用 <code>error::Error</code> 上的 <code>downcast_ref()</code> 方法来处理不同的错误类型，这和它在 <code>dyn Any</code> 类型上的作用是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">handle_sum_file_errors</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">sum_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;the sum is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">downcast_ref</span>::<span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// handle io::Error
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">downcast_ref</span>::<span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// handle ParseIntError
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// we know sum_file can only return one of the
</span><span class="c1"></span><span class="w">                </span><span class="c1">// above errors so this branch is unreachable
</span><span class="c1"></span><span class="w">                </span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>第三种方法是最稳健和类型安全的方法，可以聚合这些不同的错误，是使用一个枚举建立我们自己的自定义错误类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Parse</span><span class="p">(</span><span class="n">ParseIntError</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;sum file error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;sum file error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// the default impl for this method always returns None
</span><span class="c1"></span><span class="w">    </span><span class="c1">// but we can now override it to make it way more useful!
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">SumFileError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">handle_sum_file_errors</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">sum_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;the sum is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// handle io::Error
</span><span class="c1"></span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// handle ParseIntError
</span><span class="c1"></span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="conversion-traits-continued">Conversion Traits Continued</h2>
<h3 id="tryfrom--tryinto">TryFrom &amp; TryInto</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
<li><a href="#error">Error</a></li>
</ul>
<p><code>TryFrom</code> and <code>TryInto</code> are the  versions of <code>From</code> and <code>Into</code>.
<code>TryFrom</code> 和 <code>TryInto</code> 是 <code>From</code> 和 <code>Into</code> 的不可靠版本。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Similarly to <code>Into</code> we cannot impl <code>TryInto</code> because its impl is provided by this generic blanket impl:
与 <code>Into</code> 类似，我们不能实现 <code>TryInto</code>，因为它的实现是由下面这个泛型全面实现提供的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">U</span>: <span class="nc">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>::<span class="n">try_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Let&rsquo;s say that in the context of our program it doesn&rsquo;t make sense for <code>Point</code>s to have <code>x</code> and <code>y</code> values that are less than <code>-1000</code> or greater than <code>1000</code>. This is how we&rsquo;d rewrite our earlier <code>From</code> impls using <code>TryFrom</code> to signal to the users of our type that this conversion can now fail:
假设在我们的程序中，<code>Point</code> 的 <code>x</code> 和 <code>y</code> 的值小于 <code>-1000</code> 或大于 <code>1000</code> 是不合理的。这就是我们如何使用 <code>TryFrom</code> 重写我们先前的 <code>From</code> 实现，向我们类型的用户发出信号，这个转换现在可以失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryFrom</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;out of bounds&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now fallible
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">OutOfBounds</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// still infallible
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>And here&rsquo;s the refactored <code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code> impl for <code>Triangle</code>:
这里是重构后的 <code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code> 实现，用于 <code>Triangle</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="p">{</span><span class="n">TryFrom</span><span class="p">,</span><span class="w"> </span><span class="n">TryInto</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;out of bounds&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">OutOfBounds</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Triangle</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">P</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">]</span>: <span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">p1</span>: <span class="nc">p1</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">p2</span>: <span class="nc">p2</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">p3</span>: <span class="nc">p3</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="p">,</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nc">Triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)].</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="fromstr">FromStr</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#error">Error</a></li>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromStr</code> types allow performing a fallible conversion from <code>&amp;str</code> into <code>Self</code>. The idiomatic way to use <code>FromStr</code> is to call the <code>.parse()</code> method on <code>&amp;str</code>s:
<code>FromStr</code> 类型允许执行从 <code>&amp;str</code> 到 <code>Self</code> 的错误转换。使用 <code>FromStr</code> 的习惯方法是对 <code>&amp;str</code> 调用 <code>.parse()</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">FromStr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// these are all equivalent
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FromStr</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// most idiomatic
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Point</code> 实现的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">Enumerate</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="p">{</span><span class="n">Chars</span><span class="p">,</span><span class="w"> </span><span class="n">FromStr</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, Eq, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">ParsePointError</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;failed to parse point&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">_e</span>: <span class="nc">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">ParsePointError</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="n">ParsePointError</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">is_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">char</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">..</span><span class="o">=</span><span class="sc">&#39;9&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">isnt_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">!</span><span class="n">is_num</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">get_num</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="n">char_idxs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Enumerate</span><span class="o">&lt;</span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;&gt;|</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span><span class="w"> </span><span class="n">ParsePointError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char_idxs</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">skip_while</span><span class="p">(</span><span class="n">isnt_num</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char_idxs</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">skip_while</span><span class="p">(</span><span class="n">is_num</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">((</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">))</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">enumerate</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span><span class="w"> </span><span class="n">x_end</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span><span class="w"> </span><span class="n">y_end</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">x_start</span><span class="p">..</span><span class="n">x_end</span><span class="p">].</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">y_start</span><span class="p">..</span><span class="n">y_end</span><span class="p">].</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">pos_x_y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;(4, 5)&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">neg_x_y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;(-6, -2)&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">not_a_point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;not a point&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromStr</code> has the same signature as <code>TryFrom&lt;&amp;str&gt;</code>. It doesn&rsquo;t matter which one we impl for a type first as long as we forward the impl to the other one. Here&rsquo;s a <code>TryFrom&lt;&amp;str&gt;</code> impl for <code>Point</code> assuming it already has a <code>FromStr</code> impl:
<code>FromStr</code> 与 <code>TryFrom&lt;&amp;str&gt;</code> 的签名相同。只要我们把实现转发给另一个类型，哪一个实现并不重要。下面是一个针对 <code>Point</code> 的 <code>TryFrom&lt;&amp;str&gt;</code> 实现，假设它已经有一个 <code>FromStr</code> 实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FromStr</span><span class="o">&gt;</span>::<span class="nb">Err</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FromStr</span><span class="o">&gt;</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="asref--asmut">AsRef &amp; AsMut</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">AsMut</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>?Sized</code> 说明 T 类型是大小不确定的。<code>As</code> 作为介词, 表明发生了类型转换。</p>
<p><code>AsRef</code> is for cheap reference to reference conversions. However, one of the most common ways it&rsquo;s used is to make functions generic over whether they take ownership or not:</p>
<p><code>AsRef</code> 是用于廉价的引用到引用的转换。然而，它最常见的使用方式之一是使函数在是否拥有所有权上通用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// accepts:
</span><span class="c1">//  - &amp;str
</span><span class="c1">//  - &amp;String
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">takes_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// use &amp;str
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// accepts:
</span><span class="c1">//  - &amp;str
</span><span class="c1">//  - &amp;String
</span><span class="c1">//  - String
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">takes_asref_str</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// use &amp;str
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">borrow</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">owned</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">borrow</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">owned</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">borrow</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">owned</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The other most common use-case is returning a reference to inner private data wrapped by a type which protects some invariant. A good example from the standard library is <code>String</code> which is just a wrapper around <code>Vec&lt;u8&gt;</code>:</p>
<p>另一个最常见的用例是返回一个对内部私有数据的引用，该数据由一个保护某些不变性的类型包裹。标准库中的一个很好的例子是 <code>String</code>，它只是 <code>Vec&lt;u8&gt;</code> 的一个包装器。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This inner <code>Vec</code> cannot be made public because if it was people could mutate any byte and break the <code>String</code>&rsquo;s valid UTF-8 encoding. However, it&rsquo;s safe to expose an immutable read-only reference to the inner byte array, hence this impl:
这个内部的 <code>Vec</code> 不能被公开，因为如果它被公开，人们可以改变任何字节并破坏 <code>String</code> 的有效 UTF-8 编码。然而，公开内部字节数组的不可变的只读引用是安全的，因此有了这个实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>Generally, it often only makes sense to impl <code>AsRef</code> for a type if it wraps some other type to either provide additional functionality around the inner type or protect some invariant on the inner type.</p>
<p>Let&rsquo;s examine a example of bad <code>AsRef</code> impls:
一般来说，只有当一个类型包装了其他类型，为内部类型提供了额外的功能，或者保护了内部类型的某些不变性时，为其实现 <code>AsRef</code> 才有意义。</p>
<p>让我们来看看一个不好的 <code>AsRef</code> 实现的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">age</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This works and kinda makes sense at first, but quickly falls apart if we add more members to <code>User</code>:
这在一开始是可行的，而且有点道理，但如果我们给 <code>User</code> 增加更多的成员，很快就会崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// uh, do we return name or email here?
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// uh, do we return age or height here?
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>A <code>User</code> is composed of <code>String</code>s and <code>u32</code>s but it&rsquo;s not really the same thing as a <code>String</code> or a <code>u32</code>. Even if we had much more specific types:
<code>User</code> 是由 <code>String</code> 和 <code>u32</code> 组成的，但它和 <code>String</code> 或 <code>u32</code> 并不是真正的一回事。即使我们有更具体的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nc">Name</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nc">Email</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="nc">Age</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">height</span>: <span class="nc">Height</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>It wouldn&rsquo;t make much sense to impl <code>AsRef</code> for any of those because <code>AsRef</code> is for cheap reference to reference conversions between semantically equivalent things, and <code>Name</code>, <code>Email</code>, <code>Age</code>, and <code>Height</code> by themselves are not the same thing as a <code>User</code>.</p>
<p>A good example where we would impl <code>AsRef</code> would be if we introduced a new type <code>Moderator</code> that just wrapped a <code>User</code> and added some moderation specific privileges:
实现 <code>AsRef</code> 对这些都没有意义，因为 <code>AsRef</code> 是用来在语义上等同的事物之间进行廉价的引用转换，而 <code>Name</code>、<code>Email</code>、<code>Age</code> 和 <code>Height</code> 本身就和 <code>User</code> 不是一回事。</p>
<p>一个很好的例子是，如果我们引入一个新的类型 <code>Moderator</code>，它只是包裹了一个 <code>User</code>，并增加了一些特定的管理权限，我们就会使用 <code>AsRef</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// unfortunately the standard library cannot provide
</span><span class="c1">// a generic blanket impl to save us from this boilerplate
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Privilege</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">BanUsers</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">EditPosts</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">DeletePosts</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// although Moderators have some special
</span><span class="c1">// privileges they are still regular Users
</span><span class="c1">// and should be able to do all the same stuff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">user</span>: <span class="nc">User</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">privileges</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Privilege</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Moderator</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">user</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this should be callable with Users
</span><span class="c1">// and Moderators (who are also Users)
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">create_post</span><span class="o">&lt;</span><span class="n">U</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">user</span>: <span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="n">moderator</span>: <span class="nc">Moderator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">create_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">create_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">moderator</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This works because <code>Moderator</code>s are just <code>User</code>s. Here&rsquo;s the example from the <code>Deref</code> section except using <code>AsRef</code> instead:
这样做是因为 <code>Moderator</code> 就是 <code>User</code>。下面是 <code>Deref</code> 部分的例子，只是用 <code>AsRef</code> 代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="nb">AsRef</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Weapon</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spear</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Axe</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Sword</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Soldier is just a Human with a Weapon
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Mount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Horse</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Donkey</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Cow</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Knight is just a Soldier with a Mount
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">mount</span>: <span class="nc">Mount</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Knight</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Spell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MagicMissile</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">FireBolt</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ThornWhip</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Mage is just a Human who can cast Spells
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">spells</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Staff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Wooden</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Metallic</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Plastic</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Wizard is just a Mage with a Staff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">staff</span>: <span class="nc">Staff</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Wizard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_human</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">human</span>: <span class="nc">H</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_soldier</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">soldier</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_knight</span><span class="o">&lt;</span><span class="n">K</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Knight</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">knight</span>: <span class="nc">K</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_mage</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">mage</span>: <span class="nc">M</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_wizard</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Wizard</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">wizard</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types can be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights can be used as Soldiers
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Wizards can be used as Mages
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights &amp; Wizards passed as themselves
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_knight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_wizard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Deref</code> didn&rsquo;t work in the prior version of the example above because deref coercion is an implicit conversion between types which leaves room for people to mistakenly formulate the wrong ideas and expectations for how it will behave. <code>AsRef</code> works above because it makes the conversion between types explicit and there&rsquo;s no room leftover to develop any wrong ideas or expectations.
<code>Deref</code> 在上述例子的先前版本中不起作用，因为 deref coercion 是一种隐式类型转换，为人们错误地制定错误的想法和期望留下了空间。<code>AsRef</code> 在上面起作用，因为它使类型间的转换变得明确，没有余地来发展任何错误的想法或期望。</p>
<h3 id="borrow--borrowmut">Borrow &amp; BorrowMut</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">BorrowMut</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrow_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Borrowed</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>These traits were invented to solve the very specific problem of looking up <code>String</code> keys in <code>HashSet</code>s, <code>HashMap</code>s, <code>BTreeSet</code>s, and <code>BTreeMap</code>s using <code>&amp;str</code> values.</p>
<p>We can view <code>Borrow&lt;T&gt;</code> and <code>BorrowMut&lt;T&gt;</code> as stricter versions of <code>AsRef&lt;T&gt;</code> and <code>AsMut&lt;T&gt;</code>, where the returned reference <code>&amp;T</code> has equivalent <code>Eq</code>, <code>Hash</code>, and <code>Ord</code> impls to <code>Self</code>. This is more easily explained with a commented example:
这些 trait 的发明是为了解决在 <code>HashSet</code>, <code>HashMap</code>, <code>BTreeSet</code>, 和 <code>BTreeMap</code> 中使用 <code>&amp;str</code> 值查找 <code>String</code> 键的特殊问题。</p>
<p>我们可以把 <code>Borrow&lt;T&gt;</code> 和 <code>BorrowMut&lt;T&gt;</code> 看作是 <code>AsRef&lt;T&gt;</code> 和 <code>AsMut&lt;T&gt;</code> 的更严格的版本，其中返回的引用 <code>&amp;T</code> 与 <code>Self</code> 的 <code>Eq</code>、<code>Hash</code> 和 <code>Ord</code> 等值。用一个注释的例子可以更容易地解释这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">borrow</span>::<span class="n">Borrow</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">hash_map</span>::<span class="n">DefaultHasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hash</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_hash</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Hash</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hasher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultHasher</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hasher</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">hasher</span><span class="p">.</span><span class="n">finish</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">asref_example</span><span class="o">&lt;</span><span class="n">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">Ref</span><span class="o">&gt;</span><span class="p">(</span><span class="n">owned1</span>: <span class="nc">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">owned2</span>: <span class="nc">Owned</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Owned</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Ref</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Ref</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1</span>: <span class="kp">&amp;</span><span class="nc">Ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned1</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2</span>: <span class="kp">&amp;</span><span class="nc">Ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned2</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// refs aren&#39;t required to be equal if owned types are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2</span><span class="p">,</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ref2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// ref hashes aren&#39;t required to be equal if owned type hashes are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2_hash</span><span class="p">,</span><span class="w"> </span><span class="n">ref1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ref2_hash</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// ref comparisons aren&#39;t required to match owned type comparisons
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">),</span><span class="w"> </span><span class="n">ref1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="p">));</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrow_example</span><span class="o">&lt;</span><span class="n">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="p">(</span><span class="n">owned1</span>: <span class="nc">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">owned2</span>: <span class="nc">Owned</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Owned</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow1</span>: <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned1</span><span class="p">.</span><span class="n">borrow</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow2</span>: <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned2</span><span class="p">.</span><span class="n">borrow</span><span class="p">();</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrows are required to be equal if owned types are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2</span><span class="p">,</span><span class="w"> </span><span class="n">borrow1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">borrow2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow2</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrow hashes are required to be equal if owned type hashes are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2_hash</span><span class="p">,</span><span class="w"> </span><span class="n">borrow1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">borrow2_hash</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrow comparisons are required to match owned type comparisons
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">),</span><span class="w"> </span><span class="n">borrow1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow2</span><span class="p">));</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>It&rsquo;s good to be aware of these traits and understand why they exist since it helps demystify some of the methods on <code>HashSet</code>, <code>HashMap</code>, <code>BTreeSet</code>, and <code>BTreeMap</code> but it&rsquo;s very rare that we would ever need to impl these traits for any of our types because it&rsquo;s very rare that we would ever need create a pair of types where one is the &ldquo;borrowed&rdquo; version of the other in the first place. If we have some <code>T</code> then <code>&amp;T</code> will get the job done 99.99% of the time, and <code>T: Borrow&lt;T&gt;</code> is already implemented for all <code>T</code> because of a generic blanket impl, so we don&rsquo;t need to manually impl it and we don&rsquo;t need to create some <code>U</code> such that <code>T: Borrow&lt;U&gt;</code>.</p>
<p>知道这些 trait 并理解它们存在的原因是很好的，因为这有助于解开 <code>HashSet</code>、<code>HashMap</code>、<code>BTreeSet</code> 和 <code>BTreeMap</code> 上的一些方法，但是我们很少需要为我们的任何类型实现这些 trait，因为我们很少需要创建一对类型，其中一个是另一个的 &ldquo;借用&rdquo; 版本。如果我们有一些 <code>T</code>，那么 <code>T</code> 在 99.99% 的情况下都能完成工作，而且 <code>T: Borrow&lt;T&gt;</code> 已经为所有的 <code>T</code> 实现了，因为有一个通用的一揽子实现，所以我们不需要手动实现它，我们也不需要创建一些 <code>U</code>，使 <code>T: Borrow&lt;U&gt;</code>。</p>
<h3 id="toowned">ToOwned</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">ToOwned</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Owned</span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Owned</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_into</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">target</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Owned</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>ToOwned</code> is a more generic version of <code>Clone</code>. <code>Clone</code> allows us to take a <code>&amp;T</code> and turn it into an <code>T</code> but <code>ToOwned</code> allows us to take a <code>&amp;Borrowed</code> and turn it into a <code>Owned</code> where <code>Owned: Borrow&lt;Borrowed&gt;</code>.</p>
<p>In other words, we can&rsquo;t &ldquo;clone&rdquo; a <code>&amp;str</code> into a <code>String</code>, or a <code>&amp;Path</code> into a <code>PathBuf</code>, or an <code>&amp;OsStr</code> into an <code>OsString</code>, since the <code>clone</code> method signature doesn&rsquo;t support this kind of cross-type cloning, and that&rsquo;s what <code>ToOwned</code> was made for.</p>
<p>For similar reasons as <code>Borrow</code> and <code>BorrowMut</code>, it&rsquo;s good to be aware of this trait and understand why it exists but it&rsquo;s very rare we&rsquo;ll ever need to impl it for any of our types.</p>
<p><code>ToOwned</code> 是 <code>Clone</code> 的一个更通用的版本。<code>Clone</code> 允许我们把一个 <code>&amp;T</code> 变成一个 <code>T</code>，但 <code>ToOwned</code> 允许我们把一个 <code>&amp;Borrowed</code> 变成一个 <code>Owned</code>，其中 <code>Owned: Borrow&lt;Borrowed&gt;</code>。</p>
<p>换句话说，我们不能把一个 <code>&amp;str</code> 克隆成一个 <code>String</code>，或者把一个 <code>&amp;Path</code> 克隆成一个 <code>PathBuf</code>，或者把一个 <code>&amp;OsStr</code> 克隆成一个 <code>OsString</code>，因为 <code>clone</code> 方法签名不支持这种跨类型克隆，而这正是 <code>ToOwned</code> 的用途。</p>
<p>出于与 <code>Borrow</code> 和 <code>BorrowMut</code> 类似的原因，知道这个 trait 并理解它存在的原因是很好的，但我们很少需要为我们的任何类型实现这个 trait。</p>
<h2 id="iteration-traits">Iteration Traits</h2>
<h3 id="iterator">Iterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#default-impls">Default Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">size_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">advance_by</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">step_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">step</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">StepBy</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">chain</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">other</span>: <span class="nc">U</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Chain</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">U</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">IntoIter</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">zip</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Zip</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">U</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">IntoIter</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Map</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">for_each</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">filter</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Filter</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">filter_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">FilterMap</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Enumerate</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">peekable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Peekable</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">skip_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">SkipWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TakeWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">map_while</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MapWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Skip</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Take</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">scan</span><span class="o">&lt;</span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">initial_state</span>: <span class="nc">St</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Scan</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flat_map</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">FlatMap</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Flatten</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fuse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fuse</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inspect</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Inspect</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partition</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partition_in_place</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">DoubleEndedIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_partitioned</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_fold</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">init</span>: <span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_for_each</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fold</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">init</span>: <span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fold_first</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">all</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">any</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">find</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">find_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_find</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">f</span>: <span class="nc">F</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">R</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Try</span><span class="o">&gt;</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">position</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rposition</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">ExactSizeIterator</span> <span class="o">+</span><span class="w"> </span><span class="nb">DoubleEndedIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max_by_key</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min_by_key</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rev</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Rev</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">DoubleEndedIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">unzip</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">FromA</span><span class="p">,</span><span class="w"> </span><span class="n">FromB</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">FromA</span><span class="p">,</span><span class="w"> </span><span class="n">FromB</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">FromA</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">FromB</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">copied</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Copied</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cloned</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cloned</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cycle</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Clone</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sum</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">S</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">S</span>: <span class="nc">Sum</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">product</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">P</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nc">Product</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">partial_cmp</span>: <span class="nc">F</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialEq</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> </span><span class="n">eq</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialEq</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">lt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">le</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">gt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ge</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted_by_key</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">K</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">K</span>: <span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Iterator&lt;Item = T&gt;</code> 类型可以被迭代，并会产生 <code>T</code> 类型。没有 <code>IteratorMut</code> trait。每个 <code>Iterator</code> 实现可以通过 <code>Item</code> 关联类型指定它是返回不可变引用、可变引用还是拥有其值。</p>
<table>
<thead>
<tr>
<th><code>Vec&lt;T&gt;</code> 方法</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.iter()</code></td>
<td><code>Iterator&lt;Item = &amp;T&gt;</code></td>
</tr>
<tr>
<td><code>.iter_mut()</code></td>
<td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td>
</tr>
<tr>
<td><code>.into_iter()</code></td>
<td><code>Iterator&lt;Item = T&gt;</code></td>
</tr>
</tbody>
</table>
<p>对于初学者来说，有些东西不是很明显，但中级 Rustaceans 认为是理所当然的，那就是大多数类型都不是他们本身的迭代器。如果一个类型是可迭代的，我们几乎总是实现一些自定义的迭代器类型来迭代它，而不是试图让它自己迭代。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">MyTypeIterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">index</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">items</span>: <span class="kp">&amp;</span><span class="nc">self</span><span class="p">.</span><span class="n">items</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MyTypeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyTypeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="p">];</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了便于教学，上面的例子展示了如何从头开始实现一个 <code>Iterator</code>，但在这种情况下，习惯性的解决方案将只是遵从 <code>Vec</code> 的 <code>iter</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，这也是一个很好的通用全面实现，要注意。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span> <span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">I</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>它说任何对迭代器的可变引用也是迭代器，这一点很有用，因为它允许我们使用 <code>self</code> 接收器，就像使用 <code>&amp;mut self</code> 接收器一样。了解这一点很有用，因为它允许我们使用迭代器方法与 <code>self</code> 接收器，就像它们有 <code>&amp;mut self</code> 接收器一样。</p>
<p>举个例子，想象一下，我们有一个函数，它可以处理一个超过三个项的迭代器，但是函数的第一步是取出迭代器的前三项，并在迭代剩下的项之前分别处理它们，下面是一个初学者可能尝试写这个函数的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌ iter consumed in line above
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>嗯，这很烦人。<code>take</code> 方法有一个 <code>self</code> 接收器，所以我们似乎不能在不消耗整个迭代器的情况下调用它。下面是上面代码的一个天真的重构。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这还算好的。然而，惯用的重构其实是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">by_ref</span><span class="p">().</span><span class="n">take</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不太容易发现。但无论如何，现在我们知道了。</p>
<p>另外，对于什么可以是迭代器，什么不能是迭代器，并没有什么规则或约定。如果类型是 <code>Iterator</code>，那么它就是一个迭代器。标准库中的一些创造性的例子如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">mpsc</span>::<span class="n">channel</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">paths_can_be_iterated</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// iterate over parts of a path
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">receivers_can_be_iterated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">send</span><span class="p">,</span><span class="w"> </span><span class="n">recv</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">recv</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// iterate over received values
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="intoiterator">IntoIterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#iterator">Iterator</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">IntoIter</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">IntoIter</span>: <span class="nb">Iterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">IntoIter</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>IntoIterator</code> 类型可以被转换为迭代器，因此得名。当一个类型在 <code>for-in</code> 循环中使用时，会调用 <code>into_iter</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above line desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>不仅 <code>Vec</code> 实现了 <code>IntoIterator</code>，如果我们想分别迭代不可变引用或可变引用而不是拥有其值，<code>&amp;Vec</code> 和 <code>&amp;mut Vec</code> 也分别实现了 <code>IntoIterator</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = &amp;T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above example desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">).</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = &amp;mut T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above example desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="p">).</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="fromiterator">FromIterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">FromIterator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromIterator</code> 类型可以从迭代器中创建，因此也被称为 <code>FromIterator</code>。<code>FromIterator</code> 最常见和最习惯的用法是调用 <code>Iterator</code> 上的 <code>collect</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">B</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>将 <code>Iterator&lt;Item = char&gt;</code> 收集成 <code>String</code> 的例子如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">filter_letters</span><span class="p">(</span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">is_alphabetic</span><span class="p">()).</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的所有集合都实现了 <code>IntoIterator</code> 和 <code>FromIterator</code>，这样可以更容易在它们之间进行转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="p">{</span><span class="n">BTreeSet</span><span class="p">,</span><span class="w"> </span><span class="n">HashMap</span><span class="p">,</span><span class="w"> </span><span class="n">HashSet</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedList</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// String -&gt; HashSet&lt;char&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">unique_chars</span><span class="p">(</span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">HashSet</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">ordered_unique_items</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BTreeSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">entry_list</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">map</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">map</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// and countless more possible examples
</span></code></pre></div><h2 id="io-traits">I/O Traits</h2>
<h3 id="read--write">Read &amp; Write</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#scope">Scope</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">IoSliceMut</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_read_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">initializer</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Initializer</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_to_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Bytes</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">chain</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Chain</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">limit</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Take</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">IoSlice</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_write_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_all_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">IoSlice</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="nc">Arguments</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>通用的全面实现值得了解。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">W</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这说明任何对 <code>Read</code> 类型的可变引用也是 <code>Read</code>，对 <code>Write</code> 也是如此。了解这一点很有用，因为它允许我们使用任何带有 <code>self</code> 接收器的方法，就像它有一个 <code>&amp;mut self</code> 接收器一样。我们已经在 <code>Iterator</code> trait 部分介绍了如何做到这一点以及为什么它很有用，所以我不打算在这里再次重复。</p>
<p>我想指出，<code>&amp;[u8]</code> 实现了 <code>Read</code>，<code>Vec&lt;u8&gt;</code> 实现了 <code>Write</code>，所以我们可以很容易地使用 <code>String</code> 对我们的文件处理函数进行单元测试，这些函数很容易转换为 <code>&amp;[u8]</code> 和 <code>Vec&lt;u8&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// function we want to test
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">uppercase</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w"> </span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">read</span>: <span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">write</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">read</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">uppercase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">to_uppercase</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">write</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">uppercase</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">write</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// in actual program we&#39;d pass Files
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">in_path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">out_path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">in_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">in_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">out_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">uppercase</span><span class="p">(</span><span class="n">in_file</span><span class="p">,</span><span class="w"> </span><span class="n">out_file</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// however in unit tests we can use Strings!
</span><span class="c1"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">in_file</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;i am screaming&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">out_file</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">uppercase</span><span class="p">(</span><span class="n">in_file</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">out_file</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">out_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8</span><span class="p">(</span><span class="n">out_file</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">out_result</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;I AM SCREAMING&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="结论">结论</h2>
<p>我们一起学到了很多东西! 事实上，太多了。它现在是我们的了:</p>
<p><img src="../assets/jason-jarvis-stdlib-traits.png" alt="rust standard library traits"></p>
<p><em>Artist credit: <a href="https://thejenkinscomic.wordpress.com/2020/05/06/memory/">The Jenkins Comic</a></em></p>
<h2 id="讨论">讨论</h2>
<p>在这里讨论这篇文章</p>
<ul>
<li><a href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
<li><a href="https://www.reddit.com/r/learnrust/comments/ml9shl/tour_of_rusts_standard_library_traits/">learnrust subreddit</a></li>
<li><a href="https://users.rust-lang.org/t/blog-post-tour-of-rusts-standard-library-traits/57974">official Rust users forum</a></li>
<li><a href="https://twitter.com/pretzelhammer/status/1379561720176336902">Twitter</a></li>
<li><a href="https://lobste.rs/s/g27ezp/tour_rust_s_standard_library_traits">lobste.rs</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/mmrao0/tour_of_rusts_standard_library_traits/">rust subreddit</a></li>
</ul>
<h2 id="通知">通知</h2>
<p>当下一篇博文发布时，会收到通知</p>
<ul>
<li><a href="https://twitter.com/pretzelhammer">Following pretzelhammer on Twitter</a> or</li>
<li>Watching this repo&rsquo;s releases (click <code>Watch</code> -&gt; click <code>Custom</code> -&gt; select <code>Releases</code> -&gt; click <code>Apply</code>)</li>
</ul>
<h2 id="更多阅读">更多阅读</h2>
<ul>
<li><a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a></li>
<li><a href="./common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a></li>
<li><a href="./learning-rust-in-2020.md">Learning Rust in 2020</a></li>
<li><a href="./too-many-brainfuck-compilers.md">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Psql]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-psql/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="related" type="text/html" title="争取在 MoarVM 中建立一个新的总调度机制" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-psql/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Psql</blockquote><h1 id="raku-与-postgresql-的连接性一览">Raku 与 PostgreSQL 的连接性一览</h1>
<p>在我看来，Raku 是一门伟大的语言，我每天都在使用它，而且越来越多。我可以说它将取代我的 Perl 脚本。</p>
<p>Raku 有一个广泛的模块库，当然包括数据库连接，这反过来又包括连接 PostgreSQL 的功能。
在这篇简单的文章中，我将快速演示如何使用 Raku 的一段代码来完成许多比数据库应用程序还琐碎的任务。
脚本是以增量的方式呈现的，所以连接数据库部分必须始终作为脚本的前言。</p>
<p>DB::Pg 模块在某种程度上与 Perl 5 的 DBD::Pg 很相似，所以很多概念和方法名都会让人想起后者。</p>
<h2 id="安装方法">安装方法</h2>
<p>可以使用 zef 来安装 DB::Pg 模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">% zef install DB::Pg
</code></pre></div><p>根据你的系统速度和已经安装的库，可能需要几分钟的时间。</p>
<p>如果你要使用 LISTEN/NOTIFY，你需要同时安装 epoLl.NET 和 EPOLl.NET。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">% zef install epoll
</code></pre></div><h2 id="连接到数据库">连接到数据库</h2>
<p>现在可以使用 DB::Pg 模块连接到数据库。例如，一个简单的脚本可以接受命令行上的所有参数（清晰的文本！），可以是：</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="ch">#!raku</span>

<span class="k">use</span> <span class="nn">DB::Pg</span><span class="p">;</span>

<span class="k">sub</span> <span class="nb">MAIN</span><span class="p">(</span> <span class="nb">Str</span> <span class="o">:</span><span class="nv">$host</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">miguel</span><span class="p">&#39;</span><span class="o">,</span>
          <span class="nb">Str</span> <span class="o">:</span><span class="nv">$username</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">luca</span><span class="p">&#39;</span><span class="o">,</span>
          <span class="nb">Str</span> <span class="o">:</span><span class="nv">$password</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">secet</span><span class="p">&#39;</span><span class="o">,</span>
          <span class="nb">Str</span> <span class="o">:</span><span class="nv">$database</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">testdb</span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">{</span>

    <span class="p">&#34;</span><span class="s2">Connecting </span><span class="nv">$username</span><span class="s2"> @ </span><span class="nv">$host</span><span class="s2">/</span><span class="nv">$database</span><span class="p">&#34;</span><span class="o">.</span><span class="nb">say</span><span class="p">;</span>

    <span class="k">my</span> <span class="nv">$connection</span> <span class="o">=</span> <span class="n">DB::Pg</span><span class="o">.</span><span class="nb">new</span><span class="o">:</span> <span class="s">conninfo</span> <span class="o">=&gt;</span> <span class="p">&#34;</span><span class="s2">host=</span><span class="nv">$host</span><span class="s2"> user=</span><span class="nv">$username</span><span class="s2"> password=</span><span class="nv">$password</span><span class="s2"> dbname=</span><span class="nv">$database</span><span class="p">&#34;;</span>
</code></pre></div><p>如你所见，DB::Pg模块接受一个 conninfo 字符串。</p>
<h2 id="读取查询和结果">读取查询和结果</h2>
<p><code>.query</code> 方法允许向数据库发出读取查询。结果是一个 Result 类对象，它可以通过不同的方法来使用，最著名的是 <code>.hash</code> 和 <code>.arrays</code>，它们返回一连串的 hash 或 arrays，从查询中提取的每一行都有一个 <code>.rows</code> 和 <code>.column</code> 等特殊方法分别提供了查询返回的行数和结果集的列名。</p>
<p>举个例子，这里是一个简单的查询。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$query</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">SELECT current_role, current_time</span><span class="p">&#39;;</span>
<span class="k">my</span> <span class="nv">$results</span> <span class="o">=</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">query:</span> <span class="nv">$query</span><span class="p">;</span>

<span class="nb">say</span> <span class="p">&#34;</span><span class="s2">The query </span><span class="p">{</span> <span class="nv">$query</span> <span class="p">}</span><span class="s2"> returned </span><span class="p">{</span> <span class="nv">$results</span><span class="o">.</span><span class="nf">rows</span> <span class="p">}</span><span class="s2"> rows with columns: </span><span class="p">{</span> <span class="nv">$results</span><span class="o">.</span><span class="nf">columns</span><span class="o">.</span><span class="nb">join</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">, </span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">}&#34;;</span>
<span class="k">for</span> <span class="nv">$results</span><span class="o">.</span><span class="nf">hashes</span> <span class="k">-&gt;</span> <span class="nv">$row</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nv">$row</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$column</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Column </span><span class="nv">$column</span><span class="s2"> = </span><span class="nv">$value</span><span class="p">&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>上面这段代码提供了一个类似于下面的输出。</p>
<p>查询 <code>SELECT current_role, current_time</code> 返回1行，列数为： current_role, current_time。</p>
<pre><code>Column current_role = luca
Column current_time = 14:48:47.147983+02
</code></pre><h2 id="光标">光标</h2>
<p>默认情况下，<code>.query</code> 方法将从查询中获取所有的行，这对于较大的数据集来说是一个问题。可以使用 <code>.cursor</code> 方法，它可以接受可选的批量大小（默认为1000个元组），并可选地接受将结果获取为哈希序列的指定器。</p>
<p>作为一个简单的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">for</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">cursor</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">select * from raku</span><span class="p">&#39;</span><span class="o">,</span> <span class="s">fetch</span> <span class="o">=&gt;</span> <span class="mi">2</span>, <span class="p">:</span><span class="s">hash</span> <span class="p">)</span> <span class="k">-&gt;</span> <span class="nv">%row</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">====================</span><span class="p">&#34;;</span>
    <span class="k">for</span> <span class="nv">%row</span><span class="o">.</span><span class="nb">kv</span> <span class="k">-&gt;</span> <span class="nv">$column</span><span class="o">,</span> <span class="nv">$value</span> <span class="p">{</span>
        <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">Column [ </span><span class="nv">$column</span><span class="s2"> ] = </span><span class="nv">$value</span><span class="p">&#34;;</span>
    <span class="p">}</span>
    <span class="nb">say</span> <span class="p">&#34;</span><span class="s2">====================</span><span class="p">&#34;;</span>
<span class="p">}</span>
</code></pre></div><p>产生和输出像这样的东西。</p>
<pre><code>====================
Column [ pk ] = 2
Column [ t ] = This is value 0
====================
====================
Column [ pk ] = 3
Column [ t ] = This is value 1
====================
====================
Column [ t ] = This is value 2
Column [ pk ] = 4
====================
====================
Column [ pk ] = 5
Column [ t ] = This is value 3
====================
...
</code></pre><h2 id="撰写声明">撰写声明</h2>
<p>编写语句可以通过 <code>.execute</code> 方法来执行，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$connection</span><span class="o">.</span><span class="nf">execute:</span> <span class="k">q</span><span class="p">&lt;</span><span class="s"> insert into raku( t ) values( &#39;Hello World&#39; )</span><span class="p">&gt;;</span>
</code></pre></div><h2 id="交易和编制报表">交易和编制报表</h2>
<p>为了处理事务，你需要访问被&quot;屏蔽&quot;到 DB::Pg 主对象中的数据库处理程序。数据库对象像往常一样提供了 <code>.begin</code>、<code>.rollback</code>、<code>.commit</code>等方法。</p>
<p>此外，还可以使用 <code>.prepare</code> 方法来获得一个已准备好的语句，该语句可以被缓存并用于循环和重复性任务中。值得注意的是，<code>.prepare</code> 方法使用了 <code>$1</code>、<code>$2</code> 等参数占位符，当语句接受单个值时，必须在 <code>.execute</code> 中不指定索引。</p>
<p>举个例子</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$database-handler</span> <span class="o">=</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">db</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$statement</span> <span class="o">=</span> <span class="nv">$database-handler</span><span class="o">.</span><span class="nf">prepare:</span> <span class="p">&#39;</span><span class="s1">insert into raku( t ) values( $1 )</span><span class="p">&#39;;</span>

<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">begin</span><span class="p">;</span>
<span class="nv">$statement</span><span class="o">.</span><span class="nf">execute</span><span class="p">(</span> <span class="p">&#34;</span><span class="s2">This is value </span><span class="nv">$_</span><span class="p">&#34;</span> <span class="p">)</span>  <span class="k">for</span> <span class="mi">0</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">commit</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nb">finish</span><span class="p">;</span>
</code></pre></div><p>上述循环相当于一个SQL事务，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">BEGIN</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 0&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 1&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 2&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">raku</span><span class="p">(</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;This is value 10&#39;</span><span class="w"> </span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">COMMIT</span><span class="p">;</span><span class="w">
</span></code></pre></div><p><code>.finish</code> 方法是必需的，因为 DB::Pg 处理缓存。请注意，<code>.commit</code> 和 <code>.rollback</code> 方法是流畅的，并返回一个对象实例，这样你就可以调用 <code>.commit.finish</code>。</p>
<h2 id="数据库与连接">数据库与连接</h2>
<p>缓存的处理方式是，当发出一个查询时，会打开一个新的连接并使用。一旦工作完成，连接就会返回到内部池中。DB::Pg::Database 对象做的工作和 DB::Pg 的一样，不同的是它不会自动将连接返回到池中，所以需要自己进行 <code>.</code> 完成。</p>
<p>因此，你可以在两个对象上使用相同的 <code>.query</code> 和 <code>.execute</code> 方法，但 DB::Pg 会自动将连接返回到内部池中，而数据库对象则允许你对何时将连接返回到池中进行细粒度的控制。</p>
<h2 id="复制">复制</h2>
<p>PostgreSQL 提供了特殊的 COPY 命令，可以用来复制从和进入。有一个方法 <code>.copy-in</code> 可以执行 <code>COPY FROM</code>，而 <code>COPY TO</code> 可以在迭代循环中使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">/tmp/raku.csv</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">open</span><span class="o">:</span> <span class="p">:</span><span class="s">w</span><span class="p">;</span>
<span class="k">for</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">query:</span> <span class="p">&#39;</span><span class="s1">COPY raku TO stdout (FORMAT CSV)</span><span class="p">&#39;</span>  <span class="k">-&gt;</span> <span class="nv">$row</span> <span class="p">{</span>
    <span class="nv">$file</span><span class="o">.</span><span class="nb">print</span><span class="o">:</span> <span class="nv">$row</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>以上将 CSV 结果导出到文本文件上。
如果要读回数据，可以发出 <code>.copy-in</code> 方法，但首先需要发出 <code>SQL COPY</code>。工作流程是</p>
<pre><code>issue a COPY FROM STDIN;
use .copy-data to slurp all the data;
use .copy-end to notify the database that the COPY is concluded.
</code></pre><p>对.copy-end的需求是一个建议：可以在一次运行中发出不同的.copy-data，例如从不同文件中导入数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$database-handler</span> <span class="o">=</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">db</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">query:</span> <span class="p">&#39;</span><span class="s1">COPY raku FROM STDIN (FORMAT CSV)</span><span class="p">&#39;;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">copy-data:</span>  <span class="p">&#39;</span><span class="s1">/tmp/raku1.csv</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">copy-data:</span>  <span class="p">&#39;</span><span class="s1">/tmp/raku2.csv</span><span class="p">&#39;</span><span class="o">.</span><span class="nb">IO</span><span class="o">.</span><span class="nb">slurp</span><span class="p">;</span>
<span class="nv">$database-handler</span><span class="o">.</span><span class="nf">copy-end</span><span class="p">;</span>
</code></pre></div><h2 id="转换器">转换器</h2>
<p>可以指定转换器，即处理进出数据库的值的特殊角色；这让我想起了 DBI::Class 的 <code>inflate</code> 和 <code>deflate</code> 选项。
第一步是在 <code>DB::Pg</code> 中给转换器实例添加一个角色，这样的实例必须。</p>
<ul>
<li>增加一个新的类型转换方法。</li>
<li>增加一个转换方法来处理类型字符串化的值，并返回新值（在任何 Raku 实例中）。</li>
</ul>
<p>作为一个例子，下面将一个文本 PostgreSQL 类型转换为一个 Str Raku 对象，并在其内容上进行反转。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nv">$connection</span><span class="o">.</span><span class="nf">converter</span> <span class="k">does</span> <span class="k">role</span> <span class="nc">fluca-converter</span>
<span class="p">{</span>
    <span class="k">submethod</span> <span class="nb">BUILD</span> <span class="p">{</span> <span class="nb">self</span><span class="o">.</span><span class="nf">add-type</span><span class="p">(</span> <span class="s">text</span> <span class="o">=&gt;</span> <span class="nb">Str</span> <span class="p">)</span> <span class="p">}</span>
    <span class="k">multi</span> <span class="k">method</span> <span class="nf">convert</span><span class="p">(</span> <span class="nb">Str:U</span><span class="o">,</span> <span class="nb">Str:D</span> <span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$value</span><span class="o">.</span><span class="nb">flip</span><span class="o">.</span><span class="nb">uc</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="o">.</span><span class="nb">say</span> <span class="k">for</span> <span class="nv">$connection</span><span class="o">.</span><span class="nf">query</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">select * from raku</span><span class="p">&#39;</span> <span class="p">)</span><span class="o">.</span><span class="nf">arrays</span><span class="p">;</span>
</code></pre></div><p>产生类似于的输出。</p>
<pre><code>[442 DLROW OLLEH]
[454 DLROW OLLEH]
[466 DLROW OLLEH]
</code></pre><p>其中字符串 Hello World 被翻转。</p>
<h2 id="listen-和-notify">listen 和 notify</h2>
<p>DB::Pg也可以处理LISTEN和NOTIFY，它们能够与Raku的react动态功能进行交互。
首先，创建一个简单的机制来通知一些事件。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="s">testdb</span><span class="o">=&gt;</span> <span class="n">create</span> <span class="ow">or</span> <span class="n">replace</span> <span class="k">rule</span> <span class="nf">r_raku_insert</span> 
         <span class="n">as</span> <span class="n">on</span> <span class="n">insert</span> <span class="nb">to</span> <span class="nb">raku</span> 
         <span class="nb">do</span> <span class="k">also</span> 
         <span class="n">SELECT</span> <span class="nf">pg_notify</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">insert_event</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">INSERTING ROW(S)</span><span class="p">&#39;</span> <span class="p">);</span>
<span class="nb">CREATE</span> <span class="n">RULE</span>

<span class="s">testdb</span><span class="o">=&gt;</span> <span class="n">create</span> <span class="ow">or</span> <span class="n">replace</span> <span class="k">rule</span> <span class="nf">r_raku_delete</span>
         <span class="n">as</span> <span class="n">on</span> <span class="nb">delete</span> <span class="nb">to</span> <span class="nb">raku</span> 
         <span class="nb">do</span> <span class="k">also</span> 
         <span class="n">SELECT</span> <span class="nf">pg_notify</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">delete_event</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">DELETING ROW(S)</span><span class="p">&#39;</span> <span class="p">);</span>
<span class="nb">CREATE</span> <span class="n">RULE</span>
</code></pre></div><p>现在，可以创建一个等待传入事件的 Raku 脚本。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">react</span> <span class="p">{</span>
    <span class="k">whenever</span> <span class="nv">$connection</span><span class="o">.</span><span class="nb">listen</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">delete_event</span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">whenever</span> <span class="nv">$connection</span><span class="o">.</span><span class="nb">listen</span><span class="p">(</span> <span class="p">&#39;</span><span class="s1">insert_event</span><span class="p">&#39;</span> <span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="nb">say</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>目的是，每次发出一个事件，<code>.listen</code> 都会将消息有效载荷传递给 react 代码块。因此，发出一些 <code>DELETE</code> 和 <code>INSERT</code> 会导致输出。</p>
<pre><code>DELETING ROW(S)
INSERTING ROW(S)
INSERTING ROW(S)
</code></pre><p>可以通过 <code>.unlisten</code> 方法停止监听反应块。也可以通过 <code>.notify</code> 方法发出事件。</p>
<h2 id="总结">总结</h2>
<p>DB::Pg 是 PostgreSQL 的一个很好的驱动程序，它允许 Raku 直接在语言中利用很多功能。</p>
<p>文章 A glance at Raku connectivity towards PostgreSQL 已经由 Luca Ferrari 发布在博客上。</p>
<p>原文链接: <a href="https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html">https://fluca1978.github.io/2021/03/29/RakuPostgreSQL.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[争取在 MoarVM 中建立一个新的总调度机制]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-03-07-difference-between-build-and-tweak-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="BUILD 和 TWEAK 的区别" />
                <link href="https://ohmyweekly.github.io/notes/2021-03-01-how-to-type-unicode-in-raku/?utm_source=atom_feed" rel="related" type="text/html" title="如何在 Raku 中输入 Unicode" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-17-method-isd/?utm_source=atom_feed" rel="related" type="text/html" title="Method-ish" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-pattern-dispatch/?utm_source=atom_feed" rel="related" type="text/html" title="模式分派" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-28-custom-when/?utm_source=atom_feed" rel="related" type="text/html" title="自定义 when" />
            
                <id>https://ohmyweekly.github.io/notes/2021-03-15-towards-a-new-general-dispatch-mechanism-in-moarvm/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-03-15T00:00:00+08:00</published>
            <updated>2021-03-15T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Towards a New General Dispatch Mechanism in Moarvm</blockquote><p>我的天啊，看来我是两年多来第一次写 Raku 内部的博文了。当然，两年前还不叫 Raku。总之，话不多说，继续说说这个共同的脑洞吧。</p>
<h2 id="什么是调度">什么是调度？</h2>
<p>我用 &ldquo;dispatch&rdquo; 来表示我们接受一组参数，最后根据这些参数采取一些行动的过程。一些熟悉的例子包括:</p>
<ul>
<li>
<p>进行一个方法调用，比如 <code>$basket.add($product, $quantity)</code>。传统上，我们可能只调用 <code>$product</code> 和 <code>$qauntity</code> 作为参数，但就我的目的而言，所有的 <code>$basket</code>、方法名  &ldquo;add&rdquo;、<code>$product</code> 和 <code>$quantity</code> 都是 dispatch 的参数：它们是我们需要的东西，以便决定我们要做什么。</p>
</li>
<li>
<p>进行子程序调用，如 <code>uc($youtube-comment)</code>。由于 Raku sub 调用是词法解析的，所以在这种情况下，调度的参数是 <code>&amp;uc</code>（查找子程序的结果）和 <code>$youtube-comment</code>。</p>
</li>
<li>
<p>调用多个调度子程序或方法，根据参数的数量和类型来决定调用一组候选程序中的哪一个。这个过程可以看作是发生在上述两个调度中的一个 &ldquo;内部&rdquo;，因为我们在 Raku 中既有多重调度子程序，也有方法。</p>
</li>
</ul>
<p>乍一看，也许前两个看起来相当简单，第三个就有点手忙脚乱了 - 这也算是事实。然而，Raku 还有一些其他的特性，使得调度变得相当，嗯，有趣。例如：</p>
<ul>
<li>
<p><code>wrap</code> 允许我们包装任何 Routine (sub 或方法); 包装器可以选择用原来的参数或新的参数来服从原来的例程。</p>
</li>
<li>
<p>当进行多重调度时，我们可以写一个原型例程，让它选择何时 - 甚至是否 - 调用合适的候选者。</p>
</li>
<li>
<p>我们可以使用 <code>callsame</code> 这样的例程，以便在调度中推迟到下一个候选者。但这意味着什么呢？如果我们是在一个多重调度中，它意味着下一个最适用的候选者，如果有的话。如果我们是在一个方法调度中，那么它意味着一个基类的方法。(同样的事情也被用来实现去下一个封装者，或者，最终也是去最初封装的例程)。而且这些都可以结合起来：我们可以包装一个 multi 方法，这意味着我们可以有 3 个层次的东西，都有可能贡献下一个要调用的东西!</p>
</li>
</ul>
<p>多亏了这一点，dispatch - 至少在 Raku 中 - 并不总是我们所做的事情并产生一个结果，而是一个可能会被要求继续多次进行的过程!</p>
<p>最后，虽然我上面所写的例子都可以很清楚地看成是调度的例子，但在 Raku 中，其他一些常见的构造也可以表达为一种调度。分配是一个例子：它的语义取决于分配的目标和被分配的值，因此我们需要选择正确的语义。强制类型转换(Coercion)是另一个例子，返回值类型检查又是一个例子。</p>
<h2 id="为什么调度很重要">为什么调度很重要？</h2>
<p>Dispatch 在我们的程序中无处不在，它悄悄地把想做事情的代码和做事情的代码联系在一起。它的无处不在意味着它在程序性能中扮演着重要的角色。在最好的情况下，我们可以将成本降为零。在最坏的情况下，调度的成本高到足以超过作为调度结果的工作的成本。</p>
<p>初步估计，当运行时&quot;理解&quot;调度时，性能至少会有些不错，但当运行时不理解时，很有可能会很糟糕。调度往往涉及到一个可以缓存的工作量，往往会有一些廉价的防护措施来验证缓存结果的有效性。例如，在方法调度中，天真地我们需要走一个线性化的继承图，并询问沿途遇到的每个类是否有指定名称的方法。显然，如果我们在每次方法调用时都这样做，速度不会非常快。然而，特定类型上的特定方法名（精确识别，不考虑子类）每次都会解析到同一个方法。因此，我们可以缓存查找的结果，只要调用者的类型与用于产生缓存结果的类型相匹配，就可以使用它。</p>
<h2 id="语言运行时的专门化与通用化机制">语言运行时的专门化与通用化机制</h2>
<p>当一个人开始构建一个针对特定语言的运行时，并且必须在相当紧张的预算下完成时，要想获得某种可容忍的性能，最明显的方法就是将各种热路径语言语义烘焙到运行时中。这正是 MoarVM 的起步方式。因此，如果我们看看 MoarVM 几年前的样子，我们会发现这样的事情。</p>
<ul>
<li>对方法缓存的一些支持</li>
<li>一个与 Raku 的多重调度语义高度绑定的多重调度缓存，只有在调度都是名义类型的时候才真正能够起到帮助作用（所以使用 <code>where</code> 的代价非常高）。</li>
<li>一种机制，用于指定如何在封装代码对象内部找到实际的代码句柄（例如，<code>Sub</code> 对象有一个私有属性，它持有识别要运行的字节码的低级代码句柄）。</li>
<li>一些有限的尝试，让我们能够在知道一个调度不会继续的情况下正确地进行优化 - 这需要编译器和运行时之间的谨慎合作（或者不那么外交地讲，这都是一个大黑客）。</li>
</ul>
<p>这些今天都还在，然而也都在淘汰的路上。这个榜单最能说明问题的是什么，不包括在内。比如：</p>
<ul>
<li>私有方法调用，需要不同的缓存 但最初的虚拟机设计限制了每一种类型的调用</li>
<li>合格的方法调用(<code>$obj.SomeType::method-name()</code>)</li>
<li>体面优化调度恢复的方法</li>
</ul>
<p>几年前，我开始部分解决这个问题，引入了一种机制，我称之为 &ldquo;specializer 插件&rdquo;。但首先，什么是特化器(specializer)？</p>
<p>MoarVM 刚开始的时候，它是一个比较简单的字节码解释器。它只需要足够快的速度击败 Parrot VM 就可以获得相当的使用量，我认为在继续实现一些更有趣的优化之前，这一点非常重要（当时我们还没有今天这样的发布前自动测试基础设施，因此更多的是依赖于早期采用者的反馈）。总之，在能够像其他后端一样运行 Raku 语言后不久，我就开始了动态优化器的开发。它在程序被解释时收集类型统计，识别热代码，将其放入 <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA 形式</a>，使用类型统计插入防护，将这些与字节码的静态属性一起使用来分析和优化，并为相关函数生成专门的字节码。这个字节码可以省略类型检查和各种查找，也可以使用一系列的内部操作，做出各种假设，由于优化器证明了程序的属性，这些假设是安全的。这被称为专门化的字节码，因为它的很多通用性 - 这将使它能够正确地工作在我们可能遇到的所有类型的值上 - 被删除了，转而工作在运行时实际发生的特殊情况下。(代码，尤其是动态语言中的代码，一般来说，理论上的通用性远远大于实践中的通用性。)</p>
<p>这个组件 - 内部称为 &ldquo;spesh&rdquo; 的 specializer - 为 Raku 程序的性能带来了显著的进一步提升，随着时间的推移，它的复杂程度也在不断提高，并采用了<a href="https://en.wikipedia.org/wiki/Inline_expansion">内联</a>和<a href="https://en.wikipedia.org/wiki/Escape_analysis">带有标量替换的转义分析</a>等优化功能。这些并不是容易构建的东西 - 但一旦运行时拥有了它们，它们就会创造出以前不存在的设计可能性，并使在没有它们的情况下做出的决定看起来是次优的。</p>
<p>值得注意的是，那些特殊情况下的语言特定机制，在早期为了获得一些速度而被嵌入到运行时中，反而成为了一种负担和瓶颈。它们具有复杂的语义，这意味着它们对优化器来说要么是不透明的（所以优化器无法对它们进行推理，意味着优化受到抑制），要么就是需要在优化器中进行特殊的封装（一种负担）。</p>
<p>所以，回到 specializer 插件。我到了一个地步，我想承担像 <code>$obj.?meth(&quot;call me maybe&quot;, dispatch)</code>、<code>$obj.SomeType::meth()</code>(用类开始寻找的调度限定)，以及角色中的私有方法调用(不能静态解析)这样的性能。同时，我还准备实现一定量的转义分析，但意识到它的作用将非常有限，因为赋值在虚拟机中也被特例化了，有一大块不透明的 C 代码在做热路径的事情。</p>
<p>但为什么我们要让 C 代码来做那些热路径的事情呢？嗯，因为让每个赋值都调用一个虚拟机级别的函数，做一堆检查和逻辑，花费太大了。为什么这样做成本很高？因为函数调用的开销和解释的成本。这在以前都是正确的。但是，若干年后的发展。</p>
<ul>
<li>内联被实现了，并且可以消除做一个函数调用的开销。</li>
<li>我们可以编译成机器代码，消除解释开销。</li>
<li>我们当时的处境是，我们手头有 specializer 的类型信息，可以让我们消除 C 代码中的分支，但由于我们调用的只是一个不透明的函数，所以没有办法抓住这个机会</li>
</ul>
<p>我解决了上面提到的分配问题和调度问题，引入了一个新的机制：specializer 插件。它们的工作原理如下。</p>
<ul>
<li>当我们第一次到达字节码中的一个给定的调用点时，我们就会运行这个插件。它产生了一个要调用的代码对象，以及一组守卫（为了使用该代码对象结果而必须满足的条件）。</li>
<li>下一次到达时，我们检查是否满足守卫，如果满足，就用结果</li>
<li>如果没有，我们再运行一次插件，并在 callsite 处堆积一个防护集。</li>
<li>我们统计了一个给定的防护集成功的频率，然后将其用于 specializer</li>
</ul>
<p>绝大多数情况下都是单态的，这意味着只产生一组守卫，而且之后总是成功的。因此，特殊化器可以将这些守卫编译到专门的字节码中，然后假设给定的目标调用者就是将被调用的守卫。(进一步，重复的守卫可以被消除，所以某个插件引入的守卫可能会减少到零)。</p>
<p>Specializer 插件感觉挺好的。一个新机制解决了多个优化头疼的问题。</p>
<p>新的 MoarVM 调度机制是对一个相当简单的问题的回答：如果我们把所有与调度相关的特例机制去掉，而采用有点像 specializer 插件的机制，会怎么样？由此产生的机制需要是一个比 specializer 插件更强大的机制。进一步说，我可以学习特殊器插件的一些缺点。因此，虽然它们会在比较短的寿命后消失，但我认为可以说，如果没有这些经验，我就不会有能力设计新的 MoarVM 调度机制。</p>
<h2 id="调度操作和引导调度器">调度操作和引导调度器</h2>
<p>所有的方法缓存。所有的多重调度缓存。所有的 specializer 插件。所有用于在代码对象中解包字节码句柄的调用协议的东西。这一切都将被取消，取而代之的是一个新的调度指令。它的名字很无聊，叫 <code>dispatch</code>。它看起来像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">dispatch_o</span> <span class="nb">result</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-name</span><span class="p">&#39;</span><span class="o">,</span> <span class="n">callsite</span><span class="o">,</span> <span class="n">arg0</span><span class="o">,</span> <span class="n">arg1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">argN</span>
</code></pre></div><p>这意味着：</p>
<ul>
<li>使用名为 dispatcher-name 的调度器。</li>
<li>给它指定的参数寄存器（所引用的调用点表示参数的数量）。</li>
<li>将调度的对象结果放入寄存器结果中。</li>
</ul>
<p>(旁白：这意味着一个新的调用约定，即我们不再将参数复制到参数缓冲区，而是将寄存器集的基数和一个指针传递到找到寄存器参数映射的字节码中，然后做一个查询 <code>registers[map[argument_index]]</code> 来获取一个参数的值。仅此一点，我们在解释时就很省事，因为我们不再需要每个参数绕着解释器循环了）。)</p>
<p>有些参数可能是我们传统上称之为参数的东西。有些则是针对调度过程本身。这其实并不重要 - 但如果我们安排将只针对调度的参数放在前面（例如，方法名），而将针对调度目标的参数放在后面（例如，方法参数），则会更加理想。</p>
<p>新的 bootstrap 机制提供了少量的内置调度器，它们的名字以 &ldquo;boot-&rdquo; 开头。它们是：</p>
<ul>
<li><code>boot-value</code> - 取第一个参数并将其作为结果（身份函数，除了丢弃任何其他参数）。</li>
<li><code>boot-constant</code> - 取第一个参数并将其作为结果，但同时也将其视为一个将始终产生的常量值（因此意味着优化器可以将任何用于计算该值的纯代码视为死值）。</li>
<li><code>boot-code</code> - 取第一个参数（必须是虚拟机字节码句柄），并运行该字节码，将其余参数作为参数传给它；评估为字节码的返回值。</li>
<li><code>boot-syscall</code> - 将第一个参数视为虚拟机提供的内置操作的名称，然后调用它，并将其余参数作为其参数。</li>
<li><code>boot-resume</code> - 恢复正在进行的最上层调度。</li>
</ul>
<p>差不多就是这样。我们构建的每一个调度器，为了教给运行时一些其他的调度行为，最终都会终止于其中一个。</p>
<h2 id="在引导程序的基础上">在引导程序的基础上</h2>
<p>教 MoarVM 了解不同种类的调度，不外乎使用调度机制本身! 在大多数情况下，<code>boot-syscall</code> 被用来注册一个调度器，设置守卫，并提供与它们相匹配的结果。</p>
<p>这里是一个最小的例子，取自 dispatcher 测试套件，展示了一个提供同一性功能的 dispatcher 的样子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">identity</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-value</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="p">);</span>
<span class="p">});</span>
<span class="k">sub</span> <span class="nf">identity</span><span class="p">(</span><span class="nv">$x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">identity</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$x</span><span class="p">)</span>
<span class="p">}</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">identity</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">==</span> <span class="mi">42</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can define identity dispatch (1)</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">identity</span><span class="p">(&#39;</span><span class="s1">foo</span><span class="p">&#39;)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">foo</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can define identity dispatch (2)</span><span class="p">&#39;);</span>
</code></pre></div><p>在第一条语句中，我们调用 dispatcher-register MoarVM 系统调用，传递一个 dispatcher 的名称以及一个闭包，每次我们需要处理调度时，都会调用这个闭包（我倾向于将其称为&quot;调度回调&quot;）。它接收一个单一的参数，这是一个参数的捕获（其实不是 Raku 级别的捕获，但想法 - 一个包含一组调用参数的对象 - 是一样的）。</p>
<p>每一个用户定义的调度器最终都应该使用 dispatcher-delegate，以便确定另一个调度器将控制权传递给它。在这种情况下，它立即委托给 <code>boot-value</code> - 这意味着它除了是 <code>boot-value</code> 内置调度器的包装器外，其实什么都不是。</p>
<p>sub <code>identity</code> 包含一个调度操作的静态出现。鉴于我们两次调用 sub，我们在运行时将两次遇到这个 op，但这两次是非常不同的。</p>
<p>第一次是 &ldquo;记录&rdquo; 阶段。参数形成一个捕获，回调运行，回调又将其传给引导值调度器，产生结果。这样就形成了一个极其简单的调度程序，它说结果应该是捕获中的第一个参数。由于没有守卫，所以这将永远是一个有效的结果。</p>
<p>第二次遇到调度操作时，它那里已经记录了一个调度程序，所以我们处于运行模式。在 MoarVM 源码中开启调试模式，我们可以看到结果的调度程序是这样的。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load argument 0 into temporary 0
    Set result object value from temporary 0
</code></pre><p>也就是说，它将参数 0 读入一个临时位置，然后将其设置为调度的结果。请注意，没有提到我们经过了额外的一层调度，这些在结果调度程序中的成本为零。</p>
<h2 id="捕获操作">捕获操作</h2>
<p>参数捕获是不可改变的。各种虚拟机系统调用的存在，可以通过一些调整将它们转化为新的参数捕获，例如删除或插入参数。这里还有一个测试套件的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">drop-first</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$capture-derived</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-value</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture-derived</span><span class="p">);</span>
<span class="p">});</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">drop-first</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">first</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">second</span><span class="p">&#39;)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">second</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg works</span><span class="p">&#39;);</span>
</code></pre></div><p>这就在将捕获传递给引导值调度器之前丢弃了第一个参数 - 意味着它将返回第二个参数。回头看一下之前的身份函数的调度程序。你能猜到这个程序会是什么样子吗？</p>
<p>好吧，就是这样。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load argument 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>同样，虽然在这样一个调度器的记录阶段，我们确实是创建了捕获对象，并做了一个调度器代理，但由此产生的调度程序要简单得多。</p>
<p>下面是一个稍微复杂一点的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$target</span> <span class="o">:=</span> <span class="k">-&gt;</span> <span class="nv">$x</span> <span class="p">{</span> <span class="nv">$x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">call-on-target</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$capture-derived</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$target</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="p">&#39;</span><span class="s1">boot-code-constant</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture-derived</span><span class="p">);</span>
<span class="p">});</span>
<span class="k">sub</span> <span class="nf">cot</span><span class="p">()</span> <span class="p">{</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">call-on-target</span><span class="p">&#39;</span><span class="o">,</span> <span class="mi">49</span><span class="p">)</span> <span class="p">}</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">cot</span><span class="p">()</span> <span class="o">==</span> <span class="mi">50</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj works at start of capture</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">cot</span><span class="p">()</span> <span class="o">==</span> <span class="mi">50</span><span class="o">,</span>
    <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj works at start of capture after link too</span><span class="p">&#39;);</span>
</code></pre></div><p>这里，我们有一个存储在变量 <code>$target</code> 中的闭包。我们把它作为捕获的第一个参数插入，然后委托给 <code>boot-code-constant</code>，它将调用那个代码对象，并把其他调度参数传递给它。再次，在记录阶段，我们真正要做的事情是这样的。</p>
<ul>
<li>创建一个新的捕获 在开始的时候插入一个代码对象。</li>
<li>委托给引导代码常量分配器，它&hellip;。</li>
<li>&hellip;在没有原始参数的情况下创建一个新的捕获，并使用这些参数运行字节码。</li>
</ul>
<p>由此产生的调度程序呢？就是这个</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Load collectable constant at index 0 into temporary 0
    Skip first 0 args of incoming capture; callsite from 0
    Invoke MVMCode in temporary 0
</code></pre><p>也就是说，加载我们要调用的常量字节码句柄，设置 <code>args</code>（在本例中等于传入捕获的参数），然后用这些参数调用字节码。参数的洗牌，又一次消失了。一般来说，只要我们做最终的字节码调用的参数是初始调度参数的尾巴，参数转换就会变得不过是一个指针的添加。</p>
<h2 id="守卫">守卫</h2>
<p>目前看到的所有调度方案都是无条件的：一旦在某一通话地点记录下来，就应一直使用。要使这样的机制具有实用性，缺少的一大块就是守卫。守卫断言了一些属性，比如参数的类型或者参数是确定的（<code>Int:D</code>）还是不确定的（<code>Int:U</code>）。</p>
<p>下面是一个有点长的测试用例，并在其中放置了一些解释。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># A couple of classes for test purposes</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">C1</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">C2</span> <span class="p">{</span> <span class="p">}</span>
 
<span class="c1"># A counter used to make sure we&#39;re only invokving the dispatch callback as</span>
<span class="c1"># many times as we expect.</span>
<span class="k">my</span> <span class="nv">$count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
 
<span class="c1"># A type-name dispatcher that maps a type into a constant string value that</span>
<span class="c1"># is its name. This isn&#39;t terribly useful, but it is a decent small example.</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">type-name</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="c1"># Bump the counter, just for testing purposes.</span>
    <span class="nv">$count</span><span class="o">++</span><span class="p">;</span>
 
    <span class="c1"># Obtain the value of the argument from the capture (using an existing</span>
    <span class="c1"># MoarVM op, though in the future this may go away in place of a syscall)</span>
    <span class="c1"># and then obtain the string typename also.</span>
    <span class="k">my</span> <span class="nv">$arg-val</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">my</span> <span class="nb">str</span> <span class="nv">$name</span> <span class="o">:=</span> <span class="nv">$arg-val</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">name</span><span class="p">(</span><span class="nv">$arg-val</span><span class="p">);</span>
 
    <span class="c1"># This outcome is only going to be valid for a particular type. We track</span>
    <span class="c1"># the argument (which gives us an object back that we can use to guard</span>
    <span class="c1"># it) and then add the type guard.</span>
    <span class="k">my</span> <span class="nv">$arg</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-type</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$arg</span><span class="p">);</span>
 
    <span class="c1"># Finally, insert the type name at the start of the capture and then</span>
    <span class="c1"># delegate to the boot-constant dispatcher.</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-constant</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-str</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$name</span><span class="p">));</span>
<span class="p">});</span>
 
<span class="c1"># A use of the dispatch for the tests. Put into a sub so there&#39;s a single</span>
<span class="c1"># static dispatch op, which all dispatch programs will hang off.</span>
<span class="k">sub</span> <span class="nf">type-name</span><span class="p">(</span><span class="nv">$obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">type-name</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$obj</span><span class="p">)</span>
<span class="p">}</span>
 
<span class="c1"># Check with the first type, making sure the guard matches when it should</span>
<span class="c1"># (although this test would pass if the guard were ignored too).</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C1</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatcher setting guard works</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback ran once</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C1</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can use it another time with the same type</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">1</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback was not run again</span><span class="p">&#39;);</span>
 
<span class="c1"># Test it with a second type, both record and run modes. This ensures the</span>
<span class="c1"># guard really is being checked.</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C2</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Can handle polymorphic sites when guard fails</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback ran a second time for new type</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C2</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Second call with new type works</span><span class="p">&#39;);</span>
 
<span class="c1"># Check that we can use it with the original type too, and it has stacked</span>
<span class="c1"># the dispatch programs up at the same callsite.</span>
<span class="nb">ok</span><span class="p">(</span><span class="nf">type-name</span><span class="p">(</span><span class="n">C1</span><span class="p">)</span> <span class="ow">eq</span> <span class="p">&#39;</span><span class="s1">C1</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Call with original type still works</span><span class="p">&#39;);</span>
<span class="nb">ok</span><span class="p">(</span><span class="nv">$count</span> <span class="o">==</span> <span class="mi">2</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">Dispatch callback only ran a total of 2 times</span><span class="p">&#39;);</span>
</code></pre></div><p>这个时候就会产生两个调度程序，一个是 C1。</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C1)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>另一个是 C2:</p>
<pre><code>Dispatch program (1 temporaries)
  Ops:
    Guard arg 0 (type=C2)
    Load collectable constant at index 1 into temporary 0
    Set result string value from temporary 0
</code></pre><p>再一次，没有捕获操作、跟踪或调度器委托的遗留问题；调度程序对一个参数进行类型防护，然后产生结果字符串。整个对 <code>$arg-val.HOW.name($arg-val)</code> 的调用都被省略了，我们写的调度程序将知识进行了编码 - 以虚拟机能够理解的方式 - 一个类型的名称可以被认为是不可改变的。</p>
<p>这个例子有点造作，但现在考虑一下，我们反而要查找一个方法，并在调用者类型上进行守卫：这就是一个方法缓存! 守护更多参数的类型，我们就有了一个多缓存。两者都做，我们就有了一个多方法缓存。</p>
<p>后者很有意思，因为方法调度和多调度都想对调用者进行守护。事实上，在 MoarVM 中，今天会有两个这样的类型测试，直到我们到了特殊化器做工作并消除这些重复的守卫。然而，新的调度器并没有将调度器 - guard-类型当作一种命令式操作，将守卫写入结果调度程序中。相反，它声明相关的参数必须被防护。如果其他的调度器已经这样做了，那它就是幂等的。一旦我们委派通过的所有调度程序，在通往最终结果的路径上，都有了自己的发言权，就会发出守卫。</p>
<p>有趣的是：特别细心的人会注意到，调度机制也被用作实现新的调度程序的一部分，事实上，这最终也将意味着特殊化者可以将调度程序特殊化，让它们也被 JIT 编译成更高效的东西。毕竟，从 MoarVM 的角度来看，这一切都只是要运行的字节码，只是有些字节码是告诉 VM 如何更高效地执行 Raku 程序的!</p>
<h2 id="恢复调度">恢复调度</h2>
<p>可恢复调度器需要做两件事。</p>
<ul>
<li>在注册调度器的时候，提供一个恢复回调和一个调度回调。</li>
<li>在 dispatch 回调中，指定一个捕获，这将形成恢复初始化状态。</li>
</ul>
<p>当发生恢复时，将调用恢复回调，并提供恢复的任何参数。它还可以获得在 dispatch 回调中设置的 resume 初始化状态。resume 初始化状态包含了第一次恢复调度时继续进行调度所需要的东西。我们先来看看方法调度的工作原理，看一个具体的例子。我也会在此时，切换到看真正的 Rakudo 调度器，而不是简化的测试用例。</p>
<p>Rakudo 调度器利用授权、重复守卫和捕获操作都没有运行时成本的优势，在结果调度程序中，至少在我看来，很好地因素了一个有些复杂的调度过程。方法调度有多个切入点：普通无聊的 <code>$obj.meth()</code>，限定的 <code>$obj.Type::meth()</code>，以及调用我也许 <code>$obj.?meth()</code>。这些都有共同的 resume 语义 - 或者至少，只要我们在 resume 初始化状态中始终携带一个起始类型，也就是我们做方法调度的对象的类型，就可以使它们成为。</p>
<p>这里是普通方法调度的切入点，去掉了报告缺失方法错误的无聊细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># A standard method call of the form $obj.meth($arg); also used for the</span>
<span class="c1"># indirect form $obj.&#34;$name&#34;($arg). It receives the decontainerized invocant,</span>
<span class="c1"># the method name, and the the args (starting with the invocant including any</span>
<span class="c1"># container).</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-meth-call</span><span class="p">&#39;</span><span class="o">,</span> <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
    <span class="c1"># Try to resolve the method call using the MOP.</span>
    <span class="k">my</span> <span class="nv">$obj</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">my</span> <span class="nb">str</span> <span class="nv">$name</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg_s</span><span class="p">(</span><span class="nv">$capture</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$meth</span> <span class="o">:=</span> <span class="nv">$obj</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">find_method</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="nv">$name</span><span class="p">);</span>
 
    <span class="c1"># Report an error if there is no such method.</span>
    <span class="k">unless</span> <span class="nf">nqp::isconcrete</span><span class="p">(</span><span class="nv">$meth</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">!!!</span> <span class="p">&#39;</span><span class="s1">Error reporting logic elided for brevity</span><span class="p">&#39;;</span>
    <span class="p">}</span>
 
    <span class="c1"># Establish a guard on the invocant type and method name (however the name</span>
    <span class="c1"># may well be a literal, in which case this is free).</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-type</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">1</span><span class="p">));</span>
 
    <span class="c1"># Add the resolved method and delegate to the resolved method dispatcher.</span>
    <span class="k">my</span> <span class="nv">$capture-delegate</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$meth</span><span class="p">);</span>
    <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span>
        <span class="p">&#39;</span><span class="s1">raku-meth-call-resolved</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture-delegate</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div><p>现在是解析方法 dispatcher，也就是处理恢复的地方。首先，让我们看看正常的 dispatch 回调（恢复回调是包含的，但是是空的，我稍后会展示它）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Resolved method call dispatcher. This is used to call a method, once we have</span>
<span class="c1"># already resolved it to a callee. Its first arg is the callee, the second and</span>
<span class="c1"># third are the type and name (used in deferral), and the rest are the args to</span>
<span class="c1"># the method.</span>
<span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-meth-call-resolved</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="c1"># Initial dispatch</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="c1"># Save dispatch state for resumption. We don&#39;t need the method that will</span>
        <span class="c1"># be called now, so drop it.</span>
        <span class="k">my</span> <span class="nv">$resume-capture</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-init-args</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$resume-capture</span><span class="p">);</span>
 
        <span class="c1"># Drop the dispatch start type and name, and delegate to multi-dispatch or</span>
        <span class="c1"># just invoke if it&#39;s single dispatch.</span>
        <span class="k">my</span> <span class="nv">$delegate_capture</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$capture</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$method</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$delegate_capture</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$method</span><span class="o">,</span> <span class="nb">Routine</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$method</span><span class="o">.</span><span class="nf">is_dispatcher</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$delegate_capture</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-invoke</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$delegate_capture</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="o">,</span>
    <span class="c1"># Resumption</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="o">...</span> <span class="p">&#39;</span><span class="s1">Will be shown later</span><span class="p">&#39;;</span>
    <span class="p">});</span>
</code></pre></div><p>raku-meth-call 中有一个可以论证的欺骗：它实际上并没有插入调用者的类型对象来代替调用者。事实证明，这并不重要。否则，我认为注释（在真正的实现中也可以找到）很好地说明了这个问题。</p>
<p>有一个重要的点可能并不清楚 - 但遵循了一个重复的主题 - 那就是恢复初始化状态的设置也更多的是一种声明式而不是命令式的东西：在调度的时候并没有运行时成本，而是我们在周围保留了足够的信息，以便能够在我们需要的时候重建恢复初始化状态。事实上，当我们处于恢复的运行阶段时，我们甚至不需要在创建捕获对象的意义上重建它）。</p>
<p>现在说说复盘。我将介绍一个严重简化的版本，它只处理 callsame 语义（完整的东西也要处理 lastcall 和 nextcallee 这样的乐趣）。resume 初始化状态的存在是为了给 resumption 过程播种。一旦我们知道我们实际上确实要处理恢复，我们就可以做一些事情，比如计算我们想要走过的继承图中的全部方法列表。每个可恢复的调度器在调用栈上得到一个单一的存储槽，它可以用于它的状态。它可以在恢复的第一步中初始化这个，然后在我们走的时候更新它。或者更准确的说，它可以设置一个调度程序，在运行时就会这样做。</p>
<p>对于我们将要走过的候选链来说，链接列表原来是一个非常方便的数据结构。我们可以通过跟踪当前节点来完成链接列表的工作，也就是说只需要有一个东西发生突变，也就是当前调度的状态。调度程序机制还提供了一种从对象中读取属性的方法，这就足以将遍历链接列表表达到调度程序中。这也意味着零分配。</p>
<p>所以，不多说了，下面是链接列表（在 NQP 这个受限的 Raku 子集中，相当不如在完整的 Raku 中漂亮）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># A linked list is used to model the state of a dispatch that is deferring</span>
<span class="c1"># through a set of methods, multi candidates, or wrappers. The Exhausted class</span>
<span class="c1"># is used as a sentinel for the end of the chain. The current state of the</span>
<span class="c1"># dispatch points into the linked list at the appropriate point; the chain</span>
<span class="c1"># itself is immutable, and shared over (runtime) dispatches.</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">DeferralChain</span> <span class="p">{</span>
    <span class="k">has</span> <span class="nv">$!code</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">$!next</span><span class="p">;</span>
    <span class="k">method</span> <span class="nb">new</span><span class="p">(</span><span class="nv">$code</span><span class="o">,</span> <span class="nv">$next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$obj</span> <span class="o">:=</span> <span class="nf">nqp::create</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
        <span class="nf">nqp::bindattr</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!code</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$code</span><span class="p">);</span>
        <span class="nf">nqp::bindattr</span><span class="p">(</span><span class="nv">$obj</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!next</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$next</span><span class="p">);</span>
        <span class="nv">$obj</span>
    <span class="p">}</span>
    <span class="k">method</span> <span class="nb">code</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$!code</span> <span class="p">}</span>
    <span class="k">method</span> <span class="nb">next</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$!next</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">my</span> <span class="k">class</span> <span class="nc">Exhausted</span> <span class="p">{};</span>
</code></pre></div><p>最后是恢复处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-register</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-meth-call-resolved</span><span class="p">&#39;</span><span class="o">,</span>
    <span class="c1"># Initial dispatch</span>
    <span class="k">-&gt;</span> <span class="nv">$capture</span> <span class="p">{</span>
        <span class="o">...</span> <span class="p">&#39;</span><span class="s1">Presented earlier;
</span><span class="s1">    },
</span><span class="s1">    # Resumption. The resume init capture</span><span class="p">&#39;</span><span class="k">s</span> <span class="err">first</span> <span class="err">two</span> <span class="err">arguments</span> <span class="err">are</span> <span class="err">the</span> <span class="err">type</span>
    <span class="p">#</span><span class="sr"> that we initially did a method dispatch against and the method name
</span><span class="sr">    </span><span class="p">#</span><span class="s2"> respectively.
</span><span class="s2">    -&gt; </span><span class="nv">$capture</span><span class="s2"> {
</span><span class="s2">        </span><span class="p">#</span> <span class="n">Work</span> <span class="n">out</span> <span class="n">the</span> <span class="nb">next</span> <span class="k">method</span> <span class="nb">to</span> <span class="n">call</span><span class="o">,</span> <span class="k">if</span> <span class="nb">any</span><span class="o">.</span> <span class="n">This</span> <span class="n">depends</span> <span class="n">on</span> <span class="k">if</span> <span class="n">we</span> <span class="n">have</span>
        <span class="c1"># an existing dispatch state (that is, a method deferral is already in</span>
        <span class="c1"># progress).</span>
        <span class="k">my</span> <span class="nv">$init</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-get-resume-init-args</span><span class="p">&#39;);</span>
        <span class="k">my</span> <span class="nv">$state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-get-resume-state</span><span class="p">&#39;);</span>
        <span class="k">my</span> <span class="nv">$next_method</span><span class="p">;</span>
        <span class="k">if</span> <span class="nf">nqp::isnull</span><span class="p">(</span><span class="nv">$state</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1"># No state, so just starting the resumption. Guard on the</span>
            <span class="c1"># invocant type and name.</span>
            <span class="k">my</span> <span class="nv">$track_start_type</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$init</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-type</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_start_type</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">$track_name</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$init</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_name</span><span class="p">);</span>
 
            <span class="c1"># Also guard on there being no dispatch state.</span>
            <span class="k">my</span> <span class="nv">$track_state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-resume-state</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_state</span><span class="p">);</span>
 
            <span class="c1"># Build up the list of methods to defer through.</span>
            <span class="k">my</span> <span class="nv">$start_type</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg</span><span class="p">(</span><span class="nv">$init</span><span class="o">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">my</span> <span class="nb">str</span> <span class="nv">$name</span> <span class="o">:=</span> <span class="nf">nqp::captureposarg_s</span><span class="p">(</span><span class="nv">$init</span><span class="o">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">@mro</span> <span class="o">:=</span> <span class="nf">nqp::can</span><span class="p">(</span><span class="nv">$start_type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">mro_unhidden</span><span class="p">&#39;)</span>
                <span class="o">??</span> <span class="nv">$start_type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nf">mro_unhidden</span><span class="p">(</span><span class="nv">$start_type</span><span class="p">)</span>
                <span class="o">!!</span> <span class="nv">$start_type</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">mro</span><span class="p">(</span><span class="nv">$start_type</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">@methods</span><span class="p">;</span>
            <span class="k">for</span> <span class="nv">@mro</span> <span class="p">{</span>
                <span class="k">my</span> <span class="nv">%mt</span> <span class="o">:=</span> <span class="nf">nqp::hllize</span><span class="p">(</span><span class="nv">$_</span><span class="o">.</span><span class="nb">HOW</span><span class="o">.</span><span class="nb">method_table</span><span class="p">(</span><span class="nv">$_</span><span class="p">));</span>
                <span class="k">if</span> <span class="nf">nqp::existskey</span><span class="p">(</span><span class="nv">%mt</span><span class="o">,</span> <span class="nv">$name</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nv">@methods</span><span class="o">.</span><span class="nb">push</span><span class="p">(</span><span class="nv">%mt</span><span class="p">{</span><span class="nv">$name</span><span class="p">});</span>
                <span class="p">}</span>
            <span class="p">}</span>
 
            <span class="c1"># If there&#39;s nothing to defer to, we&#39;ll evaluate to Nil (just don&#39;t set</span>
            <span class="c1"># the next method, and it happens below).</span>
            <span class="k">if</span> <span class="nf">nqp::elems</span><span class="p">(</span><span class="nv">@methods</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="c1"># We can defer. Populate next method.</span>
                <span class="nv">@methods</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span> <span class="c1"># Discard the first one, which we initially called</span>
                <span class="nv">$next_method</span> <span class="o">:=</span> <span class="nv">@methods</span><span class="o">.</span><span class="nb">shift</span><span class="p">;</span> <span class="c1"># The immediate next one</span>
 
                <span class="c1"># Build chain of further methods and set it as the state.</span>
                <span class="k">my</span> <span class="nv">$chain</span> <span class="o">:=</span> <span class="n">Exhausted</span><span class="p">;</span>
                <span class="k">while</span> <span class="nv">@methods</span> <span class="p">{</span>
                    <span class="nv">$chain</span> <span class="o">:=</span> <span class="n">DeferralChain</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="nv">@methods</span><span class="o">.</span><span class="nb">pop</span><span class="o">,</span> <span class="nv">$chain</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-state-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$chain</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">elsif</span> <span class="o">!</span><span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$state</span><span class="o">,</span> <span class="n">Exhausted</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1"># Already working through a chain of method deferrals. Obtain</span>
            <span class="c1"># the tracking object for the dispatch state, and guard against</span>
            <span class="c1"># the next code object to run.</span>
            <span class="k">my</span> <span class="nv">$track_state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-resume-state</span><span class="p">&#39;);</span>
            <span class="k">my</span> <span class="nv">$track_method</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-attr</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nv">$track_state</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!code</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_method</span><span class="p">);</span>
 
            <span class="c1"># Update dispatch state to point to next method.</span>
            <span class="k">my</span> <span class="nv">$track_next</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-attr</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nv">$track_state</span><span class="o">,</span> <span class="n">DeferralChain</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">$!next</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-set-resume-state</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_next</span><span class="p">);</span>
 
            <span class="c1"># Set next method, which we shall defer to.</span>
            <span class="nv">$next_method</span> <span class="o">:=</span> <span class="nv">$state</span><span class="o">.</span><span class="nb">code</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1"># Dispatch already exhausted; guard on that and fall through to returning</span>
            <span class="c1"># Nil.</span>
            <span class="k">my</span> <span class="nv">$track_state</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-track-resume-state</span><span class="p">&#39;);</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-guard-literal</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$track_state</span><span class="p">);</span>
        <span class="p">}</span>
 
        <span class="c1"># If we found a next method...</span>
        <span class="k">if</span> <span class="nf">nqp::isconcrete</span><span class="p">(</span><span class="nv">$next_method</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1"># Call with same (that is, original) arguments. Invoke with those.</span>
            <span class="c1"># We drop the first two arguments (which are only there for the</span>
            <span class="c1"># resumption), add the code object to invoke, and then leave it</span>
            <span class="c1"># to the invoke or multi dispatcher.</span>
            <span class="k">my</span> <span class="nv">$just_args</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-drop-arg</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$init</span><span class="o">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">,</span>
                <span class="mi">0</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">$delegate_capture</span> <span class="o">:=</span> <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span> <span class="nv">$just_args</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">$next_method</span><span class="p">);</span>
            <span class="k">if</span> <span class="nf">nqp::istype</span><span class="p">(</span><span class="nv">$next_method</span><span class="o">,</span> <span class="nb">Routine</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nv">$next_method</span><span class="o">.</span><span class="nf">is_dispatcher</span> <span class="p">{</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-multi</span><span class="p">&#39;</span><span class="o">,</span>
                        <span class="nv">$delegate_capture</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">raku-invoke</span><span class="p">&#39;</span><span class="o">,</span>
                        <span class="nv">$delegate_capture</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1"># No method, so evaluate to Nil (boot-constant disregards all but</span>
            <span class="c1"># the first argument).</span>
            <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-delegate</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">boot-constant</span><span class="p">&#39;</span><span class="o">,</span>
                <span class="nf">nqp::dispatch</span><span class="p">(&#39;</span><span class="s1">boot-syscall</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">&#39;</span><span class="s1">dispatcher-insert-arg-literal-obj</span><span class="p">&#39;</span><span class="o">,</span>
                    <span class="nv">$capture</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="nb">Nil</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">});</span>
</code></pre></div><p>这是相当多的内容，也是相当多的代码。但请记住，这只是运行在调度恢复的记录阶段。它还会在 callsame 的 callsite 产生一个调度程序，并带有通常的守卫和结果。隐式守卫是为我们在该点恢复的调度程序创建的。在最常见的情况下，这最终将是单形或双形的，尽管涉及多个调度或方法调度的嵌套的情况可能会产生一个更有形态的 callsite。</p>
<p>我选取的设计迫使 resume 回调处理两种情况：第一次复用和后一次复用。这在几个方面都不理想。</p>
<p>这对那些编写调度简历回调的人来说有点不方便。然而，这又不是特别常见的活动!</p>
<p>这种差异导致两个调度程序堆积在一个调用点，而在其他情况下，这个调用点可能只得到一个
只有其中第二项真正重要。之所以不统一，是为了确保绝大多数从未恢复调度的电话，不会因其最终从未使用的功能而产生每次调度的费用。如果结果是使用该功能的人多花了一点成本，那就这样吧。事实上，早期的基准测试显示，使用新调度器的 callsame 与 wrap 和方法调用似乎比当前 Rakudo 中的速度快了 10 倍，这还没等专门人员对它有足够的了解，就已经进一步改进了!</p>
<h2 id="目前所做的事情">目前所做的事情</h2>
<p>我上面讨论的所有内容都已经实现了，只是我可能在某个地方给人的印象是，使用新的 dispatcher 已经完全实现了多重调度，而现在还不是这样（没有处理 where 子句，也不支持调度恢复）。</p>
<h2 id="今后的步骤">今后的步骤</h2>
<p>下一步显然是要完全实现多调度的缺失部分。另一个缺失的语义是对 callwith 和 nextwith 的支持，当我们希望改变移动到下一个候选人时使用的参数。抛开其他一些小问题不谈，理论上来说，这至少可以让所有的 Raku 调度语义得到支持。</p>
<p>目前，所有的标准方法调用（$obj.meth()）和其他调用（foo()和$foo()）都会通过现有的调度机制，而不是新的调度器。这些也需要迁移到新的调度器上，而且任何发现的错误都需要修复。这将使事情达到新调度器在语义上已经准备好的程度。</p>
<p>之后是性能工作：确保专用器能够处理调度程序的防护和结果。最初的目标是，让常见调用形式的稳态性能至少与当前乐道主分支中的性能相同。已经很清楚了，对于一些到目前为止还很冰冷的东西来说，会有一些大的胜利，但它不应该以最常见的调度种类的退步为代价，因为这些调度种类之前已经得到了大量的优化努力。</p>
<p>此外，NQP - 乐道编译器和运行时内脏的其他位写的乐的限制形式 - 也需要迁移到使用新的调度器。只有做到这一点，才有可能从 MoarVM 中扯出当前的方法缓存、多调度缓存等。</p>
<p>一个悬而未决的问题是，如何处理 MoarVM 以外的后端。理想情况下，新的调度机制将被移植到这些地方。相当多的内容应该可以用 JVM 的 invokedynamic 来表达（而这一切可能会在基于 Truffle 的 Raku 实现中发挥得相当好，尽管我不确定目前是否有这方面的积极努力）。</p>
<h2 id="未来的机会">未来的机会</h2>
<p>虽然我目前的重点是发布一个使用新调度机制的 Rakudo 和 MoarVM 版本，但这不会是旅程的终点。一些眼前的想法。</p>
<ul>
<li>对角色的方法调用需要把角色打入一个类中， 所以方法查找会返回一个闭包来完成这个任务并替换调用者。这是一个很大的间接性；新的调度者可以获得 pun，并产生一个调度程序，用 punn 化的类类型对象替换角色类型对象，这将使每次调用的成本大大降低。</li>
<li>我期望使用新的 dispatcher 可以使句柄（dlegated）和 fallback（处理缺失的方法调用）机制都能有更好的表现</li>
<li>当前的 assuming - 用于为例程讨价还价或其他首要参数 - 的实现并不理想，利用新调度器的参数重写能力的实现可能会有更好的表现。
在新的调度机制的帮助下，一些新的语言功能也可能以高效的方式提供。例如，目前没有一种可靠的方式来尝试调用一段代码，如果签名绑定了就运行它，如果没有绑定就做其他事情。相反，像 Cro 路由器这样的东西，必须先做签名的试绑定，然后再做调用，这使得路由的成本相当高。还有一个建议已久的想法，就是通过签名与 <code>when</code> 构造提供模式匹配 (例如，<code>when * -&gt; ($x) {}; when * -&gt; ($x, *@tail) { }</code>)，这和需求差不多，只是在一个不太动态的环境下。</li>
</ul>
<h2 id="最后">最后&hellip;</h2>
<p>在新的调度机制上的工作比我最初预期的历程要长。设计的恢复部分特别具有挑战性，而且还有一些重要的细节需要处理。一路走来，大概有四种潜在的方法被抛弃了（虽然其中的元素都影响了我在这篇文章中描述的内容）。能坚持下来的抽象真的非常非常难。</p>
<p>我最终也不得不从根本上离开几个月做 Raku 工作，在其他一些工作中感觉有点被压垮了，并且一直在与同样重要的 RakuAST 项目（它将因为能够承担新的调度器的存在而被简化，并且还为我提供了一系列更柔和的 Raku 黑客任务，而调度器的工作提供了很少的轻松选择）。</p>
<p>鉴于这些，我很高兴终于看到了隧道尽头的光亮。剩下的工作是数不胜数的，而我们使用新的调度器发布 Rakudo 和 MoarVM 的那一天，感觉还需要几个月的时间（我希望写下这句话不是在诱惑命运！）。</p>
<p>新的调度器可能是 MoarVM 自我创建以来最重要的变化，因为它看到我们删除了一堆从一开始就存在的东西。RakuAST 也将为 Rakudo 编译器带来十年来最大的架构变化。两者都是一个机会，将多年来学习的东西硬生生地折合到运行时和编译器中。我希望再过十年，当我回顾这一切的时候，至少会觉得自己这次犯了更多有趣的错误。</p>
<p>原文链接: <a href="https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/">https://6guts.wordpress.com/2021/03/15/towards-a-new-general-dispatch-mechanism-in-moarvm/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[为最年轻的 Raku 贡献力量]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-01-30-caesarean-substrings-with-raku-and-perl/?utm_source=atom_feed" rel="related" type="text/html" title="Caesarean Substrings With Raku and Perl" />
                <link href="https://ohmyweekly.github.io/notes/2021-02-07-if-sets-would-dwim/?utm_source=atom_feed" rel="related" type="text/html" title="如果集合如我所想" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-02-16T00:00:00+08:00</published>
            <updated>2021-02-16T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Contributing to Raku</blockquote><p>在过去的几周里，我看到了一些<a href="https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/">文章</a>和<a href="https://youtu.be/GAqfMNB-YBU">视频</a>，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文<a href="http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg">Raku 是我的 MMORPG</a>。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 <a href="https://raku.org/">Raku</a> 编程语言的法师。</p>
<h2 id="选择一个任务">选择一个任务</h2>
<p>让我们挑选一些编译器的 bug，并修复它。让我们去 <a href="https://rakudo.org/">Rakudo</a> 编译器 <a href="https://github.com/rakudo/rakudo/issues">issues</a>中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究<a href="https://www.apress.com/gp/book/9781484232279">编译器语法</a>，看了一本这方面的好书。找到了四个问题。</p>
<p><img src="https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png" alt="img"></p>
<ol>
<li>标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。</li>
<li>标签 &ldquo;需要共识&rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。</li>
<li>标签为 &ldquo;grammar and actions&rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。</li>
</ol>
<p>任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。</p>
<h2 id="建立工作环境">建立工作环境</h2>
<p>为源码和我们建立的编译器建立文件夹。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir ~/dev-rakudo <span class="o">&amp;&amp;</span> mkdir ~/dev-rakudo-install
</code></pre></div><p>Rakudo 编译器由三部分组成。</p>
<ol>
<li>虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。</li>
<li>NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &ldquo;子集&rdquo;。虚拟机可以执行用 NQP 编写的代码。</li>
<li>Rakudo 编译器本身，用 NQP 和 Raku 编写。</li>
</ol>
<p>下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:MoarVM/MoarVM.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:Raku/nqp.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> nqp
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install

<span class="nb">cd</span> ~/dev-rakudo <span class="o">&amp;&amp;</span> git clone git@github.com:rakudo/rakudo.git <span class="o">&amp;&amp;</span> <span class="nb">cd</span> rakudo
perl Configure.pl --backend<span class="o">=</span>moar --prefix ~/dev-rakudo-install <span class="o">&amp;&amp;</span> make -j <span class="m">4</span> <span class="o">&amp;&amp;</span> make install
</code></pre></div><p>注意参数。<code>--prefix</code> 显示了 <code>make install</code> 命令后可执行文件的复制位置，<code>--backend=moar</code> 表示正在使用的虚拟机，而 <code>-j 4</code> 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 <code>~/dev-rakudo-install/bin/raku</code>。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/dev-rakudo/rakudo <span class="o">&amp;&amp;</span> git clone https://github.com/Raku/roast.git t/spec
</code></pre></div><p>我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。</p>
<p>这里和下面我将在 <code>~/dev-rakudo/rakudo</code> 文件夹中工作，除非另有说明。</p>
<pre><code>&gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
</code></pre><p>14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!</p>
<h2 id="让我们来看看问题的陈述">让我们来看看问题的陈述</h2>
<p>问题陈述说，某个元运算符 <code>R</code> 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Output: True</span>
</code></pre></div><p>Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 <code>:foo(42)</code> 是一个名称为 <code>foo</code>、值为 <code>42</code> 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-named-parameter</span><span class="p">(</span><span class="o">:</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Output: 42</span>
</code></pre></div><p>如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 没有冒号</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1"># Unexpected named argument &#39;foo&#39; passed</span>
</code></pre></div><p>如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-without-named-parameter</span><span class="p">(</span><span class="nv">$foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">say</span> <span class="nv">$foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-without-named-parameter</span><span class="p">((:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">)));</span> <span class="c1"># Output: foo =&gt; 42</span>
</code></pre></div><p>在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sub-with-capture</span><span class="p">(</span><span class="o">|</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span> <span class="c1"># &lt;- 参数捕获</span>
  <span class="nb">say</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>     <span class="c1"># Output: \(:foo(42))</span>
<span class="nf">sub-with-capture</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>           <span class="c1"># Output: \(42)</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">Z</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(:foo((1,).Seq))</span>
<span class="nf">sub-with-capture</span><span class="p">(:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span> <span class="c1"># Output: \(-1)</span>
</code></pre></div><p>倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。</p>
<p>在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。</p>
<h2 id="我们需要一个新的测试">我们需要一个新的测试</h2>
<p>为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（<a href="https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t">S03-metops/reverse.t</a>）。下面我将补充以下测试。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># https://github.com/rakudo/rakudo/issues/1632</span>
<span class="p">{</span>
  <span class="k">sub</span> <span class="nf">subroutine</span><span class="p">(</span><span class="nv">$expected</span><span class="o">,</span> <span class="o">|</span><span class="n">actual</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">is</span> <span class="nc">actual</span><span class="o">.</span><span class="nb">gist</span><span class="o">,</span> <span class="nv">$expected</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">Сolonpair exists</span><span class="p">&#34;</span>
  <span class="p">}</span>

  <span class="nf">subroutine</span><span class="p">(&#39;</span><span class="s1">\(:foo(-1))</span><span class="p">&#39;</span><span class="o">,</span> <span class="p">:</span><span class="s">foo</span><span class="p">(</span><span class="mi">3</span> <span class="ow">R</span><span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div><p>该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 <code>make</code> 对新构建的编译器进行单独测试。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test 'Colonpair exists'
# at t/spec/S03-metaops/reverse.t line 191
# expected: '\(:foo(-1))'
#      got: '\(-1)'
# You planned 69 tests, but ran 70
# You failed 1 test of 70
</code></pre><p>你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 <code>plan</code> 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。</p>
<h2 id="凝视法">凝视法</h2>
<p>一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：</p>
<ol>
<li>基础解析器代码在文件 <code>rakudo/src/Perl6/Grammar.nqp</code> 中。</li>
<li>这个解析器是从 <code>nqp/src/HLL/Grammar.nqp</code> 文件中的基础解析器继承的。</li>
<li>元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。</li>
</ol>
<p>我在基础解析器代码中找到了对元操作符的引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;R&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">R</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">reverse the args of</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nv">O</span><span class="o">=.</span><span class="nf">revO</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="p">)&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>

<span class="k">token</span> <span class="nf">infix_prefix_meta_operator:sym</span>&lt;Z&gt; <span class="p">{</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="nf">sym</span><span class="p">&gt;</span><span class="sr"> </span><span class="p">&lt;</span><span class="nf">infixish</span><span class="p">(&#39;</span><span class="s1">Z</span><span class="p">&#39;)&gt;</span><span class="sr"> </span><span class="p">{}</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="o">.</span><span class="nf">can_meta</span><span class="p">(</span><span class="nv">$&lt;infixish&gt;</span><span class="o">,</span> <span class="p">&#34;</span><span class="s2">zip with</span><span class="p">&#34;)&gt;</span><span class="sr">
</span><span class="sr">  </span><span class="p">&lt;</span><span class="sr">O(|</span><span class="nv">%list_infix</span><span class="sr">)</span><span class="p">&gt;</span><span class="sr">
</span><span class="sr"></span><span class="p">}</span>
</code></pre></div><p>这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 <code>my $r = :foo(3 R- 2); say $r; # Output: foo =&gt; -1</code> 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。</p>
<h2 id="编译器将帮助我们">编译器将帮助我们</h2>
<p>颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 <code>--target</code> 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 <code>--target=parse</code>（因为我只知道这一个）。</p>
<p>我从 <code>~/dev-rakudo/rakudo</code> 文件夹中使用 <code>rakumo-m</code>，这样我就不必等待通过 <code>make install</code> 命令将所需文件复制到 <code>~/dev-rakudo-install</code>。简单的脚本可以这样运行。更复杂的脚本必须在 <code>make install</code> 之后从 <code>-install</code> 中运行。</p>
<pre><code>&gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
</code></pre><p>结论：R 和 Z 的解析是一样的。</p>
<h2 id="这不是解析">这不是解析</h2>
<p>所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 <code>rakudo/src/Perl6/Actions.nqp</code> 和 <code>nqp/src/HLL/Actions.nqp</code> 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。</p>
<p>我在主 Actions 中找到了以下代码。</p>
<pre><code>[...]
elsif $&lt;infix_prefix_meta_operator&gt; {
[...]
  if    $metasym eq 'R' { $helper := '&amp;METAOP_REVERSE'; $t := nqp::flip($t) if $t; }
  elsif $metasym eq 'X' { $helper := '&amp;METAOP_CROSS'; $t := nqp::uc($t); }
  elsif $metasym eq 'Z' { $helper := '&amp;METAOP_ZIP'; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&lt;call&gt;, :name($helper), WANTED($basepast,'infixish') );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&lt;OPER&gt;&lt;O&gt;.made)), :scope&lt;lexical&gt;))
    if $metasym eq 'X' || $metasym eq 'Z';
[...]
</code></pre><p>它说，如果在代码中解析了元操作符 <code>R</code>、<code>Z</code> 或 <code>X</code>，就应该在语法树中添加一些 <code>METAOP_</code> 函数调用。在 <code>Z</code> 和 <code>X</code> 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 <code>rakudo/src/core.c/metaops.pm6</code> 中找到。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">sub</span> <span class="nf">METAOP_ZIP</span><span class="p">(</span>\<span class="n">op</span><span class="o">,</span> <span class="nv">&amp;reduce</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
 <span class="nf">nqp::if</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="nf">prec</span><span class="p">(&#39;</span><span class="s1">thunky</span><span class="p">&#39;)</span><span class="o">.</span><span class="nb">starts-with</span><span class="p">(&#39;</span><span class="s1">.</span><span class="p">&#39;)</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$arity</span> <span class="o">=</span> <span class="n">lol</span><span class="o">.</span><span class="nb">elems</span><span class="p">;</span>
    <span class="o">[...]</span>
  <span class="p">}</span><span class="o">,</span>
  <span class="k">-&gt;</span> <span class="o">+</span><span class="n">lol</span> <span class="p">{</span>
    <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">Rakudo::Iterator</span><span class="o">.</span><span class="nf">ZipIterablesOp</span><span class="p">(</span><span class="n">lol</span><span class="o">,</span><span class="n">op</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>给你：</p>
<ol>
<li><code>\op</code> 是由我们的元操作符，即-，在前面的操作。</li>
<li>Trait <code>implementation-detail</code> 只是表明这不是公共代码，是编译器实现的一部分。</li>
<li>由于-操作没有笨重的特性，所以 <code>&amp;reduce</code> 函数不会参与计算，<code>Z</code> 的结果是 <code>Seq.new(...)</code>。</li>
<li><code>R</code> 的结果是一个操作调用 - 参数顺序相反。</li>
</ol>
<p>这时我想起还有一个 - 目标，即星。它将显示行动的结果。</p>
<pre><code>&gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(call &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>一如所料。除了调用不同的 <code>METAOP_</code> 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 <code>Int</code> 和 <code>Seq</code>。众所周知，Raku 对不同类型的对象的上下文相当敏感&hellip;&hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">Seq</span><span class="o">.</span><span class="nb">new</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="p">(</span><span class="o">|</span><span class="nb">args</span><span class="o">.</span><span class="nb">reverse</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>一切都没有改变。所以，不是返回值&hellip;&hellip;想了想，不知道为什么结果又是 <code>-1</code> 而不是 <code>(-1,).Seq</code>。而且，从代码来看，<code>Seq</code> 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 <code>METAOP_REVERSE</code> 结果只是为了崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">METAOP_REVERSE</span><span class="p">(</span>\<span class="n">op</span><span class="p">)</span> <span class="k">is</span> <span class="nc">implementation-detail</span> <span class="p">{</span>
  <span class="k">-&gt;</span> <span class="o">|</span><span class="nb">args</span> <span class="p">{</span> <span class="nb">die</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>编译、运行。</p>
<pre><code>&gt; make
[...]
&gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
</code></pre><p>怎么会呢？语法树中包含了对 <code>METAOP_REVERSE</code> 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 <code>-1</code>。</p>
<p>这些都不是《行动》。</p>
<p>这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 <code>--target=mast</code>。</p>
<pre><code>&gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&lt;s&gt;, cuuid&lt;1&gt;
  Local types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;int&gt;, 5&lt;str&gt;, 6&lt;obj&gt;, 7&lt;obj&gt;, 8&lt;obj&gt;,
  Lexical types: 0&lt;obj&gt;, 1&lt;obj&gt;, 2&lt;obj&gt;, 3&lt;obj&gt;, 4&lt;obj&gt;,
  Lexical names: 0&lt;c&gt;, 1&lt;$¢&gt;, 2&lt;$!&gt;, 3&lt;$/&gt;, 4&lt;$*DISPATCHER&gt;,
  Lexical map: $!&lt;2&gt;, c&lt;0&gt;, $*DISPATCHER&lt;4&gt;, $¢&lt;1&gt;, $/&lt;3&gt;,
  Outer: name&lt;&lt;unit&gt;&gt;, cuuid&lt;2&gt;
[...]
</code></pre><p>某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。</p>
<pre><code>&gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;7&gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;8&gt; :before_promotion&lt;?&gt; Z-
    - QAST::Op(callstatic &amp;METAOP_ZIP) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
      - QAST::Var(lexical &amp;METAOP_REDUCE_LEFT)
    - QAST::Want &lt;wanted&gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &lt;wanted&gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
</code></pre><p>哈，就是这样。在优化阶段后，行将失踪。</p>
<ul>
<li><code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-.</code>
并将整个 <code>METAOP_REVERSE</code> 调用替换为通常的操作 <code>(&amp;infix:&lt;-&gt;)</code>。所以问题一定在优化器的某个地方。</li>
</ul>
<p>只有在 <code>optim_nameless_call</code> 方法中才会提到 <code>&amp;METAOP_ASSIGN</code>，其中 <code>QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;)</code>。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 <code>_</code> 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
  }
[...]
</code></pre><p>让我提醒你，优化前的树是这样的。</p>
<pre><code>[...]
- QAST::Op(call &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&lt;foo&gt;) &lt;wanted&gt; :statement_id&lt;5&gt; :before_promotion&lt;?&gt; R-
    - QAST::Op(call &amp;METAOP_REVERSE) &lt;wanted&gt; :is_pure&lt;?&gt;
      - QAST::Var(lexical &amp;infix:&lt;-&gt;) &lt;wanted&gt;
    - QAST::Want &lt;wanted&gt; 3
    - QAST::Want &lt;wanted&gt; 2
[...]
</code></pre><p>而精简之后，是这样的。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;infix:&lt;-&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>也就是说，优化 <code>_nameless_call</code> 做了以下工作。</p>
<p>如果我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作没有三个参数，如果 <code>METAOP_REVERSE</code> 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 <code>QAST::Op+{QAST::SpecialArg}</code> 操作，以相反的顺序调用 <code>&amp;infix:&lt;-&gt;</code> 参数。就是说，把结果打包成一对就没了。</p>
<p>在摸索了一下如何解决这个问题，并阅读了 <code>QAST::SpecialArg</code> 和 <code>QAST::Node</code> 的实现后，我想到了下面的代码。</p>
<pre><code>[...]
  elsif self.op_eq_core($metaop, '&amp;METAOP_REVERSE') {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;&amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&lt;call&gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: 'METAOP_opt_result', 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
</code></pre><p>还有木头。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;infix:&lt;-&gt; :named&lt;foo&gt;)  :METAOP_opt_result&lt;?&gt;
    - QAST::Want &lt;wanted&gt; 2
    - QAST::Want &lt;wanted&gt; 3
[...]
</code></pre><p>命名的参数返回到它的位置。测试也开始通过。</p>
<pre><code>&gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
</code></pre><p>我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 <code>self.visit_op: $opt_result;</code>，对产生的非优化操作调用优化器，那么产生的树就会像这样。</p>
<pre><code>[...]
- QAST::Op(callstatic &amp;s) &lt;sunk&gt; :statement_id&lt;4&gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&lt;foo&gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&lt;foo&gt;)
    - QAST::IVal(-1)
[...]
</code></pre><p>现在一切都很理想。</p>
<h2 id="分享成果">分享成果</h2>
<p>我们已经到了终点线。现在我们只需要分享我们的经验。</p>
<ol>
<li>重要的是：运行所有的 <code>make spectest</code> 测试，确保没有新的东西被破坏。</li>
<li>在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。</li>
<li>将 fork 仓库添加为新的 git 远程仓库。</li>
<li>cd ~/dev-rakudo/rakudo &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
<li>cd ~/dev-rakudo/t/spec &amp;&amp; git remote add fork <!-- raw HTML omitted -->。</li>
</ol>
<p>重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。</p>
<p>提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。</p>
<p>运行提交。</p>
<pre><code>cd ~/dev-rakudo/rakudo &amp;&amp; git push fork
cd ~/dev-rakudo/t/spec &amp;&amp; git push fork
</code></pre><p>向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。</p>
<h2 id="结论">结论</h2>
<p>对开源软件的贡献是：</p>
<ol>
<li>趣味性和趣味性。</li>
<li>给你的感觉是，你正在做一些有用的事情，你真的是。</li>
<li>让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 <code>#raku IRC</code> 频道中得到回答）。</li>
<li>解决非标准任务，没有截止日期的压力，是一种很好的体验。</li>
</ol>
<p>选择你觉得最舒服的角色等级，去做新的任务吧!</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rakulang" term="rakulang" label="Rakulang" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[贪婪 Junction 的奇闻异事]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="related" type="text/html" title="重构 Raku 的 Junction" />
            
                <id>https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-10-04T00:00:00+08:00</published>
            <updated>2020-10-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>The Strange Case of the Greedy Junction</blockquote><h2 id="贪婪-junction-的奇闻异事">贪婪 junction 的奇闻异事</h2>
<p>说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。</p>
<p><a href="https://raku.org/">Raku</a> 有一个整洁的功能，叫做 <a href="https://docs.raku.org/type/Junction">Junction</a>。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 <code>pair</code> 数据结构，它可以接受两个不同类型的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">enum</span> <span class="n">RGB</span> <span class="p">&lt;</span><span class="s">R G B</span><span class="p">&gt;;</span>

<span class="c1"># Pair Constructor: the arguments of pair() are captured</span>
<span class="c1"># in a closure that is returned</span>
<span class="k">sub</span> <span class="nb">pair</span><span class="p">(</span>\<span class="nb">x</span><span class="o">,</span> \<span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="p">(</span><span class="nv">&amp;p</span><span class="p">){</span> <span class="nf">p</span><span class="p">(</span><span class="nb">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div><p>所以 <code>pair</code> 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 <code>pair</code> 中的值。我将把这些访问(accessor)函数称为 <code>fst</code> 和 <code>snd</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Accessors to get the values from the closure</span>
<span class="k">my</span> <span class="k">sub</span> <span class="nf">fst</span> <span class="p">(</span><span class="nv">&amp;p</span><span class="p">)</span> <span class="p">{</span><span class="nf">p</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="o">,</span>\<span class="n">y</span><span class="p">){</span><span class="nb">x</span><span class="p">})}</span>
<span class="k">my</span> <span class="k">sub</span> <span class="nf">snd</span> <span class="p">(</span><span class="nv">&amp;p</span><span class="p">)</span> <span class="p">{</span><span class="nf">p</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="o">,</span>\<span class="n">y</span><span class="p">){</span><span class="n">y</span><span class="p">})}</span>
</code></pre></div><p>做实际选择的函数是由 <code>fst</code> 和 <code>snd</code> 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 <code>pair</code>，而不是必须将它们作为参数传递。让我们看一个例子，一个 <code>Int</code> 和一个 <code>RGB</code> 的 pair。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">\p1</span> <span class="o">=</span> <span class="nb">pair</span> <span class="mi">42</span><span class="o">,</span> <span class="ow">R</span><span class="err">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="mi">42</span> <span class="o">==</span> <span class="n">fst</span> <span class="n">p1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="n">snd</span> <span class="n">p1</span><span class="p">;</span>	<span class="k">#=</span><span class="p">&gt;</span><span class="sd"> says &#34;R&#34;
</span><span class="sd">}
</span></code></pre></div><p>所以我们用两个值调用 <code>pair</code> 来创建一个 pair，并使用 <code>fst</code> 和 <code>snd</code> 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。</p>
<p>现在让我们使用 junction 作为其中一个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># Example instance with a &#39;one&#39;-type junction</span>
<span class="k">my</span> <span class="nb">Junction</span> \<span class="n">p1j</span> <span class="o">=</span> <span class="nb">pair</span> <span class="p">(</span><span class="mi">42</span><span class="o">^</span><span class="mi">43</span><span class="p">)</span><span class="o">,</span><span class="ow">R</span><span class="err">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="mi">42</span> <span class="o">==</span> <span class="n">fst</span> <span class="n">p1j</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="n">snd</span> <span class="n">p1j</span><span class="p">;</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> one(R, R)
</span><span class="sd">}
</span></code></pre></div><p>这里发生的情况是，原始参数 <code>R</code> 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 <code>R</code> 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章&quot;<a href="https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e">重构 Raku 的 Junction</a>&quot;。</p>
<p><a href="https://docs.raku.org/type/Junction">Raku 关于 junction 的文档</a>中说，你不应该真正尝试从 junction 中获取值。</p>
<p>&ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。&rdquo;</p>
<p>然而，有一个 FAQ <a href="https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)">勉强地告诉你如何做</a>。FAQ 再次警告不要这样做。</p>
<p>&ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。&rdquo;</p>
<p>然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。</p>
<p>因此，我建议增加一个折叠(<code>collapse</code>)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span> <span class="mi">42</span> <span class="o">==</span> <span class="n">fst</span> <span class="n">p1j</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="nf">collapse</span><span class="p">(</span><span class="n">snd</span> <span class="n">p1j</span><span class="p">);</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> says &#39;R&#39;
</span><span class="sd">}
</span></code></pre></div><p>该函数的实现取自<a href="https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)">上述常见问题</a>，并增加了一个检查，以确保 junction 上的所有值都相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">collapse</span><span class="p">(</span><span class="nb">Junction</span> \<span class="n">j</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">my</span> <span class="nv">@vvs</span><span class="p">;</span>
    <span class="k">-&gt;</span> <span class="nb">Any</span> \<span class="k">s</span> <span class="p">{</span><span class="sr"> push </span><span class="nv">@vvs</span><span class="sr">, s </span><span class="p">}</span><span class="o">.</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>    
    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span>  <span class="nb">shift</span> <span class="nv">@vvs</span><span class="p">;</span>        
    <span class="k">my</span> <span class="nv">@ts</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span><span class="o">!</span><span class="p">(</span><span class="nv">$_</span> <span class="o">~~</span> <span class="nv">$v</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@vvs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">@ts</span><span class="o">.</span><span class="nb">elems</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
        <span class="nv">$v</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Can&#39;t collapse this Junction: elements are not identical: </span><span class="p">{</span><span class="nv">$v</span><span class="o">,</span><span class="nv">@vvs</span><span class="p">}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果能把这个功能作为一个 <code>collapse</code> 方法添加到 <code>Junction</code> 类中就更好了。</p>
<p>原文链接: <a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/junction" term="junction" label="Junction" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[重构 Raku 的 Junction]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/?utm_source=atom_feed" rel="related" type="text/html" title="贪婪 Junction 的奇闻异事" />
            
                <id>https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-10-04T00:00:00+08:00</published>
            <updated>2020-10-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Reconstructing Raku&rsquo;s Junctions</blockquote><h2 id="重构-raku-的-junction">重构 Raku 的 Junction</h2>
<p>Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。</p>
<h3 id="raku-中的-junction">Raku 中的 Junction</h3>
<p><a href="https://docs.raku.org/">Raku</a> 有一个整洁的功能叫做 <a href="https://docs.raku.org/type/Junction">Junction</a>。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(<code>&amp;</code>)、any(<code>|</code>)、one(<code>^</code>) 或 <code>none</code> (空结点)。</p>
<p>例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">11</span><span class="o">|</span><span class="mi">22</span><span class="p">;</span> <span class="c1"># short for any(11,22)</span>
<span class="k">if</span> <span class="mi">33</span> <span class="o">==</span> <span class="nv">$j</span> <span class="o">+</span> <span class="mi">11</span> <span class="p">{</span>
    <span class="nb">say</span> <span class="p">&#39;</span><span class="s1">yes</span><span class="p">&#39;;</span>
<span class="p">}</span>

<span class="nb">say</span> <span class="nb">so</span> <span class="mi">3</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="nb">one</span><span class="p">;</span>         <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> True 
</span><span class="sd">say so (&#34;a&#34; ^ &#34;b&#34; ^ &#34;c&#34;) eq &#34;a&#34;; #=</span> <span class="nb">True</span>
</code></pre></div><p>函数 <code>so</code> 强制使用布尔上下文。</p>
<p>Junction 有 <code>Junction</code> 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 <code>sq</code> 从 <code>Int</code> 到 <code>Int</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sq</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="p">}</span>

<span class="k">my</span> <span class="nb">Int</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span> <span class="c1"># OK</span>
<span class="nb">say</span> <span class="nv">$res</span><span class="p">;</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> 121
</span></code></pre></div><p>现在让我们定义一个类型为任何 <code>Int</code> 值的 Junction。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">|</span> <span class="mi">22</span><span class="p">;</span> 
</code></pre></div><p>当我们将 <code>sq</code> 应用于 <code>$j</code> 时，我们没有得到一个类型错误，即使函数的类型是 <code>:(Int --&gt; Int)</code>，Junction 的类型是 <code>Junction</code>。相反，我们得到的是一个结果的 Junction。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">say</span> <span class="nf">sq</span><span class="p">(</span><span class="nv">$j</span><span class="p">);</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> any(121, 484)
</span></code></pre></div><p>如果我们像之前一样将其赋值给一个类型为 <code>Int</code> 的变量，我们会得到一个类型错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Int</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="nv">$j</span><span class="p">);</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd"> Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))
</span></code></pre></div><p>取而代之的是，现在返回值的类型为 <code>Junction</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="mi">11</span><span class="o">|</span><span class="mi">22</span><span class="p">);</span> <span class="c1"># OK</span>
</code></pre></div><p>所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。</p>
<p>另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 <code>Junction</code> 类型。例如，如果我们创建了一个由 <code>Str</code> 值组成的 Junction，并试图将这个 Junction 的值传递到 <code>sq</code> 中，我们会得到一个类型错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">$sj</span> <span class="o">=</span> <span class="p">&#39;</span><span class="s1">11</span><span class="p">&#39;</span> <span class="o">|</span> <span class="p">&#39;</span><span class="s1">22</span><span class="p">&#39;;</span>
<span class="nb">say</span> <span class="nv">$sj</span><span class="o">.</span><span class="nb">WHAT</span><span class="p">;</span> <span class="k">#=</span><span class="p">&gt;</span><span class="sd">(Junction)
</span><span class="sd">
</span><span class="sd">my Junction $svj = sq($sj); #=</span> <span class="n">Type</span> <span class="n">check</span> <span class="n">failed</span> <span class="nb">in</span> <span class="n">binding</span> <span class="nb">to</span> <span class="nb">parameter</span> <span class="p">&#39;</span><span class="s1">x</span><span class="p">&#39;;</span> <span class="nb">expected</span> <span class="nb">Int</span> <span class="k">but</span> <span class="nb">got</span> <span class="nb">Str</span> <span class="p">(&#34;</span><span class="s2">11</span><span class="p">&#34;)</span>
</code></pre></div><h3 id="junction-不遵循静态类型规则">Junction 不遵循静态类型规则</h3>
<p>虽然这样做是有道理的(如果原始函数期望使用 <code>Int</code>，我们不希望它与 <code>Str</code> 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 <code>Int</code>，那么可以使用类型图中低于它的任何类型来代替。但是 <code>Int</code> 和 <code>Junction</code> 的简化类型图如下。</p>
<pre><code>Int -&gt; Cool -&gt; Any -&gt; Mu &lt;- Junction
</code></pre>
<p>所以 Junction 永远不是 <code>Any</code> 以下任何东西的子类型。因此，将 Junction 放在类型为 <code>Any</code> 或其子类型的槽中应该是一个类型错误。</p>
<p>此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。</p>
<p>那么这里到底发生了什么？</p>
<h3 id="一个工作假设">一个工作假设</h3>
<p>一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。</p>
<h3 id="重构-junction-的第一部分类型">重构 Junction 的第一部分：类型</h3>
<p>让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。</p>
<h4 id="junction-类型">Junction 类型</h4>
<p>Junction 是一个由 Junction 类型 <code>JType</code> 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="n">data</span> <span class="n">JType</span> <span class="o">=</span> <span class="n">JAny</span> <span class="o">|</span> <span class="n">JAll</span> <span class="o">|</span> <span class="n">JOne</span> <span class="o">|</span> <span class="n">JNone</span>

<span class="n">data</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">Junction</span> <span class="n">JType</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
</code></pre></div><h4 id="应用结点">应用结点</h4>
<p>对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。</p>
<ul>
<li>将非 Junction 函数应用于 Junction 表达式</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span>•￮<span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="k">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="k">-&gt;</span>  <span class="nb">Junction</span> <span class="n">b</span>
</code></pre></div><ul>
<li>将 Junction 函数应用于非 Junction 表达式。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span>￮•<span class="p">)</span> <span class="o">::</span>  <span class="nb">Junction</span> <span class="p">(</span><span class="n">b</span> <span class="k">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">b</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="n">c</span>
</code></pre></div><ul>
<li>将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="p">(</span>￮￮<span class="p">)</span> <span class="o">::</span>  <span class="nb">Junction</span> <span class="p">(</span><span class="n">b</span> <span class="k">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="n">b</span> <span class="k">-&gt;</span> <span class="nb">Junction</span> <span class="p">(</span><span class="nb">Junction</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div><p>为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="o">--</span> <span class="ow">and</span> <span class="n">similar</span> <span class="k">for</span> <span class="o">/-,</span> <span class="o">&gt;,</span> <span class="o">&lt;,</span> <span class="p">&lt;</span><span class="s">=,</span><span class="p">&gt;</span><span class="o">=</span>
<span class="p">(</span>￮<span class="o">==</span>•<span class="p">)</span> <span class="o">::</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="k">-&gt;</span> <span class="n">a</span> <span class="k">-&gt;</span> <span class="nb">Bool</span>
</code></pre></div><h4 id="折叠-junction">折叠 Junction</h4>
<p>那么我们就有了 <code>so</code>，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nb">so</span> <span class="o">::</span> <span class="nb">Junction</span> <span class="nb">Bool</span> <span class="k">-&gt;</span> <span class="nb">Bool</span>
</code></pre></div><p>最后我们有 <code>collapse</code>，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="nf">collapse</span> <span class="o">::</span> <span class="p">(</span><span class="n">Show</span> <span class="n">a</span><span class="o">,</span><span class="n">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Junction</span> <span class="n">a</span> <span class="k">-&gt;</span> <span class="n">a</span>
</code></pre></div><p>这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在&quot;<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的奇怪情况</a>&ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。</p>
<h4 id="重新审视贪婪-junction-的奇怪情况">重新审视贪婪 Junction 的奇怪情况</h4>
<p>假设我们有一个两个参数的函数 <code>f :: a -&gt; b -&gt; c</code>，我们对第一个参数应用一个结点 <code>j :: Junction</code> a 应用到第一个参数 <code>f •￮ j</code> 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：<code>fp :: Junction b -&gt; c</code>。如果我们现在想用 <code>fp ￮• v</code> 将这个函数应用于一个非结点的值 <code>v :: b</code>，那么结果就是 <code>Junction c</code> 类型的。</p>
<p>现在，让我们考虑类型 <code>c</code> 是 <code>forall d . (a -&gt; b -&gt; d) -&gt; d</code> 的特殊情况。所以我们有 <code>Junction</code>(<code>forall d . (a-&gt;b-&gt;d) -&gt; d</code>)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 <code>forall</code>，所以 <code>d</code> 可以是任何东西，但在实践中我们希望它是 <code>a</code> 或 <code>b</code>。</p>
<p>假设我们将这个函数(称它为 <code>p</code>)应用于 <code>fst :: a-&gt;b-&gt;a</code>，使用 <code>p ￮• fst</code>，那么我们得到 <code>Junction a</code>。但是如果我们将它应用于 <code>snd :: a-&gt;b-&gt;b</code>，使用 <code>p ￮• snd</code>，那么我们得到 <code>Junction b</code>。</p>
<p>这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在&rdquo;<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的奇怪情况</a>&ldquo;中已经解释过。而这也是我们需要 <code>collapse</code> 函数的原因。</p>
<h4 id="重构-junction-的第2部分raku-的实现">重构 Junction 的第2部分：Raku 的实现。</h4>
<p>我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="c1"># The types of Junctions</span>
<span class="k">enum</span> <span class="n">JType</span> <span class="p">&lt;</span><span class="s">JAny  JAll  JOne  JNone </span><span class="p">&gt;;</span>

<span class="c1"># The actual Junction type</span>
<span class="k">role</span> <span class="nb">Junction</span><span class="o">[</span>\<span class="n">jt</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">]</span> <span class="p">{</span>
    <span class="k">has</span> <span class="n">JType</span> <span class="nv">$.junction-type</span><span class="o">=</span><span class="n">jt</span><span class="p">;</span>
    <span class="k">has</span> <span class="nv">@.values</span><span class="o">=</span><span class="nv">@vs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">our</span> <span class="k">sub</span> <span class="nf">all_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JAll</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">our</span> <span class="k">sub</span> <span class="nf">any_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JAny</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">our</span> <span class="k">sub</span> <span class="nf">one_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JOne</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">our</span> <span class="k">sub</span> <span class="nf">none_</span><span class="p">(</span><span class="nv">@vs</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">JNone</span><span class="o">,</span> <span class="nv">@vs</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>将一个（单参数）函数应用于 junction 参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">●○</span><span class="p">&gt;(</span> <span class="nv">&amp;f</span><span class="o">,</span> \<span class="n">j</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jt</span><span class="o">=</span><span class="n">j</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@vs</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
  
    <span class="nb">Junction</span><span class="o">[</span> <span class="n">jt</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">&amp;f</span><span class="p">(</span><span class="nv">$_</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@vs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>要将 Junction 内的函数应用于非 Junction 的参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">○●</span><span class="p">&gt;(</span> \<span class="n">jf</span><span class="o">,</span> \<span class="n">v</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jt</span><span class="o">=</span><span class="n">jf</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@fs</span> <span class="o">=</span> <span class="n">jf</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>

    <span class="nb">Junction</span><span class="o">[</span> <span class="n">jt</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="p">{</span><span class="nv">$_</span><span class="p">(</span> <span class="n">v</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@fs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s">○○</span><span class="p">&gt;(</span> \<span class="n">jf</span><span class="o">,</span> \<span class="n">jv</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jft</span><span class="o">=</span> <span class="n">jf</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@fs</span> <span class="o">=</span> <span class="n">jf</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">\jvt</span> <span class="o">=</span> <span class="n">jv</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@vs</span> <span class="o">=</span> <span class="n">jv</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">jvt</span> <span class="o">==</span> <span class="n">JAll</span> <span class="ow">and</span> <span class="n">jft</span> <span class="o">!=</span> <span class="n">JAll</span><span class="p">)</span> <span class="p">{</span>        
        <span class="nb">Junction</span><span class="o">[</span> <span class="n">jvt</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="n">v</span><span class="p">){</span><span class="n">jf</span> ○● <span class="n">v</span><span class="p">}</span><span class="o">,</span> <span class="nv">@vs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>  
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        
        <span class="nb">Junction</span><span class="o">[</span> <span class="n">jft</span><span class="o">,</span> <span class="nb">map</span><span class="p">(</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">&amp;f</span><span class="p">){</span> <span class="nv">&amp;f</span> ●○ <span class="n">jv</span><span class="p">}</span><span class="o">,</span> <span class="nv">@fs</span><span class="p">)</span><span class="o">].</span><span class="nb">new</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>为了完整，这里是 <code>○==●</code> 的定义。<code>○!=●</code>、<code>○&gt;●</code> 等的定义是类似的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nb">infix</span><span class="o">:</span><span class="p">&lt;</span><span class="s"> ○==● </span><span class="p">&gt;(</span> \<span class="n">j</span><span class="o">,</span> \<span class="n">v</span> <span class="p">)</span> <span class="k">is</span> <span class="k">export</span> <span class="p">{</span>
    <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="p">){</span><span class="nb">x</span><span class="o">==</span><span class="n">v</span><span class="p">}</span> ●○ <span class="n">j</span>
<span class="p">}</span>
</code></pre></div><p>接下来我们有 <code>so</code>，它把布尔值的 junction 变成了布尔值。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">our</span> <span class="k">sub</span> <span class="nb">so</span> <span class="p">(</span>\<span class="n">jv</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">my</span> <span class="nv">@vs</span> <span class="o">=</span> <span class="n">jv</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">given</span> <span class="n">jv</span><span class="o">.</span><span class="nf">junction-type</span> <span class="p">{</span>
        <span class="k">when</span> <span class="n">JAny</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span>  <span class="nv">@vs</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">}</span>
        <span class="k">when</span> <span class="n">JAll</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="o">!</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span> <span class="nv">@vs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">}</span>
        <span class="k">when</span> <span class="n">JOne</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span>  <span class="nv">@vs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">}</span>
        <span class="k">when</span> <span class="n">JOne</span> <span class="p">{</span> <span class="nb">elems</span><span class="p">(</span><span class="nb">grep</span> <span class="p">{</span><span class="nv">$_</span><span class="p">}</span><span class="o">,</span>  <span class="nv">@vs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>最后我们有 <code>collapse</code>，正如<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 的文章</a>中所定义的那样， <code>collapse</code> 返回 Junction 的值，只要它们都是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">our</span> <span class="k">sub</span> <span class="nf">collapse</span><span class="p">(</span> \<span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">\jt</span><span class="o">=</span><span class="n">j</span><span class="o">.</span><span class="nf">junction-type</span><span class="p">;</span> 
    <span class="k">my</span> <span class="nv">@vvs</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="nb">values</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$v</span> <span class="o">=</span>  <span class="nb">shift</span> <span class="nv">@vvs</span><span class="p">;</span>        
    <span class="k">my</span> <span class="nv">@ts</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span><span class="o">!</span><span class="p">(</span><span class="nv">$_</span> <span class="o">~~</span> <span class="nv">$v</span><span class="p">)}</span><span class="o">,</span> <span class="nv">@vvs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">@ts</span><span class="o">.</span><span class="nb">elems</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
        <span class="nv">$v</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">die</span> <span class="p">&#34;</span><span class="s2">Can&#39;t collapse this Junction: elements are not identical: </span><span class="p">{</span><span class="nv">$v</span><span class="o">,</span><span class="nv">@vvs</span><span class="p">}&#34;;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="junction-清理">Junction 清理</h3>
<p>现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">sq</span><span class="p">(</span><span class="nb">Int</span> <span class="nv">$x</span> <span class="k">--&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$x</span><span class="o">*</span><span class="nv">$x</span> <span class="p">}</span>
<span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$j</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">|</span> <span class="mi">22</span><span class="p">;</span> 
<span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nf">sq</span><span class="p">(</span><span class="nv">$j</span><span class="p">);</span> 
</code></pre></div><p>去语法塘后这变成了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$j</span> <span class="o">=</span> <span class="n">any_</span> <span class="o">[</span><span class="mi">11</span><span class="o">,</span><span class="mi">22</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nb">Junction</span> <span class="nv">$rj</span> <span class="o">=</span> <span class="nv">&amp;sq</span> ●○ <span class="nv">$j</span><span class="p">;</span>
</code></pre></div><p>类似地,</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span><span class="nv">$j</span> <span class="o">==</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span> 
</code></pre></div><p>变成了:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">if</span> <span class="p">(</span><span class="nb">so</span> <span class="p">(</span><span class="nv">$j</span> ○<span class="o">==</span>● <span class="mi">42</span><span class="p">))</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>和其他布尔上下文类似。</p>
<p>如果我们仔细看<a href="https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8">贪婪 Junction 文章</a>中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> \<span class="n">p1j</span> <span class="o">=</span> <span class="nb">pair</span> <span class="ow">R</span><span class="o">,</span><span class="err">(42</span><span class="o">^</span><span class="err">43);</span>
</code></pre></div><p>去语法塘后变为:</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nb">Junction</span> \<span class="n">p1j</span> <span class="o">=</span> <span class="nv">&amp;pair</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="ow">R</span><span class="err">)</span> ●○ <span class="n">one_</span> <span class="o">[</span><span class="mi">42</span><span class="o">,</span><span class="mi">43</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><p>我们使用 <code>.assuming()</code> 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">my</span> <span class="nv">\p1jr</span> <span class="o">=</span> <span class="p">(</span> <span class="k">sub</span> <span class="p">(</span><span class="nv">$y</span><span class="p">){</span> <span class="nv">&amp;pair</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="o">*,</span><span class="nv">$y</span><span class="p">)</span> <span class="p">}</span> ●○ <span class="n">one_</span> <span class="o">[</span><span class="mi">42</span><span class="o">,</span><span class="mi">43</span><span class="o">]</span> <span class="p">)</span> ○● <span class="ow">R</span><span class="err">;</span>
</code></pre></div><p>最后，举一个两个参数都是 Junction 的例子。由于 <code>○○</code> 的定义，应用的顺序并不重要。</p>
<div class="highlight"><pre class="chroma"><code class="language-raku" data-lang="raku"><span class="k">sub</span> <span class="nf">m</span><span class="p">(</span>\<span class="nb">x</span><span class="o">,</span>\<span class="n">y</span><span class="p">){</span><span class="nb">x</span><span class="o">*</span><span class="n">y</span><span class="p">}</span>

<span class="k">my</span> <span class="nv">\p4</span> <span class="o">=</span> <span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="p">){</span> <span class="nv">&amp;m</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="nb">x</span><span class="p">)</span> <span class="p">}</span> ●○ <span class="n">any_</span> <span class="o">[</span><span class="mi">11</span><span class="o">,</span><span class="mi">22</span><span class="o">]</span> <span class="p">)</span> ○○ <span class="n">all_</span> <span class="o">[</span><span class="mi">33</span><span class="o">,</span><span class="mi">44</span><span class="o">]</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">\p4r</span> <span class="o">=</span> <span class="p">(</span> <span class="k">sub</span> <span class="p">(</span>\<span class="nb">x</span><span class="p">){</span> <span class="nv">&amp;m</span><span class="o">.</span><span class="nb">assuming</span><span class="p">(</span><span class="o">*,</span><span class="nb">x</span><span class="p">)</span> <span class="p">}</span> ●○ <span class="n">all_</span> <span class="o">[</span><span class="mi">33</span><span class="o">,</span><span class="mi">44</span><span class="o">]</span> <span class="p">)</span> ○○ <span class="n">any_</span> <span class="o">[</span><span class="mi">11</span><span class="o">,</span><span class="mi">22</span><span class="o">]</span><span class="p">;</span>
</code></pre></div><h3 id="结论">结论</h3>
<p>从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。</p>
<p>原文链接: <a href="https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e">https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rakulang" term="rakulang" label="rakulang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="Raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/junction" term="junction" label="Junction" />
                            
                        
                    
                
            
        </entry>
    
</feed>
