<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>
            
                    rakulang on
                
            
            焉知非鱼</title>
        <link>https://ohmyweekly.github.io/categories/rakulang/</link>
        <description>Recent content  in rakulang
            on 焉知非鱼</description>
        <language>en-us</language>
        <lastBuildDate>Sun, 28 Feb 2021 14:55:59 +0800</lastBuildDate>
        <generator>Hugo -- gohugo.io</generator>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
            <atom:link href="https://ohmyweekly.github.io/categories/rakulang/index.xml" rel="self" type="application/rss&#43;xml" />
        
            
            <item>
                <title>为最年轻的 Raku 贡献力量</title>
                <link>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</link>
                
                
                <description>&lt;blockquote&gt;Contributing to Raku&lt;/blockquote&gt;&lt;p&gt;在过去的几周里，我看到了一些&lt;a href=&#34;https://mydeveloperplanet.com/2021/01/20/how-to-start-contributing-to-open-source/&#34;&gt;文章&lt;/a&gt;和&lt;a href=&#34;https://youtu.be/GAqfMNB-YBU&#34;&gt;视频&lt;/a&gt;，讲述了在开源软件中构思是多么的伟大。这次我又想起了另一篇旧文&lt;a href=&#34;http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg&#34;&gt;Raku 是我的 MMORPG&lt;/a&gt;。它说，你可以从以下几个方面受益于开源软件。比如说，可以做一个大侠，基于一些开源软件来写软件。作为写手，可以写博客、微博等，对所选软件产生兴趣。或者你可以成为一个法师 - 实现新的功能和修复 bug。今天小编就带着弓箭手来告诉大家如何成为 &lt;a href=&#34;https://raku.org/&#34;&gt;Raku&lt;/a&gt; 编程语言的法师。&lt;/p&gt;
&lt;h2 id=&#34;选择一个任务&#34;&gt;选择一个任务&lt;/h2&gt;
&lt;p&gt;让我们挑选一些编译器的 bug，并修复它。让我们去 &lt;a href=&#34;https://rakudo.org/&#34;&gt;Rakudo&lt;/a&gt; 编译器 &lt;a href=&#34;https://github.com/rakudo/rakudo/issues&#34;&gt;issues&lt;/a&gt;中选择我们想要修复的 bug。我滚动了一下 bug 列表，遇到了解析 - 运气不错，我前段时间一直在研究&lt;a href=&#34;https://www.apress.com/gp/book/9781484232279&#34;&gt;编译器语法&lt;/a&gt;，看了一本这方面的好书。找到了四个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://rakurs.atroxaper.net/assets/img/posts/2021-02-13-contributing-raku-1.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标签为 LTA （Less Than Awesome - 当真实行为与直觉预期不同时）- 我们暂时把它划掉。&lt;/li&gt;
&lt;li&gt;标签 &amp;ldquo;需要共识&amp;rdquo; - 我们只想修复一个不复杂的 bug - 肯定要划掉。&lt;/li&gt;
&lt;li&gt;标签为 &amp;ldquo;grammar and actions&amp;rdquo; 的关于一个可能死的代码是一个很好的候选人的第一个任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;任务确定后，现在我们需要配置工作环境。在 Windows、Linux 和 macOS 中，一切应该都差不多。我将通过 macOS 的例子来告诉你。&lt;/p&gt;
&lt;h2 id=&#34;建立工作环境&#34;&gt;建立工作环境&lt;/h2&gt;
&lt;p&gt;为源码和我们建立的编译器建立文件夹。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;mkdir ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkdir ~/dev-rakudo-install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Rakudo 编译器由三部分组成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机。现在有三种 - JVM、JS 和 MoarVM。我们以 MoarVM 为最稳定的一个。&lt;/li&gt;
&lt;li&gt;NQP（Not Quite Perl），是一种低级（中级）语言的实现，它是 Raku 的一个 &amp;ldquo;子集&amp;rdquo;。虚拟机可以执行用 NQP 编写的代码。&lt;/li&gt;
&lt;li&gt;Rakudo 编译器本身，用 NQP 和 Raku 编写。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下载并编译这三个组件。我分别花了一分半钟、半分钟和两分半钟才编好。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:MoarVM/MoarVM.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; MoarVM
perl Configure.pl --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:Raku/nqp.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; nqp
perl Configure.pl --backend&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;moar --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install

&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone git@github.com:rakudo/rakudo.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; rakudo
perl Configure.pl --backend&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;moar --prefix ~/dev-rakudo-install &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -j &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意参数。&lt;code&gt;--prefix&lt;/code&gt; 显示了 &lt;code&gt;make install&lt;/code&gt; 命令后可执行文件的复制位置，&lt;code&gt;--backend=moar&lt;/code&gt; 表示正在使用的虚拟机，而 &lt;code&gt;-j 4&lt;/code&gt; 则要求跨多线程并行化（以防加快进度）。现在我们已经建立了 Rakudo 编译器 &lt;code&gt;~/dev-rakudo-install/bin/raku&lt;/code&gt;。我们还需要官方的编译器测试套件。你应该把它和它的代码一起放在文件夹里。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ~/dev-rakudo/rakudo &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone https://github.com/Raku/roast.git t/spec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们先进行测试。这种情况很常见，有些测试甚至在新的变化之前就失败了。我们需要辨别出来，这样以后就不会害怕这些变化破坏了一些不必要的东西。&lt;/p&gt;
&lt;p&gt;这里和下面我将在 &lt;code&gt;~/dev-rakudo/rakudo&lt;/code&gt; 文件夹中工作，除非另有说明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make spectest
[...]
Test Summary Report
-------------------
t/spec/S32-str/utf8-c8.t    (Wstat: 65280 Tests: 54 Failed: 0)
  Non-zero exit status: 255
  Parse errors: Bad plan.  You planned 66 tests but ran 54.
Files=1346, Tests=117144, 829 wallclock secs (27.70 usr  6.04 sys + 2638.79 cusr 210.98 csys = 2883.51 CPU)
Result: FAIL
make: *** [m-spectest5] Error 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;14分钟内共运行了1,346个文件中的117,144次测试。一些与utf8相关的测试由于某种原因失败了，其他的都能正常工作。我们已经准备好去工作了!&lt;/p&gt;
&lt;h2 id=&#34;让我们来看看问题的陈述&#34;&gt;让我们来看看问题的陈述&lt;/h2&gt;
&lt;p&gt;问题陈述说，某个元运算符 &lt;code&gt;R&lt;/code&gt; 在 colonpair 上出了问题。我打开文档，搜索 R 这个词，但下拉列表中没有这个名字的元运算符。我试着输入 metaop，看到的是反向元操作符(R)。原来，如果你想把二元运算的操作数按相反的顺序写出来，你可以在其符号前使用前缀 R。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;say 3 R- 2 == -1 # Output: True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Colonpair 是命名对的语法。它看起来就像名字前面有一个冒号，前面有一个括号，有一个值。例如 &lt;code&gt;:foo(42)&lt;/code&gt; 是一个名称为 &lt;code&gt;foo&lt;/code&gt;、值为 &lt;code&gt;42&lt;/code&gt; 的对儿。这个语法通常用于在调用函数时，向函数传递一个命名参数中的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-with-named-parameter(:$foo) {
    say $foo;
}

sub-with-named-parameter(:foo(42)); # Output: 42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一个函数参数不是命名的，而是位置的，那么在用命名对调用时，就会出现编译错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-without-named-parameter($foo) { # &amp;lt;- 没有冒号
  say $foo;
}

sub-without-named-parameter(:foo(42)); # Unexpected named argument &#39;foo&#39; passed
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你在调用这样的函数时用括号包围一个参数，整个参数对将被传递到位置参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-without-named-parameter($foo) {
  say $foo;
}

sub-without-named-parameter((:foo(42))); # Output: foo =&amp;gt; 42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Raku 中，你可以写一个函数来捕获所有传递给它的参数并分析它们。这是在单个参数 - 捕获前用竖线完成的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sub-with-capture(|foo) { # &amp;lt;- 参数捕获
  say foo;
}

sub-with-capture(:foo(42));     # Output: \(:foo(42))
sub-with-capture(42);           # Output: \(42)
sub-with-capture(:foo(3 Z- 2)); # Output: \(:foo((1,).Seq))
sub-with-capture(:foo(3 R- 2)); # Output: \(-1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;倒数第二行使用了 Z 元操作符 - zip 操作符。它将左右两部分作为一个列表，按顺序每次从它们中抽取一个元素，并进行操作，从而形成一个序列。&lt;/p&gt;
&lt;p&gt;在最后一行，只用了我们需要的 R 元操作符。在这种情况下，它不是一个对，而是一个常量，它被传递到函数中。我们可以假设这是元运算符工作方式的一些特殊性，但用 Z 的例子表明并非如此。其实这是一个 bug - 当一个对被传递到一个使用 R 元运算符的函数中时，它的值会被转换。&lt;/p&gt;
&lt;h2 id=&#34;我们需要一个新的测试&#34;&gt;我们需要一个新的测试&lt;/h2&gt;
&lt;p&gt;为了确保未来的变化能够修复错误的行为，我们需要写一个新的测试。在测试文件中不难找到 R 元操作符的测试（&lt;a href=&#34;https://github.com/Raku/roast/blob/fea1d16d993eb851d2935155e0b0d074fa3593bf/S03-metaops/reverse.t&#34;&gt;S03-metops/reverse.t&lt;/a&gt;）。下面我将补充以下测试。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# https://github.com/rakudo/rakudo/issues/1632
{
  sub subroutine($expected, |actual) {
    is actual.gist, $expected, &amp;quot;Сolonpair exists&amp;quot;
  }

  subroutine(&#39;\(:foo(-1))&#39;, :foo(3 R- 2));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试有一个功能，有两个参数 - 正常和捕获。在函数体中，第一个参数和传递的 Capture 的字符串表示进行比较。你可以使用 &lt;code&gt;make&lt;/code&gt; 对新构建的编译器进行单独测试。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make t/spec/S03-metaops/reverse.t
[...]
ok 69 - [R~]=
not ok 70 - Colonpair exists
# Failed test &#39;Colonpair exists&#39;
# at t/spec/S03-metaops/reverse.t line 191
# expected: &#39;\(:foo(-1))&#39;
#      got: &#39;\(-1)&#39;
# You planned 69 tests, but ran 70
# You failed 1 test of 70
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以看到，测试失败了（如预期）。还有一个单独的说明，系统预计69次测试，但收到70次。这是基于 TAP 的测试系统的特点 - 必须在文件的顶部修正传递给 &lt;code&gt;plan&lt;/code&gt; 函数的数字。现在测试崩溃了，但编号没有受到影响。你可以开始修复它。&lt;/p&gt;
&lt;h2 id=&#34;凝视法&#34;&gt;凝视法&lt;/h2&gt;
&lt;p&gt;一开始我很相信任务上的标签 - 如果是解析的话，一定是源码解析阶段的某个地方出现了问题。目前我的认识如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础解析器代码在文件 &lt;code&gt;rakudo/src/Perl6/Grammar.nqp&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;这个解析器是从 &lt;code&gt;nqp/src/HLL/Grammar.nqp&lt;/code&gt; 文件中的基础解析器继承的。&lt;/li&gt;
&lt;li&gt;元操作符的解析和工作方式都差不多，你可以通过仔细观察来发现不同之处。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我在基础解析器代码中找到了对元操作符的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;token infix_prefix_meta_operator:sym&amp;lt;R&amp;gt; {
  &amp;lt;sym&amp;gt; &amp;lt;infixish(&#39;R&#39;)&amp;gt; {}
  &amp;lt;.can_meta($&amp;lt;infixish&amp;gt;, &amp;quot;reverse the args of&amp;quot;)&amp;gt;
  &amp;lt;O=.revO($&amp;lt;infixish&amp;gt;)&amp;gt;
}

token infix_prefix_meta_operator:sym&amp;lt;Z&amp;gt; {
  &amp;lt;sym&amp;gt; &amp;lt;infixish(&#39;Z&#39;)&amp;gt; {}
  &amp;lt;.can_meta($&amp;lt;infixish&amp;gt;, &amp;quot;zip with&amp;quot;)&amp;gt;
  &amp;lt;O(|%list_infix)&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这需要对 Raku grammar 有一定的了解。据我所知，原来这两个元运算符在解析上并没有根本的区别。一段时间后，在解析器的源代码中挖得够多了，我开始怀疑解析工作是否正确。认为代码 &lt;code&gt;my $r = :foo(3 R- 2); say $r; # Output: foo =&amp;gt; -1&lt;/code&gt; 正确工作的建议 - 问题恰恰发生在调用函数时。显然，我白白相信了任务栏上的标签。&lt;/p&gt;
&lt;h2 id=&#34;编译器将帮助我们&#34;&gt;编译器将帮助我们&lt;/h2&gt;
&lt;p&gt;颇为迟钝的我想起了我从一开始就应该做的事情。Rakudo 编译器有 &lt;code&gt;--target&lt;/code&gt; 调试开关。它取编译器阶段的名称，你想将其结果输出到控制台并退出。我想看看 &lt;code&gt;--target=parse&lt;/code&gt;（因为我只知道这一个）。&lt;/p&gt;
&lt;p&gt;我从 &lt;code&gt;~/dev-rakudo/rakudo&lt;/code&gt; 文件夹中使用 &lt;code&gt;rakumo-m&lt;/code&gt;，这样我就不必等待通过 &lt;code&gt;make install&lt;/code&gt; 命令将所需文件复制到 &lt;code&gt;~/dev-rakudo-install&lt;/code&gt;。简单的脚本可以这样运行。更复杂的脚本必须在 &lt;code&gt;make install&lt;/code&gt; 之后从 &lt;code&gt;-install&lt;/code&gt; 中运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; cat ~/test.raku
sub s(|c) { say c }
s(:foo(3 R- 2));
s(:foo(3 Z- 2));

&amp;gt; ./rakudo-m --target=parse ~/test.raku
[...]
- args: (:foo(3 R- 2))
  - semiarglist: :foo(3 R- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 R- 2)
        - colonpair: :foo(3 R- 2)
          - identifier: foo
          - coloncircumfix: (3 R- 2)
            - circumfix: (3 R- 2)
              - semilist: 3 R- 2
                - statement: 1 matches
                  - EXPR: R- 2
[...]
- args: (:foo(3 Z- 2))
  - semiarglist: :foo(3 Z- 2)
    - arglist: 1 matches
      - EXPR: :foo(3 Z- 2)
        - colonpair: :foo(3 Z- 2)
          - identifier: foo
          - coloncircumfix: (3 Z- 2)
            - circumfix: (3 Z- 2)
              - semilist: 3 Z- 2
                - statement: 1 matches
                  - EXPR: Z- 2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结论：R 和 Z 的解析是一样的。&lt;/p&gt;
&lt;h2 id=&#34;这不是解析&#34;&gt;这不是解析&lt;/h2&gt;
&lt;p&gt;所有被解析的东西都会被传递给所谓的 Action，把字词变成一棵语法树。在我们的例子中，Actions 位于文件 &lt;code&gt;rakudo/src/Perl6/Actions.nqp&lt;/code&gt; 和 &lt;code&gt;nqp/src/HLL/Actions.nqp&lt;/code&gt; 中。这里就比较容易搞清楚了，毕竟是代码，是 grammar。&lt;/p&gt;
&lt;p&gt;我在主 Actions 中找到了以下代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
elsif $&amp;lt;infix_prefix_meta_operator&amp;gt; {
[...]
  if    $metasym eq &#39;R&#39; { $helper := &#39;&amp;amp;METAOP_REVERSE&#39;; $t := nqp::flip($t) if $t; }
  elsif $metasym eq &#39;X&#39; { $helper := &#39;&amp;amp;METAOP_CROSS&#39;; $t := nqp::uc($t); }
  elsif $metasym eq &#39;Z&#39; { $helper := &#39;&amp;amp;METAOP_ZIP&#39;; $t := nqp::uc($t); }
  
  my $metapast := QAST::Op.new( :op&amp;lt;call&amp;gt;, :name($helper), WANTED($basepast,&#39;infixish&#39;) );
  $metapast.push(QAST::Var.new(:name(baseop_reduce($base&amp;lt;OPER&amp;gt;&amp;lt;O&amp;gt;.made)), :scope&amp;lt;lexical&amp;gt;))
    if $metasym eq &#39;X&#39; || $metasym eq &#39;Z&#39;;
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它说，如果在代码中解析了元操作符 &lt;code&gt;R&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; 或 &lt;code&gt;X&lt;/code&gt;，就应该在语法树中添加一些 &lt;code&gt;METAOP_&lt;/code&gt; 函数调用。在 &lt;code&gt;Z&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 的情况下，它会多一个参数，即某种还原函数。所有这些功能都可以在 &lt;code&gt;rakudo/src/core.c/metaops.pm6&lt;/code&gt; 中找到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { op.(|args.reverse) }
}

sub METAOP_ZIP(\op, &amp;amp;reduce) is implementation-detail {
 nqp::if(op.prec(&#39;thunky&#39;).starts-with(&#39;.&#39;),
  -&amp;gt; +lol {
    my $arity = lol.elems;
    [...]
  },
  -&amp;gt; +lol {
    Seq.new(Rakudo::Iterator.ZipIterablesOp(lol,op))
  }
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给你：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;\op&lt;/code&gt; 是由我们的元操作符，即-，在前面的操作。&lt;/li&gt;
&lt;li&gt;Trait &lt;code&gt;implementation-detail&lt;/code&gt; 只是表明这不是公共代码，是编译器实现的一部分。&lt;/li&gt;
&lt;li&gt;由于-操作没有笨重的特性，所以 &lt;code&gt;&amp;amp;reduce&lt;/code&gt; 函数不会参与计算，&lt;code&gt;Z&lt;/code&gt; 的结果是 &lt;code&gt;Seq.new(...)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 的结果是一个操作调用 - 参数顺序相反。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时我想起还有一个 - 目标，即星。它将显示行动的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=ast ~/test.raku
[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-
    - QAST::Op(call &amp;amp;METAOP_REVERSE) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;7&amp;gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(:named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;8&amp;gt; :before_promotion&amp;lt;?&amp;gt; Z-
    - QAST::Op(call &amp;amp;METAOP_ZIP) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
      - QAST::Var(lexical &amp;amp;METAOP_REDUCE_LEFT)
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一如所料。除了调用不同的 &lt;code&gt;METAOP_&lt;/code&gt; 函数外，所有的东西几乎都是一样的。从它们的代码中我们可以知道，原则上这些函数的不同之处在于返回值的类型 - 分别是 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Seq&lt;/code&gt;。众所周知，Raku 对不同类型的对象的上下文相当敏感&amp;hellip;&amp;hellip;我想，它关注的可能是返回值。我试着用下面的方式修改代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { Seq.new(op.(|args.reverse)) }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译、运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make
[...]
Stage start      :   0.000
Stage parse      :  61.026
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   7.076
Stage mast       :  14.120
Stage mbc        :   3.941
[...]
&amp;gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一切都没有改变。所以，不是返回值&amp;hellip;&amp;hellip;想了想，不知道为什么结果又是 &lt;code&gt;-1&lt;/code&gt; 而不是 &lt;code&gt;(-1,).Seq&lt;/code&gt;。而且，从代码来看，&lt;code&gt;Seq&lt;/code&gt; 根本就没有一个合适的构造函数。下一次，作为一些疯狂的事情，我尝试调用 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 结果只是为了崩溃。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub METAOP_REVERSE(\op) is implementation-detail {
  -&amp;gt; |args { die }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译、运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make
[...]
&amp;gt; ./rakudo-m ~/test.raku
\(-1)
\(:foo((1,).Seq))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;怎么会呢？语法树中包含了对 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 的调用，它的代码应该是折叠的，但计算仍然进行，我们得到 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些都不是《行动》。&lt;/p&gt;
&lt;p&gt;这里我的目光落在编译器的构建日志上。它是一些阶段被列在那里。我随机试了 &lt;code&gt;--target=mast&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=mast ~/test.raku
[...]
MAST::Frame name&amp;lt;s&amp;gt;, cuuid&amp;lt;1&amp;gt;
  Local types: 0&amp;lt;obj&amp;gt;, 1&amp;lt;obj&amp;gt;, 2&amp;lt;obj&amp;gt;, 3&amp;lt;obj&amp;gt;, 4&amp;lt;int&amp;gt;, 5&amp;lt;str&amp;gt;, 6&amp;lt;obj&amp;gt;, 7&amp;lt;obj&amp;gt;, 8&amp;lt;obj&amp;gt;,
  Lexical types: 0&amp;lt;obj&amp;gt;, 1&amp;lt;obj&amp;gt;, 2&amp;lt;obj&amp;gt;, 3&amp;lt;obj&amp;gt;, 4&amp;lt;obj&amp;gt;,
  Lexical names: 0&amp;lt;c&amp;gt;, 1&amp;lt;$¢&amp;gt;, 2&amp;lt;$!&amp;gt;, 3&amp;lt;$/&amp;gt;, 4&amp;lt;$*DISPATCHER&amp;gt;,
  Lexical map: $!&amp;lt;2&amp;gt;, c&amp;lt;0&amp;gt;, $*DISPATCHER&amp;lt;4&amp;gt;, $¢&amp;lt;1&amp;gt;, $/&amp;lt;3&amp;gt;,
  Outer: name&amp;lt;&amp;lt;unit&amp;gt;&amp;gt;, cuuid&amp;lt;2&amp;gt;
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;某种不可读的矩阵。星号和桅杆之间有一个阶段性的优化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; ./rakudo-m --target=optimize ~/test.raku
[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;amp;infix:&amp;lt;-&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;7&amp;gt; s(:foo(3 Z- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;8&amp;gt; :before_promotion&amp;lt;?&amp;gt; Z-
    - QAST::Op(callstatic &amp;amp;METAOP_ZIP) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
      - QAST::Var(lexical &amp;amp;METAOP_REDUCE_LEFT)
    - QAST::Want &amp;lt;wanted&amp;gt; 3
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(3)  3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
      - QAST::WVal(Int)
      - Ii
      - QAST::IVal(2)  2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;哈，就是这样。在优化阶段后，行将失踪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-.&lt;/code&gt;
并将整个 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 调用替换为通常的操作 &lt;code&gt;(&amp;amp;infix:&amp;lt;-&amp;gt;)&lt;/code&gt;。所以问题一定在优化器的某个地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有在 &lt;code&gt;optim_nameless_call&lt;/code&gt; 方法中才会提到 &lt;code&gt;&amp;amp;METAOP_ASSIGN&lt;/code&gt;，其中 &lt;code&gt;QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;)&lt;/code&gt;。显然，这个操作负责生成一个命名对 - 它已经有了一个名字（命名参数），它需要计算值。从优化 &lt;code&gt;_&lt;/code&gt; 无名方法的执行路径来看，我们可以得出结论，我们对最后一个块感兴趣。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
  elsif self.op_eq_core($metaop, &#39;&amp;amp;METAOP_REVERSE&#39;) {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;amp;&amp;amp; nqp::elems($op) == 3;
    return QAST::Op.new(:op&amp;lt;call&amp;gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: &#39;METAOP_opt_result&#39;, 1;
  }
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我提醒你，优化前的树是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(call &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call :named&amp;lt;foo&amp;gt;) &amp;lt;wanted&amp;gt; :statement_id&amp;lt;5&amp;gt; :before_promotion&amp;lt;?&amp;gt; R-
    - QAST::Op(call &amp;amp;METAOP_REVERSE) &amp;lt;wanted&amp;gt; :is_pure&amp;lt;?&amp;gt;
      - QAST::Var(lexical &amp;amp;infix:&amp;lt;-&amp;gt;) &amp;lt;wanted&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 3
    - QAST::Want &amp;lt;wanted&amp;gt; 2
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而精简之后，是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op(call &amp;amp;infix:&amp;lt;-&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说，优化 &lt;code&gt;_nameless_call&lt;/code&gt; 做了以下工作。&lt;/p&gt;
&lt;p&gt;如果我们的 &lt;code&gt;QAST::Op+{QAST::SpecialArg}&lt;/code&gt; 操作没有三个参数，如果 &lt;code&gt;METAOP_REVERSE&lt;/code&gt; 调用没有一个正确的类型，我们就返回空。这不是我们的情况。
否则，我们将返回一个新的操作，代替我们的 &lt;code&gt;QAST::Op+{QAST::SpecialArg}&lt;/code&gt; 操作，以相反的顺序调用 &lt;code&gt;&amp;amp;infix:&amp;lt;-&amp;gt;&lt;/code&gt; 参数。就是说，把结果打包成一对就没了。&lt;/p&gt;
&lt;p&gt;在摸索了一下如何解决这个问题，并阅读了 &lt;code&gt;QAST::SpecialArg&lt;/code&gt; 和 &lt;code&gt;QAST::Node&lt;/code&gt; 的实现后，我想到了下面的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
  elsif self.op_eq_core($metaop, &#39;&amp;amp;METAOP_REVERSE&#39;) {
    return NQPMu unless nqp::istype($metaop[0], QAST::Var)
      &amp;amp;&amp;amp; nqp::elems($op) == 3;
    my $opt_result := QAST::Op.new(:op&amp;lt;call&amp;gt;, :name($metaop[0].name),
      $op[2], $op[1]).annotate_self: &#39;METAOP_opt_result&#39;, 1;
    if $op.named { $opt_result.named($op.named) } # 添加选项 named 
    if $op.flat { $opt_result.flat($op.flat) }    # 添加选项 flat
    return $opt_result;
  }
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有木头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Op+{QAST::SpecialArg}(call &amp;amp;infix:&amp;lt;-&amp;gt; :named&amp;lt;foo&amp;gt;)  :METAOP_opt_result&amp;lt;?&amp;gt;
    - QAST::Want &amp;lt;wanted&amp;gt; 2
    - QAST::Want &amp;lt;wanted&amp;gt; 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命名的参数返回到它的位置。测试也开始通过。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; make t/spec/S03-metaops/reverse.t
[...]
All tests successful.
Files=1, Tests=70,  3 wallclock secs ( 0.03 usr  0.01 sys +  3.61 cusr  0.17 csys =  3.82 CPU)
Result: PASS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们本可以就此打住，但这是编译器优化器的代码，它的结果是一个有两个整数参数的方法调用。我认为这在某种程度上是次优的。如果我们将返回表达式改为返回 &lt;code&gt;self.visit_op: $opt_result;&lt;/code&gt;，对产生的非优化操作调用优化器，那么产生的树就会像这样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[...]
- QAST::Op(callstatic &amp;amp;s) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;4&amp;gt; s(:foo(3 R- 2))
  - QAST::Want+{QAST::SpecialArg}(:named&amp;lt;foo&amp;gt;)
    - QAST::WVal+{QAST::SpecialArg}(Int :named&amp;lt;foo&amp;gt;)
    - QAST::IVal(-1)
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在一切都很理想。&lt;/p&gt;
&lt;h2 id=&#34;分享成果&#34;&gt;分享成果&lt;/h2&gt;
&lt;p&gt;我们已经到了终点线。现在我们只需要分享我们的经验。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重要的是：运行所有的 &lt;code&gt;make spectest&lt;/code&gt; 测试，确保没有新的东西被破坏。&lt;/li&gt;
&lt;li&gt;在 GitHub 上使用 Rakudo 编译器和测试制作 fork 仓库。&lt;/li&gt;
&lt;li&gt;将 fork 仓库添加为新的 git 远程仓库。&lt;/li&gt;
&lt;li&gt;cd ~/dev-rakudo/rakudo &amp;amp;&amp;amp; git remote add fork &lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;li&gt;cd ~/dev-rakudo/t/spec &amp;amp;&amp;amp; git remote add fork &lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重要：确保两个仓库在 git 中都有正确的用户名和用户邮箱。&lt;/p&gt;
&lt;p&gt;提交到两个版本库，详细说明你为什么做了哪些改动，并添加对原始问题跟踪器的引用。&lt;/p&gt;
&lt;p&gt;运行提交。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~/dev-rakudo/rakudo &amp;amp;&amp;amp; git push fork
cd ~/dev-rakudo/t/spec &amp;amp;&amp;amp; git push fork
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向两个仓库提出拉取请求。在他们的描述中，最好是相互参照和原任务。&lt;/p&gt;
&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;
&lt;p&gt;对开源软件的贡献是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;趣味性和趣味性。&lt;/li&gt;
&lt;li&gt;给你的感觉是，你正在做一些有用的事情，你真的是。&lt;/li&gt;
&lt;li&gt;让你认识新的有趣和专业的人（任何关于 Raku 的问题都会在 &lt;code&gt;#raku IRC&lt;/code&gt; 频道中得到回答）。&lt;/li&gt;
&lt;li&gt;解决非标准任务，没有截止日期的压力，是一种很好的体验。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择你觉得最舒服的角色等级，去做新的任务吧!&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/rakulang">Rakulang</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2021-02-16-contributing-to-raku/</guid>
                <pubDate>Tue, 16 Feb 2021 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>贪婪 Junction 的奇闻异事</title>
                <link>https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/</link>
                
                
                <description>&lt;blockquote&gt;The Strange Case of the Greedy Junction&lt;/blockquote&gt;&lt;h2 id=&#34;贪婪-junction-的奇闻异事&#34;&gt;贪婪 junction 的奇闻异事&lt;/h2&gt;
&lt;p&gt;说明 Raku 的 junction 是如何贪婪的设计，以及一个建议。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://raku.org/&#34;&gt;Raku&lt;/a&gt; 有一个整洁的功能，叫做 &lt;a href=&#34;https://docs.raku.org/type/Junction&#34;&gt;Junction&lt;/a&gt;。在这篇短文中，我想强调一下 junction 与函数交互的一个特殊后果：它们是贪婪的，我的意思是它们会无意中把函数的其他参数变成 junction。为了说明这种行为，我将使用一个闭包创建一个 &lt;code&gt;pair&lt;/code&gt; 数据结构，它可以接受两个不同类型的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;enum RGB &amp;lt;R G B&amp;gt;;

# Pair Constructor: the arguments of pair() are captured
# in a closure that is returned
sub pair(\x, \y) {
    sub (&amp;amp;p){ p(x, y) } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以 &lt;code&gt;pair&lt;/code&gt; 接受两个任意类型的参数，并返回一个以函数为参数的闭包。我们将使用这个函数来访问存储在 &lt;code&gt;pair&lt;/code&gt; 中的值。我将把这些访问(accessor)函数称为 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# Accessors to get the values from the closure
my sub fst (&amp;amp;p) {p( sub (\x,\y){x})}
my sub snd (&amp;amp;p) {p( sub (\x,\y){y})}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;做实际选择的函数是由 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt; 返回的匿名子程序，这纯粹是为了让我可以将它们应用于 &lt;code&gt;pair&lt;/code&gt;，而不是必须将它们作为参数传递。让我们看一个例子，一个 &lt;code&gt;Int&lt;/code&gt; 和一个 &lt;code&gt;RGB&lt;/code&gt; 的 pair。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my \p1 = pair 42, R;

if ( 42 == fst p1) {
    say snd p1;	#=&amp;gt; says &amp;quot;R&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以我们用两个值调用 &lt;code&gt;pair&lt;/code&gt; 来创建一个 pair，并使用 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt; 来访问 pair 中的值。这是一个不可变的数据结构，所以不可能进行更新。&lt;/p&gt;
&lt;p&gt;现在让我们使用 junction 作为其中一个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# Example instance with a &#39;one&#39;-type junction
my Junction \p1j = pair (42^43),R;

if ( 42 == fst p1j) {
    say snd p1j; #=&amp;gt; one(R, R)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里发生的情况是，原始参数 &lt;code&gt;R&lt;/code&gt; 已经不可逆转地变成了与自己的 junction，尽管我们从未明确地在 &lt;code&gt;R&lt;/code&gt; 上创建过 junction，但还是发生了这种情况。这是将 junction 类型应用于函数的结果，它不是一个 bug，只是 junction 行为的一个影响。更详细的解释，请看我的文章&amp;quot;&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e&#34;&gt;重构 Raku 的 Junction&lt;/a&gt;&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.raku.org/type/Junction&#34;&gt;Raku 关于 junction 的文档&lt;/a&gt;中说，你不应该真正尝试从 junction 中获取值。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Junction 是用来作为布尔上下文中的匹配器，不支持 junction 的自省。如果你觉得有自省 junction 的冲动，请使用 Set 或相关类型代替。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;然而，有一个 FAQ &lt;a href=&#34;https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)&#34;&gt;勉强地告诉你如何做&lt;/a&gt;。FAQ 再次警告不要这样做。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;如果你想从 junction 中提取值（特征态），你可能做错了什么，应该用 Set 来代替。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;然而，正如我所举的例子所证明的那样，从 junction 中恢复值是有明确的用例的。当然，仅仅因为另一个值恰好是 junction，存储在 pair 中的其中一个值就变得不可访问，这不是我们的本意。&lt;/p&gt;
&lt;p&gt;因此，我建议增加一个折叠(&lt;code&gt;collapse&lt;/code&gt;)函数，允许将这些无意中出现的 junction 值折叠成它们的原始值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if ( 42 == fst p1j) {
    say collapse(snd p1j); #=&amp;gt; says &#39;R&#39;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该函数的实现取自&lt;a href=&#34;https://docs.raku.org/language/faq#index-entry-Junction_(FAQ)&#34;&gt;上述常见问题&lt;/a&gt;，并增加了一个检查，以确保 junction 上的所有值都相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub collapse(Junction \j) {    
    my @vvs;
    -&amp;gt; Any \s { push @vvs, s }.(j);    
    my $v =  shift @vvs;        
    my @ts = grep {!($_ ~~ $v)}, @vvs;
    if (@ts.elems==0) {  
        $v
    } else {
        die &amp;quot;Can&#39;t collapse this Junction: elements are not identical: {$v,@vvs}&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果能把这个功能作为一个 &lt;code&gt;collapse&lt;/code&gt; 方法添加到 &lt;code&gt;Junction&lt;/code&gt; 类中就更好了。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/junction">Junction</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2020-10-04-the-strange-case-of-the-greedy-junction/</guid>
                <pubDate>Sun, 04 Oct 2020 00:00:00 +0800</pubDate>
            </item>
        
            
            <item>
                <title>重构 Raku 的 Junction</title>
                <link>https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/</link>
                
                
                <description>&lt;blockquote&gt;Reconstructing Raku&amp;rsquo;s Junctions&lt;/blockquote&gt;&lt;h2 id=&#34;重构-raku-的-junction&#34;&gt;重构 Raku 的 Junction&lt;/h2&gt;
&lt;p&gt;Raku 中的 junction 很酷，但乍一看它们并没有遵循静态类型化的规则。我对它们的形式化类型语义很好奇，所以我从功能、静态类型的角度对 junction 进行了解构和重构。&lt;/p&gt;
&lt;h3 id=&#34;raku-中的-junction&#34;&gt;Raku 中的 Junction&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.raku.org/&#34;&gt;Raku&lt;/a&gt; 有一个整洁的功能叫做 &lt;a href=&#34;https://docs.raku.org/type/Junction&#34;&gt;Junction&lt;/a&gt;。Junction 是一个无序的复合值。当使用 junction 代替值时，会对每个结点(junction)元素进行操作，结果是所有这些操作符的返回值的结点(junction)。当在布尔上下文中使用 junction 时，结点(junction)会折叠成一个值。Junction 的类型可以是 all(&lt;code&gt;&amp;amp;&lt;/code&gt;)、any(&lt;code&gt;|&lt;/code&gt;)、one(&lt;code&gt;^&lt;/code&gt;) 或 &lt;code&gt;none&lt;/code&gt; (空结点)。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $j = 11|22; # short for any(11,22)
if 33 == $j + 11 {
    say &#39;yes&#39;;
}

say so 3 == (1..30).one;         #=&amp;gt; True 
say so (&amp;quot;a&amp;quot; ^ &amp;quot;b&amp;quot; ^ &amp;quot;c&amp;quot;) eq &amp;quot;a&amp;quot;; #=&amp;gt; True
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数 &lt;code&gt;so&lt;/code&gt; 强制使用布尔上下文。&lt;/p&gt;
&lt;p&gt;Junction 有 &lt;code&gt;Junction&lt;/code&gt; 类型，我很好奇 Junction 的类型规则，因为乍一看有些奇怪。比方说我们有一个函数 &lt;code&gt;sq&lt;/code&gt; 从 &lt;code&gt;Int&lt;/code&gt; 到 &lt;code&gt;Int&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sq(Int $x --&amp;gt; Int) { $x*$x }

my Int $res = sq(11); # OK
say $res; #=&amp;gt; 121
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在让我们定义一个类型为任何 &lt;code&gt;Int&lt;/code&gt; 值的 Junction。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction $j = 11 | 22; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们将 &lt;code&gt;sq&lt;/code&gt; 应用于 &lt;code&gt;$j&lt;/code&gt; 时，我们没有得到一个类型错误，即使函数的类型是 &lt;code&gt;:(Int --&amp;gt; Int)&lt;/code&gt;，Junction 的类型是 &lt;code&gt;Junction&lt;/code&gt;。相反，我们得到的是一个结果的 Junction。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;say sq($j); #=&amp;gt; any(121, 484)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们像之前一样将其赋值给一个类型为 &lt;code&gt;Int&lt;/code&gt; 的变量，我们会得到一个类型错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Int $rj = sq($j); #=&amp;gt; Type check failed in assignment to $rj; expected Int but got Junction (any(121, 484))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取而代之的是，现在返回值的类型为 &lt;code&gt;Junction&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction $rj = sq(11|22); # OK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，Junction 类型可以代替任何其他类型，但这样一来，操作也变成了 Junction。&lt;/p&gt;
&lt;p&gt;另一方面，Junction 是由其组成值隐式类型的，尽管它们看起来是不透明的 &lt;code&gt;Junction&lt;/code&gt; 类型。例如，如果我们创建了一个由 &lt;code&gt;Str&lt;/code&gt; 值组成的 Junction，并试图将这个 Junction 的值传递到 &lt;code&gt;sq&lt;/code&gt; 中，我们会得到一个类型错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my $sj = &#39;11&#39; | &#39;22&#39;;
say $sj.WHAT; #=&amp;gt;(Junction)

my Junction $svj = sq($sj); #=&amp;gt; Type check failed in binding to parameter &#39;x&#39;; expected Int but got Str (&amp;quot;11&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;junction-不遵循静态类型规则&#34;&gt;Junction 不遵循静态类型规则&lt;/h3&gt;
&lt;p&gt;虽然这样做是有道理的(如果原始函数期望使用 &lt;code&gt;Int&lt;/code&gt;，我们不希望它与 &lt;code&gt;Str&lt;/code&gt; 一起工作)，但这确实违背了静态类型化的规则，即使是子类型化。如果一个参数的类型是 &lt;code&gt;Int&lt;/code&gt;，那么可以使用类型图中低于它的任何类型来代替。但是 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Junction&lt;/code&gt; 的简化类型图如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Int -&amp;gt; Cool -&amp;gt; Any -&amp;gt; Mu &amp;lt;- Junction
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以 Junction 永远不是 &lt;code&gt;Any&lt;/code&gt; 以下任何东西的子类型。因此，将 Junction 放在类型为 &lt;code&gt;Any&lt;/code&gt; 或其子类型的槽中应该是一个类型错误。&lt;/p&gt;
&lt;p&gt;此外，由于 Junction 类型是不透明的（即它不是一个参数化的类型），它不应该持有任何关于 Junction 内部值的类型的信息。然而它却对这些不可见、不可访问的值进行了类型检查。&lt;/p&gt;
&lt;p&gt;那么这里到底发生了什么？&lt;/p&gt;
&lt;h3 id=&#34;一个工作假设&#34;&gt;一个工作假设&lt;/h3&gt;
&lt;p&gt;一个工作假设是，Junction 类型并不真正取代任何其他类型：它只是一个语法糖，使它看起来如此。&lt;/p&gt;
&lt;h3 id=&#34;重构-junction-的第一部分类型&#34;&gt;重构 Junction 的第一部分：类型&lt;/h3&gt;
&lt;p&gt;让我们试着重建这个。我们的目的是想出一个数据类型和一些动作，以复制观察到的 Raku Junction 的行为。首先我们讨论一下类型，为了清晰起见，使用 Haskell 符号。然后我介绍 Raku 中的实现。这个实现将像 Raku 的原生 Junction 一样，但没有神奇的语法糖。通过这种方式，我证明了 Raku 的 Junction 毕竟遵循了正确的类型规则。&lt;/p&gt;
&lt;h4 id=&#34;junction-类型&#34;&gt;Junction 类型&lt;/h4&gt;
&lt;p&gt;Junction 是一个由 Junction 类型 &lt;code&gt;JType&lt;/code&gt; 和一组值组成的数据结构。为了方便起见，我将这个值集限制为单一类型，同时也是因为混合类型的 Junction 其实没有什么意义。我使用一个列表来模拟这个集合，同样是为了方便。因为 Junction 可以包含任何类型的值，所以它是一个多态的代数数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;data JType = JAny | JAll | JOne | JNone

data Junction a = Junction JType [a]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;应用结点&#34;&gt;应用结点&lt;/h4&gt;
&lt;p&gt;对一个 Junction 做任何事情都意味着对它应用一个函数。我们可以考虑三种情况，我为每一种情况介绍一个特别定制的操作符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将非 Junction 函数应用于 Junction 表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;(•￮) :: (a -&amp;gt; b) -&amp;gt; Junction a -&amp;gt;  Junction b
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;将 Junction 函数应用于非 Junction 表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;(￮•) ::  Junction (b -&amp;gt; c) -&amp;gt; b -&amp;gt; Junction c
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;将 Junction 函数应用于 Junction 表达式，创建一个嵌套 Junction。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;(￮￮) ::  Junction (b -&amp;gt; c) -&amp;gt; Junction b -&amp;gt; Junction (Junction c)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了方便，我们还可以在 Junction a 和 a 之间创建自定义比较运算符。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;-- and similar for /-, &amp;gt;, &amp;lt;, &amp;lt;=,&amp;gt;=
(￮==•) :: Junction a -&amp;gt; a -&amp;gt; Bool
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;折叠-junction&#34;&gt;折叠 Junction&lt;/h4&gt;
&lt;p&gt;那么我们就有了 &lt;code&gt;so&lt;/code&gt;，布尔强制函数。它的作用是将一个布尔的 Junction 折叠成一个布尔。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;so :: Junction Bool -&amp;gt; Bool
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后我们有 &lt;code&gt;collapse&lt;/code&gt;，它从一个 Junction 返回值，前提是它是一个 Junction，所有存储的值都是一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;collapse :: (Show a,Eq a) =&amp;gt; Junction a -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这似乎是一个奇怪的函数，但由于 Junction 的行为，它是必要的。正如我们将看到的，上述语义意味着 Junction 是贪婪的：如果一个函数的一个参数是 Junction，那么所有其他参数也会成为 Junction，但 Junction 中的所有值都是相同的。我已经在&amp;quot;&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 的奇怪情况&lt;/a&gt;&amp;ldquo;中讨论过这个问题，但我们现在可以将这种行为形式化。&lt;/p&gt;
&lt;h4 id=&#34;重新审视贪婪-junction-的奇怪情况&#34;&gt;重新审视贪婪 Junction 的奇怪情况&lt;/h4&gt;
&lt;p&gt;假设我们有一个两个参数的函数 &lt;code&gt;f :: a -&amp;gt; b -&amp;gt; c&lt;/code&gt;，我们对第一个参数应用一个结点 &lt;code&gt;j :: Junction&lt;/code&gt; a 应用到第一个参数 &lt;code&gt;f •￮ j&lt;/code&gt; 上，那么结果是一个部分应用的函数，包裹在一个 Junction 上：&lt;code&gt;fp :: Junction b -&amp;gt; c&lt;/code&gt;。如果我们现在想用 &lt;code&gt;fp ￮• v&lt;/code&gt; 将这个函数应用于一个非结点的值 &lt;code&gt;v :: b&lt;/code&gt;，那么结果就是 &lt;code&gt;Junction c&lt;/code&gt; 类型的。&lt;/p&gt;
&lt;p&gt;现在，让我们考虑类型 &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;forall d . (a -&amp;gt; b -&amp;gt; d) -&amp;gt; d&lt;/code&gt; 的特殊情况。所以我们有 &lt;code&gt;Junction&lt;/code&gt;(&lt;code&gt;forall d . (a-&amp;gt;b-&amp;gt;d) -&amp;gt; d&lt;/code&gt;)。这是一个函数，它接受一个函数参数并返回该函数的返回类型的东西。我们使用 &lt;code&gt;forall&lt;/code&gt;，所以 &lt;code&gt;d&lt;/code&gt; 可以是任何东西，但在实践中我们希望它是 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设我们将这个函数(称它为 &lt;code&gt;p&lt;/code&gt;)应用于 &lt;code&gt;fst :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;，使用 &lt;code&gt;p ￮• fst&lt;/code&gt;，那么我们得到 &lt;code&gt;Junction a&lt;/code&gt;。但是如果我们将它应用于 &lt;code&gt;snd :: a-&amp;gt;b-&amp;gt;b&lt;/code&gt;，使用 &lt;code&gt;p ￮• snd&lt;/code&gt;，那么我们得到 &lt;code&gt;Junction b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就是形式上基于类型的分析，为什么我们不能从一个 pair 中返回一个非 Junction 的值，在&amp;rdquo;&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 的奇怪情况&lt;/a&gt;&amp;ldquo;中已经解释过。而这也是我们需要 &lt;code&gt;collapse&lt;/code&gt; 函数的原因。&lt;/p&gt;
&lt;h4 id=&#34;重构-junction-的第2部分raku-的实现&#34;&gt;重构 Junction 的第2部分：Raku 的实现。&lt;/h4&gt;
&lt;p&gt;我们从创建 Junction 类型开始，为四种 Junction 类型使用一个枚举，为实际的 Junction 数据类型使用一个角色。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;# The types of Junctions
enum JType &amp;lt;JAny  JAll  JOne  JNone &amp;gt;;

# The actual Junction type
role Junction[\jt, @vs] {
    has JType $.junction-type=jt;
    has @.values=@vs;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来是四种类型的 Junction 的构造函数（下划线，避免与内建函数的名称冲突）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;our sub all_(@vs) {
    Junction[ JAll, @vs].new;
}

our sub any_(@vs) {
    Junction[ JAny, @vs].new;
}

our sub one_(@vs) {
    Junction[ JOne, @vs].new;
}

our sub none_(@vs) {
    Junction[ JNone, @vs].new;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将一个（单参数）函数应用于 junction 参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt;●○&amp;gt;( &amp;amp;f, \j ) is export {
    my \jt=j.junction-type; 
    my @vs = j.values;
  
    Junction[ jt, map( {&amp;amp;f($_)}, @vs)].new;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要将 Junction 内的函数应用于非 Junction 的参数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt;○●&amp;gt;( \jf, \v ) is export {
    my \jt=jf.junction-type; 
    my @fs = jf.values;

    Junction[ jt, map( {$_( v)}, @fs)].new;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将一个函数应用于两个 junction 参数，相当于将一个 junction 内的函数应用于一个 junction。这里有一个复杂的问题。Raku 对嵌套施加了一个排序，即所有的嵌套总是外嵌套。因此，我们必须检查 junction 的类型，如果需要的话，我们必须交换映射。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt;○○&amp;gt;( \jf, \jv ) is export {
    my \jft= jf.junction-type; 
    my @fs = jf.values;
    my \jvt = jv.junction-type;
    my @vs = jv.values;
    if (jvt == JAll and jft != JAll) {        
        Junction[ jvt, map( sub (\v){jf ○● v}, @vs)].new;  
    } else {        
        Junction[ jft, map( sub (&amp;amp;f){ &amp;amp;f ●○ jv}, @fs)].new;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了完整，这里是 &lt;code&gt;○==●&lt;/code&gt; 的定义。&lt;code&gt;○!=●&lt;/code&gt;、&lt;code&gt;○&amp;gt;●&lt;/code&gt; 等的定义是类似的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub infix:&amp;lt; ○==● &amp;gt;( \j, \v ) is export {
    sub (\x){x==v} ●○ j
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们有 &lt;code&gt;so&lt;/code&gt;，它把布尔值的 junction 变成了布尔值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;our sub so (\jv) { 
    my @vs = jv.values;
    given jv.junction-type {
        when JAny { elems(grep {$_},  @vs) &amp;gt;0}
        when JAll { elems(grep {!$_}, @vs)==0}
        when JOne { elems(grep {$_},  @vs)==1}
        when JOne { elems(grep {$_},  @vs)==0}
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后我们有 &lt;code&gt;collapse&lt;/code&gt;，正如&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 的文章&lt;/a&gt;中所定义的那样， &lt;code&gt;collapse&lt;/code&gt; 返回 Junction 的值，只要它们都是一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;our sub collapse( \j ) {
    my \jt=j.junction-type; 
    my @vvs = j.values;
    my $v =  shift @vvs;        
    my @ts = grep {!($_ ~~ $v)}, @vvs;
    if (@ts.elems==0) {  
        $v
    } else {
        die &amp;quot;Can&#39;t collapse this Junction: elements are not identical: {$v,@vvs}&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;junction-清理&#34;&gt;Junction 清理&lt;/h3&gt;
&lt;p&gt;现在我们再来看看我们的工作假说，将 Raku 的 Junction 上的动作解释为上述类型和操作符的语法糖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub sq(Int $x --&amp;gt; Int) { $x*$x }
my Junction $j = 11 | 22; 
my Junction $rj = sq($j); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;去语法塘后这变成了:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction $j = any_ [11,22];
my Junction $rj = &amp;amp;sq ●○ $j;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似地,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if ($j == 42) {...} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;变成了:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;if (so ($j ○==● 42)) {...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和其他布尔上下文类似。&lt;/p&gt;
&lt;p&gt;如果我们仔细看&lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/85fb4b88ec53a0b8149e6c05740adcf8&#34;&gt;贪婪 Junction 文章&lt;/a&gt;中的 pair 例子，那么将 junction 应用到一个有多个参数的函数上:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction \p1j = pair R,(42^43);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;去语法塘后变为:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my Junction \p1j = &amp;amp;pair.assuming(R) ●○ one_ [42,43];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用 &lt;code&gt;.assuming()&lt;/code&gt; 是因为我们需要部分应用。不管我们是先应用非 Junction 参数还是 Junction 参数，都没有关系。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;my \p1jr = ( sub ($y){ &amp;amp;pair.assuming(*,$y) } ●○ one_ [42,43] ) ○● R;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，举一个两个参数都是 Junction 的例子。由于 &lt;code&gt;○○&lt;/code&gt; 的定义，应用的顺序并不重要。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-raku&#34; data-lang=&#34;raku&#34;&gt;sub m(\x,\y){x*y}

my \p4 = ( sub (\x){ &amp;amp;m.assuming(x) } ●○ any_ [11,22] ) ○○ all_ [33,44];
my \p4r = ( sub (\x){ &amp;amp;m.assuming(*,x) } ●○ all_ [33,44] ) ○○ any_ [11,22];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;
&lt;p&gt;从 Raku 的 junction 的神奇类型行为实际上是语法糖的假设出发，我使用多态代数数据类型重构了 junction 类型和它的动作，并表明 Raku 的行为作为语法糖的解释对于所提出的实现是成立的。换句话说，Raku 的 Junction 确实遵循静态类型规则。&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e&#34;&gt;https://gist.github.com/wimvanderbauwhede/19cc1e8d04e9a477f58cfe7288a6172e&lt;/a&gt;&lt;/p&gt;
</description>
                
                        <author>焉知非鱼@fakeEmailToMakeValidatorHappy.com (焉知非鱼)</author>
                
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/categories/rakulang">rakulang</category>
                                
                            
                        
                     
                        
                             
                            
                                
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/raku">Raku</category>
                                 
                                    <category domain="https://ohmyweekly.github.io/tags/junction">Junction</category>
                                
                            
                        
                    
                
                <guid>https://ohmyweekly.github.io/notes/2020-10-04-reconstructing-raku-junctions/</guid>
                <pubDate>Sun, 04 Oct 2020 00:00:00 +0800</pubDate>
            </item>
        
    </channel>
</rss>


