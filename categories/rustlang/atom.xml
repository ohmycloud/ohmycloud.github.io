<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.79.0">Hugo</generator><title type="html"><![CDATA[rustlang on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/categories/rustlang/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/categories/rustlang/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/categories/rustlang/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/categories/rustlang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-05-18T22:23:48+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/categories/rustlang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Kafka 和 Rust入门 - 第一部分]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-14-getting-started-with-kafka-and-rust-part1/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-14-a-beginner-guide-to-handling-errors-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 中处理错误的初级指南" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Sizedness in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-14-getting-started-with-kafka-and-rust-part1/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-14T00:00:00+08:00</published>
            <updated>2021-04-14T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Getting Started With Kafka and Rust</blockquote><p>这是一个两部分的系列，帮助你开始使用 Rust 和 Kafka。我们将使用 <a href="https://github.com/fede1024/rust-rdkafka/">rust-rdkafka</a> crate，它本身就是基于 <a href="https://github.com/edenhill/librdkafka">librdkafka</a>（C库）的。</p>
<p>在这篇文章中，我们将介绍 Kafka Producer API。</p>
<h2 id="初始设置">初始设置</h2>
<p>确保你<a href="https://kafka.apache.org/downloads">安装了一个 Kafka broker</a> - 本地设置应该足够了。当然，你也需要<a href="https://www.rust-lang.org/tools/install">安装Rust</a> - 你需要<a href="https://github.com/fede1024/rust-rdkafka#minimum-supported-rust-version-msrv">1.45或以上版本</a>。</p>
<p>在你开始之前，先克隆 GitHub repo。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git clone https://github.com/abhirockzz/rust-kafka-101
<span class="nb">cd</span> part1
</code></pre></div><p>检查 Cargo.toml 文件:</p>
<pre><code>...
[dependencies]
rdkafka = { version = &quot;0.25&quot;, features = [&quot;cmake-build&quot;,&quot;ssl&quot;] }
...
</code></pre><h2 id="关于-cmake-build-功能的说明">关于 cmake-build 功能的说明</h2>
<p><code>rust-rdkafka</code> 提供了几种解决 <code>librdkafka</code> 依赖关系的方法。我选择了 <code>static</code> 链接，其中 <code>librdkafka</code> 被编译。不过你也可以选择 <code>dynamic</code> 链接来引用本地安装的版本。</p>
<blockquote>
<p>更多内容，请<a href="https://github.com/fede1024/rust-rdkafka/blob/master/rdkafka-sys/README.md#features">参考以下链接</a></p>
</blockquote>
<p>好吧，我们先从基本的开始说起。</p>
<h2 id="简单的生产者">简单的生产者</h2>
<p>这里是一个基于 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseProducer.html">BaseProducer</a> 的简单生产者。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">producer</span>: <span class="nc">BaseProducer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ClientConfig</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;bootstrap.servers&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;localhost:9092&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;security.protocol&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;SASL_SSL&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;sasl.mechanisms&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;PLAIN&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;sasl.username&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;&lt;update&gt;&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;sasl.password&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;&lt;update&gt;&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">create</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;invalid producer config&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p><code>send</code> 方法开始产生消息 - 它是在紧缩 <code>loop</code> 中完成的，中间有一个 <code>thread::sleep</code>(不是在生产中会做的事情)，以使其更容易追踪/跟踪结果。键、值（有效载荷）和目标 Kafka 主题以 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseRecord.html">BaseRecord</a> 的形式表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;sending message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">producer</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">BaseRecord</span>::<span class="n">to</span><span class="p">(</span><span class="s">&#34;rust&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;key-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;value-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)),</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to send message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><blockquote>
<p>你可以在文件 <code>src/1_producer_simple.rs</code> 中查看整个代码。</p>
</blockquote>
<h2 id="要测试生产者是否在工作-">要测试生产者是否在工作 &hellip;</h2>
<p>运行这段代码:</p>
<ul>
<li>只需将文件 <code>src/1_producer_simple.rs</code> 重命名为 <code>main.rs</code>。</li>
<li>执行 <code>cargo run</code></li>
</ul>
<p>你应该看到这个输出:</p>
<pre><code>sending message
sending message
sending message
...
</code></pre><p>到底发生了什么？要弄清楚 - 使用 Kafka CLI 消费者（或其他消费者客户端，如 kafkacat）连接到你的 Kafka 主题（我在上面的例子中使用 rust 作为 Kafka 主题的名称）。你应该看到消息流进来了。</p>
<p>例如</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="p">&amp;</span>KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning
</code></pre></div><h2 id="生产者回调">生产者回调</h2>
<p>我们现在是在瞎飞! 除非我们明确地创建一个消费者来查看我们的消息，否则我们不知道它们是否被发送到 Kafka。让我们通过实现 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/trait.ProducerContext.html">ProducerContext</a>(trait)来解决这个问题，以挂接到 produce 事件 - 它就像一个回调。</p>
<p>首先为 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/client/trait.ClientContext.html">ClientContext</a> trait 创建一个结构体和一个空的实现（这是必须的）。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">ProducerCallbackLogger</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">ClientContext</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ProducerCallbackLogger</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>现在到了主要部分，我们在 <code>ProducerContext</code> trait 中实现 <code>delivery</code> 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">ProducerContext</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ProduceCallbackLogger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">DeliveryOpaque</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">delivery</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">delivery_result</span>: <span class="kp">&amp;</span><span class="nc">rdkafka</span>::<span class="n">producer</span>::<span class="n">DeliveryResult</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_delivery_opaque</span>: <span class="nc">Self</span>::<span class="n">DeliveryOpaque</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">dr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delivery_result</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">dr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">key_view</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;produced message with key {} in offset {} of partition {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">key</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">msg</span><span class="p">.</span><span class="n">offset</span><span class="p">(),</span><span class="w">
</span><span class="w">                    </span><span class="n">msg</span><span class="p">.</span><span class="n">partition</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">producer_err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">producer_err</span><span class="p">.</span><span class="mf">1.</span><span class="n">key_view</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;failed to produce message with key {} - {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">producer_err</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们根据 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/type.DeliveryResult.html">DeliveryResult</a>(毕竟它是一个 <code>Result</code>)来匹配成功(<code>Ok</code>)和失败(<code>Err</code>)的情况。我们所做的只是简单地记录这两种情况下的消息，因为这只是一个例子。你可以在这里做任何你想做的事情（虽然不要太疯狂！）。</p>
<blockquote>
<p>我们忽略了 <code>ProducerContext</code> trait 的关联类型 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/trait.ProducerContext.html#associatedtype.DeliveryOpaque">DeliveryOpaque</a>。</p>
</blockquote>
<p>我们需要确保我们插入了 <code>ProducerContext</code> 的实现。我们通过使用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/config/struct.ClientConfig.html#method.create_with_context">create_with_context</a> 方法（而不是 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/config/struct.ClientConfig.html#method.create">create</a>）来实现，并确保为 <code>BaseProducer</code> 提供正确的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">producer</span>: <span class="nc">BaseProducer</span><span class="o">&lt;</span><span class="n">ProduceCallbackLogger</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ClientConfig</span>::<span class="n">new</span><span class="p">().</span><span class="n">set</span><span class="p">(....)</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">.</span><span class="n">create_with_context</span><span class="p">(</span><span class="n">ProduceCallbackLogger</span><span class="w"> </span><span class="p">{})</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span></code></pre></div><h2 id="如何调用-回调">如何调用 &ldquo;回调&rdquo;？</h2>
<p>好了，我们有了实现，但我们需要一种方法来触发它! 其中一个方法就是在生产者上调用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseProducer.html#method.flush">flush</a>。所以，我们可以把我们的 producer 写成这样。</p>
<ul>
<li>添加 <code>producer.flush(Duration::from_secs(3));</code>, 并</li>
<li>注释掉 <code>sleep</code> (just for now)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">        </span><span class="n">producer</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">BaseRecord</span>::<span class="n">to</span><span class="p">(</span><span class="s">&#34;rust&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;key-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;value-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)),</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to send message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">producer</span><span class="p">.</span><span class="n">flush</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;flushed message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">//thread::sleep(Duration::from_secs(3));
</span></code></pre></div><h2 id="等等我们可以做得更好">等等，我们可以做得更好</h2>
<p><code>send</code> 方法是非阻塞的（默认），但通过在每次 <code>send</code> 后调用 <code>flush</code>，我们现在已经将其转换为同步调用 - 从性能角度来看，不推荐使用。</p>
<p>我们可以通过使用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.ThreadedProducer.html">ThreadedProducer</a> 来改善这种情况。它负责在后台线程中调用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/base_producer/struct.BaseProducer.html#method.poll">poll</a> 方法，以确保发送回调通知的传递。这样做非常简单 - 只需将类型从 <code>BaseProducer</code> 改为 <code>ThreadedProducer</code> 即可!</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="err">#</span><span class="w"> </span><span class="n">before</span>: <span class="nc">BaseProducer</span><span class="o">&lt;</span><span class="n">ProduceCallbackLogger</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="err">#</span><span class="w"> </span><span class="n">after</span>: <span class="nc">ThreadedProducer</span><span class="o">&lt;</span><span class="n">ProduceCallbackLogger</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>而且，我们也不需要再调用 <code>flush</code> 了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="c1">//producer.flush(Duration::from_secs(3));
</span><span class="c1">//println!(&#34;flushed message&#34;);
</span><span class="c1"></span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span></code></pre></div><blockquote>
<p>代码在 <code>src/2_threaded_producer.rs</code> 中可以找到。</p>
</blockquote>
<h2 id="再次运行该程序">再次运行该程序</h2>
<ul>
<li>将文件 <code>src/2_threaded_producer.rs</code> 重命名为 <code>main.rs</code>，并且</li>
<li>执行 <code>cargo run</code></li>
</ul>
<p>输出:</p>
<pre><code>sending message
sending message
produced message with key key-1 in offset 6 of partition 2
produced message with key key-2 in offset 3 of partition 0
sending message
produced message with key key-3 in offset 7 of partition 2
</code></pre><p>正如预期的那样，你应该能够看到生产者事件回调，表示消息确实被发送到了 Kafka 主题。当然，你可以直接连接到主题，并再次检查，就像之前一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="p">&amp;</span>KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning
</code></pre></div><blockquote>
<p>要尝试失败的情况，请尝试使用一个不正确的主题名称，并注意 <code>delivery</code> 实现的 <code>Err</code> 变体是如何被调用的。</p>
</blockquote>
<h2 id="发送-json-消息">发送 JSON 消息</h2>
<p>到目前为止，我们只是发送 <code>String</code> 作为 key 和 value。JSON 是一种常用的消息格式，让我们看看如何使用它。</p>
<p>假设我们要发送 <code>User</code> 信息，将使用这个结构体来表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">id</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后我们可以使用 <a href="https://docs.serde.rs/serde_json/">serde_json</a> 库将其序列化为 JSON。我们所需要的就是使用 <a href="https://serde.rs/derive.html">serde 中的自定义派生函数</a> - <code>Deserialize</code> 和 <code>Serialize</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">serde</span>::<span class="p">{</span><span class="n">Deserialize</span><span class="p">,</span><span class="w"> </span><span class="n">Serialize</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Serialize, Deserialize, Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">id</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="修改生产者循环">修改生产者循环。</h2>
<ul>
<li>创建一个 <code>User</code> 实例</li>
<li>使用 <a href="https://docs.serde.rs/serde_json/fn.to_string_pretty.html">to_string_pretty</a> 将其序列化为 JSON 字符串。</li>
<li>在有效载荷中加入这一点</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">...</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">user_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">to_string_pretty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;json serialization failed&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">producer</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">BaseRecord</span>::<span class="n">to</span><span class="p">(</span><span class="s">&#34;rust&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;user-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_json</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to send message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span></code></pre></div><blockquote>
<p>你也可以使用 <a href="https://docs.serde.rs/serde_json/fn.to_vec.html">to_vec</a>(而不是 <code>to_string()</code>)将其转换为一个字节的<code>Vec</code>(<code>Vec&lt;u8&gt;</code>)。</p>
</blockquote>
<h2 id="要运行该程序">要运行该程序&hellip;</h2>
<ul>
<li>将文件 <code>src/3_JSON_payload.rs</code> 重命名为 <code>main.rs</code>，然后</li>
<li>执行 <code>cargo run</code></li>
</ul>
<p>从主题中消费:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="p">&amp;</span>KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning
</code></pre></div><p>你应该看到带有 <code>String</code> 的键（如 <code>user-34</code>）和 JSON 值的消息。</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span>
  <span class="nt">&#34;email&#34;</span><span class="p">:</span> <span class="s2">&#34;user-34@foobar.com&#34;</span>
<span class="p">}</span>
</code></pre></div><h2 id="有更好的方法吗">有更好的方法吗？</h2>
<p>是的！如果你习惯了 Kafka Java 客户端中的声明式序列化/去序列化方法（可能其他客户端也一样），你可能不喜欢这种 &ldquo;显式&rdquo; 方法。只是为了让大家明白，这是你在 Java 中的做法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">BOOTSTRAP_SERVERS_CONFIG</span><span class="o">,</span> <span class="s">&#34;localhost:9092&#34;</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">KEY_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span>
  <span class="s">&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">VALUE_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span>
  <span class="s">&#34;io.confluent.kafka.serializers.json.KafkaJsonSchemaSerializer&#34;</span><span class="o">);</span>

<span class="o">....</span>

<span class="n">ProducerRecord</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">User</span><span class="o">&gt;</span> <span class="n">record</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProducerRecord</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">User</span><span class="o">&gt;(</span><span class="n">topic</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">user</span><span class="o">);</span>
<span class="n">producer</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>
</code></pre></div><blockquote>
<p>请注意，您只需将 <code>Producer</code> 配置为使用 <code>KafkaJsonSchemaSerializer</code>，<code>User</code> 类就会被序列化为 JSON。</p>
</blockquote>
<p><code>rust-rdkafka</code> 用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/message/trait.ToBytes.html">ToBytes</a> trait 提供了类似的东西。下面是它的样子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">ToBytes</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Converts the provided data to bytes.
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不言而喻吧？<code>String</code>、<code>Vec&lt;u8&gt;</code> 等都有现有的实现。所以你可以使用这些类型作为键或值，而不需要任何额外的工作 - 这正是我们刚刚做的。但问题是我们的方法是 &ldquo;显式&rdquo; 的，即我们将 <code>User</code> 结构转换为 JSON 字符串，并将其传递出去。</p>
<h2 id="如果我们可以为-user-实现-tobytes-呢">如果我们可以为 <code>User</code> 实现 <code>ToBytes</code> 呢？</h2>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">ToBytes</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">to_vec_pretty</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;json serialization failed&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>你会看到一个编译器错误。</p>
<pre><code>cannot return value referencing local variable `b`
returns a value referencing data owned by the current function
</code></pre><blockquote>
<p>更多的背景资料，请参考 <a href="https://github.com/fede1024/rust-rdkafka/issues/128">GitHub</a> 的问题。我很乐意看到其他可以与 <code>ToBytes</code> 一起工作的例子 - 如果你有这方面的意见，请在留言中留下。</p>
</blockquote>
<p>TL;DR是，最好坚持用 &ldquo;显式&rdquo; 的方式做事，除非你有一个 <code>ToBytes</code> 的实现，&ldquo;不涉及分配，不能失败&rdquo;。</p>
<h2 id="总结">总结</h2>
<p>第一部分就到这里。第二部分将涉及围绕 Kafka 消费者的话题。</p>
<p>原文链接: <a href="https://dev.to/abhirockzz/getting-started-with-kafka-and-rust-part-1-4hkb">https://dev.to/abhirockzz/getting-started-with-kafka-and-rust-part-1-4hkb</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                             
                                <category scheme="https://ohmyweekly.github.io/categories/kafka" term="kafka" label="kafka" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Rust 中处理错误的初级指南]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-14-a-beginner-guide-to-handling-errors-in-rust/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-14-getting-started-with-kafka-and-rust-part1/?utm_source=atom_feed" rel="related" type="text/html" title="Kafka 和 Rust入门 - 第一部分" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Sizedness in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-14-a-beginner-guide-to-handling-errors-in-rust/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-14T00:00:00+08:00</published>
            <updated>2021-04-14T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>A Beginner&rsquo;s Guide to Handling Errors in Rust</blockquote><p>《Rust 编程语言》中的示例项目对于向新的潜在 Rustaceans 介绍 Rust 的不同方面和特性是非常好的。在这篇文章中，我们将通过扩展《Rust 编程语言》中的 <code>minigrep</code> 项目，看看实现更强大的错误处理基础架构的一些不同方法。</p>
<p><code>minigrep</code> 项目在<a href="https://doc.rust-lang.org/book/ch12-00-an-io-project.html">第12章</a>中介绍，它引导读者构建一个简单版本的 <code>grep</code> 命令行工具，这是一个用于搜索文本的工具。例如，你会传入一个查询，你要搜索的文本，以及文本所在的文件名，然后得到包含查询文本的所有行。</p>
<p>这篇文章的目标是用更强大的错误处理模式来扩展本书的 <code>minigrep</code> 实现，这样你就能更好地了解 Rust 项目中处理错误的不同方法。</p>
<p>作为参考，你可以在<a href="https://github.com/seanchen1991/error-handling-examples/tree/minigrep-control/examples/minigrep">这里</a>找到本书的 <code>minigrep</code> 版本的最终代码。</p>
<h2 id="错误处理用例">错误处理用例</h2>
<p>当涉及到 Rust 项目的结构时，一个常见的模式是有一个 &ldquo;库&rdquo; 的部分和一个 &ldquo;应用&rdquo; 的部分，前者是主要的数据结构、函数和逻辑，后者是将库函数联系在一起。</p>
<p>你可以在原始 <code>minigrep</code> 代码的文件结构中看到这一点：应用逻辑存在于 <code>src/bin/main.rs</code> 文件中，它只是一个薄薄的包裹，包裹着在 <code>src/lib.rs</code> 文件中定义的数据结构和函数；主函数所做的就是调用 <code>minigrep::run</code>。</p>
<p>这一点很重要，因为取决于我们是在构建一个应用程序还是一个库，会改变我们处理错误的方式。</p>
<p>当涉及到一个应用程序时，最终用户很可能不想知道是什么原因导致了一个错误的琐碎细节。事实上，应用程序的最终用户可能只应该在错误无法恢复的情况下被通知错误。在这种情况下，提供关于为什么发生不可恢复的错误的细节也是有用的，特别是当它与用户输入有关时。如果某种可恢复的错误发生在后台，应用程序的消费者可能不需要知道它。</p>
<p>相反，当涉及到一个库时，最终用户是其他开发人员，他们正在使用该库并在其之上构建一些东西。在这种情况下，我们希望尽可能多地提供关于我们的库中发生的任何错误的相关细节。然后，库的消费者将决定他们想要如何处理这些错误。</p>
<p>那么，当我们的项目中既有库部分又有应用部分时，这两种方法是如何一起发挥作用的呢？<code>main</code> 函数执行 <code>minigrep::run</code> 函数，并输出结果中出现的任何错误。所以我们大部分的错误处理工作将集中在库部分。</p>
<h2 id="浮现库错误">浮现库错误</h2>
<p>在 <code>src/lib.rs</code> 中，我们有两个函数，<code>Config::new</code> 和 <code>run</code>，它们可能会返回错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">args</span>: <span class="nc">env</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">case_sensitive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">var</span><span class="p">(</span><span class="s">&#34;CASE_INSENSITIVE&#34;</span><span class="p">).</span><span class="n">is_err</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">query</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">filename</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">case_sensitive</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">case_sensitive</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">search_case_insensitive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>确切有三个地方在返回错误：两个错误发生在 <code>Config::new</code> 函数中，该函数返回一个 <code>Result&lt;Config，&amp;'static str&gt;</code>。在这种情况下，<code>Result</code> 的错误变体是一个静态字符串切片。</p>
<p>在这里，当用户没有提供查询时，我们会返回一个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p>这里，当用户没有提供文件名时，我们会返回一个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p>以这种方式将错误结构化为静态字符串的主要问题是，错误信息并没有被放置在一个中心位置，如果需要的话，我们可以轻松地重构它们。这也使得我们更难在相同类型的错误之间保持错误信息的一致性。</p>
<p>第三种错误发生在 <code>run</code> 函数的顶部，它返回一个 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。在这种情况下，错误变体是一个实现  <code>Error</code> <a href="https://doc.rust-lang.org/std/error/trait.Error.html">trait</a> 的 trait 对象。换句话说，这个函数的错误变体是实现 <code>Error</code> trait 的类型的任何实例。</p>
<p>在这里，我们将调用 <code>fs::read_to_string</code> 时可能发生的任何错误冒出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这适用于调用 <code>fs::read_to_string</code> 时可能出现的错误，因为这个函数能够返回多种类型的错误。因此，我们需要一种方法来表示这些不同的可能的错误类型；它们之间的共同点是它们都实现了 <code>Error</code> trait！最终，我们要做的是定义所有这些错误类型。</p>
<p>最终，我们要做的是在一个中心位置定义所有这些不同类型的错误，并让它们都成为单一类型的变体。</p>
<h2 id="在一个中心类型中定义错误变种">在一个中心类型中定义错误变种</h2>
<p>我们将创建一个新的 <code>src/error.rs</code> 文件，并定义一个枚举 <code>AppError</code>，并在此过程中派生出 <code>Debug</code> trait，以便我们在需要时可以得到一个调试表示。我们将为这个枚举的每一个变体命名，使它们恰当地代表三种类型的错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MissingQuery</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">MissingFilename</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ConfigLoad</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>第三个变体，<code>ConfigLoad</code>，映射到 <code>Config::run</code> 函数中调用 <code>fs::read_to_string</code> 时可能出现的错误。乍一看，这似乎有点不妥，因为如果该函数出现错误，那就是在读取提供的配置文件时出现了某种I/O问题。那么我们为什么不把它命名为 <code>IOError</code> 或者类似的东西呢？</p>
<p>在这种情况下，由于我们是将一个标准库函数的错误浮出水面，所以描述浮出水面的错误是如何影响它的，而不是简单地重申它，这与我们的应用更相关。当 <code>fs::read_to_string</code> 发生错误时，会阻止我们的 <code>Config</code> 加载，所以这就是为什么我们把它命名为 <code>ConfigLoad</code>。</p>
<p>现在我们有了这个类型，我们需要更新代码中所有返回错误的地方以利用这个 <code>AppError</code> 枚举。</p>
<h2 id="返回-apperror-的变体">返回 <code>AppError</code> 的变体</h2>
<p>在我们的 <code>src/lib.rs</code> 文件的顶部，我们需要声明我们的错误模块，并将 <code>error::AppError</code> 带入作用域。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="nn">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">error</span>::<span class="n">AppError</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>在我们的 <code>Config::new</code> 函数中，我们需要更新我们作为错误返回静态字符串切片的地方，以及函数本身的返回类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">-</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">args</span>: <span class="nc">env</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">args</span>: <span class="nc">env</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="n">AppError</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">AppError</span>::<span class="n">MissingQuery</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">AppError</span>::<span class="n">MissingFilename</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// --snip--
</span></code></pre></div><p>运行函数中的第三个错误，只需要我们更新它的返回类型，因为 <code>?</code> 操作符已经负责将错误冒出来，并在发生时返回。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">-</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">AppError</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>好了，现在我们正在使用我们的错误变体，一旦发生，这些错误变体将被浮现到我们的 <code>main</code> 函数中并打印出来。但是我们不再有之前定义的实际错误信息了！我们可以用 <code>thiserror</code> 注释错误变体。</p>
<h2 id="用-thiserror-注释错误变体">用 <code>thiserror</code> 注释错误变体</h2>
<p><code>thiserror</code> <a href="https://docs.rs/thiserror/1.0.24/thiserror/">crate</a> 是一个常用的工具，它提供了一种符合人体工程学的方式来格式化 Rust 库中的错误信息。</p>
<p>它允许我们在 <code>AppError</code> 枚举中用我们希望显示给最终用户的实际错误信息来注解每个变体。</p>
<p>让我们在 Cargo.toml 中添加它作为依赖。</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
<span class="nx">thiserror</span> <span class="p">=</span> <span class="s2">&#34;1&#34;</span>
</code></pre></div><p>在 <code>src/error.rs</code> 中，我们将把 <code>thiserror::Error</code> trait 带入作用域，并让我们的 <code>AppError</code> 类型派生它。我们需要派生这个 trait，以便用 <code>#[error]</code> 块来注解每个枚举变量。现在我们指定我们希望为每个特定变量显示的错误信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">+</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">thiserror</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w"> </span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="cp">#[derive(Debug, Error)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingQuery</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingFilename</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Could not load config&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="cp">#[from]</span><span class="w"> 
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="n">source</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>ConfigLoad</code> 变体中增加了什么额外的东西？由于 <code>ConfigLoad</code> 错误只有在调用 <code>fs::read_to_string</code> 出现底层错误时才会发生，所以 <code>ConfigLoad</code> 变体实际上做的是围绕底层I/O错误提供额外的上下文。</p>
<p><code>thiserror</code> 允许我们通过用 <code>#[from]</code> 来注解一个低级错误，以将源码转换为我们自制的错误类型，从而将其包裹在额外的上下文中。这样一来，当一个I/O错误发生时（比如我们指定了一个要搜索的文件，但实际上并不存在），我们就会得到这样一个错误。</p>
<pre><code>Could not load config: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre><p>如果没有它，产生的错误信息看起来像这样。</p>
<pre><code>Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre><p>对于我们库的消费者来说，要想找出这个错误的来源是比较困难的，额外的上下文帮助很大。</p>
<p>你可以在<a href="https://github.com/seanchen1991/error-handling-examples/tree/minigrep-thiserror/examples/minigrep">这里</a>找到使用这个错误的 <code>minigrep</code> 版本。</p>
<h2 id="更加手动的方法">更加手动的方法</h2>
<p>现在，我们将换个角度，看看如何在不将其作为依赖的情况下，实现与 <code>thiserror</code> 相同的结果。</p>
<p>在引擎盖下，<code>thiserror</code> 用程序宏执行了一些魔法，这对编译速度有明显的影响。在 <code>minigrep</code> 的情况下，我们的错误变体很少，而且项目也很小，所以依赖 <code>thiserror</code> 并不会增加多少编译时间，但是在一个更大更复杂的项目中，这可能是一个考虑因素。</p>
<p>所以在这一点上，我们将把这篇文章撕掉，换成我们自己的手动实现来结束这篇文章。走这条路的好处是，我们只需要修改 <code>src/error.rs</code> 文件就可以实现所有必要的改变（当然，除了从我们的 Cargo.toml 中删除 thiserror 之外）。</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
<span class="err">-</span> <span class="nx">thiserror</span> <span class="p">=</span> <span class="s2">&#34;1&#34;</span>
</code></pre></div><p>让我们删除所有 <code>thiserror</code> 提供给我们的注释。我们还将用 <code>std::error::Error</code> trait 替换 <code>thiserror::Error</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">-</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">thiserror</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w"> </span><span class="cp">#[derive(Debug, Error)]</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="cp">#[derive(Error)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingQuery</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingFilename</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Could not load config&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">      </span><span class="cp">#[from]</span><span class="w">
</span><span class="w">       </span><span class="n">source</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了恢复我们刚刚擦除的所有功能，我们需要做三件事。</p>
<ol>
<li>为 <code>AppError</code> 实现 <code>Display</code> trait，这样我们的错误变体就可以显示给用户了。</li>
<li>为 <code>AppError</code> 实现 <code>Error</code> trait。这个 trait 代表了对错误类型的基本期望，即它们实现了 <code>Display</code> 和 <code>Debug</code>，再加上获取错误底层源或原因的能力。</li>
<li>为 <code>AppError</code> 实现 <code>From&lt;io::Error&gt;</code>。这是必要的，这样我们就可以将从 <code>fs::read_to_string</code> 返回的I/O错误转换为 <code>AppError</code> 的实例。</li>
</ol>
<p>这里是我们对 <code>AppError</code> 的 <code>Display</code> trait 的实现。它将每个错误变量映射为一个字符串，并将其写入到 <code>Display</code>  formatter 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">MissingQuery</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">MissingFilename</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Could not load config: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>而这就是我们对 <code>Error</code> trait 的实现。要实现的主要方法是 <code>Error::source</code> 方法，它的目的是提供错误源的信息。对于我们的 <code>AppError</code> 类型，只有 <code>ConfigLoad</code> 会暴露任何底层源信息，即调用 <code>fs::read_to_string</code> 可能发生的I/O错误。在其他错误变体的情况下，没有底层的源信息需要暴露。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">source</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>返回类型的 <code>&amp;(dyn Error + 'static')</code> 部分类似于我们之前看到的 <code>Box&lt;dyn Error&gt;</code> trait 对象。这里的主要区别是，trait 对象是在一个不可变的引用后面，而不是 <code>Box</code> 指针。这里的 <code>'static</code> lifetime 意味着 trait 对象本身只包含拥有的值，也就是说，它内部不存储任何引用。这是必要的，以便让编译器确信这里没有悬空指针的机会。</p>
<p>最后，我们需要一种将 <code>io::Error</code> 转换为 <code>AppError</code> 的方法。我们将通过为 <code>AppError for From&lt;io::error&gt;</code> 来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">source</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个没什么好说的。如果我们得到一个 <code>io::Error</code>，我们要做的就是将其转换为 <code>AppError</code>，并将其封装在 <code>ConfigLoad</code> 变体中。</p>
<p>这就是全部了，伙计们 你可以在<a href="https://github.com/seanchen1991/error-handling-examples/tree/main/examples/minigrep">这里</a>找到这个版本的 <code>minigrep</code> 实现。</p>
<h2 id="总结">总结</h2>
<p>最后，我们讨论了《Rust编程语言》一书中介绍的原始 <code>minigrep</code> 实现在错误处理方面是如何有点欠缺的，以及如何考虑不同的错误处理用例。</p>
<p>从那里，我们展示了如何使用 <code>thiserror</code> crate 将所有可能的错误变体集中到一个类型中。</p>
<p>最后，我们剥开了 <code>thiserror</code> 提供的外衣，展示了如何手动复制同样的功能。</p>
<p>希望大家能从这篇文章中学到一些东西!</p>
<p>原文链接: <a href="https://dev.to/seanchen1991/a-beginner-s-guide-to-handling-errors-in-rust-40k2">https://dev.to/seanchen1991/a-beginner-s-guide-to-handling-errors-in-rust-40k2</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                             
                                <category scheme="https://ohmyweekly.github.io/categories/error" term="error" label="error" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Sizedness in Rust]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-11T00:00:00+08:00</published>
            <updated>2021-04-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Sizedness in Rust</blockquote><h1 id="sizedness-in-rust">Sizedness in Rust</h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#sizedness">Sizedness</a></li>
<li><a href="#sized-trait"><code>Sized</code> Trait</a></li>
<li><a href="#sized-in-generics"><code>Sized</code> in Generics</a></li>
<li><a href="#unsized-types">Unsized Types</a>
<ul>
<li><a href="#slices">Slices</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#trait-object-limitations">Trait Object Limitations</a>
<ul>
<li><a href="#cannot-cast-unsized-types-to-trait-objects">Cannot Cast Unsized Types to Trait Objects</a></li>
<li><a href="#cannot-create-multi-trait-objects">Cannot create Multi-Trait Objects</a></li>
</ul>
</li>
<li><a href="#user-defined-unsized-types">User-Defined Unsized Types</a></li>
</ul>
</li>
<li><a href="#zero-sized-types">Zero-Sized Types</a>
<ul>
<li><a href="#unit-type">Unit Type</a></li>
<li><a href="#user-defined-unit-structs">User-Defined Unit Structs</a></li>
<li><a href="#never-type">Never Type</a></li>
<li><a href="#user-defined-pseudo-never-types">User-Defined Pseudo Never Types</a></li>
<li><a href="#phantomdata">PhantomData</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#discuss">Discuss</a></li>
<li><a href="#notifications">Notifications</a></li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>Sizedness是Rust中最重要的概念之一。它与其他语言特性有很多微妙的交集，只是以_&ldquo;x在编译时不知道大小&rdquo;_错误信息的形式出现，而这些错误信息是每个Rustacean都非常熟悉的。在这篇文章中，我们将探讨从大小类型，到无大小类型，再到零大小类型的各种风味，同时研究它们的用例、好处、痛点和变通方法。</p>
<p>我使用的短语表，以及它们的含义。</p>
<table>
<thead>
<tr>
<th>Phrase</th>
<th>Shorthand for</th>
</tr>
</thead>
<tbody>
<tr>
<td>sizedness</td>
<td>property of being sized or unsized</td>
</tr>
<tr>
<td>sized type</td>
<td>type with a known size at compile time</td>
</tr>
<tr>
<td>1) unsized type <em>or</em><!-- raw HTML omitted -->2) DST</td>
<td>dynamically-sized type, i.e. size not known at compile time</td>
</tr>
<tr>
<td>?sized type</td>
<td>type that may or may not be sized</td>
</tr>
<tr>
<td>unsized coercion</td>
<td>coercing a sized type into an unsized type</td>
</tr>
<tr>
<td>ZST</td>
<td>zero-sized type, i.e. instances of the type are 0 bytes in size</td>
</tr>
<tr>
<td>width</td>
<td>single unit of measurement of pointer width</td>
</tr>
<tr>
<td>1) thin pointer <em>or</em><!-- raw HTML omitted -->2) single-width pointer</td>
<td>pointer that is <em>1 width</em></td>
</tr>
<tr>
<td>1) fat pointer <em>or</em><!-- raw HTML omitted -->2) double-width pointer</td>
<td>pointer that is <em>2 widths</em></td>
</tr>
<tr>
<td>1) pointer <em>or</em><!-- raw HTML omitted -->2) reference</td>
<td>some pointer of some width, width will be clarified by context</td>
</tr>
<tr>
<td>slice</td>
<td>double-width pointer to a dynamically sized view into some array</td>
</tr>
</tbody>
</table>
<h2 id="sizedness">Sizedness</h2>
<p>在 Rust 中，如果在编译时可以确定类型的字节大小，那么就可以确定类型的大小。确定一个类型的大小对于能够在栈上为该类型的实例分配足够的空间是很重要的。固定大小的类型可以通过值或引用来传递。如果一个类型的大小不能在编译时确定，那么它被称为不确定大小类型或 DST，动态大小类型。由于不确定大小类型不能被放置在栈上，它们只能通过引用来传递。下面是一些固定大小类型和不确定大小类型的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// primitives
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// tuples
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// arrays
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// structs
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// enums
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// get pointer width, will be
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 4 bytes wide on 32-bit targets or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 8 bytes wide on 64-bit targets
</span><span class="c1"></span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// pointers to sized types are 1 width
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">DOUBLE_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized struct
</span><span class="c1"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">Unsized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">unsized_field</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// pointers to unsized types are 2 widths
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// slice
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// slice
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// trait object
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// trait object
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">Unsized</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// user-defined unsized type
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized types
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Unsized</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们如何确定固定大小类型的大小是直截了当的：所有原生类型和指针都有已知的大小，所有的结构体、元组、枚举和数组只是由原生类型和指针或其他嵌套的结构体、元组、枚举和数组组成，因此我们只需考虑到填充和对齐所需的额外字节，递归地计数字节即可。我们无法确定不确定大小类型的大小，原因同样简单明了：切片可以有任意数量的元素在其中，因此在运行时可以是任意大小的，trait 对象可以由任意数量的结构或枚举实现，因此在运行时也可以是任意大小的。</p>
<p><strong>专业提示</strong></p>
<ul>
<li>在Rust中，视图到数组中的动态大小的指针被称为切片。例如 <code>&amp;str</code> 是一个&quot;字符串切片&quot;, <code>&amp;[i32]</code> 一个 <em>&ldquo;i32 切片&rdquo;</em>。</li>
<li>切片是双倍宽度的，因为它们存储了一个指向数组的指针和数组中元素的数量。</li>
<li>trait 对象指针是双宽度的，因为它们存储了一个指向数据的指针和一个指向 vtable 的指针。</li>
<li>不确定大小的结构体指针是双倍宽度的，因为它们存储了一个指向结构体数据的指针和结构体的大小。</li>
<li>不确定大小的结构体只能有1个不确定大小的字段，而且必须是结构体中的最后一个字段。</li>
</ul>
<p>为了让大家真正明白关于不确定大小类型的双宽度指针的点，这里有一个比较数组和切片的注释代码示例。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">DOUBLE_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// data length stored in type
</span><span class="c1"></span><span class="w">    </span><span class="c1">// an [i32; 3] is an array of three i32s
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// can iterate over nums safely
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Rust knows it&#39;s exactly 3 elements
</span><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized coercion from [i32; 3] to [i32]
</span><span class="c1"></span><span class="w">    </span><span class="c1">// data length now stored in pointer
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// double-width pointer required to also store data length
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// can iterate over nums safely
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Rust knows it&#39;s exactly 3 elements
</span><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里还有一个注释的代码例子，比较结构体和 trait 对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">DOUBLE_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct2</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;struct&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;struct2&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">print_struct</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">Struct</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// always prints &#34;struct&#34;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// this is known at compile-time
</span><span class="c1"></span><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">print_struct2</span><span class="p">(</span><span class="n">s2</span>: <span class="kp">&amp;</span><span class="nc">Struct2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// always prints &#34;struct2&#34;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// this is known at compile-time
</span><span class="c1"></span><span class="w">    </span><span class="n">s2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">Struct2</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">print_trait</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// print &#34;struct&#34; or &#34;struct2&#34; ?
</span><span class="c1"></span><span class="w">    </span><span class="c1">// this is unknown at compile-time
</span><span class="c1"></span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// Rust has to check the pointer at run-time
</span><span class="c1"></span><span class="w">    </span><span class="c1">// to figure out whether to use Struct&#39;s
</span><span class="c1"></span><span class="w">    </span><span class="c1">// or Struct2&#39;s implementation of &#34;print&#34;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// so the pointer has to be double-width
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer to data
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w"> 
</span><span class="w">    </span><span class="n">print_struct</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// single-width pointer to data
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_struct2</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct2&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// unsized coercion from Struct to dyn Trait
</span><span class="c1"></span><span class="w">    </span><span class="c1">// double-width pointer to point to data AND Struct&#39;s vtable
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// unsized coercion from Struct2 to dyn Trait
</span><span class="c1"></span><span class="w">    </span><span class="c1">// double-width pointer to point to data AND Struct2&#39;s vtable
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct2&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>只有固定大小类型的实例才能被放置在栈上，也就是说，可以通过值来传递</li>
<li>不确定大小类型的实例不能放在栈上，必须通过引用来传递</li>
<li>指向不确定大小类型的指针是双宽度的，因为除了指向数据外，它们还需要做额外的记账工作，以跟踪数据的长度或指向一个 vtable</li>
</ul>
<h2 id="sized-trait"><code>Sized</code> Trait</h2>
<p>Rust中的 &ldquo;Sized&rdquo; trait 是一个自动 trait 和一个标记 trait。</p>
<p>自动 trait 是指当一个类型通过某些条件时，自动实现的 trait。标记 trait 是标记一个类型具有特定属性的 trait。标记 trait 没有任何 trait 项，如方法、关联函数、关联常量或关联类型。所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait。自动 trait 必须是标记 trait，所以编译器可以为它们提供一个自动的缺省实现，如果 trait 有任何 trait 项，这是不可能的。</p>
<p>如果一个类型的所有成员也是 &ldquo;确定大小的&rdquo;，那么它就会得到一个自动的 <code>Sized</code> 实现。&ldquo;成员&quot;的含义取决于所包含的类型，例如：结构体的字段、枚举的变体、数组的元素、元组的项等等。一旦一个类型被 &ldquo;标记&rdquo; 了一个 <code>Sized</code> 的实现，这意味着在编译时就知道它的字节大小。</p>
<p>其他自动标记 trait 的例子是 <code>Send</code> 和 <code>Sync</code> trait。如果跨线程发送一个类型是安全的，那么这个类型就是可 <code>Send</code> 的。如果在线程之间共享该类型的引用是安全的，那么该类型就是可 <code>Sync</code> 的。如果一个类型的所有成员都是可 <code>Send</code> 和 <code>Sync</code> 的, 那么这个类型就会得到自动的 <code>Send</code> 和 <code>Sync</code> 实现。<code>Sized</code> 的特殊之处在于它不可能选择退出，不像其他自动标记 trait 可以选择退出。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(negative_impls)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is Sized, Send, and Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Send trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Sync trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Sized</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span></code></pre></div><p>这似乎是合理的，因为我们可能有理由不希望我们的类型被跨线程发送或共享，但是很难想象我们会希望编译器 &ldquo;忘记&rdquo; 我们类型的大小，并将其视为一个不确定大小的类型，因为这不会带来任何好处，只会让类型更难处理。</p>
<p>另外，说得迂腐一点，<code>Sized</code> 在技术上并不是一个自动 trait，因为它没有使用 <code>auto</code> 关键字来定义，但是编译器对它的特殊处理使它的行为与自动 trait 非常相似，所以在实践中，把它看作是一个自动 trait 是可以的。</p>
<p><strong>关键要点</strong></p>
<ul>
<li><code>Sized</code> 是一个自动标记 trait</li>
</ul>
<h2 id="泛型中的-sized">泛型中的 <code>Sized</code></h2>
<p>每当我们编写任何泛型代码时，每一个泛型类型参数都会被默认的 <code>Sized</code> trait 自动绑定，这一点并不明显。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this generic function...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...desugars to...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...which we can opt-out of by explicitly setting ?Sized...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// ...which doesn&#39;t compile since t doesn&#39;t have
</span><span class="c1">// a known size so we must put it behind a pointer...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span></code></pre></div><p><strong>专业提示</strong></p>
<ul>
<li><code>?Sized</code> can be pronounced <em>&ldquo;optionally sized&rdquo;</em> or <em>&ldquo;maybe sized&rdquo;</em> and adding it to a type parameter&rsquo;s bounds allows the type to be sized or unsized</li>
<li><code>?Sized</code> in general is referred to as a <em>&ldquo;widening bound&rdquo;</em> or a <em>&ldquo;relaxed bound&rdquo;</em> as it relaxes rather than constrains the type parameter</li>
<li><code>?Sized</code> is the only relaxed bound in Rust</li>
</ul>
<p>So why does this matter? Well, any time we&rsquo;re working with a generic type and that type is behind a pointer we almost always want to opt-out of the default <code>Sized</code> bound to make our function more flexible in what argument types it will accept. Also, if we don&rsquo;t opt-out of the default <code>Sized</code> bound we&rsquo;ll eventually get some surprising and confusing compile error messages.</p>
<p>Let me take you on the journey of the first generic function I ever wrote in Rust. I started learning Rust before the <code>dbg!</code> macro landed in stable so the only way to print debug values was to type out <code>println!(&quot;{:?}&quot;, some_value);</code> every time which is pretty tedious so I decided to write a <code>debug</code> helper function like this:</p>
<ul>
<li><code>?Sized</code> 可以读作 <em>&ldquo;optionally sized&rdquo;</em> 或 <em>&ldquo;maybe sized&rdquo;</em>，将它添加到类型参数的绑定中，可以让类型被确定大小或不确定大小。</li>
<li><code>?Sized</code> 一般被称为 &ldquo;拓宽绑定&rdquo; 或 &ldquo;宽松绑定&rdquo;，因为它放松而不是约束类型参数。</li>
<li><code>?Sized</code> 是 Rust 中唯一的宽松绑定。</li>
</ul>
<p>那么为什么这很重要呢？任何时候，当我们在处理泛型类型，并且该类型在一个指针后面时，我们几乎总是希望选择退出默认的 <code>Sized</code> 绑定，以使我们的函数在接受什么参数类型时更加灵活。另外，如果我们不选择退出默认的 <code>Sized</code> 绑定，我们最终会得到一些令人惊讶和困惑的编译错误信息。</p>
<p>让我带你了解一下我在 Rust 中写的第一个泛型函数的历程。在 <code>dbg!</code> 宏登陆稳定版之前，我就开始学习 Rust 了，所以打印调试值的唯一方法就是每次都要打出 <code>println!(&quot;{:?}&quot;, some_value);</code>，这是很乏味的，所以我决定写一个像这样的调试帮助函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">debug</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// T: Debug + Sized
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">debug</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// T = &amp;str, &amp;str: Debug + Sized ✔️
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>到目前为止还不错，但函数会对传递给它的任何值拥有所有权，这有点烦人，所以我把函数改为只接受引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">dbg</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// T: Debug + Sized
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">dbg</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// &amp;T = &amp;str, T = str, str: Debug + !Sized ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在出现了这个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">8</span>:<span class="mi">9</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dbg</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">        </span><span class="o">-</span><span class="w"> </span><span class="n">required</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">`</span><span class="n">dbg</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">dbg</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">         </span><span class="o">^^^^^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="n">help</span>: <span class="nc">consider</span><span class="w"> </span><span class="n">relaxing</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">implicit</span><span class="w"> </span><span class="err">`</span><span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">restriction</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dbg</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">   
</span></code></pre></div><p>当我第一次看到这个问题时，我发现它令人难以置信的混乱。尽管我的函数对参数的限制比以前更严格，但现在它却莫名其妙地抛出了一个编译错误！这是怎么回事？到底发生了什么？</p>
<p>我已经在上面的代码注释中破坏了答案，但基本上。Rust 在编译过程中把 <code>T</code> 解析为具体类型时，会执行模式匹配。这里有几个表格可以帮助澄清。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>T</code></th>
<th><code>&amp;T</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;str</code></td>
<td><code>T</code> = <code>&amp;str</code></td>
<td><code>T</code> = <code>str</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>Sized</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>str</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>&amp;str</code></td>
<td>✔️</td>
</tr>
<tr>
<td><code>&amp;&amp;str</code></td>
<td>✔️</td>
</tr>
</tbody>
</table>
<p>这也是为什么我不得不在改成取用引用后，加了一个 <code>?Sized</code> 的绑定，使函数能正常工作。下面是可以工作的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">debug</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// T: Debug + ?Sized
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">debug</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// &amp;T = &amp;str, T = str, str: Debug + !Sized ✔️
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>所有的泛型类型参数默认都是自动绑定 <code>Sized</code>。</li>
<li>如果我们有一个泛型函数，它的参数是指针后面的一些 <code>T</code>，例如 <code>&amp;T</code>、<code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 等，那么我们几乎总是希望用<code>T: ?Sized</code> 来退出默认的 <code>Sized</code> 约束。</li>
</ul>
<h2 id="unsized-类型">Unsized 类型</h2>
<h3 id="切片">切片</h3>
<p>最常见的切片是字符串切片 <code>&amp;str</code> 和数组切片 <code>&amp;[T]</code>。切片的好处是许多其他类型也会对其进行 coerce，所以利用切片和 Rust 的自动类型 coerce，我们可以编写灵活的 API。</p>
<p>类型 coerce 可以发生在几个地方，但最明显的是在函数参数和方法调用时。我们感兴趣的类型 coerce 是 deref coerce 和 unsized coerce。deref coerce 是指当 <code>T</code> 在 deref 操作之后被 coerce 成一个 <code>U</code>，即 <code>T: Deref&lt;Target = U&gt;</code>，例如 <code>String.deref() -&gt; str</code>。不确定大小 coerce 是指 <code>T</code> 被 coerce 成 <code>U</code>，其中 <code>T</code> 是一个确定大小的类型，<code>U</code> 是一个不确定大小的类型，即 <code>T: Unsize&lt;U&gt;</code>，例如 <code>[i32; 3] -&gt; [i32]</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// can now call &#34;method&#34; on
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 1) str or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 2) String since String: Deref&lt;Target = str&gt;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// can now call &#34;method&#34; on
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 1) any &amp;[T]
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 2) any U where U: Deref&lt;Target = [T]&gt;, e.g. Vec&lt;T&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 3) [T; N] for any N, since [T; N]: Unsize&lt;[T]&gt;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">str_fun</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">slice_fun</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">str_slice</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;str slice&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;string&#34;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// function args
</span><span class="c1"></span><span class="w">    </span><span class="n">str_fun</span><span class="p">(</span><span class="n">str_slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">str_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">);</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// method calls
</span><span class="c1"></span><span class="w">    </span><span class="n">str_slice</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">three_array</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five_array</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// function args
</span><span class="c1"></span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">);</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">three_array</span><span class="p">);</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">five_array</span><span class="p">);</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// method calls
</span><span class="c1"></span><span class="w">    </span><span class="n">slice</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">three_array</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">five_array</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>利用切片和 Rust 的自动类型强制，我们可以编写灵活的 API。</li>
</ul>
<h3 id="trait-对象">Trait 对象</h3>
<p>Traits 默认是 <code>?Sized</code> 的。这个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>抛出这个错误:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span>: <span class="err">`</span><span class="o">?</span><span class="n">Trait</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">permitted</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">supertraits</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">1</span>:<span class="mi">14</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">              </span><span class="o">^^^^^^</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">traits</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="err">`</span><span class="o">?</span><span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">default</span><span class="w">
</span></code></pre></div><p>我们很快就会讨论为什么 trait 默认为 <code>?Sized</code>，但首先让我们问问自己，一个 trait 被 <code>?Sized</code> 的含义是什么？让我们把上面的例子去掉。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>好的，默认情况下，trait 允许 <code>self</code> 是一个不确定大小的类型。正如我们前面所学，我们不能通过值来传递不确定大小的类型，所以这限制了我们在 trait 中定义方法的种类。应该是不可能写出一个通过取值来获取或返回 <code>self</code> 的方法，然而这令人惊讶的是，它的编译:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，当我们试图实现该方法时，无论是通过提供一个默认的实现，还是通过实现一个不确定大小类型的 trait，我们都会得到编译错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="n">Self</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">2</span>:<span class="mi">15</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">               </span><span class="o">^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="n">Self</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">all</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">statically</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">size</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">unsized</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">gated</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">unstable</span><span class="w"> </span><span class="n">feature</span><span class="w">
</span><span class="w"></span><span class="n">help</span>: <span class="nc">consider</span><span class="w"> </span><span class="n">further</span><span class="w"> </span><span class="n">restricting</span><span class="w"> </span><span class="err">`</span><span class="n">Self</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nc">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                     </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">6</span>:<span class="mi">15</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">6</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">               </span><span class="o">^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">all</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">statically</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">size</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">unsized</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">gated</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">unstable</span><span class="w"> </span><span class="n">feature</span><span class="w">
</span></code></pre></div><p>如果我们决心通过值来传递 <code>self</code>，我们可以通过显式绑定 trait 与 <code>Sized</code> 来解决第一个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">7</span>:<span class="mi">6</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">              </span><span class="o">-----</span><span class="w"> </span><span class="n">required</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="mi">7</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">      </span><span class="o">^^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span></code></pre></div><p>这并没有问题，因为我们知道，当我们将 trait 与 <code>Sized</code> 绑定后，我们就不能再为诸如 <code>str</code> 这样的不确定大小类型实现它了。另一方面，如果我们真的想为 <code>str</code> 实现 trait，另一种解决方案是保留 <code>?Sized</code> trait，并通过引用传递 <code>self</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>与其将整个 trait 标记为 <code>?Sized</code> 或 <code>Sized</code>，我们有更细化和精确的选择，将单个方法标记为 <code>Sized</code>，像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles!?
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="s">&#34;str&#34;</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>令人惊讶的是，Rust编译 <code>impl Trait for str {}</code> 时没有任何抱怨，但当我们试图在一个不确定大小的类型上调用 <code>method</code> 时，它最终还是抓到了错误，所以一切正常。这有点怪异，但为我们提供了一些灵活性，只要我们从不调用 <code>Sized</code> 方法，我们就可以用一些 <code>Sized</code> 方法为不确定大小的类型实现 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// we never call &#34;method&#34; so no errors
</span><span class="c1"></span><span class="w">    </span><span class="s">&#34;str&#34;</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在回到最初的问题，为什么 trait 默认是 <code>?Sized</code>？答案是 trait 对象。trait 对象本质上是不确定大小的，因为任何大小的类型都可以实现 trait，因此我们只有在 <code>Trait: ?Sized</code> 的情况下，才能为 <code>dyn Trait</code> 实现 <code>Trait</code>。用代码来说：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// the above is REQUIRED for
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// compiler magic here
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// since `dyn Trait` is unsized
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// and now we can use `dyn Trait` in our program
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span></code></pre></div><p>如果我们尝试实际编译上述程序，我们会得到：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0371</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="n">automatically</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">5</span>:<span class="mi">1</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w"> </span><span class="err">`</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="n">automatically</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span></code></pre></div><p>这就是编译器告诉我们要冷静，因为它自动为 <code>dyn Trait</code> 提供了 <code>Trait</code> 的实现。同样，由于 <code>dyn Trait</code> 是不确定大小的，编译器只能在 <code>Trait: ?Sized</code> 的情况下提供这个实现。如果我们将 <code>Trait</code> 与 <code>Sized</code> 绑定，那么 <code>Trait</code> 就变成了 &ldquo;对象不安全&rdquo; 的了，这意味着我们不能将实现 <code>Trait</code> 的类型转为 <code>dyn Trait</code> 的 trait 对象。正如预期的那样，这个程序不能编译:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0038</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">3</span>:<span class="mi">18</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">       </span><span class="o">-----</span><span class="w">  </span><span class="o">-----</span><span class="w"> </span><span class="p">...</span><span class="n">because</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="err">`</span><span class="n">Self</span>: <span class="nb">Sized</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">       </span><span class="n">this</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> 
</span><span class="w"></span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                </span><span class="o">^^^^^^^^^^</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="w">
</span></code></pre></div><p>让我们尝试用 <code>Sized</code> 方法制作一个 <code>?Sized</code> trait，看看能否将它转一个 trait 对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">arg</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">arg</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>正如我们之前看到的那样，只要我们不调用 trait 对象上的 <code>Sized</code> 方法，一切都没问题。</p>
<p><strong>关键要点</strong></p>
<ul>
<li>所有的 traits 默认都是 <code>?Sized</code> 的。</li>
<li><code>Trait: ?Sized</code> 是 <code>impl Trait for dyn Trait</code> 所必需的。</li>
<li>我们可以在每个方法的基础上要求 <code>Self: Sized</code>。</li>
<li>由 <code>Sized</code> 绑定的 trait 不能成为 trait 对象。</li>
</ul>
<h3 id="trait-对象限制">trait 对象限制</h3>
<p>即使一个 traitt 是对象安全的，也会有一些与大小相关的边缘情况，这些情况限制了哪些类型可以转换为 trait 对象，以及一个 trait 对象可以表示多少个和什么样的 trait。</p>
<h4 id="不能将不确定大小的类型转换为--trait-对象">不能将不确定大小的类型转换为  Trait 对象</h4>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">ToString</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">trait_object</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">generic</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;String&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">generic</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">trait_object</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;String&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// compiles, unsized coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">trait_object</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error, unsized coercion impossible
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">8</span>:<span class="mi">18</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">trait_object</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="o">^^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">required</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cast</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="n">dyn</span><span class="w"> </span><span class="n">std</span>::<span class="n">string</span>::<span class="nb">ToString</span><span class="err">`</span><span class="w">
</span></code></pre></div><p>为什么将一个 <code>&amp;String</code> 传给一个期望得到 <code>&amp;dyn ToString</code> 的函数，是因为类型胁迫。<code>String</code> 实现了 <code>ToString</code>，我们可以通过不确定大小的胁迫将 <code>String</code> 这样的确定大小的类型转换成 <code>dyn ToString</code> 这样的不确定大小的类型。<code>str</code> 也实现了 <code>ToString</code>，将 <code>str</code> 转换为 <code>dyn ToString</code> 也需要一个不确定大小的胁迫，但 <code>str</code> 已经是不确定大小的了！我们如何将一个已经是不确定大小的类型，变成另一个不确定大小的类型？</p>
<p><code>&amp;str</code> 指针是双宽的，存储一个数据指针和数据长度。<code>&amp;dyn ToString</code> 指针也是双宽度的，存储一个指向数据的指针和一个指向 vtable 的指针。要把一个 <code>&amp;str</code> 胁迫成一个 <code>&amp;dyn toString</code>，就需要一个三倍宽度的指针来存储一个指向数据的指针、数据长度和一个指向 vtable 的指针。Rust 不支持三倍宽度指针，所以不可能将一个不确定大小的类型转换成一个 trait 对象。</p>
<p>前面2段用表格总结了一下。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Pointer to Data</th>
<th>Data Length</th>
<th>Pointer to VTable</th>
<th>Total Width</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;String</code></td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td>1 ✔️</td>
</tr>
<tr>
<td><code>&amp;str</code></td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>2 ✔️</td>
</tr>
<tr>
<td><code>&amp;String as &amp;dyn ToString</code></td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td>2 ✔️</td>
</tr>
<tr>
<td><code>&amp;str as &amp;dyn ToString</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>3 ❌</td>
</tr>
</tbody>
</table>
<h4 id="不能创建-multi-trait-对象">不能创建 Multi-Trait 对象</h4>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0225</span><span class="p">]</span>: <span class="nc">only</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="n">traits</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">additional</span><span class="w"> </span><span class="n">traits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">object</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">4</span>:<span class="mi">30</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">-----</span><span class="w">   </span><span class="o">^^^^^^</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">|</span><span class="w">       </span><span class="n">additional</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">|</span><span class="w">       </span><span class="k">trait</span><span class="w"> </span><span class="n">alias</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="p">(</span><span class="n">additional</span><span class="w"> </span><span class="k">use</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="n">first</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="k">trait</span><span class="w"> </span><span class="n">alias</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="k">use</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>请记住，trait 对象指针是双宽度的：存储1个指向数据的指针和另一个指向 vtable 的指针，但这里有2个trait，所以有2个 vtable，这就需要 <code>&amp;(dyn Trait + Trait2)</code> 指针是3个宽度。像 <code>Send</code> 和 <code>Sync</code> 这样的自动 trait 是允许的，因为它们没有方法，因此没有 vtable。</p>
<p>这方面的变通方法是通过使用另一个 trait 来组合 vtable，比如这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait3</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// auto blanket impl Trait3 for any type that also impls Trait &amp; Trait2
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// from `dyn Trait + Trait2` to `dyn Trait3` 
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个变通方法的一个缺点是，Rust 不支持 supertrait 向上转换。这意味着，如果我们有一个 <code>dyn Trait3</code>，我们不能在需要 <code>dyn Trait</code> 或 <code>dyn Trait2</code> 的地方使用它。这个程序不能编译。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait3</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait2</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">takes_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_trait2</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w">
</span><span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">22</span>:<span class="mi">17</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">22</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">takes_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">                 </span><span class="o">^</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">expected</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span><span class="w">              </span><span class="n">found</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w">
</span><span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">23</span>:<span class="mi">18</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">23</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">takes_trait2</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">                  </span><span class="o">^</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait2</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">expected</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="err">`</span><span class="w">
</span><span class="w">              </span><span class="n">found</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span></code></pre></div><p>这是因为 <code>dyn Trait3</code> 是一个不同于 <code>dyn Trait</code> 和 <code>dyn Trait</code> 的类型，因为它们有不同的 vtable 布局，尽管  <code>dyn Trait3</code> 确实包含 <code>dyn Trait</code> 和 <code>dyn Trait2</code> 的所有方法。这里的变通办法是增加显式转换方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait3</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait2</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">takes_trait</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">as_trait</span><span class="p">());</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_trait2</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">as_trait2</span><span class="p">());</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这是一个简单而直接的工作方法，似乎是 Rust 编译器可以为我们自动完成的事情。Rust 并不羞于执行类型胁迫，正如我们在 deref 和 unsized 胁迫中所看到的那样，那么为什么没有 trait 向上胁迫呢？这是一个很好的问题，有一个熟悉的答案：Rust核心团队正在研究其他更高优先级和更高影响的功能。很公平。</p>
<p><strong>关键要点</strong></p>
<ul>
<li>Rust 不支持宽度超过2的指针，所以&hellip;
<ul>
<li>我们不能将不确定大小的类型转换 trait 对象</li>
<li>我们不能有多个 trait 对象，但我们可以通过将多个 trait 强转成一个 trait 来解决这个问题。</li>
</ul>
</li>
</ul>
<h3 id="用户自定义的不确定大小类型">用户自定义的不确定大小类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Unsized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">unsized_field</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以通过赋予结构体一个不确定大小的字段来定义一个不确定大小的结构体。不确定大小的结构体只能有1个不确定大小的字段，而且它必须是结构体中的最后一个字段。这是一个要求，这样编译器就可以在编译时确定结构中每个字段的起始偏移量，这对高效快速的字段访问非常重要。此外，使用双宽度指针最多只能跟踪一个不确定大小的字段，因为更多的不确定大小的字段将需要更多的宽度。</p>
<p>那么我们到底该如何实例化这个东西呢？和我们处理任何不确定大小类型的方式一样：先做一个可确定大小的版本，然后胁迫它变成不确定大小的版本。然而，<code>Unsized</code> 的定义总是不确定大小的，没有办法制作它的可确定大小版本！唯一的变通办法是使结构体通用化，使它可以存在于确定大小的版本中和不确定大小的版本中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MaybeSized</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">maybe_sized</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized coercion from MaybeSized&lt;[i32; 3]&gt; to MaybeSized&lt;[i32]&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ms</span>: <span class="kp">&amp;</span><span class="nc">MaybeSized</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MaybeSized</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">maybe_sized</span>: <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>那么这有什么用处呢？没有什么特别引人注目的，用户定义的不确定大小的类型现在是一个非常半成品的功能，它们的局限性超过了任何好处。这里提到它们纯粹是为了全面性。</p>
<p><strong>有趣的事实：</strong> <code>std::fi::OsStr</code> 和 <code>std::path::Path</code> 是标准库中的2个不确定大小的结构，你可能已经在不知不觉中使用过了。</p>
<p><strong>关键 要点</strong></p>
<ul>
<li>用户定义的不确定大小类型现在是一个半成品的功能，它们的局限性超过了任何好处</li>
</ul>
<h2 id="zero-sized-类型">Zero-Sized 类型</h2>
<p>Zero-Sized 乍听起来很奇异，但到处都在使用。</p>
<h3 id="unit-类型">Unit 类型</h3>
<p>最常见的零大小类型是 Unit 类型: <code>()</code>. 所有的空块 <code>{}</code> 都评估为 <code>()</code>，如果块是非空的，但最后一个表达式用分号 <code>;</code> 丢弃，那么它也评估为 <code>()</code>。例子如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">5</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>每一个没有显式返回类型的函数都会默认返回 <code>()</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// with sugar
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// desugared
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>由于 <code>()</code> 是零字节，所以 <code>()</code> 的所有实例都是一样的，这使得 <code>Default</code>、<code>PartialEq</code> 和 <code>Ord</code> 的实现非常简单。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_other</span>: <span class="kp">&amp;</span><span class="p">())</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kc">true</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_other</span>: <span class="kp">&amp;</span><span class="p">())</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kc">false</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_other</span>: <span class="kp">&amp;</span><span class="p">())</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>编译器理解 <code>()</code> 是零大小的，并优化了与 <code>()</code> 实例的交互。例如，<code>Vec&lt;()&gt;</code> 永远不会进行任何堆分配，从 <code>Vec</code> 中推送和弹出 <code>()</code> 只是增加和减少它的 <code>len</code> 字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// zero capacity is all the capacity we need to &#34;store&#34; infinitely many ()
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// causes no heap allocations or vec capacity changes
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(());</span><span class="w"> </span><span class="c1">// len++
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(());</span><span class="w"> </span><span class="c1">// len++
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(());</span><span class="w"> </span><span class="c1">// len++
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"> </span><span class="c1">// len--
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>上面的例子没有实际应用，但是有没有什么情况下，我们可以有意义地利用上面的想法呢？令人惊讶的是，是的，我们可以通过将 <code>Value</code> 设置为 <code>()</code>，从 <code>HashMap&lt;Key，Value&gt;</code> 中得到一个高效的 <code>HashSet&lt;Key&gt;</code> 实现，这正是 Rust 标准库中 <code>HashSet</code> 的工作原理。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// std::collections::HashSet
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">map</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>ZST 的所有实例都是彼此相等的。</li>
<li>Rust 编译器知道优化与 ZSTs 的交互。</li>
</ul>
<h3 id="用户自定义的-unit-结构体">用户自定义的 Unit 结构体</h3>
<p>Unit 结构体是指不含任何字段的结构体，如</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>属性，使 Unit 结构体比 <code>()</code> 更有用。</p>
<ul>
<li>我们可以在自己的 Unit 结构体上实现任何我们想要的 trait，Rust 的 trait 孤儿规则阻止我们实现标准库中定义的 <code>()</code> 的 trait。</li>
<li>在我们的程序中，Unit 结构体可以被赋予有意义的名称。</li>
<li>Unit 结构体，就像所有结构体一样，默认情况下是不可复制的，这在我们的程序中可能很重要。</li>
</ul>
<h3 id="never-类型">Never 类型</h3>
<p>第二种最常见的 ZST 是 never 类型: <code>!</code>。 之所以称为 never 类型，是因为它代表的是永远不会解析到任何值的计算。</p>
<p><code>!</code> 的几个有趣的特性使它不同于 <code>()</code>。</p>
<ul>
<li><code>!</code> 可以被胁迫成任何其他类型。</li>
<li>不可能创建 <code>!</code> 的实例。</li>
</ul>
<p>第一个有趣的属性对人体工程学非常有用，允许我们使用像这样的方便的宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// nice for quick prototyping
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">()</span><span class="w"> </span><span class="c1">// ! coerced to Vec&lt;T&gt;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example2</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// we know this parse call will never fail
</span><span class="c1"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="s">&#34;123&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w"> </span><span class="c1">// ! coerced to i32
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example3</span><span class="p">(</span><span class="n">some_condition</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">some_condition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">()</span><span class="w"> </span><span class="c1">// ! coerced to &amp;str
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;str&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>break</code>, <code>continue</code> 和 <code>return</code> 表达式也拥有类型 <code>!</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// we can set the type of x to anything here
</span><span class="c1"></span><span class="w">    </span><span class="c1">// since the block never evaluates to any value
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">123</span><span class="w"> </span><span class="c1">// ! coerced to String
</span><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example2</span><span class="p">(</span><span class="n">nums</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">filtered</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="c1">// ! coerced to i32
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="o">*</span><span class="n">num</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">continue</span><span class="w"> </span><span class="c1">// ! coerced to i32
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">filtered</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>!</code> 的第二个有趣的属性允许我们在类型层面上将某些状态标记为不可能。让我们以这个函数签名为例。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Success</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>我们知道，如果函数返回并成功，<code>Result</code> 将包含一些类型为 <code>Success</code> 的实例，如果函数出错，<code>Result</code> 将包含一些类型为 <code>Error</code> 的实例。现在我们来对比一下这个函数的签名。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Success</span><span class="p">,</span><span class="w"> </span><span class="o">!&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>我们知道，如果函数返回并且成功了，<code>Result</code> 将持有一些类型为 <code>Success</code> 的实例，如果出错了&hellip;但等等，它永远不会出错，因为不可能创建 <code>!</code> 的实例。鉴于上面的函数签名，我们知道这个函数永远不会出错。那这个函数签名呢:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;!</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>前面的反义词现在是真的：如果这个函数返回，我们知道它肯定出错了，因为成功是不可能的。</p>
<p>前一个例子的实际应用是 <code>FromStr</code> 对 <code>String</code> 的实现，因为将 <code>&amp;str</code> 转换为 <code>String</code> 是不可能失败的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(never_type)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>后一个例子的实际应用是一个运行无限循环的函数，这个函数永远不打算返回，就像服务器响应客户端的请求一样，除非有一些错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(never_type)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">run_server</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;!</span><span class="p">,</span><span class="w"> </span><span class="n">ConnectionError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_request</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">process</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">response</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 <code>feature</code> 标记是必要的，因为当 never 类型存在并在 Rust 内部工作时，在用户代码中使用它仍然被认为是实验性的。</p>
<p><strong>要点</strong></p>
<ul>
<li><code>!</code> 可以被胁迫成任何其他类型。</li>
<li>不可能创建 <code>!</code> 的实例，我们可以用它来标记某些状态，在类型级别上是不可能的。</li>
</ul>
<h3 id="用户定义的伪-never-类型">用户定义的伪 Never 类型</h3>
<p>虽然不可能定义一个可以强制到任何其他类型的类型，但可以定义一个不可能创建实例的类型，比如一个 <code>enum</code>，没有任何变体。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这使得我们可以从前面的2个例子中移除 <code>feature</code> 标记，并使用稳定的 Rust 实现它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example 1
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="n">Void</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example 2
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">run_server</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Void</span><span class="p">,</span><span class="w"> </span><span class="n">ConnectionError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_request</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">process</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">response</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这是 Rust 标准库使用的技术，因为 <code>String</code> 的 <code>FromStr</code> 实现的 <code>Err</code> 类型是 <code>std::convert::Infallible</code>，它被定义为:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Infallible</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="phantomdata">PhantomData</h3>
<p>第三种最常用的 ZST 可能是 <code>PhantomData</code>。<code>PhantomData</code> 是一个零大小的标记结构，它可以用来 &ldquo;标记&rdquo; 一个包含的结构体具有某些属性。它和它的自动标记 trait 表亲如 <code>Sized</code>、<code>Send</code>、<code>Sync</code> 等在目的上是相似的，但作为一个标记结构体的使用方式有点不同。对 <code>PhantomData</code> 进行彻底的解释并探索它的所有用例不在本文的范围内，所以我们只简单地介绍一个简单的例子。回顾一下前面介绍的这个代码片段。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(negative_impls)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is Send and Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Send trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Sync trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>很不幸，我们必须使用一个 <code>feature</code> 标记，我们是否可以只使用稳定的 Rust 来达到同样的结果？我们已经了解到，一个类型只有当它的所有成员也是 <code>Send</code> 和 <code>Sync</code> 时才是 <code>Send</code> 和 <code>Sync</code> 的，所以我们可以像 <code>Rc&lt;()&gt;</code> 一样在 <code>Struct</code> 中添加一个 <code>!Send</code> 和 <code>!Sync</code> 成员。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is not Send or Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// adds 8 bytes to every instance
</span><span class="c1"></span><span class="w">    </span><span class="n">_not_send_or_sync</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这不太理想，因为它增加了 <code>Struct</code> 的每个实例的大小，而且我们现在每次要创建一个 <code>Struct</code> 时，还得凭空想象出一个  <code>Rc&lt;()&gt;</code>。由于 <code>PhantomData</code> 是一个 ZST，它解决了这两个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">NotSendOrSyncPhantom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is not Send or Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// adds no additional size to instances
</span><span class="c1"></span><span class="w">    </span><span class="n">_not_send_or_sync</span>: <span class="nc">NotSendOrSyncPhantom</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li><code>PhantomData</code> 是一个零大小的标记结构，它可以用来 &ldquo;标记&rdquo; 一个包含的结构体具有某些属性。</li>
</ul>
<h2 id="结论">结论</h2>
<ul>
<li>只有确定大小类型的实例才能被放置在栈上，也就是说，可以通过值来传递</li>
<li>不确定大小类型的实例不能放在栈上，必须通过引用来传递。</li>
<li>指向不确定大小类型的指针是双宽度的，因为除了指向数据外，它们还需要做额外的记账工作，以跟踪数据的长度或指向一个  vtable。</li>
<li><code>Sized</code> 是一个 &ldquo;自动&rdquo; 标记 trait。</li>
<li>所有的泛型类型参数默认都是自动绑定 <code>Sized</code> 的。</li>
<li>如果我们有一个泛型函数，它的参数是指针后面的一些 <code>T</code>，例如 <code>&amp;T</code>、<code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 等，那么我们几乎总是希望用 <code>T: ?Sized</code> 来退出默认的 <code>Sized</code> 约束。</li>
<li>利用切片和 Rust 的自动类型强制，我们可以编写灵活的 API。</li>
<li>所有的 trait 默认为 <code>Sized</code>。</li>
<li><code>Trait: ?Sized</code> 是 <code>impl Trait for dyn Trait</code> 所必需的。</li>
<li>我们可以根据每个方法要求 <code>Self: Sized</code>。</li>
<li>由 <code>Sized </code> 绑定的 trait 不能被制作成 trait 对象。</li>
<li>Rust 不支持宽度超过2的指针，所以&hellip;
<ul>
<li>我们不能将不确定大小的类型转换为 trait 对象</li>
<li>我们不能有多 trait 对象，但我们可以通过将多个 trait 转化成一个 trait 来解决这个问题。</li>
</ul>
</li>
<li>用户定义的不确定大小的类型现在是一个半成品的功能，它们的局限性超过了任何好处</li>
<li>ZST 的所有实例都是彼此相等的。</li>
<li>Rust 编译器知道优化与 ZSTs 的交互。</li>
<li><code>!</code> 可以被胁迫成任何其他类型。</li>
<li>不可能创建 <code>!</code> 的实例，我们可以用它来标记某些状态，在类型级别上是不可能的。</li>
<li><code>PhantomData</code> 是一个零大小的标记结构，它可以用来 &ldquo;标记&rdquo; 一个包含的结构体具有某些属性。</li>
</ul>
<h2 id="讨论">讨论</h2>
<p>在这里讨论本文:</p>
<ul>
<li><a href="https://users.rust-lang.org/t/blog-post-sizedness-in-rust/46293?u=pretzelhammer">official Rust users forum</a></li>
<li><a href="https://www.reddit.com/r/learnrust/comments/hx2jd0/sizedness_in_rust/">learnrust subreddit</a></li>
<li><a href="https://twitter.com/pretzelhammer/status/1286669073137491973">Twitter</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/hxips7/sizedness_in_rust/">rust subreddit</a></li>
<li><a href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
</ul>
<h2 id="通知">通知</h2>
<p>当发表下一篇博文时，会收到通知:</p>
<ul>
<li><a href="https://twitter.com/pretzelhammer">Following pretzelhammer on Twitter</a> or</li>
<li>Watching this repo&rsquo;s releases (click <code>Watch</code> -&gt; click <code>Custom</code> -&gt; select <code>Releases</code> -&gt; click <code>Apply</code>)</li>
</ul>
<h2 id="更多阅读">更多阅读</h2>
<ul>
<li><a href="./common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a></li>
<li><a href="./tour-of-rusts-standard-library-traits.md">Tour of Rust&rsquo;s Standard Library Traits</a></li>
<li><a href="./learning-rust-in-2020.md">Learning Rust in 2020</a></li>
<li><a href="./too-many-brainfuck-compilers.md">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/sizedness" term="sizedness" label="Sizedness" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[For the Love of Macros]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>For the Love of Macros</blockquote><p>我一直在重读 Ted Kaminski 关于软件设计的博客。我强烈推荐所有的文章，尤其是早期的文章（这是<a href="https://www.tedinski.com/2018/01/16/how-humans-write-programs.html">第一篇</a>）。他设法提供了既不平凡又合理的设计建议（当然是主观判断），这是一个难得的标本!</p>
<p>无论如何，这一系列的见解之一是，当设计一个抽象的概念时，我们总是要面对权力和属性之间的内在权衡。我们使用一个特定的抽象能表达的越多，我们对使用它的代码能说的就越少。然而，我们人类对更多表达能力的偏爱并非与生俱来。这一点在编程语言社区中很明显，用户不停地要求提供新功能，而语言设计者却说不。</p>
<p>宏是一个在 &ldquo;更强大&quot;方面走得很远的语言功能。宏给了你一种在源代码上抽象的能力。作为交换，你放弃了（自动）推理表面语法的能力。作为一个具体的<a href="https://rust-analyzer.github.io/blog/2020/03/30/macros-vs-rename.html">例子</a>，重命名重构在具有强大宏系统的语言中并不能 100% 可靠地工作。</p>
<p>我确实认为，在理想的世界里，对于一个想要扩展到巨大项目的语言来说，这是一个错误的交易。当你增加了更多的程序员、更多的年限和更多的数百万行代码时，自动推理和转换源代码的能力就会变得越来越重要。但是，请谨慎对待这一点 - 我显然是有偏见的，因为我花了几年时间开发 Rust IDE。</p>
<p>也就是说，宏有巨大的吸引力 - 它们是语言设计师的胶带。宏很少是最好的工具，但它们几乎可以完成任何工作。语言设计是渐进式的。宏系统通过为许多功能提供一个现成的穷人的替代品来缓解设计压力。</p>
<p>在这篇文章中，我想探讨一下 Rust 中宏的用途。目的是为了找到不放弃&quot;推理源代码&quot;属性的解决方案。</p>
<h2 id="字符串插值">字符串插值</h2>
<p>到目前为止，最常见的使用情况是 <code>format!</code> 系列的宏。这里的无宏解决方案很直接 - 字符串插值语法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;number&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">92</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="s">&#34;$key: ${values()}&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;number: 92&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>在 Rust 中，插值可能不应该直接构造一个字符串，而是可以产生一个实现 Display 的值（就像 <code>format_args!</code> 一样），这样可以避免分配。一个有趣的扩展是允许在格式字符串片段上迭代。这样一来，插值语法就可以用于 SQL 语句或命令行参数之类的东西，而不用担心引入注入漏洞。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;my dir&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="s">&#34;ls $arg&#34;</span><span class="p">.</span><span class="n">to_cmd</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;ls &#39;my dir&#39;&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p><a href="https://julialang.org/blog/2012/03/shelling-out-sucks/">这篇</a>关于 Julia 编程语言的文章解释了这个问题。 <a href="https://github.com/matklad/xshell">xshell</a> crate 为 Rust 实现了这个想法。</p>
<h2 id="derives">Derives</h2>
<p>我认为在 Rust 中，宏的第二个最常见，也可能是最重要的用法是派生。Rust 是为数不多的能正确实现平等的语言之一（禁止比较苹果和橘子），但这关键取决于 <code>derive(Eq)</code> 的能力。这个领域常见的解决方案是编译器中的特殊 casing（Haskell 的派生）或运行时反射。</p>
<p>但我最感兴趣的解决方案是 <code>C#</code> <a href="https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/">源码生成器</a>。这并不是什么新鲜事 - 这只是老式的（源码）代码生成器，只是具有很好的实现质量。你可以提供自定义的代码，这些代码在构建过程中被运行，它可以读取现有的源码并生成额外的文件，然后再添加到编译中。</p>
<p>这个解决方案的优点在于它将所有的复杂性从语言中移出，移到了编译系统中。这意味着你可以免费获得基线工具支持。生成代码的 Goto 定义？就能用了。调试时想介入一些序列化代码？磁盘上有实际的源码，所以可以放心的去做! 你是比较喜欢用 <code>printf</code> 的人？好吧，你需要说服构建系统不要踩过你的改动，但是，否则，为什么不呢？</p>
<p>此外，源码生成器的表现力明显更强。它们可以调用到 Roslyn 编译器来分析源代码，所以它们能够生成类型导向的代码。</p>
<p>为了有用，源码生成器需要一些语言级别的支持，以便将一个实体分割到多个文件中。在 <code>C#</code> 中，部分类就扮演了这个角色。</p>
<h2 id="特定领域语言">特定领域语言</h2>
<p>宏的存在理由是嵌入式 DSL 的实现。我们希望在语言中引入自定义语法，以简洁地对程序的领域进行建模。例如，可以用宏来嵌入 Rust 代码中的 HTML 片段。</p>
<p>对我个人来说，eDSL 不是要解决的问题，只是一个问题。引入一个新的子语言（即使是小的）会花费大量的认知复杂性预算。如果你偶尔需要它，最好坚持只把有点啰嗦的函数调用链在一起。如果你经常需要它，引入外部的 DSL 是有意义的，它有一个编译器，一个语言服务器，以及所有使编程富有成效的工具。对我来说，基于宏的 DSL 只是在成本效益曲线上不落像一个有趣的点。</p>
<p>也就是说，Kotlin 编程语言很好地解决了强类型化、工具友好型 DSL 的问题（例子）。令人气愤的是，很难指出具体的解决方案是什么。就是&hellip;&hellip;主要是具体的语法。下面是一些成分。</p>
<ul>
<li>闭包的语法是 <code>{ arg -&gt; body }</code>，或者直接是 <code>{ body }</code>，所以闭包在语法上类似于块。</li>
<li>扩展方法（这只是静态方法的语法糖）。</li>
<li>Java 风格的隐式 this，它将名称引入到作用域中，而不需要显式声明。</li>
<li><a href="https://boats.gitlab.io/blog/post/the-problem-of-effects/">TCP-preserving</a> inline closures (这是唯一一个非语法特征)</li>
</ul>
<p>尽管如此，这还不足以实现 Jetpack Compose UI DSL，它还需要一个编译器插件。</p>
<h2 id="sqlx">sqlx</h2>
<p>我想调用的一个有趣的 DSL 案例是 <a href="https://docs.rs/sqlx/0.5.1/sqlx/macro.query.html">sqlx::query</a>。它允许我们写这样的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">account</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">  </span><span class="n">sqlx</span>::<span class="n">query</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;select (1) as id, &#39;Herp Derpinson&#39; as name&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">fetch_one</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// anonymous struct has `#[derive(Debug)]` for convenience
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>这一点我想是eDSL确实很拉风的几个案例之一。没有宏的情况下，我不知道该怎么做。使用字符串插值（高级版本，以保护不被注入），可以指定查询。使用源码生成器，可以检查查询的语法和类型，例如，在这种情况下，会出现类型错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">  </span><span class="n">query</span><span class="p">(</span><span class="s">&#34;select (1) as id, &#39;Herp Derpinson&#39; as name&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">fetch_one</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>但这还不足以生成一个匿名结构体，也不足以摆脱动态 casts。</p>
<h2 id="有条件编译">有条件编译</h2>
<p>Rust 还使用宏进行条件编译。这个用例令人信服地展示了&quot;缺乏属性&quot;方面的能力。处理特征组合是 Cargo 永远头痛的问题。当特征标志改变时，用户不得不反复重新编译大块的装箱图。在 CI 上用 <code>Cargo test --no-default-features</code> 捕捉类型错误是非常恼人的，尤其是当你在提交 PR 之前确实运行了 <code>Cargo test</code>。&ldquo;添加特性&quot;是一个无法选中的一厢情愿。</p>
<p>在这种情况下，我不知道有什么好的无宏选择。但是，原则上，这似乎是可行的，如果将条件编译进一步推到编译器流水线的下游，推到代码生成和链接阶段。编译器可以在为一个函数生成机器代码之前，选择特定平台的版本，而不是在解析过程中提前丢弃一些代码。在此之前，它会检查该函数的所有条件编译版本是否具有相同的接口。这样一来，平台特定的类型错误就不可能出现了。</p>
<h2 id="占位符语法">占位符语法</h2>
<p>最后一个我想介绍的用例是占位符语法。Rust 的 <code>macro_call!(...)</code> 语法开辟了一个很好的隔离区域，只要小括号是平衡的，任何东西都可以用。理论上，这允许语言设计者在确定某些东西之前先试验临时语法。在实践中，这看起来好像并没有什么好处？有人反对稳定 <code>postfix .await</code>，而不通过中间期与 <code>await!</code> 宏来稳定。而且，稳定之后，所有的语法讨论都立即被遗忘了？另一方面，我们确实有 <code>try! -&gt; ?</code> 转变，但我不认为它有助于发现任何设计上的缺陷？至少，我们成功地稳定了那个<a href="https://internals.rust-lang.org/t/can-try-and-use-the-into-trait-instead-of-from/6714">不必要的限制性</a>去语法糖。</p>
<p>对于结论，我想绕回源码生成器。究竟是什么让它们比宏更容易被工具化？我认为有以下三个特性。第一，无论是输入还是输出，从根本上说，都是文本。没有中间的表示方式（比如 token 树），而这个元程序设施使用的是中间的表示方式。这意味着，它不需要与编译器深度集成。当然，在内部，该工具可以自由地对代码进行任意解析、类型检查和转换。其次，有一个阶段性的区分。源码生成器是一次执行，无序的。在元编程和名称解析之间没有来回，这又可以将&quot;元&quot;的部分保留在外面。第三，源码生成器只能添加代码，不能改变现有代码的含义。这意味着，在代码生成器的存在下，语义上合理的源码转换依然如此。</p>
<p>就这样吧! 在 <a href="https://old.reddit.com/r/rust/comments/ljnkwg/blog_post_for_the_love_of_macros/">/r/rust</a> 上讨论。</p>
<p>原文链接: <a href="https://matklad.github.io/2021/02/14/for-the-love-of-macros.html">https://matklad.github.io/2021/02/14/for-the-love-of-macros.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Std Error in Rust]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Std Error in Rust</blockquote><h1 id="学习-stdioerror">学习 std::io::Error</h1>
<p>在这篇文章中，我们将剖析 Rust 标准库中 std::io::Error 类型的实现。相关代码在这里：<code>library/std/src/io/error.rs</code>。</p>
<p>你可以把这篇文章看成是其中之一。</p>
<ul>
<li>一个标准库的特定位的研究</li>
<li>一个高级错误管理指南</li>
<li>一个漂亮的 API 设计案例</li>
</ul>
<p>文章要求基本熟悉 Rust 错误处理。</p>
<p>在设计一个用于 <code>Result&lt;T，E&gt;</code> 的 Error 类型时，主要的问题是&quot;如何使用这个错误？&quot;。通常，以下情况之一为真。</p>
<ul>
<li>错误被程序化处理。消费者检查错误，所以它的内部结构需要在合理的程度上暴露出来。</li>
<li>错误被传播并显示给用户。消费者不检查 <code>fmt::Display</code> 之外的错误；所以它的内部结构可以被封装。</li>
</ul>
<p>请注意，暴露实现细节和封装细节之间存在紧张关系。实现第一种情况的常见反模式是定义一个厨房水槽枚举。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">Tokio</span><span class="p">(</span><span class="n">tokio</span>::<span class="n">io</span>::<span class="n">Error</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">ConnectionDiscovery</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">path</span>: <span class="nc">PathBuf</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">reason</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">stderr</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">},</span><span class="w">
</span><span class="w">  </span><span class="n">Deserialize</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">source</span>: <span class="nc">serde_json</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">},</span><span class="w">
</span><span class="w">  </span><span class="p">...,</span><span class="w">
</span><span class="w">  </span><span class="n">Generic</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这种方法有很多问题。</p>
<p>首先，从底层库中暴露错误会使它们成为你的公共 API 的一部分。在你的依赖关系中的主要 semver bump 会要求你也做一个新的主要版本。</p>
<p>其次，它将所有的实现细节都固定下来。例如，如果你注意到 ConnectionDiscovery 的大小是巨大的，那么将这个变体装箱将是一个突破性的变化。</p>
<p>第三，它通常表明了一个更大的设计问题。厨房水槽错误将不同的故障模式打包成一种类型。但是，如果故障模式差异很大，处理起来可能就不合理了! 这说明情况看起来更像案例二。</p>
<p>错误厨房水槽病的一个经常有效的治疗方法是将错误推送给调用者的模式。</p>
<p>考虑这个例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">my_function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">MyError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dep_function</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>my_function</code> 调用 <code>dep_function</code>，所以 <code>MyError</code> 应该可以从 <code>DepError</code> 转换过来。更好的写法可能是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">thing</span>: <span class="nc">DepThing</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">MyError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在这个版本中，调用者被迫调用 <code>dep_function</code> 并处理其错误。这就用更多的类型交换了更多的类型安全。<code>MyError</code> 和 <code>DepError</code> 现在是不同的类型，调用者可以分别处理它们。如果 <code>DepError</code> 是 <code>MyError</code> 的变体，那么就需要进行运行时匹配。</p>
<p>这个想法的一个极端版本是 <code>sans-io</code> 编程。大多数错误来自于 IO；如果你把所有的 IO 推给调用者，你就可以跳过大部分的错误处理。</p>
<p>无论枚举方法多么糟糕，它确实实现了第一种情况的最大可检查性。</p>
<p>以传播为中心的第二种情况下的错误管理，通常是通过使用盒状特质对象来处理。像 <code>Box&lt;dyn std::error::Error&gt;</code> 这样的类型可以从任何具体的错误中构造出来，可以通过 <code>Display</code> 打印出来，并且仍然可以选择通过动态下传来暴露底层错误。<code>Anyhow</code> crate 就是这种风格的一个很好的例子。</p>
<p><code>std::io::Error</code> 的例子很有趣，因为它想同时具备上述两种风格。</p>
<ul>
<li>这是 std，所以封装和面向未来是最重要的。</li>
<li>来自操作系统的 IO 错误往往可以被处理（比如 EWOULDBLOCK）。</li>
<li>对于系统编程语言来说，准确地暴露底层 OS 错误是很重要的。</li>
<li>未来潜在的操作系统错误集是没有限制的。</li>
<li><code>io::Error</code> 也是一种词汇类型，应该可以表示一些不完全的 os 错误。例如，Rust Paths 可以包含内部的0字节，打开这样的路径应该在进行 <code>syscall</code> 之前返回一个 <code>io::Error</code>。</li>
</ul>
<p>下面是 <code>std::io::Error</code> 的样子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">repr</span>: <span class="nc">Repr</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">Os</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">Simple</span><span class="p">(</span><span class="n">ErrorKind</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Custom</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Custom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>首先要注意的是，它内部是一个枚举，但这是一个隐藏得很好的实现细节。为了允许检查和处理各种错误条件，有一个单独的公共无字段种类枚举。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone, Copy)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[non_exhaustive]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">ErrorKind</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">NotFound</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">PermissionDenied</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">Interrupted</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="n">Other</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ErrorKind</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">sys</span>::<span class="n">decode_error_kind</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">kind</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">kind</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然 ErrorKind 和 Repr 都是枚举，但公开暴露 ErrorKind 就没那么可怕了。一个 <code>#[non_exhaustive]Copy</code> 无字段枚举的设计空间是一个点 - 没有合理的替代方案或兼容性隐患。</p>
<p>有些 <code>io::Errors</code> 只是原始的操作系统错误代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">from_raw_os_error</span><span class="p">(</span><span class="n">code</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">raw_os_error</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>特定平台的 <code>sys::decode_error_kind</code> 函数负责将错误代码映射到 <code>ErrorKind</code> 枚举。所有这些都意味着代码可以通过检查 <code>.kind()</code> 来跨平台处理错误类别。然而，如果需要以一种依赖于操作系统的方式处理一个非常特殊的错误代码，这也是可能的。API 小心翼翼地提供了一个方便的抽象，而没有抽象掉重要的低级细节。</p>
<p>一个 <code>std::io::Error</code> 也可以从一个 <code>ErrorKind</code> 中构造出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ErrorKind</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这提供了跨平台访问错误代码风格的错误处理。如果你需要尽可能快的错误，这很方便。</p>
<p>最后，还有第三种完全自定义的变体表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span>: <span class="nc">E</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w">
</span><span class="w">  </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">E</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Self</span>::<span class="n">_new</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">_new</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Custom</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">})),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_ref</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">into_inner</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>需要注意的地方。</p>
<ul>
<li>
<p>通用的 <code>new</code> 函数委托给单态的 <code>_new</code> 函数。这改善了编译时间，因为在单态化过程中需要重复的代码更少。我认为这也改善了一些运行时：<code>_new</code> 函数没有被标记为内联，所以会在调用处产生一个函数调用。这是好的，因为错误构造是冷路径，节省指令缓存是受欢迎的。</p>
</li>
<li>
<p>自定义变体被框住了 - 这是为了让整体 <code>size_of</code> 更小。错误的 <code>on-the-stack</code> 大小是很重要的：即使没有错误，你也要为此付出代价!</p>
</li>
</ul>
<p>这两种类型都是指&quot;静态错误&quot;。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">A</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="o">&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>在 <code>dyn Trait + '_</code> 中，<code>'_</code> 被省略为 <code>'static</code>，除非 trait 对象是在引用后面，在这种情况下，它被省略为 <code>&amp;'a dyn Trait + 'a</code>。</p>
<p><code>get_ref</code>, <code>get_mut</code> 和 <code>into_inner</code> 提供了对底层错误的完全访问。类似于 <code>os_error</code> 的情况，抽象模糊了细节，但也提供了钩子来获取底层数据的原样。</p>
<p>同样，Display 的实现揭示了内部表示的最重要细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span>::<span class="n">os</span>::<span class="n">error_string</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{} (os error {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">detail</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>综上所述，std::io::Error:</p>
<ul>
<li>封装了它的内部表现形式，并通过框定大的枚举变体来优化它。</li>
<li>通过 <code>ErrorKind</code> 模式提供了一种方便的方法来处理基于类别的错误。</li>
<li>完全暴露底层操作系统的错误（如果有的话）。</li>
</ul>
<p>可以透明地包裹任何其他错误类型。</p>
<p>最后一点意味着 <code>io::Error</code> 可以用于临时错误，因为 <code>&amp;str</code> 和 String 可以转换为 <code>Box&lt;dyn std::error::Error&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">Other</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;something went wrong&#34;</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>它也可以作为 anyhow 的简单替换。我想一些库可能会用这个来简化他们的错误处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">my_specific_error</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>例如，<code>serde_json</code> 提供了以下方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>读取会因为 <code>io::Error</code> 而失败，所以 <code>serde_json::Error</code> 需要能够在内部表示 <code>io::Error</code>。我认为这是倒退的 (但我不知道整个上下文，如果被证明是错的我会很高兴！)，签名应该是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>那么，<code>serde_json::Error</code> 就不会有 <code>Io</code> 的变体，而会以 <code>InvalidData</code> 的形式被藏到 <code>io::Error</code> 中。
补遗, 2021-01-25</p>
<p>重新阅读这篇文章，我现在认为正确的返回类型应该是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">  </span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>这迫使 IO 和反序列化错误分开处理，这在这种情况下是有意义的。IO 错误可能是程序领域之外的硬件/环境问题，而序列化错误很可能是系统中的某个错误。</p>
<p>我认为 <code>std::io::Error</code> 是一个非常了不起的类型，它能够在没有太多妥协的情况下为许多不同的用例服务。但我们是否可以做得更好呢？</p>
<p><code>std::io::Error</code> 的首要问题是，当一个文件系统操作失败时，你不知道它是为哪个路径失败的。这是可以理解的 - Rust 是一种系统语言，所以它不应该比 OS 原生提供的东西增加多少脂肪。OS 返回的是一个整数返回代码，而将其与一个堆分配的 <code>PathBuf</code> 耦合在一起，可能是一个不可接受的开销!</p>
<p>我很惊讶地得知，事实上，<code>std</code> 对每一个与路径相关的系统调用都会进行分配。</p>
<p>它需要以某种形式存在。<code>OS API</code> 需要在字符串的结尾有一个不幸的零字节. 但我想知道对短路径使用堆栈分配的缓冲区是否有意义。可能不会 - 路径通常不会那么短，而且现代分配器能有效地处理瞬时分配。</p>
<p>我不知道这里有什么明显的好办法。一个选择是在编译时（一旦我们得到 <code>std-aware cargo</code>）或运行时（<code>a-la RUST_BACKTRACE</code>）添加开关，以堆分配所有与路径相关的 IO 错误。一个类似形的问题是 <code>io::Error</code> 不携带 backtrace。</p>
<p>另一个问题是，<code>std::io::Error</code> 的效率不高。</p>
<p>它的体积是相当大的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span></code></pre></div><p>对于自定义的情况，会产生双重的间接和分配。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">Repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Os</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Simple</span><span class="p">(</span><span class="n">ErrorKind</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="c1">// First Box :|
</span><span class="c1"></span><span class="w">      </span><span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Custom</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Custom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="c1">// Second Box :(
</span><span class="c1"></span><span class="w">      </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我想我们现在可以解决这个问题了</p>
<p>首先，我们可以通过使用一个瘦的特质对象来摆脱双重内向性，比如失败或 anyhow。现在 GlobalAlloc 已经存在，这是一个比较直接的实现。</p>
<p>其次，我们可以利用指针是对齐的这一事实，将 Os 和 Simple 变体都用最小的有效位集储藏到 usize 中。我认为我们甚至可以发挥创意，使用第二个最小有意义的位，把第一个位留作小众。这样一来，即使是像 <code>io::Result&lt;i32&gt;</code> 这样的东西，也可以是指针大小的!</p>
<p>本篇文章到此结束。下一次你要为你的库设计一个错误类型的时候，花点时间去看看 <code>std::io::Error</code> 的源头，你可能会发现一些值得偷的东西。</p>
<p>讨论在 /r/rust.Net 上进行。</p>
<h2 id="额外的谜题">额外的谜题</h2>
<p>看看实现中的这一行。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span>::<span class="n">os</span>::<span class="n">error_string</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{} (os error {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">detail</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>原文链接: <a href="https://matklad.github.io/2020/10/15/study-of-std-io-error.html">https://matklad.github.io/2020/10/15/study-of-std-io-error.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Two Beautiful Rust Programs]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Two Beautiful Rust Programs</blockquote><h1 id="two-beautiful-rust-programs">Two Beautiful Rust Programs</h1>
<p>这是一则 Rust 编程语言的短广告，目标是有经验的 <code>C++</code> 开发者。作为一则广告，它只能吊起你的胃口，具体内容请参考其他资源。</p>
<p>第一个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="n">xs</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">92</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个程序创建了一个 32 位整数的向量(<code>std::vector&lt;int32_t&gt;</code>)，接收第一个元素 <code>x</code> 的引用，再向向量推送一个数字，然后使用 <code>x</code>。这个程序是错误的：扩展向量可能会使对元素的引用无效，而且 <code>*x</code> 可能会取消引用一个 danging 指针。</p>
<p>这个程序的好处是它不会被编译。</p>
<pre><code>error[E0502]: cannot borrow xs as mutable
    because it is also borrowed as immutable
 --&gt; src/main.rs:4:5

     let x: &amp;i32 = &amp;xs[0];
                    -- immutable borrow occurs here
     xs.push(92);
     ^^^^^^^^^^^ mutable borrow occurs here
     println!(x);
              - immutable borrow later used here
</code></pre><p>Rust 编译器跟踪每块数据的别名状态，并禁止潜在的别名数据的突变。在这个例子中，<code>x</code> 和 <code>xs</code> 别名了向量在堆中存储的第一个整数。</p>
<p>Rust 不允许做傻事。</p>
<p>第二个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">scope</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">parking_lot</span>::<span class="p">{</span><span class="n">Mutex</span><span class="p">,</span><span class="w"> </span><span class="n">MutexGuard</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">s</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">          </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">guard</span>: <span class="nc">MutexGuard</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w">
</span><span class="w">          </span><span class="o">*</span><span class="n">guard</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">total</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">get_mut</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;total = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">total</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个程序创建一个由 mutex 保护的整数计数器，生成10个线程，从每个线程开始将计数器递增10次，并打印出总数。</p>
<p>计数器变量位于堆栈中，这些堆栈数据的指针与其他线程共享。线程必须锁定 mutex 才能进行增量。打印总数时，绕过 mutex 读取计数器，没有任何同步。</p>
<p>这个程序的妙处在于，它的正确性依赖于几位精妙的推理，每一个推理都会被编译器检查。</p>
<p>子线程不会逃离主函数 所以可以从它的堆栈中读取计数器</p>
<p>子线程只通过 mutex 访问 counter。</p>
<p>子线程将在我们从计数器中读出总数而不使用 mutex 时终止。</p>
<p>如果这些约束中的任何一个被破坏，编译器就会拒绝该代码。没有必要使用 <code>std::shared_ptr</code> 只是为了防御性地确保内存不会在你的脚下被释放。</p>
<p>Rust 允许做危险的、聪明的、快速的事情，而不用担心引入未定义的行为。</p>
<p>如果你喜欢你所看到的，这里有两本我推荐的书，可以让你更深入地了解 Rust。</p>
<p>原文链接: <a href="https://matklad.github.io/2020/07/15/two-beautiful-programs.html">https://matklad.github.io/2020/07/15/two-beautiful-programs.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
</feed>
