<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.79.0">Hugo</generator><title type="html"><![CDATA[rustlang on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/categories/rustlang/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/categories/rustlang/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/categories/rustlang/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/categories/rustlang/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2021-06-22T21:24:18+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/categories/rustlang/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Rust 标准库中的 Trait 之旅]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rusts-standard-library-traits/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-14-getting-started-with-kafka-and-rust-part1/?utm_source=atom_feed" rel="related" type="text/html" title="Kafka 和 Rust入门 - 第一部分" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-14-a-beginner-guide-to-handling-errors-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 中处理错误的初级指南" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Sizedness in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
            
                <id>https://ohmyweekly.github.io/notes/2021-05-19-a-tour-of-rusts-standard-library-traits/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-05-19T00:00:00+08:00</published>
            <updated>2021-05-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>A Tour of Rust&rsquo;s Standard Library Traits</blockquote><h1 id="rust-的标准库-trait-之旅">Rust 的标准库 Trait 之旅</h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#trait-basics">Trait Basics</a>
<ul>
<li><a href="#trait-items">Trait Items</a>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
</ul>
</li>
<li><a href="#scope">Scope</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
<li><a href="#unsafe-traits">Unsafe Traits</a></li>
</ul>
</li>
<li><a href="#auto-traits-1">Auto Traits</a>
<ul>
<li><a href="#send--sync">Send &amp; Sync</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
</li>
<li><a href="#general-traits">General Traits</a>
<ul>
<li><a href="#default">Default</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#any">Any</a></li>
</ul>
</li>
<li><a href="#formatting-traits">Formatting Traits</a>
<ul>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
</ul>
</li>
<li><a href="#operator-traits">Operator Traits</a>
<ul>
<li><a href="#comparison-traits">Comparison Traits</a>
<ul>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
</li>
<li><a href="#arithmetic-traits">Arithmetic Traits</a>
<ul>
<li><a href="#add--addassign">Add &amp; AddAssign</a></li>
</ul>
</li>
<li><a href="#closure-traits">Closure Traits</a>
<ul>
<li><a href="#fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</a></li>
</ul>
</li>
<li><a href="#other-traits">Other Traits</a>
<ul>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
<li><a href="#index--indexmut">Index &amp; IndexMut</a></li>
<li><a href="#drop">Drop</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conversion-traits">Conversion Traits</a>
<ul>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
</li>
<li><a href="#error-handling">Error Handling</a>
<ul>
<li><a href="#error">Error</a></li>
</ul>
</li>
<li><a href="#conversion-traits-continued">Conversion Traits Continued</a>
<ul>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
<li><a href="#fromstr">FromStr</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
<li><a href="#toowned">ToOwned</a></li>
</ul>
</li>
<li><a href="#iteration-traits">Iteration Traits</a>
<ul>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#fromiterator">FromIterator</a></li>
</ul>
</li>
<li><a href="#io-traits">I/O Traits</a>
<ul>
<li><a href="#read--write">Read &amp; Write</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#discuss">Discuss</a></li>
<li><a href="#notifications">Notifications</a></li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>你有没有想过，这两者之间有什么区别?</p>
<ul>
<li><code>Deref&lt;Target = T&gt;</code>, <code>AsRef&lt;T&gt;</code> 和 <code>Borrow&lt;T&gt;</code>?</li>
<li><code>Clone</code>, <code>Copy</code> 和 <code>ToOwned</code>?</li>
<li><code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code>?</li>
<li><code>TryFrom&lt;&amp;str&gt;</code> 和 <code>FromStr</code>?</li>
<li><code>FnOnce</code>, <code>FnMut</code>, <code>Fn</code> 和 <code>fn</code>?</li>
</ul>
<p>或者曾经问过自己这样的问题:</p>
<ul>
<li>在我的 trait 中, 我什么时候使用关联类型, 什么时候使用泛型类型?</li>
<li>什么是泛型的 blanket 实现?</li>
<li>subtrait 和 supertrait 是如何工作的?</li>
<li>为什么这个 trait 没有任何方法?</li>
</ul>
<p>那么这篇文章就是为你准备的! 它回答了以上所有的问题以及更多的问题。我们将一起对 Rust 标准库中所有最流行、最常用的 trait 进行快速飞越之旅!</p>
<p>你可以按顺序逐节阅读本文，也可以跳转到你最感兴趣的 trait，因为每个 trait 部分都有一个链接列表，链接到 “先决知识” 部分，你应该阅读这些链接，以便有足够的背景来理解当前部分的解释。</p>
<h2 id="trait-基础">Trait 基础</h2>
<p>我们将只涉及足够的基础知识，以便文章的其余部分可以精简，而不必在不同的 trait 中重新出现时重复相同的概念解释。</p>
<h3 id="trait-项">Trait 项</h3>
<p>Trait 项是指作为 trait 声明一部分的任何项。</p>
<h4 id="self">Self</h4>
<p><code>Self</code> 总是指实现类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// always returns i32
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// returns implementing type
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">5</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// Self == SomeType
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SomeType</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_num</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">6</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// Self == OtherType
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">returns_self</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">OtherType</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="函数">函数</h4>
<p>Trait 函数是任何第一个参数不使用 <code>self</code> 关键字的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// function
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 函数可以通过 trait 或实现类型按照命名空间的方式来调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">zero</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="nb">Default</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="方法">方法</h4>
<p>Trait 方法是指第一个参数使用 <code>self</code> 关键字并且类型为 <code>Self</code>、<code>&amp;Self</code>、<code>&amp;mut Self</code> 的任何函数。前面的类型也可以用 <code>Box</code>、<code>Rc</code>、<code>Arc</code> 或 <code>Pin</code> 来包装。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// methods
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_self</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_immut_self</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_mut_self</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// above methods desugared
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_self</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_immut_self</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">takes_mut_self</span><span class="p">(</span><span class="bp">self</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example from standard library
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以使用实现类型上的点运算符来调用方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，与函数类似，它们也可以通过 trait 或实现类型按照命名空间的方式来调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">ToString</span>::<span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="关联类型">关联类型</h4>
<p>Trait 可以有关联类型。当我们需要在函数签名中使用 <code>Self</code> 以外的其他类型，但又希望类型由实现者选择，而不是在 trait 声明中硬编码时，这很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// any type implementing Trait can
</span><span class="c1">// choose the type of AssociatedType
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i8</span><span class="p">;</span><span class="w"> </span><span class="c1">// chooses i8
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">AssociatedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="c1">// chooses u8
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">Self</span>::<span class="n">AssociatedType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span>::<span class="n">func</span><span class="p">(</span><span class="o">-</span><span class="mi">1_</span><span class="k">i8</span><span class="p">);</span><span class="w"> </span><span class="c1">// can only call func with i8 on SomeType
</span><span class="c1"></span><span class="w">    </span><span class="n">OtherType</span>::<span class="n">func</span><span class="p">(</span><span class="mi">1_</span><span class="k">u8</span><span class="p">);</span><span class="w"> </span><span class="c1">// can only call func with u8 on OtherType
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="泛型参数">泛型参数</h4>
<p>“泛型参数” 泛指泛型类型参数、泛型 lifetime 参数和泛型常量参数。由于这些说起来都很拗口，所以人们通常把它们缩写为 <em>&ldquo;generic types&rdquo;</em>, <em>&ldquo;lifetimes&rdquo;</em> 和 <em>&ldquo;generic consts&rdquo;</em>。由于 generic consts 没有在我们将要涉及的任何标准库 trait 中使用，所以它们不在本文的范围之内。</p>
<p>我们可以使用参数来泛型化一个 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// trait declaration generalized with lifetime &amp; type parameters
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// signature uses generic type
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="nc">T</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// signature uses lifetime
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// signature uses generic type &amp; lifetime
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">i8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">i8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;b</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="na">&#39;b</span><span class="p">,</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func1</span><span class="p">(</span><span class="n">arg</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func3</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="na">&#39;b</span><span class="w"> </span><span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以为泛型类型提供默认值。最常用的默认值是 <code>Self</code>，但任何类型都可以。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// make T = Self by default
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// any type can be used as the default
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// omitting the generic type will
</span><span class="c1">// cause the impl to use the default
</span><span class="c1">// value, which is Self here
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nc">SomeType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// default value here is i32
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// the default is overridable as we&#39;d expect
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="p">(</span><span class="n">t</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// overridable here too
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func2</span><span class="p">(</span><span class="n">t</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>除了对 trait 进行参数化外，还可以对单个函数和方法进行参数化。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>尖括号(<code>&lt; &gt;</code>)中的类型要么是泛型(<code>T</code>), 要么是一个具体类型(例如 <code>i32</code>)。所以, 看到尖括号时, 要意识到这个东西应该是泛型的。</p>
<h4 id="泛型类型-vs-关联类型">泛型类型 vs 关联类型</h4>
<p>泛型类型和关联类型都将决定权交给了实现者，让他们决定在 trait 的函数和方法中应该使用哪种具体类型，所以本节试图解释什么时候使用一种类型而不是另一种类型。</p>
<p>一般的经验法则是</p>
<ul>
<li>当每个类型只能有一个 trait 的实现时，使用关联类型。</li>
<li>当每个类型可以有许多可能的 trait 的实现时，使用泛型类型。</li>
</ul>
<p>假设我们想定义一个名为 <code>Add</code> 的 trait，它允许我们将值加在一起。下面是一个初始设计和只使用关联类型的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span>::<span class="n">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>比方说，我们想给 <code>Point</code> 添加和 <code>i32</code> 相加的能力，其中 <code>i32</code> 将和 <code>x</code> 和 <code>y</code> 成员相加。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Self</span>::<span class="n">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这抛出:</p>
<pre><code class="language-none" data-lang="none">error[E0119]: conflicting implementations of trait `Add` for type `Point`:
  --&gt; src/main.rs:23:1
   |
12 | impl Add for Point {
   | ------------------ first implementation here
...
23 | impl Add for Point {
   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `Point`
</code></pre><p>由于 <code>Add</code> trait 没有任何泛型类型的参数化，我们只能对每个类型进行一次实现，这意味着我们只能为 <code>Rhs</code> 和 <code>Output</code> 选择一次类型！为了允许 <code>Point</code> 和 <code>Point</code> 相加,以及 <code>i32</code> 和 <code>Point</code> 相加，我们必须将 <code>Rhs</code> 从关联类型重构为泛型类型，这将允许我们用不同的类型参数为 <code>Rhs</code> 多次实现 <code>Point</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>比方说，我们添加了一个名为 <code>Line</code> 的新类型，它包含两个 <code>Point</code>，现在在我们的程序中，将两个 <code>Point</code> 相加应该产生一个 <code>Line</code> 而不是 <code>Point</code>。考虑到 <code>Add</code> trait 当前的设计，这是不可能的，因为 <code>Output</code> 是一个关联类型，但是我们可以通过将 <code>Output</code> 从关联类型重构为泛型类型来满足这些新的要求。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="p">,</span><span class="w"> </span><span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">start</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">end</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Line</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">start</span>: <span class="nc">self</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">end</span>: <span class="nc">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">int2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">int2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">l</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>那么，上面的 <code>Add</code> trait 哪种最好呢？这真的取决于你的程序的要求! 合适的就是最好的。</p>
<h3 id="作用域">作用域</h3>
<p>Trait 项不能使用，除非该 trait 在作用域内。大多数 Rustaceans 在第一次尝试写一个用 I/O 做任何事情的程序时，都会艰难地学会这一点，因为 <code>Read</code> 和 <code>Write</code> trait 不在标准库的预加载中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;Cargo.toml&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ read_to_string not found in File
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>read_to_string(buf: &amp;mut String)</code> 由 <code>std::io::Read</code> trait 声明，并由 <code>std::fs::File</code> 结构体实现，但为了调用它，<code>std::io::Read</code> 必须在作用域内。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="s">&#34;Cargo.toml&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的 prelude 是标准库中的一个模块，即 <code>std::prelude::v1</code>，它在每个其他模块的顶部被自动导入，即 <code>use std::prelude::v1::*</code>。因此，下面的 trait 总是在作用域内，我们永远不需要显式导入它们，因为它们是 prelude 的一部分。</p>
<ul>
<li><a href="#asref--asmut">AsMut</a></li>
<li><a href="#asref--asmut">AsRef</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#drop">Drop</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#fnonce-fnmut--fn">Fn</a></li>
<li><a href="#fnonce-fnmut--fn">FnMut</a></li>
<li><a href="#fnonce-fnmut--fn">FnOnce</a></li>
<li><a href="#from--into">From</a></li>
<li><a href="#from--into">Into</a></li>
<li><a href="#toowned">ToOwned</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
<li><a href="#send--sync">Send</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#send--sync">Sync</a></li>
<li><a href="#display--tostring">ToString</a></li>
<li><a href="#partialord--ord">Ord</a></li>
</ul>
<h3 id="派生宏">派生宏</h3>
<p>标准库导出了一些派生宏，如果一个类型的所有成员都实现了某个 trait, 我们可以使用这些宏来快速方便地在这个类型上实现该 trait。这些派生宏以它们所实现的 trait 命名。</p>
<ul>
<li><a href="#clone">Clone</a></li>
<li><a href="#copy">Copy</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#default">Default</a></li>
<li><a href="#partialeq--eq">Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">Ord</a></li>
<li><a href="#partialeq--eq">PartialEq</a></li>
<li><a href="#partialord--ord">PartialOrd</a></li>
</ul>
<p>使用示例:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// macro derives Copy &amp; Clone impl for SomeType
</span><span class="c1"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>注意：派生宏只是过程宏，可以做任何事情，没有硬性规定一定要实现一个 trait，也没有规定只有在类型的所有成员都实现一个 trait 的情况下才能工作，这些只是标准库中派生宏所遵循的约定。</p>
<h3 id="默认实现">默认实现</h3>
<p>Trait 可以为其函数和方法提供默认的实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;default impl&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OtherType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// use default impl for Trait::method
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// use our own impl for Trait::method
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;OtherType impl&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;default impl&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">OtherType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;OtherType impl&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一些 trait 方法可以只用其他 trait 方法来实现，这就特别方便。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet_loudly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hello</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Hola</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Hello</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hello {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// use default impl for greet_loudly
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Greet</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Hola</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hola {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="c1">// override default impl
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">greet_loudly</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">greeting</span><span class="p">.</span><span class="n">insert_str</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;¡&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hello</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hello John&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hello</span><span class="p">.</span><span class="n">greet_loudly</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hello John!&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hola</span><span class="p">.</span><span class="n">greet</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;Hola John&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Hola</span><span class="p">.</span><span class="n">greet_loudly</span><span class="p">(</span><span class="s">&#34;John&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// prints &#34;¡Hola John!&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的许多 trait 为它们的许多方法提供了默认的实现。</p>
<h3 id="generic-blanket-impls">Generic Blanket Impls</h3>
<p>通用全面实现是在泛型类型而不是具体类型上的实现。为了解释为什么以及如何使用，让我们从为数字类型编写一个 <code>is_even</code> 方法开始。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">i8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">i8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">u8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">u8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">i16</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">i16</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">i16</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// etc
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_is_even</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2_</span><span class="k">i8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4_</span><span class="k">u8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">6_</span><span class="k">i16</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>显然，这是很啰嗦的。而且，我们所有的实现几乎都是一样的。此外，如果 Rust 决定在未来添加更多的数字类型，我们必须记得回到这段代码，并用新的数字类型更新它。我们可以使用一个通用的全面实现来解决所有这些问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryInto</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Rem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// generic blanket impl
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">u8</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>::<span class="n">Error</span>: <span class="nc">Debug</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// these unwraps will never panic
</span><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">2.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_is_even</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">2_</span><span class="k">i8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">4_</span><span class="k">u8</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="mi">6_</span><span class="k">i16</span><span class="p">.</span><span class="n">is_even</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Unlike default impls, which provide <em>an</em> impl, generic blanket impls provide <em>the</em> impl, so they are not overridable.
与默认实现不同，默认的实现提供了一个实现，而通用的全面实现提供了特定的实现，所以它们是不可覆盖的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryInto</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Rem</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">T</span>: <span class="nc">Rem</span><span class="o">&lt;</span><span class="n">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">u8</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="kt">u8</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>::<span class="n">Error</span>: <span class="nc">Debug</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mf">2.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Even</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2_</span><span class="k">u8</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0_</span><span class="k">u8</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这抛出:</p>
<pre><code class="language-none" data-lang="none">error[E0119]: conflicting implementations of trait `Even` for type `u8`:
  --&gt; src/lib.rs:22:1
   |
10 | / impl&lt;T&gt; Even for T
11 | | where
12 | |     T: Rem&lt;Output = T&gt; + PartialEq&lt;T&gt; + Sized,
13 | |     u8: TryInto&lt;T&gt;,
...  |
19 | |     }
20 | | }
   | |_- first implementation here
21 | 
22 |   impl Even for u8 {
   |   ^^^^^^^^^^^^^^^^ conflicting implementation for `u8`
</code></pre><p>These impls overlap, hence they conflict, hence Rust rejects the code to ensure trait coherence. Trait coherence is the property that there exists at most one impl of a trait for any given type. The rules Rust uses to enforce trait coherence, the implications of those rules, and workarounds for the implications are outside the scope of this article.</p>
<p>这些实现重叠了，因此它们冲突，因此 Rust 拒绝了确保 trait 一致性的代码。Trait 一致性是指任何给定类型的 trait 最多存在一个实现的属性。Rust 用来强制执行 trait 一致性的规则，这些规则的含义，以及含义的变通方法都不在本文的范围内。</p>
<h3 id="subtraits--supertraits">Subtraits &amp; Supertraits</h3>
<p>&ldquo;subtrait&rdquo; 中的 &ldquo;sub&rdquo; 指的是子集，&ldquo;supertrait&rdquo; 中的 &ldquo;super&rdquo; 指的是超集。如果我们有一个这样的 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>All of the types which impl <code>Subtrait</code> are a subset of all the types which impl <code>Supertrait</code>, or to put it in opposite but equivalent terms: all the types which impl <code>Supertrait</code> are a superset of all the types which impl <code>Subtrait</code>.</p>
<p>Also, the above is just syntax sugar for:
所有实现 <code>Subtrait</code> 的类型都是所有实现 <code>Supertrait</code> 的类型的子集，或者用相反但等价的词语来表达：所有实现 <code>Supertrait</code> 的类型都是所有实现 <code>Subtrait</code> 的类型的超集。</p>
<p>另外，上面的代码只是下面这段代码的语法糖:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这是一个微妙而又重要的区别，要理解的是，约束是在 <code>Self</code> 上的，即实现 <code>Subtrait</code> 的类型，而不是在 <code>Subtrait</code> 本身。后者是没有任何意义的，因为 trait 约束只能应用于具体的类型，这些类型可以实现 trait。Trait 不能实现其他 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in supertrait&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// this looks like it might impl or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// override Supertrait::method but it
</span><span class="c1"></span><span class="w">    </span><span class="c1">// does not
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in subtrait&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// adds Supertrait::method to SomeType
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// adds Subtrait::method to SomeType
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// both methods exist on SomeType simultaneously
</span><span class="c1">// neither overriding or shadowing the other
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">SomeType</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// ❌ ambiguous method call
</span><span class="c1"></span><span class="w">    </span><span class="c1">// must disambiguate using fully-qualified syntax
</span><span class="c1"></span><span class="w">    </span><span class="o">&lt;</span><span class="n">SomeType</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Supertrait</span><span class="o">&gt;</span>::<span class="n">method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅ prints &#34;in supertrait&#34;
</span><span class="c1"></span><span class="w">    </span><span class="o">&lt;</span><span class="n">SomeType</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Subtrait</span><span class="o">&gt;</span>::<span class="n">method</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅ prints &#34;in subtrait&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Furthermore, there are no rules for how a type must impl both a subtrait and a supertrait. It can use the methods from either in the impl of the other.
此外，没有规定一个类型必须同时实现一个 subtrait 和一个 supertrait。它可以在另一个类型的实现中使用其中一个类型的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Subtrait</span>: <span class="nc">Supertrait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallSuperFromSub</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSuperFromSub</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSuperFromSub</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallSubFromSuper</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSubFromSuper</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallSubFromSuper</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">CallEachOther</span><span class="p">(</span><span class="kt">bool</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Supertrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallEachOther</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">super_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in super&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Subtrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">CallEachOther</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sub_method</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;in sub&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">CallSuperFromSub</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallSuperFromSub</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;, &#34;in super&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="n">CallSubFromSuper</span><span class="p">.</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;, &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallSubFromSuper</span><span class="p">.</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="n">CallEachOther</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">super_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in super&#34;, &#34;in sub&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">CallEachOther</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">sub_method</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;in sub&#34;, &#34;in super&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Hopefully the examples above show that the relationship between subtraits and supertraits can be complex. Before introducing a mental model that neatly encapsulates all of that complexity let&rsquo;s quickly review and establish the mental model we use for understanding trait bounds on generic types:
希望上面的例子能表明，subtrait 和 supertrait 之间的关系可能很复杂。在介绍一个能整齐地概括所有这些复杂性的心理模型之前，让我们快速回顾并建立我们用于理解泛型上的 trait 约束的心理模型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Without knowing anything about the impl of this function we could reasonably guess that <code>t.clone()</code> gets called at some point because when a generic type is bounded by a trait that strongly implies it has a dependency on the trait. The mental model for understanding the relationship between generic types and their trait bounds is a simple and intuitive one: generic types <em>depend on</em> their trait bounds.</p>
<p>Now let&rsquo;s look the trait declaration for <code>Copy</code>:
在不了解这个函数的实现的情况下，我们可以合理地猜测 <code>t.clone()</code> 在某些时候会被调用，因为当一个泛型被一个 trait 约束时，强烈地意味着它对 trait 有依赖性。理解泛型与其 trait 约束之间关系的心理模型是一个简单而直观的模型：泛型 “依赖” 其 trait 约束。</p>
<p>现在让我们看看 <code>Copy</code> 的 trait 声明。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{}</span><span class="w">
</span></code></pre></div><p>上面的语法看起来非常类似于在泛型类型上应用 trait 约束的语法，然而 <code>Copy</code> 根本不依赖于 <code>Clone</code>。我们前面开发的心理模型在这里并不能帮助我们。在我看来，理解 subtrait 和 supertrait 之间关系的最简单、最优雅的心理模型是：subtrait “精炼” 其 supertrait。</p>
<p>“精炼” 这个词故意保持有些模糊，因为它在不同的语境中可以有不同的含义。</p>
<ul>
<li>subtrait 可能会使它的 supertrait 的方法更加特化，速度更快，使用更少的内存，例如：<code>Copy: Clone</code></li>
<li>subtrait 可以对 supertrait 的方法的实现做出额外的保证，例如 <code>Eq: PartialEq</code>, <code>Ord: PartialOrd</code>, <code>ExactSizeIterator: Iterator</code></li>
<li>subtrait 可能使 supertrait 的方法更灵活或更容易调用，例如 <code>FnMut: FnOnce</code>, `Fn: FnMut</li>
<li>subtrait 可以扩展一个 supertrait，并添加新的方法，例如 <code>DoubleEndedIterator: Iterator</code>, <code>ExactSizeIterator: Iterator</code></li>
</ul>
<h3 id="trait-对象">Trait 对象</h3>
<p>泛型给了我们编译时的多态性，而 trait 对象给了我们运行时的多态性。我们可以使用 trait 对象来允许函数在运行时动态地返回不同的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">condition</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Has type:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;Map&lt;IntoIter&lt;i32&gt;, Fn(i32) -&gt; i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// But is cast to:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// Has type:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;Filter&lt;IntoIter&lt;i32&gt;, Fn(&amp;i32) -&gt; bool&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// But is cast to:
</span><span class="c1"></span><span class="w">        </span><span class="c1">// Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 对象还允许我们在集合中存储异构类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">f64</span>::<span class="n">consts</span>::<span class="n">PI</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Circle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">radius</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Square</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">side</span>: <span class="kt">f64</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Square</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">side</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">side</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_total_area</span><span class="p">(</span><span class="n">shapes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">shapes</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">area</span><span class="p">()).</span><span class="n">sum</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">shapes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Shape</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">radius</span>: <span class="mf">1.0</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="c1">// Box&lt;Circle&gt; cast to Box&lt;dyn Shape&gt;
</span><span class="c1"></span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Square</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">side</span>: <span class="mf">1.0</span><span class="w"> </span><span class="p">}),</span><span class="w"> </span><span class="c1">// Box&lt;Square&gt; cast to Box&lt;dyn Shape&gt;
</span><span class="c1"></span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">PI</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">get_total_area</span><span class="p">(</span><span class="n">shapes</span><span class="p">));</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Trait 对象是不确定大小的，所以它们必须总是在指针后面。我们可以根据类型中是否存在 <code>dyn</code> 关键字来区分具体类型和 trait 对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// regular struct
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">Struct</span><span class="w">
</span><span class="w"></span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// trait objects
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w">
</span><span class="w"></span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>并非所有的 trait 都可以转换为 trait 对象。如果一个 trait 满足这些要求，它就是对象安全的。</p>
<ul>
<li>trait 不需要 <code>Self: Sized</code>。</li>
<li>所有 trait 的方法都是对象安全的。</li>
</ul>
<p>如果 trait 方法满足这些要求，它就是对象安全的。</p>
<ul>
<li>方法需要 <code>Self: Sized</code> 或</li>
<li>该方法只在接收器位置使用 <code>Self</code> 类型。</li>
</ul>
<p>理解为什么要求是这样的，与本文其他部分无关，但如果你仍然好奇，在 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a> 中会有介绍。</p>
<h3 id="marker-traits">Marker Traits</h3>
<p>标记 trait 是没有 trait 项的 trait。它们的工作是将实现类型 “标记” 为具有某些属性，否则不可能用类型系统来表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// Impling PartialEq for a type promises
</span><span class="c1">// that equality for the type has these properties:
</span><span class="c1">// - symmetry: a == b implies b == a, and
</span><span class="c1">// - transitivity: a == b &amp;&amp; b == c implies a == c
</span><span class="c1">// But DOES NOT promise this property:
</span><span class="c1">// - reflexivity: a == a
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Eq has no trait items! The eq method is already
</span><span class="c1">// declared by PartialEq, but &#34;impling&#34; Eq
</span><span class="c1">// for a type promises this additional equality property:
</span><span class="c1">// - reflexivity: a == a
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="nb">Eq</span>: <span class="nb">PartialEq</span> <span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// f64 impls PartialEq but not Eq because NaN != NaN
</span><span class="c1">// i32 impls PartialEq &amp; Eq because there&#39;s no NaNs :)
</span></code></pre></div><h3 id="auto-traits">Auto Traits</h3>
<p>自动 trait 是指如果一个类型的所有成员都实现了这个 trait，那么这个 trait 就会被自动实现。“成员” 的含义取决于类型，例如：结构体的字段、枚举的变体、数组的元素、元组的项等等。</p>
<p>所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait。自动 trait 必须是标记 trait，这样编译器就可以为它们提供一个自动的缺省实现，如果它们有任何 trait 项，那就不可能了。</p>
<p>自动 trait 的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// implemented for types which are safe to send between threads
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// implemented for types whose references are safe to send between threads
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="unsafe-traits">Unsafe Traits</h3>
<p>Trait 可以被标记为不安全，以表明实现该 trait 可能需要不安全的代码。<code>Send</code> 和 <code>Sync</code> 都被标记为 <code>unsafe</code>，因为如果它们没有被自动实现，就意味着它一定包含一些非 <code>Send</code> 或非 <code>Sync</code> 成员，如果我们想手动标记类型为 <code>Send</code> 和 <code>Sync</code>，我们作为实现者必须格外小心，以确保没有数据竞争。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// SomeType is not Send or Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">not_send_or_sync</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// but if we&#39;re confident that our impl doesn&#39;t have any data
</span><span class="c1">// races we can explicitly mark it as Send and Sync using unsafe
</span><span class="c1"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h2 id="auto-traits-1">Auto Traits</h2>
<h3 id="send--sync">Send &amp; Sync</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
<li><a href="#unsafe-traits">Unsafe Traits</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>如果一个类型是 <code>Send</code>，意味着在线程之间发送是安全的。如果一个类型是 <code>Sync</code>，这意味着在线程之间共享它的引用是安全的。更准确地说，如果且仅当 <code>&amp;T</code> 是 <code>Send</code> 时，一些类型 <code>T</code> 是 <code>Sync</code>。</p>
<p>几乎所有类型都是 <code>Send</code> 和 <code>Sync</code> 的。唯一值得注意的 <code>Send</code> 异常是 <code>Rc</code>，唯一值得注意的 <code>Sync</code> 异常是 <code>Rc</code>、<code>Cell</code> 和 <code>RefCell</code>。如果我们需要一个 <code>Rc</code> 的 <code>Send</code> 版本，我们可以使用 <code>Arc</code>。如果我们需要 <code>Cell</code> 或 <code>RefCell</code> 的 <code>Sync</code> 版本，我们可以 <code>Mutex</code> 或 <code>RwLock</code>。虽然如果我们使用 <code>Mutex</code> 或 <code>RwLock</code> 只是包裹一个原语类型，通常最好使用标准库提供的原子原语类型，如 <code>AtomicBool</code>、<code>AtomicI32</code>、<code>AtomicUsize</code> 等。</p>
<p>几乎所有的类型都是 <code>Sync</code>，这可能会让一些人感到惊讶，但是是的，即使对于没有任何内部同步的类型也是如此。这要归功于 Rust 严格的借用规则。</p>
<p>我们可以将同一数据的许多不可变的引用传递给许多线程，而且我们保证不会出现数据竞争，因为只要有任何不可变的引用存在， Rust 就会静态地保证底层数据不能被修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">greeting</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">scoped_thread</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// spawn 3 threads
</span><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="o">=</span><span class="mi">3</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// greeting_ref copied into every thread
</span><span class="c1"></span><span class="w">            </span><span class="n">scoped_thread</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting_ref</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello {n}&#34;
</span><span class="c1"></span><span class="w">            </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="c1">// line below could cause UB or data races but compiler rejects it
</span><span class="c1"></span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ cannot mutate greeting while immutable refs exist
</span><span class="c1"></span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// can mutate greeting after every thread has joined
</span><span class="c1"></span><span class="w">    </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>同样，我们可以将单个可变引用传递给一些数据到一个线程，我们可以保证不会出现数据竞争，因为 Rust 静态地保证了别名的可变引用不能存在，底层数据不能通过现有的单个可变引用以外的任何东西进行修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">greeting</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">scoped_thread</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// greeting_ref moved into thread
</span><span class="c1"></span><span class="w">        </span><span class="n">scoped_thread</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="o">*</span><span class="n">greeting_ref</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34; world&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting_ref</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world&#34;
</span><span class="c1"></span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">        
</span><span class="w">        </span><span class="c1">// line below could cause UB or data races but compiler rejects it
</span><span class="c1"></span><span class="w">        </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!!!&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ cannot mutate greeting while mutable refs exist
</span><span class="c1"></span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// can mutate greeting after the thread has joined
</span><span class="c1"></span><span class="w">    </span><span class="n">greeting</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!!!&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">greeting</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;Hello world!!!&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这就是为什么大多数类型都是 <code>Sync</code> 而不需要任何显式同步。如果我们需要在多个线程中同时修改一些数据 <code>T</code>，编译器不会让我们这样做，直到我们将数据包裹在 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> 中，所以编译器强制要求在需要时使用显式同步。</p>
<h3 id="sized">Sized</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#auto-traits">Auto Traits</a></li>
</ul>
<p>如果一个类型是 <code>Sized</code> 的，这意味着它的字节大小在编译时是已知的，并且可以将该类型的实例放在栈上。</p>
<p>类型的大小和它的含义是一个微妙而又巨大的话题，它影响到语言的很多不同方面。它是如此重要，以至于我写了整整一篇文章，叫做 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a>，我强烈推荐任何想深入了解类型大小的人阅读。我总结一下与本文相关的几个关键内容。</p>
<ol>
<li>所有的泛型类型都会得到一个隐式的 <code>Sized</code> 约束。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example above desugared
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><ol start="2">
<li>由于所有泛型类型都有一个隐式的 <code>Sized</code> 约束，如果我们想退出这个隐式约束，我们需要使用特殊的 &ldquo;放宽约束&rdquo; 语法 <code>?Sized</code>，它目前只存在于 <code>Sized</code> trait。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// now T can be unsized
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><ol start="3">
<li>所有的 trait 都有一个隐式的 <code>?Sized</code> 约束。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example above desugared
</span><span class="c1"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这是为了让 trait 对象可以实现 trait。同样，所有的琐碎细节都在 <a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a> 中。</p>
<h2 id="general-traits">General traits</h2>
<h3 id="default">Default</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以构建 <code>Default</code> 类型的默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// default color is black
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">g</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">b</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这对快速建立原型很有用，但在任何情况下，我们只需要一个类型的实例，而且对它是什么并不挑剔。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// just give me some color!
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这也是一个我们可能想明确地暴露给我们的函数用户的选项。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Canvas</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Circle</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Rectangle</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Canvas</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// let user optionally pass a color
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">paint</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span>: <span class="nc">Shape</span><span class="p">,</span><span class="w"> </span><span class="n">color</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// if no color is passed use the default color
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">.</span><span class="n">unwrap_or_default</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="c1">// etc
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Default</code> 在我们需要构造泛型类型的泛型语境中也很有用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">guarantee_length</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Default</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">min_len</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">min_len</span><span class="p">.</span><span class="n">saturating_sub</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">T</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以利用 <code>Default</code> 类型的另一种方式是使用 Rust 的结构体更新语法对结构体进行部分初始化。我们可以为 <code>Color</code> 设置一个 <code>new</code> 构造函数，将每个成员作为一个参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，我们也可以使用方便的构造函数，每个构造函数只接受一个特定的结构体成员，其他结构体成员则使用默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">red</span><span class="p">(</span><span class="n">r</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">green</span><span class="p">(</span><span class="n">g</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">g</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">blue</span><span class="p">(</span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">b</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">..</span><span class="n">Color</span>::<span class="n">default</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>还有一个 <code>Default</code> 的派生宏，所以我们可以像这样编写 <code>Color</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// default color is still black
</span><span class="c1">// because u8::default() == 0
</span><span class="c1"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">r</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">g</span>: <span class="kt">u8</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="kt">u8</span>
<span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="clone">Clone</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">source</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以将 <code>Clone</code> 类型的不可变引用转换为自有值(owned values)，即 <code>&amp;T</code> -&gt; <code>T</code>。<code>Clone</code> 没有对这种转换的效率做出承诺，所以它可能是缓慢和昂贵的。为了快速地在一个类型上实现 <code>Clone</code>，我们可以使用派生宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">cloneable_member1</span>: <span class="nc">CloneableType1</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">cloneable_member2</span>: <span class="nc">CloneableType2</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// macro generates impl below
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SomeType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">cloneable_member1</span>: <span class="nc">self</span><span class="p">.</span><span class="n">cloneable_member1</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">cloneable_member2</span>: <span class="nc">self</span><span class="p">.</span><span class="n">cloneable_member2</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="c1">// etc
</span><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Clone</code> 也可以在泛型上下文中构建一个类型的实例。下面是上一节中的一个例子，除了使用 <code>Clone</code> 而不是 <code>Default</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">guarantee_length</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">min_len</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">fill_with</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="n">min_len</span><span class="p">.</span><span class="n">saturating_sub</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fill_with</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>人们也经常使用克隆作为逃避的方法，以避免与借用检查器打交道。管理带有引用的结构体可能很有挑战性，但我们可以通过克隆将引用变成自有值(owned values)。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// oof, we gotta worry about lifetimes 😟
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeStruct</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now we&#39;re on easy street 😎
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SomeStruct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们正在开发的程序的性能不是最重要的，那么我们就不需要为克隆数据而烦恼。Rust 是一种低级别的语言，暴露了很多低级别的细节，所以很容易被过早的优化所吸引，而不是真正解决手头的问题。对于许多程序来说，最好的优先顺序通常是首先建立正确性，其次是优雅性，第三是性能，只有在对程序进行剖析并确定了性能瓶颈之后才关注性能。这是很好的一般性建议，如果它不适用于你的特定程序，你就会知道。</p>
<h3 id="copy">Copy</h3>
<p>预备知识</p>
<ul>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Copy</span>: <span class="nb">Clone</span> <span class="p">{}</span><span class="w">
</span></code></pre></div><p>我们复制 <code>Copy</code> 类型，例如：<code>T</code> -&gt; <code>T</code>。<code>Copy</code> 承诺复制操作将是一个简单的按位(bitwise)拷贝，所以它将是非常快速和高效的。我们不能自己实现 <code>Copy</code>，只有编译器可以提供一个实现，但是我们可以通过使用 <code>Copy</code> 派生宏，以及 <code>Clone</code> 派生宏来告诉编译器这样做，因为 <code>Copy</code> 是 <code>Clone</code> 的一个子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SomeType</span><span class="p">;</span><span class="w">
</span></code></pre></div><p><code>Copy</code> 完善了(refine) <code>Clone</code>。<code>Clone</code> 可能是缓慢和昂贵的，但 <code>Copy</code> 保证是快速和便宜的，所以 <code>Copy</code> 只是一个快速 <code>Clone</code>。如果一个类型实现了 <code>Copy</code>，这就使得 <code>Clone</code> 的实现变得微不足道了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this is what the derive macro generates
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Copy</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// the clone method becomes just a copy
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当一个类型被移动时，实现该类型的 <code>Copy</code> 会改变其行为。默认情况下，所有类型都有“移动语义”，但是一旦一个类型实现了 `Copy'，它就会得到“复制语义”。为了解释这两者之间的区别，我们来看看这些简单的场景。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// a &#34;move&#34;, src: !Copy
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span><span class="w"> 
</span><span class="w">
</span><span class="w"></span><span class="c1">// a &#34;copy&#34;, src: Copy
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>在这两种情况下，<code>dest = src</code> 对 <code>src</code> 的内容进行简单的按位复制，并将结果移动到 <code>dest</code> 中，唯一的区别是，在“移动”的情况下，借用检查器使 <code>src</code> 变量无效，并确保它以后不会被用于其他地方，而在“复制”的情况下，<code>src</code> 仍然有效并可使用。</p>
<p>一言以蔽之。拷贝就“是”移动。移动就“是”拷贝。唯一的区别是借用检查器对它们的处理方式。</p>
<p>关于移动的一个更具体的例子，假设 <code>src</code> 是一个 <code>Vec&lt;i32&gt;</code>，其内容是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>当我们写下 <code>dest = src</code> 时，我们的结果是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">data</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w"> </span><span class="n">length</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span>: <span class="kt">usize</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>这个时候，<code>src</code> 和 <code>dest</code> 都有对相同数据的别名可变引用，这是一个大忌，所以借用检查器使 <code>src</code> 变量无效，这样它就不能再被使用而不会产生编译错误。</p>
<p>对于一个更具体的拷贝例子，假设 <code>src</code> 是一个 <code>Option&lt;i32&gt;</code>，它的内容是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>现在，当我们写下 <code>dest = src</code> 时，我们的结果是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">is_valid</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kt">i32</span> <span class="p">}</span><span class="w">
</span></code></pre></div><p>这些都是可以同时使用的! 因此 <code>Option&lt;i32&gt;</code> 是可以 <code>Copy</code> 的。</p>
<p>虽然 <code>Copy</code> 可以是一个自动 trait，但 Rust 语言的设计者决定让类型显式地选择复制语义，而不是在类型符合条件时默默地继承复制语义，因为后者会导致令人惊讶的混乱行为，经常导致错误。</p>
<h3 id="any">Any</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Any</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">type_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TypeId</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Rust 的多态性风格是参数化的，但如果我们想使用类似于动态类型语言的多态性风格，那么我们可以使用 <code>Any</code> trait 来模仿。我们不需要为我们的类型手动实现这个 trait，因为下面这个泛型覆盖实现已经覆盖了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Any</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">type_id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TypeId</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">TypeId</span>::<span class="n">of</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们从 <code>dyn Any</code> 中得到 <code>T</code> 的方法是通过使用 <code>downcast_ref::&lt;T&gt;()</code> 和 <code>downcast_mut::&lt;T&gt;()</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">any</span>::<span class="n">Any</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">map_any</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">any</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">downcast_mut</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">point</span><span class="p">.</span><span class="n">inc</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">any</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Any</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Point</span>::<span class="n">default</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">map_any</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 trait 很少需要使用，因为在大多数情况下，参数化多态性要优于临时多态性，后者也可以用枚举来模拟，因为枚举的类型更安全，需要的迂回更少。例如，我们可以把上面的例子写成这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Integer</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="nb">String</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Point</span><span class="p">(</span><span class="n">Point</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">map_stuff</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">stuff</span>: <span class="nc">Stuff</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">stuff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Integer</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="nb">String</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">string</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&#34;!&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Point</span><span class="p">(</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">inc</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">stuff</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="nb">String</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)),</span><span class="w">
</span><span class="w">        </span><span class="n">Stuff</span>::<span class="n">Point</span><span class="p">(</span><span class="n">Point</span>::<span class="n">default</span><span class="p">()),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [0, &#34;a&#34;, Point { x: 0, y: 0 }]
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="n">map_stuff</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// vec = [1, &#34;a!&#34;, Point { x: 1, y: 1 }]
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>尽管 <code>Any</code> 很少被需要，但有时使用起来还是很方便的，我们将在后面的“错误处理”部分看到。</p>
<h2 id="formatting-traits">Formatting Traits</h2>
<p>我们可以使用 <code>std::fmt</code> 中的格式化宏将类型序列化为字符串，其中最著名的是 <code>println!</code>。我们可以将格式化参数传递给格式 <code>str</code> 中使用的 <code>{}</code> 占位符，然后用来选择使用哪个 trait 实现来序列化占位符的参数。</p>
<table>
<thead>
<tr>
<th>Trait</th>
<th>Placeholder</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Display</code></td>
<td><code>{}</code></td>
<td>display representation</td>
</tr>
<tr>
<td><code>Debug</code></td>
<td><code>{:?}</code></td>
<td>debug representation</td>
</tr>
<tr>
<td><code>Octal</code></td>
<td><code>{:o}</code></td>
<td>octal representation</td>
</tr>
<tr>
<td><code>LowerHex</code></td>
<td><code>{:x}</code></td>
<td>lowercase hex representation</td>
</tr>
<tr>
<td><code>UpperHex</code></td>
<td><code>{:X}</code></td>
<td>uppercase hex representation</td>
</tr>
<tr>
<td><code>Pointer</code></td>
<td><code>{:p}</code></td>
<td>memory address</td>
</tr>
<tr>
<td><code>Binary</code></td>
<td><code>{:b}</code></td>
<td>binary representation</td>
</tr>
<tr>
<td><code>LowerExp</code></td>
<td><code>{:e}</code></td>
<td>lowercase exponential representation</td>
</tr>
<tr>
<td><code>UpperExp</code></td>
<td><code>{:E}</code></td>
<td>uppercase exponential representation</td>
</tr>
</tbody>
</table>
<h3 id="display--tostring">Display &amp; ToString</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Display</code> 类型可以被序列化为 <code>String</code>，这对程序的终端用户很友好。例如，给 <code>Point</code> 实现 <code>Display</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Default)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;({}, {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;origin: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="c1">// prints &#34;origin: (0, 0)&#34;
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// get Point&#39;s Display representation as a String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">stringified_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;(0, 0)&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">stringified_point</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>除了使用 <code>format!</code> 宏来获得一个类型的显示表示为 <code>String</code> 之外，我们还可以使用 <code>ToString</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们没有必要自己去实现这个 trait。事实上，我们不能这样做，因为下面这个泛型覆盖实现，对于任何实现 <code>Display</code> 的类型，都自动实现 <code>ToString</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Display</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">ToString</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>将 <code>ToString</code> 与 <code>Point</code> 一起使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">display_point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="p">),</span><span class="w"> </span><span class="s">&#34;(0, 0)&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">point_to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;(0, 0)&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">display_equals_to_string</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">default</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="p">),</span><span class="w"> </span><span class="n">origin</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="debug">Debug</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Debug</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Debug</code> 与 <code>Display</code> 有相同的签名。唯一的区别是，当我们使用 <code>{:?}</code> 格式符时，<code>Debug</code> 实现被调用。`Debug' 可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// derive macro generates impl below
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Debug</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">f</span><span class="p">.</span><span class="n">debug_struct</span><span class="p">(</span><span class="s">&#34;Point&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#34;x&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">field</span><span class="p">(</span><span class="s">&#34;y&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">finish</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为一个类型实现 <code>Debug</code> 也允许它在 <code>dbg!</code> 宏中使用，这比 <code>println!</code> 更有利于临时应急的打印日志。它的一些优点如下:</p>
<ol>
<li><code>dbg!</code> 打印到 stderr 而不是 stdout，所以调试日志很容易与我们程序的实际 stdout 输出分开。</li>
<li><code>dbg!</code> 打印传递给它的表达式，以及表达式所评估的值。</li>
<li><code>dbg!</code> 拥有其参数的所有权，并返回这些参数，所以你可以在表达式中使用它。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">some_condition</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kc">true</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// no logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">some_condition</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// println! logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_println</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 🤦
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_condition</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w"> </span><span class="c1">// just prints &#34;true&#34;
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// dbg! logging
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_dbg</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// 😍
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">dbg</span><span class="o">!</span><span class="p">(</span><span class="n">some_condition</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// prints &#34;[src/main.rs:22] some_condition() = true&#34;
</span><span class="c1"></span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>唯一的缺点是，<code>dbg!</code> 在发布版本中不会被自动剥离，所以如果我们不想在最终的可执行文件中使用它，就必须从我们的代码中手动删除它。</p>
<h2 id="operator-traits">Operator Traits</h2>
<p>Rust 中的所有运算符都与 trait 相关。如果我们想为我们的类型实现运算符，就必须实现相关的 trait。</p>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>
<h3 id="comparison-traits">Comparison Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Eq</code>, <code>PartialEq</code></td>
<td>comparison</td>
<td><code>==</code></td>
<td>equality</td>
</tr>
<tr>
<td><code>Ord</code>, <code>PartialOrd</code></td>
<td>comparison</td>
<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td>
<td>comparison</td>
</tr>
</tbody>
</table>
<h4 id="partialeq--eq">PartialEq &amp; Eq</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#marker-traits">Marker Traits</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Rhs</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialEq&lt;Rhs&gt;</code> 类型可以使用 <code>==</code> 运算符检查是否与 <code>Rhs</code> 类型相等。</p>
<p>所有的 <code>PartialEq&lt;Rhs&gt;</code> 实现必须确保相等是对称的和传递的。这意味着对于所有的 <code>a</code>, <code>b</code>, 和 <code>c</code>:</p>
<ul>
<li><code>a == b</code> 意味着 <code>b == a</code> (对称性)</li>
<li><code>a == b &amp;&amp; b == c</code> 意味着 <code>a == c</code> (传递性)</li>
</ul>
<p>默认情况下 <code>Rhs = Self</code>，因为我们几乎总是想把一个类型的实例相互比较，而不是与不同类型的实例比较。这也自动保证了我们的实现是对称的和传递的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Rhs == Self == Point
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl automatically symmetric &amp; transitive
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型的所有成员都实现了 `PartialEq'，那么它可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Heart</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Club</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Diamond</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一旦为我们的类型实现了 <code>PartialEq</code>，我们也可以免费得到我们类型的引用之间的相等性比较，这要感谢这些泛型覆盖实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this impl only gives us: Point == Point
</span><span class="c1"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// all of the generic blanket impls below
</span><span class="c1">// are provided by the standard library
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;Point == &amp;Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;mut Point == &amp;Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;Point == &amp;mut Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this impl gives us: &amp;mut Point == &amp;mut Point
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;_</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">A</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">A</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>由于这个 trait 是泛型化的，我们可以定义不同类型之间的相等性。标准库利用这一点，允许检查许多类似字符串的类型，如<code>String</code>、<code>&amp;str</code>、<code>PathBuf</code>、<code>&amp;Path</code>、<code>OsString</code>、<code>&amp;OsStr</code> 等之间的相等性。</p>
<p>一般来说，我们只应该在不同类型之间实现相等性关系，如果它们实现同一种数据，并且类型之间的唯一区别是它们如何表示数据或如何允许与数据进行交互。</p>
<p>这里有一个可爱但糟糕的例子，说明有人可能会被诱惑实现 <code>PartialEq</code> 来检查不符合上述标准的不同类型之间的相等。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Club</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Heart</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Diamond</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Rank</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Two</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Three</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Four</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Five</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Six</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Seven</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Eight</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Nine</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Ten</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Jack</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Queen</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">King</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">suit</span>: <span class="nc">Suit</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">rank</span>: <span class="nc">Rank</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s suit
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Suit</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Suit</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s rank
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rank</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rank</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Suit</span>::<span class="n">Spade</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">AceOfSpades</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Rank</span>::<span class="n">Ace</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这很有效，而且有点道理。一张黑桃A的牌既是A又是黑桃，如果我们要写一个处理扑克牌的库，那么我们想让它简单方便地单独检查一张牌的花色和等级是合理的。然而，我们还缺少一些东西：对称性。 我们可以 <code>Card == Suit</code> 和 <code>Card == Rank</code>，但我们不能 <code>Suit == Card</code> 或 <code>Rank == Card</code>，所以让我们解决这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// check equality of Card&#39;s suit
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Suit</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Suit</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// added for symmetry
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Suit</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Card</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">suit</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// check equality of Card&#39;s rank
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rank</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rank</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">other</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// added for symmetry
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Rank</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Card</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">*</span><span class="bp">self</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">rank</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们有对称性! 太好了。增加对称性只是打破了传递性！这是不可能的。哎呀。现在可以这样了：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Ace of Spades
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">Ace</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Suit</span>::<span class="n">Spade</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="c1">// King of Spades
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Card</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">suit</span>: <span class="nc">Suit</span>::<span class="n">Spade</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">rank</span>: <span class="nc">Rank</span>::<span class="n">King</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>实现 <code>PartialEq</code> 以检查不同类型之间的相等关系的一个好例子是一个处理距离的程序，它使用不同的类型来代表不同的测量单位。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foot</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Yard</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Mile</span><span class="p">(</span><span class="kt">u32</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Mile</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Mile</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5280</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Foot</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mile</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Foot</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5280</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Mile</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Yard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Mile</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1760</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Yard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mile</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Yard</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1760</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">    
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Foot</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Yard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Foot</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Yard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foot</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Yard</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foot</span><span class="p">(</span><span class="mi">5280</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Yard</span><span class="p">(</span><span class="mi">1760</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mile</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// symmetry
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// transitivity
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Eq</code> 是一个标记 trait，是 <code>PartialEq&lt;Self&gt;</code> 的子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Eq</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>如果我们为一个类型实现 <code>Eq</code>，在 <code>PartialEq</code> 所要求的对称性和传递性的基础上，我们还保证了自反性，即 对所有 <code>a</code>, <code>a == a</code>。在这个意义上，<code>Eq</code> 完善了 <code>PartialEq</code>，因为它代表了一个更严格的相等性版本。如果一个类型的所有成员都是<code>Eq</code> 的，那么 <code>Eq</code> 实现就可以为该类型派生。</p>
<p>浮点类型是 <code>PartialEq</code> 的，但不是 <code>Eq</code> 的，因为 <code>NaN != NaN</code>。几乎所有其他的 <code>PartialEq</code> 类型都是 <code>Eq</code>，当然，除非它们包含浮点。</p>
<p>一旦一个类型实现了 <code>PartialEq</code> 和 <code>Debug</code>，我们就可以在 <code>assert_eq!</code> 宏中使用它。我们也可以比较 <code>PartialEq</code> 类型的集合。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq, Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_assert</span><span class="p">(</span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_compare_collections</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialEq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vec1</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">vec2</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// if T: PartialEq this now works!
</span><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">vec1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// some code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// other code
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="hash">Hash</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash_slice</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">Self</span><span class="p">],</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 trait 与任何运算符无关，但谈论它的最好时机是在 <code>PartialEq</code> &amp; <code>Eq</code> 之后，所以它在这里。<code>Hash</code> 类型可以使用 <code>Hasher</code> 进行散列。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hash</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">hash</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nc">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">hasher</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">hasher</span><span class="p">.</span><span class="n">write_i32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">hasher</span><span class="p">.</span><span class="n">write_i32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>有一个派生宏，它生成的实现与上述相同。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Hash)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型同时实现了 <code>Hash</code> 和 <code>Eq</code>，这些实现必须相互一致，即对于所有的 <code>a</code> 和 <code>b</code>，如果 <code>a == b</code>，那么 <code>a.hash() == b.hash()</code>。所以我们应该总是使用派生宏来实现两者，或者手动实现两者，但不能混合使用，否则就有可能破坏上述不变性。</p>
<p>为一个类型实现 <code>Eq</code> 和 <code>Hash</code> 的主要好处是，它允许我们将该类型作为键存储在 <code>HashMap</code> 和 <code>HashSet</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">HashSet</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now our type can be stored
</span><span class="c1">// in HashSets and HashMaps!
</span><span class="c1"></span><span class="cp">#[derive(PartialEq, Eq, Hash)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_hashset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">points</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="partialord--ord">PartialOrd &amp; Ord</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Less</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Equal</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Greater</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span>: <span class="nb">PartialEq</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Rhs</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">lt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">le</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">gt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ge</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd&lt;Rhs&gt;</code> 类型可以使用 <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, 和 <code>&gt;=</code> 运算符与 <code>Rhs</code> 类型进行比较。</p>
<p>所有的 <code>PartialOrd</code> 实现必须确保比较是不对称的和传递的。这意味着对于所有的 <code>a</code>, <code>b</code>, 和 <code>c</code>:</p>
<ul>
<li><code>a &lt; b</code> 意味着 <code>!(a &gt; b)</code> (不对称性)</li>
<li><code>a &lt; b &amp;&amp; b &lt; c</code> 意味着 <code>a &lt; c</code> (传递性)</li>
</ul>
<p><code>PartialOrd</code> 是 <code>PartialEq</code> 的一个子 trait，它们的实现必须总是相互一致。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">must_always_agree</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">PartialOrd</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialEq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="p">),</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd</code> 是对 <code>PartialEq</code> 的细化，当比较 <code>PartialEq</code> 类型时，我们可以检查它们是否相等，但当比较 <code>PartialOrd</code> 类型时，我们可以检查它们是否相等，如果它们不相等，我们可以检查它们是否不相等，因为第一项小于或大于第二项。</p>
<p>默认情况下 <code>Rhs = Self</code>，因为我们几乎总是想把一个类型的实例相互比较，而不是和不同类型的实例比较。这也自动保证了我们的实现是对称的和传递的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Rhs == Self == Point
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// impl automatically symmetric &amp; transitive
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="p">.</span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">ordering</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型的所有成员都实现了 <code>PartialOrd</code>，那么它可以被派生。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(PartialEq, PartialOrd)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Stoplight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Red</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Yellow</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Green</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>PartialOrd</code> 派生宏基于其成员的字母顺序对类型进行排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// generates PartialOrd impl which orders
</span><span class="c1">// Points based on x member first and
</span><span class="c1">// y member second because that&#39;s the order
</span><span class="c1">// they appear in the source code
</span><span class="c1"></span><span class="cp">#[derive(PartialOrd, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// generates DIFFERENT PartialOrd impl
</span><span class="c1">// which orders Points based on y member
</span><span class="c1">// first and x member second
</span><span class="c1"></span><span class="cp">#[derive(PartialOrd, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Ord</code> is a subtrait of <code>Eq</code> and <code>PartialOrd&lt;Self&gt;</code>:
<code>Ord</code> 是 <code>Eq</code> 和 <code>PartialOrd&lt;Self&gt;</code> 的子 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Ord</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">min</span>: <span class="nc">Self</span><span class="p">,</span><span class="w"> </span><span class="n">max</span>: <span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们为一个类型实现 <code>Ord</code>，在 <code>PartialOrd</code> 所要求的不对称性和传递性的基础上，我们还保证不对称性是完全的，即对于任何给定的 <code>a</code> 和 <code>b</code>，<code>a == b</code> 或 <code>a &gt; b</code> 中只有一个是真的。在这个意义上，<code>Ord</code> 完善了 <code>Eq</code> 和 <code>PartialOrd</code>，因为它代表了一个更严格的比较版本。如果一个类型实现了 <code>Ord</code>，我们就可以用这个实现来实现 <code>PartialOrd</code>、<code>PartialEq</code> 和 <code>Eq</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// of course we can use the derive macros here
</span><span class="c1"></span><span class="cp">#[derive(Ord, PartialOrd, Eq, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// note: as with PartialOrd, the Ord derive macro
</span><span class="c1">// orders a type based on the lexicographical order
</span><span class="c1">// of its members
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// but here&#39;s the impls if we wrote them out by hand
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">ordering</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialOrd</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Eq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>浮点数实现了 <code>PartialOrd</code>，但不是 <code>Ord</code>，因为 <code>NaN &lt; 0 == false</code> 和 <code>NaN &gt;= 0 == false</code> 同时为真。几乎所有其他的 <code>PartialOrd</code> 类型都是 <code>Ord</code>，当然，除非它们包含浮点数。</p>
<p>一旦一个类型被认为是 <code>Ord</code> 的，我们就可以将其存储在 <code>BTreeMap</code> 和 <code>BTreeSet</code> 中，并且可以使用 <code>sort()</code> 方法对其进行排序，以及对数组、<code>Vec</code> 和 <code>VecDeque</code> 等任何类型的切片进行解引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">BTreeSet</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now our type can be stored
</span><span class="c1">// in BTreeSets and BTreeMaps!
</span><span class="c1"></span><span class="cp">#[derive(Ord, PartialOrd, PartialEq, Eq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example_btreeset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeSet</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">points</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// we can also .sort() Ord types in collections!
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_sort</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">sortable</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">sortable</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortable</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="arithmetic-traits">Arithmetic Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Add</code></td>
<td>arithmetic</td>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>AddAssign</code></td>
<td>arithmetic</td>
<td><code>+=</code></td>
<td>addition assignment</td>
</tr>
<tr>
<td><code>BitAnd</code></td>
<td>arithmetic</td>
<td><code>&amp;</code></td>
<td>bitwise AND</td>
</tr>
<tr>
<td><code>BitAndAssign</code></td>
<td>arithmetic</td>
<td><code>&amp;=</code></td>
<td>bitwise assignment</td>
</tr>
<tr>
<td><code>BitXor</code></td>
<td>arithmetic</td>
<td><code>^</code></td>
<td>bitwise XOR</td>
</tr>
<tr>
<td><code>BitXorAssign</code></td>
<td>arithmetic</td>
<td><code>^=</code></td>
<td>bitwise XOR assignment</td>
</tr>
<tr>
<td><code>Div</code></td>
<td>arithmetic</td>
<td><code>/</code></td>
<td>division</td>
</tr>
<tr>
<td><code>DivAssign</code></td>
<td>arithmetic</td>
<td><code>/=</code></td>
<td>division assignment</td>
</tr>
<tr>
<td><code>Mul</code></td>
<td>arithmetic</td>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>MulAssign</code></td>
<td>arithmetic</td>
<td><code>*=</code></td>
<td>multiplication assignment</td>
</tr>
<tr>
<td><code>Neg</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>unary negation</td>
</tr>
<tr>
<td><code>Not</code></td>
<td>arithmetic</td>
<td><code>!</code></td>
<td>unary logical negation</td>
</tr>
<tr>
<td><code>Rem</code></td>
<td>arithmetic</td>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>RemAssign</code></td>
<td>arithmetic</td>
<td><code>%=</code></td>
<td>remainder assignment</td>
</tr>
<tr>
<td><code>Shl</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>ShlAssign</code></td>
<td>arithmetic</td>
<td><code>&lt;&lt;=</code></td>
<td>left shift assignment</td>
</tr>
<tr>
<td><code>Shr</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
<tr>
<td><code>ShrAssign</code></td>
<td>arithmetic</td>
<td><code>&gt;&gt;=</code></td>
<td>right shift assignment</td>
</tr>
<tr>
<td><code>Sub</code></td>
<td>arithmetic</td>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>SubAssign</code></td>
<td>arithmetic</td>
<td><code>-=</code></td>
<td>subtraction assignment</td>
</tr>
</tbody>
</table>
<p>仔细研究所有这些将是非常多余的。反正大多数只适用于数字类型。我们只讨论 <code>Add</code> 和 <code>AddAssign</code>，因为 <code>+</code> 操作符通常被重载来做其他事情，如向集合添加项目或将事物串联起来，这样我们就能覆盖最有趣的地方，而不会重复。</p>
<h4 id="add--addassign">Add &amp; AddAssign</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#derive-macros">Derive Macros</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Add&lt;Rhs, Output = T&gt;</code> 类型可以和 <code>Rhs</code> 类型相加，并将产生 <code>T</code> 作为输出。</p>
<p>例子 <code>Add&lt;Point, Output = Point&gt;</code> 是针对 <code>Point</code> 实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone, Copy)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是如果我们只有对 <code>Point</code> 的引用呢？那我们还能让它们相加吗？让我们试试。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不幸的是没有。编译器会抛出异常：</p>
<pre><code class="language-none" data-lang="none">error[E0369]: cannot add `&amp;Point` to `&amp;Point`
  --&gt; src/main.rs:50:25
   |
50 |     let p3: Point = &amp;p1 + &amp;p2;
   |                     --- ^ --- &amp;Point
   |                     |
   |                     &amp;Point
   |
   = note: an implementation of `std::ops::Add` might be missing for `&amp;Point`
</code></pre><p>在 Rust 的类型系统中，对于某些类型 <code>T</code> 来说，<code>T</code>、<code>&amp;T</code> 和 <code>&amp;mut T</code> 都被视为唯一的不同类型，这意味着我们必须为它们分别提供 trait 实现。让我们为 <code>&amp;Point</code> 定义一个 <code>Add</code> 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，有些事情还是感觉不大对劲。我们有两个独立的 <code>Add</code> 实现，分别用于 <code>Point</code> 和 <code>&amp;Point</code>，它们目前做的是同样的事情，但不能保证将来也会这样做。例如，我们决定当我们把两个 <code>Point</code> 相加时，我们想创建一个包含这两个 <code>Point</code> 的 <code>Line</code>，而不是创建一个新的 <code>Point</code>，我们会像这样更新我们的 <code>Add</code> 程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">start</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">end</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// we updated this impl
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Line</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Line</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">start</span>: <span class="nc">self</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">end</span>: <span class="nc">rhs</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// but forgot to update this impl, uh oh!
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="nc">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="nc">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ expected Line, found Point
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们目前对 <code>&amp;Point</code> 的 <code>Add</code> 实现造成了不必要的维护负担，我们希望这个实现与 <code>Point</code> 的实现相匹配，而不必在每次改变 <code>Point</code> 的实现时都要手动更新。我们希望尽可能地保持我们的代码是 DRY（Don&rsquo;t Repeat Yourself）。幸运的是这是可以实现的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// updated, DRY impl
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Add</span><span class="o">&gt;</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span>::<span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rhs</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">line</span>: <span class="nc">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>AddAssign&lt;Rhs&gt;</code> 类型允许我们相加并分配 <code>Rhs</code> 类型给它们。Trait 声明如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;</span><span class="n">Rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Rhs</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为 <code>Point</code> 和 <code>&amp;Point</code> 类型的实现的例子如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">AddAssign</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;&amp;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kp">&amp;</span><span class="nc">Point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span>::<span class="n">add_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rhs</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">2</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="mi">4</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="闭包-traits">闭包 Traits</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Fn</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>immutable closure invocation</td>
</tr>
<tr>
<td><code>FnMut</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>mutable closure invocation</td>
</tr>
<tr>
<td><code>FnOnce</code></td>
<td>closure</td>
<td><code>(...args)</code></td>
<td>one-time closure invocation</td>
</tr>
</tbody>
</table>
<h4 id="fnonce-fnmut--fn">FnOnce, FnMut, &amp; Fn</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnOnce</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">Fn</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span>: <span class="nb">FnMut</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">args</span>: <span class="nc">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然这些 trait 存在，但在稳定的 Rust 中，我们不可能为自己的类型实现这些特性。我们唯一能创建的实现这些 trait 的类型是闭包。根据闭包从其环境中捕获的内容，决定了它是实现了 <code>FnOnce</code>、<code>FnMut</code> 还是 <code>Fn</code>。</p>
<p><code>FnOnce</code> 闭包只能被调用一次，因为它在执行中会消耗一些值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">get_range_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">range</span><span class="p">.</span><span class="n">count</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">get_range_count</span><span class="p">(),</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">get_range_count</span><span class="p">();</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>迭代器上的 <code>.count()</code> 方法会消耗迭代器，所以它只能被调用一次。因此，我们的闭包只能被调用一次。这就是为什么当我们试图第二次调用它时，会出现这个错误。</p>
<pre><code class="language-none" data-lang="none">error[E0382]: use of moved value: `get_range_count`
 --&gt; src/main.rs:5:5
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ----------------- `get_range_count` moved due to this call
5 |     get_range_count();
  |     ^^^^^^^^^^^^^^^ value used here after move
  |
note: closure cannot be invoked more than once because it moves the variable `range` out of its environment
 --&gt; src/main.rs:3:30
  |
3 |     let get_range_count = || range.count();
  |                              ^^^^^
note: this value implements `FnOnce`, which causes it to be moved when called
 --&gt; src/main.rs:4:16
  |
4 |     assert_eq!(get_range_count(), 10);
  |                ^^^^^^^^^^^^^^^
</code></pre><p><code>FnMut</code> 闭包可以被多次调用，也可以改变它从环境中捕获的变量。我们可以说 <code>FnMut</code> 闭包是执行副作用的，或者说是有状态的。下面是一个闭包的例子，它通过跟踪到目前为止看到的最小值，从迭代器中过滤出所有非升序的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span>::<span class="n">MIN</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ascending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kc">false</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="kc">true</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">],</span><span class="w"> </span><span class="n">ascending</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FnMut</code> 完善了 <code>FnOnce</code>，即 <code>FnOnce</code> 需要取得其参数的所有权，只能调用一次，但 <code>FnMut</code> 只需要取得可变的引用，可以多次调用。<code>FnMut</code> 可以在任何可以使用 <code>FnOnce</code> 的地方使用。</p>
<p><code>Fn</code> 闭包可以被多次调用，并且不改变它从环境中捕获的任何变量。我们可以说 <code>Fn</code> 闭包没有副作用或无状态。下面是一个闭包的例子，它过滤掉了所有小于它从环境中捕获的迭代器中的某个栈变量的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">greater_than_9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">min</span><span class="p">).</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">],</span><span class="w"> </span><span class="n">greater_than_9</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Fn</code> 细化了 <code>FnMut</code>，即 <code>FnMut</code> 需要可变的引用并可多次调用，但 <code>Fn</code> 只需要不可变的引用并可多次调用。<code>Fn</code> 可以用在任何可以使用 <code>FnMut</code> 的地方，包括可以使用 <code>FnOnce</code> 的地方。</p>
<p>如果一个闭包没有从它的环境中捕获任何东西，那么从技术上讲，它不是一个闭包，而只是一个匿名声明的内联函数，并且可以作为一个普通的函数指针被转换、使用和传递，也就是 <code>fn</code>。函数指针可以在任何可以使用 <code>Fn</code> 的地方使用，这包括可以使用 <code>FnMut</code> 和 <code>FnOnce </code>的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">fn_ptr</span>: <span class="nc">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">add_one</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">fn_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// capture-less closure cast to fn pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">fn_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// same as add_one
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">fn_ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>传递普通函数指针以代替闭包的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">absolutes</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="kt">i32</span>::<span class="n">abs</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">absolutes</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="其他-trait">其他 Trait</h3>
<table>
<thead>
<tr>
<th>Trait(s)</th>
<th>Category</th>
<th>Operator(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Deref</code></td>
<td>other</td>
<td><code>*</code></td>
<td>immutable dereference</td>
</tr>
<tr>
<td><code>DerefMut</code></td>
<td>other</td>
<td><code>*</code></td>
<td>mutable derenence</td>
</tr>
<tr>
<td><code>Drop</code></td>
<td>other</td>
<td>-</td>
<td>type destructor</td>
</tr>
<tr>
<td><code>Index</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>immutable index</td>
</tr>
<tr>
<td><code>IndexMut</code></td>
<td>other</td>
<td><code>[]</code></td>
<td>mutable index</td>
</tr>
<tr>
<td><code>RangeBounds</code></td>
<td>other</td>
<td><code>..</code></td>
<td>range</td>
</tr>
</tbody>
</table>
<h4 id="deref--derefmut">Deref &amp; DerefMut</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">DerefMut</span>: <span class="nc">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可以使用解引用操作符 <code>*</code> 把实现了 <code>Deref&lt;Target = T&gt;</code> trait 的类型解引用为  <code>T</code> 类型。这对于智能指针类型（如 <code>Box</code> 和 <code>Rc</code>）有明显的用途。然而，我们很少看到在 Rust 代码中显式地使用解引用操作符，这是因为 Rust 的一个叫做 “强制解引用”(<em>deref coercion</em>)的特性。</p>
<p>当类型作为函数参数传递、从函数返回或作为方法调用的一部分使用时，Rust 会自动地对类型进行解引用。这就是为什么我们可以将 <code>&amp;String</code> 和 <code>&amp;Vec&lt;T&gt;</code> 传递给期望 <code>&amp;str</code> 和 <code>&amp;[T]</code> 的函数的原因，因为 <code>String</code> 实现了 <code>Deref&lt;Target = str&gt;</code>, <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target = [T]&gt;</code>。</p>
<p><code>Deref</code> 和 <code>DerefMut</code> 只应为智能指针类型而实现。人们试图误用和滥用这些 trait 的最常见方式是试图将某种 OOP 式的数据继承塞进 Rust 中。这是行不通的。Rust 不是面向对象的。让我们来看看几种不同的情况，在哪些情况下，如何以及为什么它不起作用。让我们从这个例子开始:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Weapon</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spear</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Axe</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Sword</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Soldier is just a Human with a Weapon
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Mount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Horse</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Donkey</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Cow</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Knight is just a Soldier with a Mount
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">mount</span>: <span class="nc">Mount</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Soldier</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Spell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MagicMissile</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">FireBolt</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ThornWhip</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Mage is just a Human who can cast Spells
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">spells</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Human</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Staff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Wooden</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Metallic</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Plastic</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Wizard is just a Mage with a Staff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">staff</span>: <span class="nc">Staff</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mage</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_human</span><span class="p">(</span><span class="n">human</span>: <span class="kp">&amp;</span><span class="nc">Human</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_soldier</span><span class="p">(</span><span class="n">soldier</span>: <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_knight</span><span class="p">(</span><span class="n">knight</span>: <span class="kp">&amp;</span><span class="nc">Knight</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_mage</span><span class="p">(</span><span class="n">mage</span>: <span class="kp">&amp;</span><span class="nc">Mage</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_wizard</span><span class="p">(</span><span class="n">wizard</span>: <span class="kp">&amp;</span><span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types can be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights can be used as Soldiers
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Wizards can be used as Mages
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights &amp; Wizards passed as themselves
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_knight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_wizard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>因此，乍一看，上面的内容看起来很不错！然而，在仔细研究后，很快就发现了问题。首先，强制解引用只对引用起作用，所以当我们真正想要传递所有权时，它就不起作用了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">takes_human</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types CANNOT be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">soldier</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">knight</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">mage</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_human</span><span class="p">(</span><span class="n">wizard</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>此外，强制解引用在泛型上下文中不起作用。比方说，我们只在人类身上实现一些 trait：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rest</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Rest</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rest</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">take_rest</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Rest</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rester</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">rester</span><span class="p">.</span><span class="n">rest</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types CANNOT be used as Rest types, only Human
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">take_rest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，尽管强制解引用在很多地方都能工作，但并不是所有地方都能工作。它对操作数不起作用，尽管操作符只是方法调用的语法糖。比方说，我们想让 <code>Mage</code>(法师) 用 <code>+=</code> 运算符来学习 <code>Spell</code>(咒语)，这很可爱。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AddAssign</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add_assign</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">spell</span>: <span class="nc">Spell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">spells</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">spell</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">,</span><span class="w"> </span><span class="n">spell</span>: <span class="nc">Spell</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">spell</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">wizard</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">spell</span><span class="p">;</span><span class="w"> </span><span class="c1">// ❌ wizard not coerced to mage here
</span><span class="c1"></span><span class="w">    </span><span class="n">wizard</span><span class="p">.</span><span class="n">add_assign</span><span class="p">(</span><span class="n">spell</span><span class="p">);</span><span class="w"> </span><span class="c1">// oof, we have to call it like this 🤦
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 OOP 式数据继承的语言中，方法中 <code>self</code> 的值总是等于调用该方法的类型，但在 Rust 中，<code>self</code> 的值总是等于实现该方法的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">profession</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// self will always be a Human here, even if we call it on a Soldier
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">state_profession</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m a {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">profession</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">soldier</span>: <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;servant&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;spearman&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span><span class="p">.</span><span class="n">profession</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="p">.</span><span class="n">state_profession</span><span class="p">();</span><span class="w"> </span><span class="c1">// prints &#34;I&#39;m a servant!&#34;
</span><span class="c1"></span><span class="w">    </span><span class="n">soldier</span><span class="p">.</span><span class="n">state_profession</span><span class="p">();</span><span class="w"> </span><span class="c1">// still prints &#34;I&#39;m a servant!&#34; 🤦
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>当在一个新类型上实现 <code>Deref</code> 或 <code>DerefMut</code> 时，上述的问题尤其严重。假设我们想创建一个 <code>SortedVec</code> 类型，它只是一个 <code>Vec</code>，但它总是按排序顺序排列。下面是我们如何做的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">SortedVec</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>很明显，我们不能在这里实现 <code>DerefMut&lt;Target = Vec&lt;T&gt;&gt;</code>，否则任何使用 <code>SortedVec</code> 的人都可以轻易地破坏排序的顺序。然而，实现 <code>Deref&lt;Target = Vec&lt;T&gt;&gt;</code> 肯定是安全的，对吗？试着在下面的程序中发现这个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Deref</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">vec</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">SortedVec</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">sort</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SortedVec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedVec</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">sorted</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sortedClone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorted</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortedClone</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们从未为 <code>SortedVec</code> 实现 <code>Clone</code>，所以当我们调用 <code>.clone()</code> 方法时，编译器使用强制解引用来解决对 <code>Vec</code> 的方法调用，所以它返回一个 <code>Vec</code> 而不是 <code>SortedVec</code>!</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sorted</span>: <span class="nc">SortedVec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SortedVec</span>::<span class="n">new</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">sorted</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// still sorted
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// calling clone on SortedVec actually returns a Vec 🤦
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sortedClone</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sorted</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">sortedClone</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"> </span><span class="c1">// sortedClone no longer sorted 💀
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>总之，以上这些限制、约束或麻烦都不是 Rust 的缺点，因为 Rust 一开始就没有被设计成一种 OO 语言或支持任何 OOP 模式。</p>
<p>本节的主要启示是，不要试图用 <code>Deref</code> 和 <code>DerefMut</code> 实现来表现可爱或聪明。它们实际上只适合于智能指针类型，目前只能在标准库中实现，因为智能指针类型目前需要不稳定的特性和编译器的魔法才能工作。如果我们想要类似于 <code>Deref</code> 和 <code>DerefMut</code> 的功能和行为，那么我们实际上可能要找的是 <code>AsRef</code> 和 <code>AsMut</code>，我们将在后面讨论。</p>
<h4 id="index--indexmut">Index &amp; IndexMut</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">Idx</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">IndexMut</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span>: <span class="nc">Index</span><span class="o">&lt;</span><span class="n">Idx</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Idx</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">Idx</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以将 <code>[]</code> 索引到有 <code>T</code> 值的 <code>Index&lt;T, Output = U&gt;</code> 类型，索引操作将返回 <code>&amp;U</code> 值。对于语法糖，编译器会在任何从索引操作返回的值前面自动插入一个解引用运算符 <code>*</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// Vec&lt;i32&gt; impls Index&lt;usize, Output = i32&gt; so
</span><span class="c1"></span><span class="w">    </span><span class="c1">// indexing Vec&lt;i32&gt; should produce &amp;i32s and yet...
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ❌ expected &amp;i32 found i32
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// above line actually desugars to
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ❌ expected &amp;i32 found i32
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// both of these alternatives work
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">num_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一开始有点让人困惑，因为看起来 <code>Index</code> trait 并不遵循它自己的方法签名，但实际上这只是有问题的语法糖。</p>
<p>因为 <code>Idx</code> 是一个泛型类型，<code>Index</code> trait 可以为一个给定的类型实现很多次，在 <code>Vec&lt;T&gt;</code> 的情况下，我们不仅可以使用 <code>usize</code> 对其进行索引，我们还可以使用 <code>Range&lt;usize&gt;</code> 对其进行索引，以获得切片。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[..],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">..],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了展示我们如何实现 <code>Index</code>，这里有一个有趣的例子，展示了我们如何使用一个新类型和 <code>Index</code> trait 来实现 <code>Vec</code> 的包装索引和负索引。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Index</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="kt">i128</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">index</span>: <span class="nc">i128</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">self_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i128</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">self_len</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">0_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">1_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">2_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">wrapping_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">3_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">4_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="mi">5_</span><span class="k">usize</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">neg_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">3_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">2_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">wrapping_neg_indexes</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WrappingIndex</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">6_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">5_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">wrapping_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">4_</span><span class="kt">i128</span><span class="p">]);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>没有要求 <code>Idx</code> 类型必须是数字类型或 <code>Range</code>，它可以是一个枚举! 下面是一个例子，使用篮球位置索引到一个篮球队，以检索该队的球员。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Index</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">BasketballPosition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">PointGuard</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ShootingGuard</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Center</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">PowerForward</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">SmallForward</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">BasketballPlayer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">position</span>: <span class="nc">BasketballPosition</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">BasketballTeam</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">point_guard</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">shooting_guard</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">center</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">power_forward</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">small_forward</span>: <span class="nc">BasketballPlayer</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Index</span><span class="o">&lt;</span><span class="n">BasketballPosition</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BasketballTeam</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BasketballPlayer</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">position</span>: <span class="nc">BasketballPosition</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">BasketballPlayer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">PointGuard</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">point_guard</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">ShootingGuard</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">shooting_guard</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">Center</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">center</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">PowerForward</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">power_forward</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">BasketballPosition</span>::<span class="n">SmallForward</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">small_forward</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h4 id="drop">Drop</h4>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果一个类型实现了 <code>Drop</code>，那么当它超出作用域但在被销毁之前，<code>drop</code> 将在该类型上调用。我们很少需要为我们的类型实现这个功能，但是一个很好的例子是，如果一个类型持有一些外部资源，当类型被销毁时，这些资源需要被清理掉。</p>
<p>在标准库中有一个 <code>BufWriter</code> 类型，允许我们对 <code>Write</code> 类型进行缓冲写入。然而，如果 <code>BufWriter</code> 在其缓冲区的内容被刷新到底层的 <code>Write</code> 类型之前就被销毁了呢？幸好这是不可能的! <code>BufWriter</code> 实现了 <code>Drop</code> trait，所以每当它离开作用域时，<code>flush</code> 总是被调用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BufWriter</span><span class="o">&lt;</span><span class="n">W</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">flush_buf</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，Rust 中的 <code>Mutex</code> 没有 <code>unlock()</code> 方法，因为它们不需要这些方法。在一个 <code>Mutex</code> 上调用 <code>lock()</code> 会返回一个 <code>MutexGuard</code>，当 <code>Mutex</code> 超出作用域时，由于它的 <code>Drop</code> 实现，它会自动解锁。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MutexGuard</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">raw_unlock</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>一般来说，如果你在某些资源上实现一个抽象，在使用后需要清理，那么这就是使用 <code>Drop</code> trait 的一个很好的理由。</p>
<h2 id="转换-traits">转换 Traits</h2>
<h3 id="from--into">From &amp; Into</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>From&lt;T&gt;</code> 类型允许我们将 <code>T</code> 转换为 <code>Self</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Into&lt;T&gt;</code> 类型允许我们将 <code>Self</code> 转换为 <code>T</code>。</p>
<p>这些 trait 是一个硬币的两个不同侧面。我们只能为我们的类型实现 <code>From&lt;T&gt;</code>，因为 <code>Into&lt;T&gt;</code> 的实现是由下面这个泛型覆盖实现自动提供的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">U</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>::<span class="n">from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这两个  trait 存在的原因是，它允许我们以稍微不同的方式在泛型类型上编写 trait 约束(trait bound)。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="c1">// these bounds are equivalent
</span><span class="c1"></span><span class="w">    </span><span class="n">T</span>: <span class="nb">From</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="kt">i32</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// these examples are equivalent
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">example</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">from</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">example</span>: <span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>关于何时使用这两种方法并没有硬性规定，所以在每种情况下都要选择最合理的方法。现在让我们看看一些关于 <code>Point</code> 的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Into
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">origin</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>实现不是对称的，所以如果我们想把 <code>Point</code> 转换成元组和数组，我们也必须显示地地添加这些。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">]</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// from (i32, i32) into Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from Point into (i32, i32)
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="n">point</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tuple</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from [i32; 2] into Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span>::<span class="n">from</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">point</span>: <span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// from Point into [i32; 2]
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span>::<span class="n">from</span><span class="p">(</span><span class="n">point</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">array</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>From&lt;T&gt;</code> 的一个普遍用途是缩减模板代码。假设我们在程序中加入一个包含三个 <code>Point</code> 的 <code>Triangle</code> 类型，这里有许多方法可以构建它。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Triangle</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">P</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">]</span>: <span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">p1</span>: <span class="nc">p1</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">p2</span>: <span class="nc">p2</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="n">p3</span>: <span class="nc">p3</span><span class="p">.</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// manual construction
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">x</span>: <span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">y</span>: <span class="mi">2</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Point::new
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="nc">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From&lt;(i32, i32)&gt; for Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">p1</span>: <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">p2</span>: <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">p3</span>: <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using Triangle::new + From&lt;(i32, i32)&gt; for Point
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Triangle</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// using From&lt;[Into&lt;Point&gt;; 3]&gt; for Triangle
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">triangle</span>: <span class="nc">Triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">].</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对于何时、如何或为什么我们应该为我们的类型实现 <code>From&lt;T&gt;</code>，没有任何规则，所以这取决于我们对每种情况的最佳判断。</p>
<p><code>Into&lt;T&gt;</code> 的一个流行用法是使需要自有值(owned values)的函数在接受自有值或借用值时具有通用性。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// accepts:
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - String
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new1</span><span class="p">(</span><span class="n">name</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// accepts:
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - String
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - &amp;String
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - &amp;str
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - Box&lt;str&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - Cow&lt;&#39;_, str&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// - char
</span><span class="c1"></span><span class="w">    </span><span class="c1">// since all of the above types can be converted into String
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new2</span><span class="o">&lt;</span><span class="n">N</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">name</span>: <span class="nc">N</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">name</span>: <span class="nc">name</span><span class="p">.</span><span class="n">into</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="错误处理">错误处理</h2>
<p>谈论错误处理和 <code>Error</code> trait 的最佳时机是在讨论完 <code>Display</code>、<code>Debug</code>、<code>Any</code> 和 <code>From</code> 之后，在讨论 <code>TryFrom</code> 之前，因此错误处理部分与转换 trait 部分尴尬地一分为二。</p>
<h3 id="error">Error</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#display--tostring">Display &amp; ToString</a></li>
<li><a href="#debug">Debug</a></li>
<li><a href="#any">Any</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Error</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Display</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">backtrace</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Backtrace</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">description</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cause</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 Rust 中，错误被返回，而不是被抛出。我们来看看一些例子。</p>
<p>由于整数类型除以0会引起 panic，如果我们想让我们的程序更安全、更明确，我们可以实现一个 <code>safe_div</code> 函数，返回一个 <code>Result</code>，就像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">DivByZero</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DivByZero</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;division by zero error&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DivByZero</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">safe_div</span><span class="p">(</span><span class="n">numerator</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">denominator</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">DivByZero</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">denominator</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">DivByZero</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">numerator</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">denominator</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">test_safe_div</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">safe_div</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">safe_div</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">DivByZero</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于错误是返回的，而不是抛出的，所以必须显式处理，如果当前函数不能处理一个错误，它应该将其传播给调用者。传播错误的最习惯的方法是使用 <code>?</code> 操作符，它只是现在被废弃的 <code>try!</code> 宏的语法糖，它只是做这个。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="kr">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="cp">$expr</span>:<span class="nc">expr</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="cp">$expr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// if Ok just unwrap the value
</span><span class="c1"></span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="c1">// if Err map the err value using From and return
</span><span class="c1"></span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="nb">From</span>::<span class="n">from</span><span class="p">(</span><span class="n">err</span><span class="p">));</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>如果我们想写一个将文件读成 <code>String</code> 的函数，我们可以这样写，用 <code>?</code> 将 <code>io::Error</code> 传播到它们可能出现的任何地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">read_file_to_string</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是，假设我们正在读取的文件实际上是一个数字列表，我们想把它们加在一起，我们会像这样更新我们的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="cm">/* What to put here? */</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>但是现在我们的 <code>Result</code> 的错误类型是什么？它可以返回一个 <code>io::Error</code> 或者一个 <code>ParseIntError</code>。我们将看一下解决这个问题的三种方法，从临时应急的方法开始，最后是最稳健的方法。</p>
<p>第一种方法是认识到所有实现了 <code>Error</code> 的类型也实现了 <code>Display</code>，所以我们可以将所有的错误映射到 <code>String</code>，并使用 <code>String</code> 作为我们的错误类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; String
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>对每个错误进行字符串化处理的明显缺点是，我们丢弃了类型信息，这使得调用者更难处理错误。</p>
<p>上述方法的一个非显而易见的好处是我们可以定制字符串以提供更多的特定环境信息。例如，<code>ParseIntError</code> 通常字符串化为 &ldquo;invalid digit found in string&rdquo;，这是非常模糊的，没有提到无效的字符串是什么或者它试图解析成什么整数类型。如果我们要调试这个问题，这个错误信息几乎是无用的。然而，我们可以通过自己提供所有与上下文相关的信息来使其明显改善。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;failed to parse {} into i32&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>第二种方法是利用标准库中的这种泛型覆盖实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">E</span>: <span class="nc">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这意味着任何 <code>Error</code> 类型都可以通过 <code>?</code> 运算符隐式地转换为 <code>Box&lt;dyn error::Error&gt;</code>，所以我们可以在任何产生错误的函数的 <code>Result</code> 返回类型中把错误类型设置为 <code>Box&lt;dyn error::Error&gt;</code>，<code>?</code> 运算符将为我们完成其余的工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; Box&lt;dyn error::Error&gt;
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然更加简洁，但这似乎与之前的方法有相同的缺点，即丢弃了类型信息。这大部分是真的，但是如果调用者知道我们函数的实现细节，他们仍然可以使用 <code>error::Error</code> 上的 <code>downcast_ref()</code> 方法来处理不同的错误类型，这和它在 <code>dyn Any</code> 类型上的作用是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">handle_sum_file_errors</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">sum_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;the sum is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">downcast_ref</span>::<span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// handle io::Error
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">downcast_ref</span>::<span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// handle ParseIntError
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// we know sum_file can only return one of the
</span><span class="c1"></span><span class="w">                </span><span class="c1">// above errors so this branch is unreachable
</span><span class="c1"></span><span class="w">                </span><span class="n">unreachable</span><span class="o">!</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>第三种方法是最稳健和类型安全的方法，可以聚合这些不同的错误，是使用一个枚举建立我们自己的自定义错误类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Io</span><span class="p">(</span><span class="n">io</span>::<span class="n">Error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Parse</span><span class="p">(</span><span class="n">ParseIntError</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">err</span>: <span class="nc">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;sum file error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;sum file error: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">SumFileError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// the default impl for this method always returns None
</span><span class="c1"></span><span class="w">    </span><span class="c1">// but we can now override it to make it way more useful!
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum_file</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">SumFileError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ io::Error -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">contents</span><span class="p">.</span><span class="n">lines</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">line</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// ⬆️ ParseIntError -&gt; SumFileError
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">handle_sum_file_errors</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">sum_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;the sum is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">SumFileError</span>::<span class="n">Io</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// handle io::Error
</span><span class="c1"></span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">SumFileError</span>::<span class="n">Parse</span><span class="p">(</span><span class="n">err</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// handle ParseIntError
</span><span class="c1"></span><span class="w">        </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="conversion-traits-continued">Conversion Traits Continued</h2>
<h3 id="tryfrom--tryinto">TryFrom &amp; TryInto</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#generic-types-vs-associated-types">Generic Types vs Associated Types</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
<li><a href="#from--into">From &amp; Into</a></li>
<li><a href="#error">Error</a></li>
</ul>
<p><code>TryFrom</code> 和 <code>TryInto</code> 是 <code>From</code> 和 <code>Into</code> 的不可靠版本。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>与 <code>Into</code> 类似，我们不能自己实现 <code>TryInto</code>，因为它的实现是由下面这个泛型覆盖实现提供的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryInto</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">U</span>: <span class="nc">TryFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_into</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">U</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>::<span class="n">try_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Let&rsquo;s say that in the context of our program it doesn&rsquo;t make sense for <code>Point</code>s to have <code>x</code> and <code>y</code> values that are less than <code>-1000</code> or greater than <code>1000</code>. This is how we&rsquo;d rewrite our earlier <code>From</code> impls using <code>TryFrom</code> to signal to the users of our type that this conversion can now fail:
假设在我们的程序中，<code>Point</code> 的 <code>x</code> 和 <code>y</code> 的值小于 <code>-1000</code> 或大于 <code>1000</code> 是不合理的。这就是我们如何使用 <code>TryFrom</code> 重写我们先前的 <code>From</code> 实现，向我们类型的用户发出信号，这个转换现在可以失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="n">TryFrom</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;out of bounds&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// now fallible
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">OutOfBounds</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// still infallible
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span>: <span class="nc">Point</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>And here&rsquo;s the refactored <code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code> impl for <code>Triangle</code>:
这里是重构后的 <code>TryFrom&lt;[TryInto&lt;Point&gt;; 3]&gt;</code> 实现，用于 <code>Triangle</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="p">{</span><span class="n">TryFrom</span><span class="p">,</span><span class="w"> </span><span class="n">TryInto</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;out of bounds&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">OutOfBounds</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">p1</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p2</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">p3</span>: <span class="nc">Point</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;</span><span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Triangle</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">P</span>: <span class="nc">TryInto</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">,</span><span class="w"> </span><span class="n">p3</span><span class="p">]</span>: <span class="p">[</span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">p1</span>: <span class="nc">p1</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">p2</span>: <span class="nc">p2</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">p3</span>: <span class="nc">p3</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="p">,</span><span class="w"> </span><span class="n">OutOfBounds</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nc">Triangle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)].</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="fromstr">FromStr</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#error">Error</a></li>
<li><a href="#tryfrom--tryinto">TryFrom &amp; TryInto</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromStr</code> types allow performing a fallible conversion from <code>&amp;str</code> into <code>Self</code>. The idiomatic way to use <code>FromStr</code> is to call the <code>.parse()</code> method on <code>&amp;str</code>s:
<code>FromStr</code> 类型允许执行从 <code>&amp;str</code> 到 <code>Self</code> 的错误转换。使用 <code>FromStr</code> 的习惯方法是对 <code>&amp;str</code> 调用 <code>.parse()</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">FromStr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// these are all equivalent
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FromStr</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// most idiomatic
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Point</code> 实现的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">iter</span>::<span class="n">Enumerate</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">num</span>::<span class="n">ParseIntError</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="p">{</span><span class="n">Chars</span><span class="p">,</span><span class="w"> </span><span class="n">FromStr</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, Eq, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Debug, PartialEq)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">ParsePointError</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;failed to parse point&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ParseIntError</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">_e</span>: <span class="nc">ParseIntError</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">ParsePointError</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ParsePointError</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="n">ParsePointError</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">is_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">char</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">matches</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">..</span><span class="o">=</span><span class="sc">&#39;9&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">isnt_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">!</span><span class="n">is_num</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">get_num</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">            </span><span class="o">|</span><span class="n">char_idxs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Enumerate</span><span class="o">&lt;</span><span class="n">Chars</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;&gt;|</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">),</span><span class="w"> </span><span class="n">ParsePointError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char_idxs</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">skip_while</span><span class="p">(</span><span class="n">isnt_num</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char_idxs</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">skip_while</span><span class="p">(</span><span class="n">is_num</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">ok_or</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">((</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">))</span><span class="w">
</span><span class="w">            </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">enumerate</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span><span class="w"> </span><span class="n">x_end</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">y_start</span><span class="p">,</span><span class="w"> </span><span class="n">y_end</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_num</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">char_idxs</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">x_start</span><span class="p">..</span><span class="n">x_end</span><span class="p">].</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">[</span><span class="n">y_start</span><span class="p">..</span><span class="n">y_end</span><span class="p">].</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">pos_x_y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;(4, 5)&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">neg_x_y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;(-6, -2)&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">)));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">not_a_point</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;not a point&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">ParsePointError</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromStr</code> has the same signature as <code>TryFrom&lt;&amp;str&gt;</code>. It doesn&rsquo;t matter which one we impl for a type first as long as we forward the impl to the other one. Here&rsquo;s a <code>TryFrom&lt;&amp;str&gt;</code> impl for <code>Point</code> assuming it already has a <code>FromStr</code> impl:
<code>FromStr</code> 与 <code>TryFrom&lt;&amp;str&gt;</code> 的签名相同。只要我们把实现转发给另一个类型，哪一个实现并不重要。下面是一个针对 <code>Point</code> 的 <code>TryFrom&lt;&amp;str&gt;</code> 实现，假设它已经有一个 <code>FromStr</code> 实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">TryFrom</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FromStr</span><span class="o">&gt;</span>::<span class="nb">Err</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_from</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&lt;</span><span class="n">Point</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FromStr</span><span class="o">&gt;</span>::<span class="n">from_str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="asref--asmut">AsRef &amp; AsMut</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#deref--derefmut">Deref &amp; DerefMut</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="nb">AsMut</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>?Sized</code> 说明 T 类型是大小不确定的。<code>As</code> 作为介词, 表明发生了类型转换。</p>
<p><code>AsRef</code> is for cheap reference to reference conversions. However, one of the most common ways it&rsquo;s used is to make functions generic over whether they take ownership or not:</p>
<p><code>AsRef</code> 是用于廉价的引用到引用的转换。然而，它最常见的使用方式之一是使函数在是否拥有所有权上通用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// accepts:
</span><span class="c1">//  - &amp;str
</span><span class="c1">//  - &amp;String
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">takes_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// use &amp;str
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// accepts:
</span><span class="c1">//  - &amp;str
</span><span class="c1">//  - &amp;String
</span><span class="c1">//  - String
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">takes_asref_str</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// use &amp;str
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">borrow</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">owned</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">borrow</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_str</span><span class="p">(</span><span class="n">owned</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">borrow</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">takes_asref_str</span><span class="p">(</span><span class="n">owned</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The other most common use-case is returning a reference to inner private data wrapped by a type which protects some invariant. A good example from the standard library is <code>String</code> which is just a wrapper around <code>Vec&lt;u8&gt;</code>:</p>
<p>另一个最常见的用例是返回一个对内部私有数据的引用，该数据由一个保护某些不变性的类型包裹。标准库中的一个很好的例子是 <code>String</code>，它只是 <code>Vec&lt;u8&gt;</code> 的一个包装器。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This inner <code>Vec</code> cannot be made public because if it was people could mutate any byte and break the <code>String</code>&rsquo;s valid UTF-8 encoding. However, it&rsquo;s safe to expose an immutable read-only reference to the inner byte array, hence this impl:
这个内部的 <code>Vec</code> 不能被公开，因为如果它被公开，人们可以改变任何字节并破坏 <code>String</code> 的有效 UTF-8 编码。然而，公开内部字节数组的不可变的只读引用是安全的，因此有了这个实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>Generally, it often only makes sense to impl <code>AsRef</code> for a type if it wraps some other type to either provide additional functionality around the inner type or protect some invariant on the inner type.</p>
<p>Let&rsquo;s examine a example of bad <code>AsRef</code> impls:
一般来说，只有当一个类型包装了其他类型，为内部类型提供了额外的功能，或者保护了内部类型的某些不变性时，为其实现 <code>AsRef</code> 才有意义。</p>
<p>让我们来看看一个不好的 <code>AsRef</code> 实现的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">age</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This works and kinda makes sense at first, but quickly falls apart if we add more members to <code>User</code>:
这在一开始是可行的，而且有点道理，但如果我们给 <code>User</code> 增加更多的成员，很快就会崩溃。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">height</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// uh, do we return name or email here?
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// uh, do we return age or height here?
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>A <code>User</code> is composed of <code>String</code>s and <code>u32</code>s but it&rsquo;s not really the same thing as a <code>String</code> or a <code>u32</code>. Even if we had much more specific types:
<code>User</code> 是由 <code>String</code> 和 <code>u32</code> 组成的，但它和 <code>String</code> 或 <code>u32</code> 并不是真正的一回事。即使我们有更具体的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nc">Name</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nc">Email</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="nc">Age</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">height</span>: <span class="nc">Height</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>It wouldn&rsquo;t make much sense to impl <code>AsRef</code> for any of those because <code>AsRef</code> is for cheap reference to reference conversions between semantically equivalent things, and <code>Name</code>, <code>Email</code>, <code>Age</code>, and <code>Height</code> by themselves are not the same thing as a <code>User</code>.</p>
<p>A good example where we would impl <code>AsRef</code> would be if we introduced a new type <code>Moderator</code> that just wrapped a <code>User</code> and added some moderation specific privileges:
实现 <code>AsRef</code> 对这些都没有意义，因为 <code>AsRef</code> 是用来在语义上等同的事物之间进行廉价的引用转换，而 <code>Name</code>、<code>Email</code>、<code>Age</code> 和 <code>Height</code> 本身就和 <code>User</code> 不是一回事。</p>
<p>一个很好的例子是，如果我们引入一个新的类型 <code>Moderator</code>，它只是包裹了一个 <code>User</code>，并增加了一些特定的管理权限，我们就会使用 <code>AsRef</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">name</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">age</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// unfortunately the standard library cannot provide
</span><span class="c1">// a generic blanket impl to save us from this boilerplate
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Privilege</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">BanUsers</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">EditPosts</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">DeletePosts</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// although Moderators have some special
</span><span class="c1">// privileges they are still regular Users
</span><span class="c1">// and should be able to do all the same stuff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">user</span>: <span class="nc">User</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">privileges</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Privilege</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Moderator</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Moderator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">user</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this should be callable with Users
</span><span class="c1">// and Moderators (who are also Users)
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">create_post</span><span class="o">&lt;</span><span class="n">U</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">u</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// etc
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">user</span>: <span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="n">moderator</span>: <span class="nc">Moderator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">create_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">create_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">moderator</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This works because <code>Moderator</code>s are just <code>User</code>s. Here&rsquo;s the example from the <code>Deref</code> section except using <code>AsRef</code> instead:
这样做是因为 <code>Moderator</code> 就是 <code>User</code>。下面是 <code>Deref</code> 部分的例子，只是用 <code>AsRef</code> 代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">convert</span>::<span class="nb">AsRef</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">health_points</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Weapon</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Spear</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Axe</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Sword</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Soldier is just a Human with a Weapon
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weapon</span>: <span class="nc">Weapon</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Mount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Horse</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Donkey</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Cow</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Knight is just a Soldier with a Mount
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">mount</span>: <span class="nc">Mount</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Knight</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Soldier</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Knight</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">soldier</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Spell</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MagicMissile</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">FireBolt</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ThornWhip</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Mage is just a Human who can cast Spells
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">spells</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Spell</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Staff</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Wooden</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Metallic</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Plastic</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// a Wizard is just a Mage with a Staff
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">staff</span>: <span class="nc">Staff</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Wizard</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Mage</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Wizard</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Human</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">mage</span><span class="p">.</span><span class="n">human</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_human</span><span class="o">&lt;</span><span class="n">H</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Human</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">human</span>: <span class="nc">H</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_soldier</span><span class="o">&lt;</span><span class="n">S</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Soldier</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">soldier</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_knight</span><span class="o">&lt;</span><span class="n">K</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Knight</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">knight</span>: <span class="nc">K</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_mage</span><span class="o">&lt;</span><span class="n">M</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Mage</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">mage</span>: <span class="nc">M</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrows_wizard</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Wizard</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">wizard</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">human</span>: <span class="nc">Human</span><span class="p">,</span><span class="w"> </span><span class="n">soldier</span>: <span class="nc">Soldier</span><span class="p">,</span><span class="w"> </span><span class="n">knight</span>: <span class="nc">Knight</span><span class="p">,</span><span class="w"> </span><span class="n">mage</span>: <span class="nc">Mage</span><span class="p">,</span><span class="w"> </span><span class="n">wizard</span>: <span class="nc">Wizard</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// all types can be used as Humans
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_human</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights can be used as Soldiers
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">soldier</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_soldier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Wizards can be used as Mages
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mage</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_mage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// Knights &amp; Wizards passed as themselves
</span><span class="c1"></span><span class="w">    </span><span class="n">borrows_knight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">knight</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">borrows_wizard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wizard</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Deref</code> didn&rsquo;t work in the prior version of the example above because deref coercion is an implicit conversion between types which leaves room for people to mistakenly formulate the wrong ideas and expectations for how it will behave. <code>AsRef</code> works above because it makes the conversion between types explicit and there&rsquo;s no room leftover to develop any wrong ideas or expectations.
<code>Deref</code> 在上述例子的先前版本中不起作用，因为 deref coercion 是一种隐式类型转换，为人们错误地制定错误的想法和期望留下了空间。<code>AsRef</code> 在上面起作用，因为它使类型间的转换变得明确，没有余地来发展任何错误的想法或期望。</p>
<h3 id="borrow--borrowmut">Borrow &amp; BorrowMut</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#subtraits--supertraits">Subtraits &amp; Supertraits</a></li>
<li><a href="#sized">Sized</a></li>
<li><a href="#asref--asmut">AsRef &amp; AsMut</a></li>
<li><a href="#partialeq--eq">PartialEq &amp; Eq</a></li>
<li><a href="#hash">Hash</a></li>
<li><a href="#partialord--ord">PartialOrd &amp; Ord</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">BorrowMut</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">borrow_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Borrowed</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>These traits were invented to solve the very specific problem of looking up <code>String</code> keys in <code>HashSet</code>s, <code>HashMap</code>s, <code>BTreeSet</code>s, and <code>BTreeMap</code>s using <code>&amp;str</code> values.</p>
<p>We can view <code>Borrow&lt;T&gt;</code> and <code>BorrowMut&lt;T&gt;</code> as stricter versions of <code>AsRef&lt;T&gt;</code> and <code>AsMut&lt;T&gt;</code>, where the returned reference <code>&amp;T</code> has equivalent <code>Eq</code>, <code>Hash</code>, and <code>Ord</code> impls to <code>Self</code>. This is more easily explained with a commented example:
这些 trait 的发明是为了解决在 <code>HashSet</code>, <code>HashMap</code>, <code>BTreeSet</code>, 和 <code>BTreeMap</code> 中使用 <code>&amp;str</code> 值查找 <code>String</code> 键的特殊问题。</p>
<p>我们可以把 <code>Borrow&lt;T&gt;</code> 和 <code>BorrowMut&lt;T&gt;</code> 看作是 <code>AsRef&lt;T&gt;</code> 和 <code>AsMut&lt;T&gt;</code> 的更严格的版本，其中返回的引用 <code>&amp;T</code> 与 <code>Self</code> 的 <code>Eq</code>、<code>Hash</code> 和 <code>Ord</code> 等值。用一个注释的例子可以更容易地解释这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">borrow</span>::<span class="n">Borrow</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">hash_map</span>::<span class="n">DefaultHasher</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>:<span class="err">#️⃣</span>:<span class="nc">Hash</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">get_hash</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Hash</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hasher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultHasher</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">hash</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">hasher</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">hasher</span><span class="p">.</span><span class="n">finish</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">asref_example</span><span class="o">&lt;</span><span class="n">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">Ref</span><span class="o">&gt;</span><span class="p">(</span><span class="n">owned1</span>: <span class="nc">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">owned2</span>: <span class="nc">Owned</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Owned</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Ref</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Ref</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1</span>: <span class="kp">&amp;</span><span class="nc">Ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned1</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2</span>: <span class="kp">&amp;</span><span class="nc">Ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned2</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// refs aren&#39;t required to be equal if owned types are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2</span><span class="p">,</span><span class="w"> </span><span class="n">ref1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ref2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ref2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// ref hashes aren&#39;t required to be equal if owned type hashes are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2_hash</span><span class="p">,</span><span class="w"> </span><span class="n">ref1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ref2_hash</span><span class="p">);</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// ref comparisons aren&#39;t required to match owned type comparisons
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">),</span><span class="w"> </span><span class="n">ref1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="p">));</span><span class="w"> </span><span class="c1">// ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">borrow_example</span><span class="o">&lt;</span><span class="n">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="p">(</span><span class="n">owned1</span>: <span class="nc">Owned</span><span class="p">,</span><span class="w"> </span><span class="n">owned2</span>: <span class="nc">Owned</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">Owned</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Borrowed</span>: <span class="nb">Eq</span> <span class="o">+</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Hash</span><span class="w">
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow1</span>: <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned1</span><span class="p">.</span><span class="n">borrow</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow2</span>: <span class="kp">&amp;</span><span class="nc">Borrowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">owned2</span><span class="p">.</span><span class="n">borrow</span><span class="p">();</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrows are required to be equal if owned types are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2</span><span class="p">,</span><span class="w"> </span><span class="n">borrow1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">borrow2</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">owned2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow1_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow1</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">borrow2_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_hash</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow2</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrow hashes are required to be equal if owned type hashes are equal
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">owned2_hash</span><span class="p">,</span><span class="w"> </span><span class="n">borrow1_hash</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">borrow2_hash</span><span class="p">);</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// borrow comparisons are required to match owned type comparisons
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">owned1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owned2</span><span class="p">),</span><span class="w"> </span><span class="n">borrow1</span><span class="p">.</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">borrow2</span><span class="p">));</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>It&rsquo;s good to be aware of these traits and understand why they exist since it helps demystify some of the methods on <code>HashSet</code>, <code>HashMap</code>, <code>BTreeSet</code>, and <code>BTreeMap</code> but it&rsquo;s very rare that we would ever need to impl these traits for any of our types because it&rsquo;s very rare that we would ever need create a pair of types where one is the &ldquo;borrowed&rdquo; version of the other in the first place. If we have some <code>T</code> then <code>&amp;T</code> will get the job done 99.99% of the time, and <code>T: Borrow&lt;T&gt;</code> is already implemented for all <code>T</code> because of a generic blanket impl, so we don&rsquo;t need to manually impl it and we don&rsquo;t need to create some <code>U</code> such that <code>T: Borrow&lt;U&gt;</code>.</p>
<p>知道这些 trait 并理解它们存在的原因是很好的，因为这有助于解开 <code>HashSet</code>、<code>HashMap</code>、<code>BTreeSet</code> 和 <code>BTreeMap</code> 上的一些方法，但是我们很少需要为我们的任何类型实现这些 trait，因为我们很少需要创建一对类型，其中一个是另一个的 &ldquo;借用&rdquo; 版本。如果我们有一些 <code>T</code>，那么 <code>T</code> 在 99.99% 的情况下都能完成工作，而且 <code>T: Borrow&lt;T&gt;</code> 已经为所有的 <code>T</code> 实现了，因为有一个通用的一揽子实现，所以我们不需要手动实现它，我们也不需要创建一些 <code>U</code>，使 <code>T: Borrow&lt;U&gt;</code>。</p>
<h3 id="toowned">ToOwned</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#default-impls">Default Impls</a></li>
<li><a href="#clone">Clone</a></li>
<li><a href="#borrow--borrowmut">Borrow &amp; BorrowMut</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">ToOwned</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Owned</span>: <span class="nc">Borrow</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_owned</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Owned</span><span class="p">;</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone_into</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">target</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Owned</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>ToOwned</code> is a more generic version of <code>Clone</code>. <code>Clone</code> allows us to take a <code>&amp;T</code> and turn it into an <code>T</code> but <code>ToOwned</code> allows us to take a <code>&amp;Borrowed</code> and turn it into a <code>Owned</code> where <code>Owned: Borrow&lt;Borrowed&gt;</code>.</p>
<p>In other words, we can&rsquo;t &ldquo;clone&rdquo; a <code>&amp;str</code> into a <code>String</code>, or a <code>&amp;Path</code> into a <code>PathBuf</code>, or an <code>&amp;OsStr</code> into an <code>OsString</code>, since the <code>clone</code> method signature doesn&rsquo;t support this kind of cross-type cloning, and that&rsquo;s what <code>ToOwned</code> was made for.</p>
<p>For similar reasons as <code>Borrow</code> and <code>BorrowMut</code>, it&rsquo;s good to be aware of this trait and understand why it exists but it&rsquo;s very rare we&rsquo;ll ever need to impl it for any of our types.</p>
<p><code>ToOwned</code> 是 <code>Clone</code> 的一个更通用的版本。<code>Clone</code> 允许我们把一个 <code>&amp;T</code> 变成一个 <code>T</code>，但 <code>ToOwned</code> 允许我们把一个 <code>&amp;Borrowed</code> 变成一个 <code>Owned</code>，其中 <code>Owned: Borrow&lt;Borrowed&gt;</code>。</p>
<p>换句话说，我们不能把一个 <code>&amp;str</code> 克隆成一个 <code>String</code>，或者把一个 <code>&amp;Path</code> 克隆成一个 <code>PathBuf</code>，或者把一个 <code>&amp;OsStr</code> 克隆成一个 <code>OsString</code>，因为 <code>clone</code> 方法签名不支持这种跨类型克隆，而这正是 <code>ToOwned</code> 的用途。</p>
<p>出于与 <code>Borrow</code> 和 <code>BorrowMut</code> 类似的原因，知道这个 trait 并理解它存在的原因是很好的，但我们很少需要为我们的任何类型实现这个 trait。</p>
<h2 id="iteration-traits">Iteration Traits</h2>
<h3 id="iterator">Iterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#default-impls">Default Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">size_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">advance_by</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">nth</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">step_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">step</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">StepBy</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">chain</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">other</span>: <span class="nc">U</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Chain</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">U</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">IntoIter</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">zip</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">U</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Zip</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">U</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">IntoIter</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Map</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">for_each</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">filter</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Filter</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">filter_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">FilterMap</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Enumerate</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">peekable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Peekable</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">skip_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">SkipWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take_while</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">TakeWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">map_while</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">MapWhile</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Skip</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Take</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">scan</span><span class="o">&lt;</span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">initial_state</span>: <span class="nc">St</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Scan</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">St</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flat_map</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">FlatMap</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">U</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">U</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Flatten</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fuse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Fuse</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inspect</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Inspect</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partition</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partition_in_place</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">DoubleEndedIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_partitioned</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_fold</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">init</span>: <span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_for_each</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fold</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">init</span>: <span class="nc">B</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fold_first</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">all</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">any</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">find</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">find_map</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">try_find</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">f</span>: <span class="nc">F</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">R</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Try</span><span class="o">&gt;</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">R</span>: <span class="nc">Try</span><span class="o">&lt;</span><span class="nb">Ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">position</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rposition</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">predicate</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">ExactSizeIterator</span> <span class="o">+</span><span class="w"> </span><span class="nb">DoubleEndedIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max_by_key</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">max_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min_by_key</span><span class="o">&lt;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">B</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">min_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">rev</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Rev</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">DoubleEndedIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">unzip</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">FromA</span><span class="p">,</span><span class="w"> </span><span class="n">FromB</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="n">FromA</span><span class="p">,</span><span class="w"> </span><span class="n">FromB</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">FromA</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">FromB</span>: <span class="nb">Default</span> <span class="o">+</span><span class="w"> </span><span class="nb">Extend</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">copied</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Copied</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Copy</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cloned</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cloned</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="na">&#39;a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Cycle</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Clone</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sum</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">S</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">S</span>: <span class="nc">Sum</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">product</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">P</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">P</span>: <span class="nc">Product</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">Ord</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> </span><span class="n">cmp</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">partial_cmp_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">partial_cmp</span>: <span class="nc">F</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialEq</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq_by</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> </span><span class="n">eq</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialEq</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">lt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">le</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">gt</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ge</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">I</span>: <span class="nb">IntoIterator</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;&lt;</span><span class="n">I</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">Item</span>: <span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted_by</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">compare</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Ordering</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_sorted_by_key</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span>
    <span class="nc">where</span><span class="w">
</span><span class="w">        </span><span class="n">F</span>: <span class="nb">FnMut</span><span class="p">(</span><span class="n">Self</span>::<span class="n">Item</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">K</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">K</span>: <span class="nb">PartialOrd</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>Iterator&lt;Item = T&gt;</code> 类型可以被迭代，并会产生 <code>T</code> 类型。没有 <code>IteratorMut</code> trait。每个 <code>Iterator</code> 实现可以通过 <code>Item</code> 关联类型指定它是返回不可变引用、可变引用还是拥有其值。</p>
<table>
<thead>
<tr>
<th><code>Vec&lt;T&gt;</code> 方法</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.iter()</code></td>
<td><code>Iterator&lt;Item = &amp;T&gt;</code></td>
</tr>
<tr>
<td><code>.iter_mut()</code></td>
<td><code>Iterator&lt;Item = &amp;mut T&gt;</code></td>
</tr>
<tr>
<td><code>.into_iter()</code></td>
<td><code>Iterator&lt;Item = T&gt;</code></td>
</tr>
</tbody>
</table>
<p>对于初学者来说，有些东西不是很明显，但中级 Rustaceans 认为是理所当然的，那就是大多数类型都不是他们本身的迭代器。如果一个类型是可迭代的，我们几乎总是实现一些自定义的迭代器类型来迭代它，而不是试图让它自己迭代。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">MyTypeIterator</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">index</span>: <span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">items</span>: <span class="kp">&amp;</span><span class="nc">self</span><span class="p">.</span><span class="n">items</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">MyTypeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">index</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyTypeIterator</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">None</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="p">];</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了便于教学，上面的例子展示了如何从头开始实现一个 <code>Iterator</code>，但在这种情况下，习惯性的解决方案将只是遵从 <code>Vec</code> 的 <code>iter</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">items</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>另外，这也是一个很好的通用全面实现，要注意。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span> <span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">I</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>它说任何对迭代器的可变引用也是迭代器，这一点很有用，因为它允许我们使用 <code>self</code> 接收器，就像使用 <code>&amp;mut self</code> 接收器一样。了解这一点很有用，因为它允许我们使用迭代器方法与 <code>self</code> 接收器，就像它们有 <code>&amp;mut self</code> 接收器一样。</p>
<p>举个例子，想象一下，我们有一个函数，它可以处理一个超过三个项的迭代器，但是函数的第一步是取出迭代器的前三项，并在迭代剩下的项之前分别处理它们，下面是一个初学者可能尝试写这个函数的方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ❌ iter consumed in line above
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>嗯，这很烦人。<code>take</code> 方法有一个 <code>self</code> 接收器，所以我们似乎不能在不消耗整个迭代器的情况下调用它。下面是上面代码的一个天真的重构。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这还算好的。然而，惯用的重构其实是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">iter</span>: <span class="nc">I</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first3</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="p">.</span><span class="n">by_ref</span><span class="p">().</span><span class="n">take</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="w">        </span><span class="c1">// process remaining items
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不太容易发现。但无论如何，现在我们知道了。</p>
<p>另外，对于什么可以是迭代器，什么不能是迭代器，并没有什么规则或约定。如果类型是 <code>Iterator</code>，那么它就是一个迭代器。标准库中的一些创造性的例子如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">mpsc</span>::<span class="n">channel</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">paths_can_be_iterated</span><span class="p">(</span><span class="n">path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// iterate over parts of a path
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">receivers_can_be_iterated</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">send</span><span class="p">,</span><span class="w"> </span><span class="n">recv</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">send</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">recv</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// iterate over received values
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="intoiterator">IntoIterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#associated-types">Associated Types</a></li>
<li><a href="#iterator">Iterator</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="nb">IntoIterator</span><span class="w"> 
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">IntoIter</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Iterator</span><span class="o">&gt;</span>::<span class="n">Item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Self</span>::<span class="n">Item</span><span class="p">,</span><span class="w"> 
</span><span class="w"></span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">Item</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">IntoIter</span>: <span class="nb">Iterator</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">into_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span>::<span class="n">IntoIter</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>IntoIterator</code> 类型可以被转换为迭代器，因此得名。当一个类型在 <code>for-in</code> 循环中使用时，会调用 <code>into_iter</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above line desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>不仅 <code>Vec</code> 实现了 <code>IntoIterator</code>，如果我们想分别迭代不可变引用或可变引用而不是拥有其值，<code>&amp;Vec</code> 和 <code>&amp;mut Vec</code> 也分别实现了 <code>IntoIterator</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = &amp;T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above example desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">).</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// vec = Vec&lt;T&gt;
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// v = &amp;mut T
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// above example desugared
</span><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="p">).</span><span class="n">into_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="fromiterator">FromIterator</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#generic-parameters">Generic Parameters</a></li>
<li><a href="#iterator">Iterator</a></li>
<li><a href="#intoiterator">IntoIterator</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">FromIterator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">T</span>: <span class="nb">IntoIterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>FromIterator</code> 类型可以从迭代器中创建，因此也被称为 <code>FromIterator</code>。<code>FromIterator</code> 最常见和最习惯的用法是调用 <code>Iterator</code> 上的 <code>collect</code> 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">collect</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">B</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">B</span>: <span class="nc">FromIterator</span><span class="o">&lt;</span><span class="n">Self</span>::<span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>将 <code>Iterator&lt;Item = char&gt;</code> 收集成 <code>String</code> 的例子如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">filter_letters</span><span class="p">(</span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">is_alphabetic</span><span class="p">()).</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>标准库中的所有集合都实现了 <code>IntoIterator</code> 和 <code>FromIterator</code>，这样可以更容易在它们之间进行转换。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="p">{</span><span class="n">BTreeSet</span><span class="p">,</span><span class="w"> </span><span class="n">HashMap</span><span class="p">,</span><span class="w"> </span><span class="n">HashSet</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedList</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// String -&gt; HashSet&lt;char&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">unique_chars</span><span class="p">(</span><span class="n">string</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">HashSet</span><span class="o">&lt;</span><span class="n">char</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">chars</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Vec&lt;T&gt; -&gt; BTreeSet&lt;T&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">ordered_unique_items</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">BTreeSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// HashMap&lt;K, V&gt; -&gt; LinkedList&lt;(K, V)&gt;
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">entry_list</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">map</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">map</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// and countless more possible examples
</span></code></pre></div><h2 id="io-traits">I/O Traits</h2>
<h3 id="read--write">Read &amp; Write</h3>
<p>预备知识</p>
<ul>
<li><a href="#self">Self</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#scope">Scope</a></li>
<li><a href="#generic-blanket-impls">Generic Blanket Impls</a></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">IoSliceMut</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_read_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">initializer</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Initializer</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_to_end</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">read_exact</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Bytes</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">chain</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">next</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Chain</span><span class="o">&lt;</span><span class="n">Self</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">limit</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Take</span><span class="o">&lt;</span><span class="n">Self</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// provided default impls
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">IoSlice</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">is_write_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_all</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_all_vectored</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bufs</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">IoSlice</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">write_fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="nc">Arguments</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">by_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Self</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>: <span class="nb">Sized</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>通用的全面实现值得了解。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span>: <span class="nc">Write</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Write</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">W</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这说明任何对 <code>Read</code> 类型的可变引用也是 <code>Read</code>，对 <code>Write</code> 也是如此。了解这一点很有用，因为它允许我们使用任何带有 <code>self</code> 接收器的方法，就像它有一个 <code>&amp;mut self</code> 接收器一样。我们已经在 <code>Iterator</code> trait 部分介绍了如何做到这一点以及为什么它很有用，所以我不打算在这里再次重复。</p>
<p>我想指出，<code>&amp;[u8]</code> 实现了 <code>Read</code>，<code>Vec&lt;u8&gt;</code> 实现了 <code>Write</code>，所以我们可以很容易地使用 <code>String</code> 对我们的文件处理函数进行单元测试，这些函数很容易转换为 <code>&amp;[u8]</code> 和 <code>Vec&lt;u8&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">path</span>::<span class="n">Path</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">File</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Read</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span>::<span class="n">Write</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// function we want to test
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">uppercase</span><span class="o">&lt;</span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w"> </span><span class="n">W</span>: <span class="nc">Write</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">read</span>: <span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">write</span>: <span class="nc">W</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">read</span><span class="p">.</span><span class="n">read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">uppercase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">to_uppercase</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">write</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">uppercase</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">write</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// in actual program we&#39;d pass Files
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="p">(</span><span class="n">in_path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">out_path</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">in_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">in_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">out_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File</span>::<span class="n">open</span><span class="p">(</span><span class="n">out_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">uppercase</span><span class="p">(</span><span class="n">in_file</span><span class="p">,</span><span class="w"> </span><span class="n">out_file</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// however in unit tests we can use Strings!
</span><span class="c1"></span><span class="cp">#[test]</span><span class="w"> </span><span class="c1">// ✅
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example_test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">in_file</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;i am screaming&#34;</span><span class="p">.</span><span class="n">into</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">out_file</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">uppercase</span><span class="p">(</span><span class="n">in_file</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">out_file</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">out_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8</span><span class="p">(</span><span class="n">out_file</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">out_result</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;I AM SCREAMING&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="结论">结论</h2>
<p>我们一起学到了很多东西! 事实上，太多了。它现在是我们的了:</p>
<p><img src="../assets/jason-jarvis-stdlib-traits.png" alt="rust standard library traits"></p>
<p><em>Artist credit: <a href="https://thejenkinscomic.wordpress.com/2020/05/06/memory/">The Jenkins Comic</a></em></p>
<h2 id="讨论">讨论</h2>
<p>在这里讨论这篇文章</p>
<ul>
<li><a href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
<li><a href="https://www.reddit.com/r/learnrust/comments/ml9shl/tour_of_rusts_standard_library_traits/">learnrust subreddit</a></li>
<li><a href="https://users.rust-lang.org/t/blog-post-tour-of-rusts-standard-library-traits/57974">official Rust users forum</a></li>
<li><a href="https://twitter.com/pretzelhammer/status/1379561720176336902">Twitter</a></li>
<li><a href="https://lobste.rs/s/g27ezp/tour_rust_s_standard_library_traits">lobste.rs</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/mmrao0/tour_of_rusts_standard_library_traits/">rust subreddit</a></li>
</ul>
<h2 id="通知">通知</h2>
<p>当下一篇博文发布时，会收到通知</p>
<ul>
<li><a href="https://twitter.com/pretzelhammer">Following pretzelhammer on Twitter</a> or</li>
<li>Watching this repo&rsquo;s releases (click <code>Watch</code> -&gt; click <code>Custom</code> -&gt; select <code>Releases</code> -&gt; click <code>Apply</code>)</li>
</ul>
<h2 id="更多阅读">更多阅读</h2>
<ul>
<li><a href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/">Sizedness in Rust</a></li>
<li><a href="./common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a></li>
<li><a href="./learning-rust-in-2020.md">Learning Rust in 2020</a></li>
<li><a href="./too-many-brainfuck-compilers.md">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Kafka 和 Rust入门 - 第一部分]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-14-getting-started-with-kafka-and-rust-part1/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-14-a-beginner-guide-to-handling-errors-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Rust 中处理错误的初级指南" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Sizedness in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-14-getting-started-with-kafka-and-rust-part1/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-14T00:00:00+08:00</published>
            <updated>2021-04-14T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Getting Started With Kafka and Rust</blockquote><p>这是一个两部分的系列，帮助你开始使用 Rust 和 Kafka。我们将使用 <a href="https://github.com/fede1024/rust-rdkafka/">rust-rdkafka</a> crate，它本身就是基于 <a href="https://github.com/edenhill/librdkafka">librdkafka</a>（C库）的。</p>
<p>在这篇文章中，我们将介绍 Kafka Producer API。</p>
<h2 id="初始设置">初始设置</h2>
<p>确保你<a href="https://kafka.apache.org/downloads">安装了一个 Kafka broker</a> - 本地设置应该足够了。当然，你也需要<a href="https://www.rust-lang.org/tools/install">安装Rust</a> - 你需要<a href="https://github.com/fede1024/rust-rdkafka#minimum-supported-rust-version-msrv">1.45或以上版本</a>。</p>
<p>在你开始之前，先克隆 GitHub repo。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git clone https://github.com/abhirockzz/rust-kafka-101
<span class="nb">cd</span> part1
</code></pre></div><p>检查 Cargo.toml 文件:</p>
<pre><code>...
[dependencies]
rdkafka = { version = &quot;0.25&quot;, features = [&quot;cmake-build&quot;,&quot;ssl&quot;] }
...
</code></pre><h2 id="关于-cmake-build-功能的说明">关于 cmake-build 功能的说明</h2>
<p><code>rust-rdkafka</code> 提供了几种解决 <code>librdkafka</code> 依赖关系的方法。我选择了 <code>static</code> 链接，其中 <code>librdkafka</code> 被编译。不过你也可以选择 <code>dynamic</code> 链接来引用本地安装的版本。</p>
<blockquote>
<p>更多内容，请<a href="https://github.com/fede1024/rust-rdkafka/blob/master/rdkafka-sys/README.md#features">参考以下链接</a></p>
</blockquote>
<p>好吧，我们先从基本的开始说起。</p>
<h2 id="简单的生产者">简单的生产者</h2>
<p>这里是一个基于 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseProducer.html">BaseProducer</a> 的简单生产者。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">producer</span>: <span class="nc">BaseProducer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ClientConfig</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;bootstrap.servers&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;localhost:9092&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;security.protocol&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;SASL_SSL&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;sasl.mechanisms&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;PLAIN&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;sasl.username&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;&lt;update&gt;&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#34;sasl.password&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;&lt;update&gt;&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">create</span><span class="p">()</span><span class="w">
</span><span class="w">        </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;invalid producer config&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p><code>send</code> 方法开始产生消息 - 它是在紧缩 <code>loop</code> 中完成的，中间有一个 <code>thread::sleep</code>(不是在生产中会做的事情)，以使其更容易追踪/跟踪结果。键、值（有效载荷）和目标 Kafka 主题以 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseRecord.html">BaseRecord</a> 的形式表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;sending message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">producer</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">BaseRecord</span>::<span class="n">to</span><span class="p">(</span><span class="s">&#34;rust&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;key-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;value-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)),</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to send message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><blockquote>
<p>你可以在文件 <code>src/1_producer_simple.rs</code> 中查看整个代码。</p>
</blockquote>
<h2 id="要测试生产者是否在工作-">要测试生产者是否在工作 &hellip;</h2>
<p>运行这段代码:</p>
<ul>
<li>只需将文件 <code>src/1_producer_simple.rs</code> 重命名为 <code>main.rs</code>。</li>
<li>执行 <code>cargo run</code></li>
</ul>
<p>你应该看到这个输出:</p>
<pre><code>sending message
sending message
sending message
...
</code></pre><p>到底发生了什么？要弄清楚 - 使用 Kafka CLI 消费者（或其他消费者客户端，如 kafkacat）连接到你的 Kafka 主题（我在上面的例子中使用 rust 作为 Kafka 主题的名称）。你应该看到消息流进来了。</p>
<p>例如</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="p">&amp;</span>KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning
</code></pre></div><h2 id="生产者回调">生产者回调</h2>
<p>我们现在是在瞎飞! 除非我们明确地创建一个消费者来查看我们的消息，否则我们不知道它们是否被发送到 Kafka。让我们通过实现 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/trait.ProducerContext.html">ProducerContext</a>(trait)来解决这个问题，以挂接到 produce 事件 - 它就像一个回调。</p>
<p>首先为 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/client/trait.ClientContext.html">ClientContext</a> trait 创建一个结构体和一个空的实现（这是必须的）。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">ProducerCallbackLogger</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">ClientContext</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ProducerCallbackLogger</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>现在到了主要部分，我们在 <code>ProducerContext</code> trait 中实现 <code>delivery</code> 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">ProducerContext</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ProduceCallbackLogger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nc">DeliveryOpaque</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">delivery</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">delivery_result</span>: <span class="kp">&amp;</span><span class="nc">rdkafka</span>::<span class="n">producer</span>::<span class="n">DeliveryResult</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_delivery_opaque</span>: <span class="nc">Self</span>::<span class="n">DeliveryOpaque</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">dr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delivery_result</span><span class="p">.</span><span class="n">as_ref</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">dr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">key_view</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;produced message with key {} in offset {} of partition {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">key</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">msg</span><span class="p">.</span><span class="n">offset</span><span class="p">(),</span><span class="w">
</span><span class="w">                    </span><span class="n">msg</span><span class="p">.</span><span class="n">partition</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">producer_err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="n">producer_err</span><span class="p">.</span><span class="mf">1.</span><span class="n">key_view</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;failed to produce message with key {} - {}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">producer_err</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们根据 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/type.DeliveryResult.html">DeliveryResult</a>(毕竟它是一个 <code>Result</code>)来匹配成功(<code>Ok</code>)和失败(<code>Err</code>)的情况。我们所做的只是简单地记录这两种情况下的消息，因为这只是一个例子。你可以在这里做任何你想做的事情（虽然不要太疯狂！）。</p>
<blockquote>
<p>我们忽略了 <code>ProducerContext</code> trait 的关联类型 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/trait.ProducerContext.html#associatedtype.DeliveryOpaque">DeliveryOpaque</a>。</p>
</blockquote>
<p>我们需要确保我们插入了 <code>ProducerContext</code> 的实现。我们通过使用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/config/struct.ClientConfig.html#method.create_with_context">create_with_context</a> 方法（而不是 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/config/struct.ClientConfig.html#method.create">create</a>）来实现，并确保为 <code>BaseProducer</code> 提供正确的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">producer</span>: <span class="nc">BaseProducer</span><span class="o">&lt;</span><span class="n">ProduceCallbackLogger</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ClientConfig</span>::<span class="n">new</span><span class="p">().</span><span class="n">set</span><span class="p">(....)</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">.</span><span class="n">create_with_context</span><span class="p">(</span><span class="n">ProduceCallbackLogger</span><span class="w"> </span><span class="p">{})</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span></code></pre></div><h2 id="如何调用-回调">如何调用 &ldquo;回调&rdquo;？</h2>
<p>好了，我们有了实现，但我们需要一种方法来触发它! 其中一个方法就是在生产者上调用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.BaseProducer.html#method.flush">flush</a>。所以，我们可以把我们的 producer 写成这样。</p>
<ul>
<li>添加 <code>producer.flush(Duration::from_secs(3));</code>, 并</li>
<li>注释掉 <code>sleep</code> (just for now)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">        </span><span class="n">producer</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">BaseRecord</span>::<span class="n">to</span><span class="p">(</span><span class="s">&#34;rust&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;key-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;value-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)),</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to send message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">producer</span><span class="p">.</span><span class="n">flush</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;flushed message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="c1">//thread::sleep(Duration::from_secs(3));
</span></code></pre></div><h2 id="等等我们可以做得更好">等等，我们可以做得更好</h2>
<p><code>send</code> 方法是非阻塞的（默认），但通过在每次 <code>send</code> 后调用 <code>flush</code>，我们现在已经将其转换为同步调用 - 从性能角度来看，不推荐使用。</p>
<p>我们可以通过使用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/struct.ThreadedProducer.html">ThreadedProducer</a> 来改善这种情况。它负责在后台线程中调用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/producer/base_producer/struct.BaseProducer.html#method.poll">poll</a> 方法，以确保发送回调通知的传递。这样做非常简单 - 只需将类型从 <code>BaseProducer</code> 改为 <code>ThreadedProducer</code> 即可!</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="err">#</span><span class="w"> </span><span class="n">before</span>: <span class="nc">BaseProducer</span><span class="o">&lt;</span><span class="n">ProduceCallbackLogger</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="err">#</span><span class="w"> </span><span class="n">after</span>: <span class="nc">ThreadedProducer</span><span class="o">&lt;</span><span class="n">ProduceCallbackLogger</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>而且，我们也不需要再调用 <code>flush</code> 了。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="c1">//producer.flush(Duration::from_secs(3));
</span><span class="c1">//println!(&#34;flushed message&#34;);
</span><span class="c1"></span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span></code></pre></div><blockquote>
<p>代码在 <code>src/2_threaded_producer.rs</code> 中可以找到。</p>
</blockquote>
<h2 id="再次运行该程序">再次运行该程序</h2>
<ul>
<li>将文件 <code>src/2_threaded_producer.rs</code> 重命名为 <code>main.rs</code>，并且</li>
<li>执行 <code>cargo run</code></li>
</ul>
<p>输出:</p>
<pre><code>sending message
sending message
produced message with key key-1 in offset 6 of partition 2
produced message with key key-2 in offset 3 of partition 0
sending message
produced message with key key-3 in offset 7 of partition 2
</code></pre><p>正如预期的那样，你应该能够看到生产者事件回调，表示消息确实被发送到了 Kafka 主题。当然，你可以直接连接到主题，并再次检查，就像之前一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="p">&amp;</span>KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning
</code></pre></div><blockquote>
<p>要尝试失败的情况，请尝试使用一个不正确的主题名称，并注意 <code>delivery</code> 实现的 <code>Err</code> 变体是如何被调用的。</p>
</blockquote>
<h2 id="发送-json-消息">发送 JSON 消息</h2>
<p>到目前为止，我们只是发送 <code>String</code> 作为 key 和 value。JSON 是一种常用的消息格式，让我们看看如何使用它。</p>
<p>假设我们要发送 <code>User</code> 信息，将使用这个结构体来表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">id</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然后我们可以使用 <a href="https://docs.serde.rs/serde_json/">serde_json</a> 库将其序列化为 JSON。我们所需要的就是使用 <a href="https://serde.rs/derive.html">serde 中的自定义派生函数</a> - <code>Deserialize</code> 和 <code>Serialize</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">serde</span>::<span class="p">{</span><span class="n">Deserialize</span><span class="p">,</span><span class="w"> </span><span class="n">Serialize</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Serialize, Deserialize, Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">id</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="修改生产者循环">修改生产者循环。</h2>
<ul>
<li>创建一个 <code>User</code> 实例</li>
<li>使用 <a href="https://docs.serde.rs/serde_json/fn.to_string_pretty.html">to_string_pretty</a> 将其序列化为 JSON 字符串。</li>
<li>在有效载荷中加入这一点</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="p">...</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">user_json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">to_string_pretty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;json serialization failed&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">producer</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="w">
</span><span class="w">                </span><span class="n">BaseRecord</span>::<span class="n">to</span><span class="p">(</span><span class="s">&#34;rust&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;user-{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">payload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_json</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;failed to send message&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span></code></pre></div><blockquote>
<p>你也可以使用 <a href="https://docs.serde.rs/serde_json/fn.to_vec.html">to_vec</a>(而不是 <code>to_string()</code>)将其转换为一个字节的<code>Vec</code>(<code>Vec&lt;u8&gt;</code>)。</p>
</blockquote>
<h2 id="要运行该程序">要运行该程序&hellip;</h2>
<ul>
<li>将文件 <code>src/3_JSON_payload.rs</code> 重命名为 <code>main.rs</code>，然后</li>
<li>执行 <code>cargo run</code></li>
</ul>
<p>从主题中消费:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="p">&amp;</span>KAFKA_HOME/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic rust --from-beginning
</code></pre></div><p>你应该看到带有 <code>String</code> 的键（如 <code>user-34</code>）和 JSON 值的消息。</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span>
  <span class="nt">&#34;email&#34;</span><span class="p">:</span> <span class="s2">&#34;user-34@foobar.com&#34;</span>
<span class="p">}</span>
</code></pre></div><h2 id="有更好的方法吗">有更好的方法吗？</h2>
<p>是的！如果你习惯了 Kafka Java 客户端中的声明式序列化/去序列化方法（可能其他客户端也一样），你可能不喜欢这种 &ldquo;显式&rdquo; 方法。只是为了让大家明白，这是你在 Java 中的做法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">BOOTSTRAP_SERVERS_CONFIG</span><span class="o">,</span> <span class="s">&#34;localhost:9092&#34;</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">KEY_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span>
  <span class="s">&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ProducerConfig</span><span class="o">.</span><span class="na">VALUE_SERIALIZER_CLASS_CONFIG</span><span class="o">,</span>
  <span class="s">&#34;io.confluent.kafka.serializers.json.KafkaJsonSchemaSerializer&#34;</span><span class="o">);</span>

<span class="o">....</span>

<span class="n">ProducerRecord</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">User</span><span class="o">&gt;</span> <span class="n">record</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProducerRecord</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">User</span><span class="o">&gt;(</span><span class="n">topic</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">user</span><span class="o">);</span>
<span class="n">producer</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>
</code></pre></div><blockquote>
<p>请注意，您只需将 <code>Producer</code> 配置为使用 <code>KafkaJsonSchemaSerializer</code>，<code>User</code> 类就会被序列化为 JSON。</p>
</blockquote>
<p><code>rust-rdkafka</code> 用 <a href="https://docs.rs/rdkafka/0.26.0/rdkafka/message/trait.ToBytes.html">ToBytes</a> trait 提供了类似的东西。下面是它的样子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">ToBytes</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// Converts the provided data to bytes.
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不言而喻吧？<code>String</code>、<code>Vec&lt;u8&gt;</code> 等都有现有的实现。所以你可以使用这些类型作为键或值，而不需要任何额外的工作 - 这正是我们刚刚做的。但问题是我们的方法是 &ldquo;显式&rdquo; 的，即我们将 <code>User</code> 结构转换为 JSON 字符串，并将其传递出去。</p>
<h2 id="如果我们可以为-user-实现-tobytes-呢">如果我们可以为 <code>User</code> 实现 <code>ToBytes</code> 呢？</h2>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">ToBytes</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">User</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">to_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">to_vec_pretty</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;json serialization failed&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">as_slice</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>你会看到一个编译器错误。</p>
<pre><code>cannot return value referencing local variable `b`
returns a value referencing data owned by the current function
</code></pre><blockquote>
<p>更多的背景资料，请参考 <a href="https://github.com/fede1024/rust-rdkafka/issues/128">GitHub</a> 的问题。我很乐意看到其他可以与 <code>ToBytes</code> 一起工作的例子 - 如果你有这方面的意见，请在留言中留下。</p>
</blockquote>
<p>TL;DR是，最好坚持用 &ldquo;显式&rdquo; 的方式做事，除非你有一个 <code>ToBytes</code> 的实现，&ldquo;不涉及分配，不能失败&rdquo;。</p>
<h2 id="总结">总结</h2>
<p>第一部分就到这里。第二部分将涉及围绕 Kafka 消费者的话题。</p>
<p>原文链接: <a href="https://dev.to/abhirockzz/getting-started-with-kafka-and-rust-part-1-4hkb">https://dev.to/abhirockzz/getting-started-with-kafka-and-rust-part-1-4hkb</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                             
                                <category scheme="https://ohmyweekly.github.io/categories/kafka" term="kafka" label="kafka" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Rust 中处理错误的初级指南]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-14-a-beginner-guide-to-handling-errors-in-rust/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-14-getting-started-with-kafka-and-rust-part1/?utm_source=atom_feed" rel="related" type="text/html" title="Kafka 和 Rust入门 - 第一部分" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Sizedness in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-14-a-beginner-guide-to-handling-errors-in-rust/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-14T00:00:00+08:00</published>
            <updated>2021-04-14T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>A Beginner&rsquo;s Guide to Handling Errors in Rust</blockquote><p>《Rust 编程语言》中的示例项目对于向新的潜在 Rustaceans 介绍 Rust 的不同方面和特性是非常好的。在这篇文章中，我们将通过扩展《Rust 编程语言》中的 <code>minigrep</code> 项目，看看实现更强大的错误处理基础架构的一些不同方法。</p>
<p><code>minigrep</code> 项目在<a href="https://doc.rust-lang.org/book/ch12-00-an-io-project.html">第12章</a>中介绍，它引导读者构建一个简单版本的 <code>grep</code> 命令行工具，这是一个用于搜索文本的工具。例如，你会传入一个查询，你要搜索的文本，以及文本所在的文件名，然后得到包含查询文本的所有行。</p>
<p>这篇文章的目标是用更强大的错误处理模式来扩展本书的 <code>minigrep</code> 实现，这样你就能更好地了解 Rust 项目中处理错误的不同方法。</p>
<p>作为参考，你可以在<a href="https://github.com/seanchen1991/error-handling-examples/tree/minigrep-control/examples/minigrep">这里</a>找到本书的 <code>minigrep</code> 版本的最终代码。</p>
<h2 id="错误处理用例">错误处理用例</h2>
<p>当涉及到 Rust 项目的结构时，一个常见的模式是有一个 &ldquo;库&rdquo; 的部分和一个 &ldquo;应用&rdquo; 的部分，前者是主要的数据结构、函数和逻辑，后者是将库函数联系在一起。</p>
<p>你可以在原始 <code>minigrep</code> 代码的文件结构中看到这一点：应用逻辑存在于 <code>src/bin/main.rs</code> 文件中，它只是一个薄薄的包裹，包裹着在 <code>src/lib.rs</code> 文件中定义的数据结构和函数；主函数所做的就是调用 <code>minigrep::run</code>。</p>
<p>这一点很重要，因为取决于我们是在构建一个应用程序还是一个库，会改变我们处理错误的方式。</p>
<p>当涉及到一个应用程序时，最终用户很可能不想知道是什么原因导致了一个错误的琐碎细节。事实上，应用程序的最终用户可能只应该在错误无法恢复的情况下被通知错误。在这种情况下，提供关于为什么发生不可恢复的错误的细节也是有用的，特别是当它与用户输入有关时。如果某种可恢复的错误发生在后台，应用程序的消费者可能不需要知道它。</p>
<p>相反，当涉及到一个库时，最终用户是其他开发人员，他们正在使用该库并在其之上构建一些东西。在这种情况下，我们希望尽可能多地提供关于我们的库中发生的任何错误的相关细节。然后，库的消费者将决定他们想要如何处理这些错误。</p>
<p>那么，当我们的项目中既有库部分又有应用部分时，这两种方法是如何一起发挥作用的呢？<code>main</code> 函数执行 <code>minigrep::run</code> 函数，并输出结果中出现的任何错误。所以我们大部分的错误处理工作将集中在库部分。</p>
<h2 id="浮现库错误">浮现库错误</h2>
<p>在 <code>src/lib.rs</code> 中，我们有两个函数，<code>Config::new</code> 和 <code>run</code>，它们可能会返回错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">args</span>: <span class="nc">env</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">case_sensitive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span>::<span class="n">var</span><span class="p">(</span><span class="s">&#34;CASE_INSENSITIVE&#34;</span><span class="p">).</span><span class="n">is_err</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Config</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">query</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">filename</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">case_sensitive</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">})</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">case_sensitive</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">search</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">search_case_insensitive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">.</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">contents</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>确切有三个地方在返回错误：两个错误发生在 <code>Config::new</code> 函数中，该函数返回一个 <code>Result&lt;Config，&amp;'static str&gt;</code>。在这种情况下，<code>Result</code> 的错误变体是一个静态字符串切片。</p>
<p>在这里，当用户没有提供查询时，我们会返回一个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p>这里，当用户没有提供文件名时，我们会返回一个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p>以这种方式将错误结构化为静态字符串的主要问题是，错误信息并没有被放置在一个中心位置，如果需要的话，我们可以轻松地重构它们。这也使得我们更难在相同类型的错误之间保持错误信息的一致性。</p>
<p>第三种错误发生在 <code>run</code> 函数的顶部，它返回一个 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。在这种情况下，错误变体是一个实现  <code>Error</code> <a href="https://doc.rust-lang.org/std/error/trait.Error.html">trait</a> 的 trait 对象。换句话说，这个函数的错误变体是实现 <code>Error</code> trait 的类型的任何实例。</p>
<p>在这里，我们将调用 <code>fs::read_to_string</code> 时可能发生的任何错误冒出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">read_to_string</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">filename</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>这适用于调用 <code>fs::read_to_string</code> 时可能出现的错误，因为这个函数能够返回多种类型的错误。因此，我们需要一种方法来表示这些不同的可能的错误类型；它们之间的共同点是它们都实现了 <code>Error</code> trait！最终，我们要做的是定义所有这些错误类型。</p>
<p>最终，我们要做的是在一个中心位置定义所有这些不同类型的错误，并让它们都成为单一类型的变体。</p>
<h2 id="在一个中心类型中定义错误变种">在一个中心类型中定义错误变种</h2>
<p>我们将创建一个新的 <code>src/error.rs</code> 文件，并定义一个枚举 <code>AppError</code>，并在此过程中派生出 <code>Debug</code> trait，以便我们在需要时可以得到一个调试表示。我们将为这个枚举的每一个变体命名，使它们恰当地代表三种类型的错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">MissingQuery</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">MissingFilename</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ConfigLoad</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>第三个变体，<code>ConfigLoad</code>，映射到 <code>Config::run</code> 函数中调用 <code>fs::read_to_string</code> 时可能出现的错误。乍一看，这似乎有点不妥，因为如果该函数出现错误，那就是在读取提供的配置文件时出现了某种I/O问题。那么我们为什么不把它命名为 <code>IOError</code> 或者类似的东西呢？</p>
<p>在这种情况下，由于我们是将一个标准库函数的错误浮出水面，所以描述浮出水面的错误是如何影响它的，而不是简单地重申它，这与我们的应用更相关。当 <code>fs::read_to_string</code> 发生错误时，会阻止我们的 <code>Config</code> 加载，所以这就是为什么我们把它命名为 <code>ConfigLoad</code>。</p>
<p>现在我们有了这个类型，我们需要更新代码中所有返回错误的地方以利用这个 <code>AppError</code> 枚举。</p>
<h2 id="返回-apperror-的变体">返回 <code>AppError</code> 的变体</h2>
<p>在我们的 <code>src/lib.rs</code> 文件的顶部，我们需要声明我们的错误模块，并将 <code>error::AppError</code> 带入作用域。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">mod</span> <span class="nn">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">error</span>::<span class="n">AppError</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>在我们的 <code>Config::new</code> 函数中，我们需要更新我们作为错误返回静态字符串切片的地方，以及函数本身的返回类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">-</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">args</span>: <span class="nc">env</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">args</span>: <span class="nc">env</span>::<span class="n">Args</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="n">AppError</span><span class="o">&gt;</span><span class="w">
</span><span class="w">    </span><span class="c1">// --snip--
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">AppError</span>::<span class="n">MissingQuery</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">AppError</span>::<span class="n">MissingFilename</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// --snip--
</span></code></pre></div><p>运行函数中的第三个错误，只需要我们更新它的返回类型，因为 <code>?</code> 操作符已经负责将错误冒出来，并在发生时返回。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">-</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="n">config</span>: <span class="nc">Config</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">AppError</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>好了，现在我们正在使用我们的错误变体，一旦发生，这些错误变体将被浮现到我们的 <code>main</code> 函数中并打印出来。但是我们不再有之前定义的实际错误信息了！我们可以用 <code>thiserror</code> 注释错误变体。</p>
<h2 id="用-thiserror-注释错误变体">用 <code>thiserror</code> 注释错误变体</h2>
<p><code>thiserror</code> <a href="https://docs.rs/thiserror/1.0.24/thiserror/">crate</a> 是一个常用的工具，它提供了一种符合人体工程学的方式来格式化 Rust 库中的错误信息。</p>
<p>它允许我们在 <code>AppError</code> 枚举中用我们希望显示给最终用户的实际错误信息来注解每个变体。</p>
<p>让我们在 Cargo.toml 中添加它作为依赖。</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
<span class="nx">thiserror</span> <span class="p">=</span> <span class="s2">&#34;1&#34;</span>
</code></pre></div><p>在 <code>src/error.rs</code> 中，我们将把 <code>thiserror::Error</code> trait 带入作用域，并让我们的 <code>AppError</code> 类型派生它。我们需要派生这个 trait，以便用 <code>#[error]</code> 块来注解每个枚举变量。现在我们指定我们希望为每个特定变量显示的错误信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">+</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">thiserror</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w"> </span><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="cp">#[derive(Debug, Error)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingQuery</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingFilename</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Could not load config&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="cp">#[from]</span><span class="w"> 
</span><span class="w"></span><span class="o">+</span><span class="w">       </span><span class="n">source</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w">   </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>ConfigLoad</code> 变体中增加了什么额外的东西？由于 <code>ConfigLoad</code> 错误只有在调用 <code>fs::read_to_string</code> 出现底层错误时才会发生，所以 <code>ConfigLoad</code> 变体实际上做的是围绕底层I/O错误提供额外的上下文。</p>
<p><code>thiserror</code> 允许我们通过用 <code>#[from]</code> 来注解一个低级错误，以将源码转换为我们自制的错误类型，从而将其包裹在额外的上下文中。这样一来，当一个I/O错误发生时（比如我们指定了一个要搜索的文件，但实际上并不存在），我们就会得到这样一个错误。</p>
<pre><code>Could not load config: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre><p>如果没有它，产生的错误信息看起来像这样。</p>
<pre><code>Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre><p>对于我们库的消费者来说，要想找出这个错误的来源是比较困难的，额外的上下文帮助很大。</p>
<p>你可以在<a href="https://github.com/seanchen1991/error-handling-examples/tree/minigrep-thiserror/examples/minigrep">这里</a>找到使用这个错误的 <code>minigrep</code> 版本。</p>
<h2 id="更加手动的方法">更加手动的方法</h2>
<p>现在，我们将换个角度，看看如何在不将其作为依赖的情况下，实现与 <code>thiserror</code> 相同的结果。</p>
<p>在引擎盖下，<code>thiserror</code> 用程序宏执行了一些魔法，这对编译速度有明显的影响。在 <code>minigrep</code> 的情况下，我们的错误变体很少，而且项目也很小，所以依赖 <code>thiserror</code> 并不会增加多少编译时间，但是在一个更大更复杂的项目中，这可能是一个考虑因素。</p>
<p>所以在这一点上，我们将把这篇文章撕掉，换成我们自己的手动实现来结束这篇文章。走这条路的好处是，我们只需要修改 <code>src/error.rs</code> 文件就可以实现所有必要的改变（当然，除了从我们的 Cargo.toml 中删除 thiserror 之外）。</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
<span class="err">-</span> <span class="nx">thiserror</span> <span class="p">=</span> <span class="s2">&#34;1&#34;</span>
</code></pre></div><p>让我们删除所有 <code>thiserror</code> 提供给我们的注释。我们还将用 <code>std::error::Error</code> trait 替换 <code>thiserror::Error</code> trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="o">-</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">thiserror</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span>::<span class="n">Error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w"> </span><span class="cp">#[derive(Debug, Error)]</span><span class="w">
</span><span class="w"></span><span class="o">+</span><span class="w"> </span><span class="cp">#[derive(Error)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingQuery</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">MissingFilename</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">   </span><span class="cp">#[error(</span><span class="s">&#34;Could not load config&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w">    </span><span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w"></span><span class="o">-</span><span class="w">      </span><span class="cp">#[from]</span><span class="w">
</span><span class="w">       </span><span class="n">source</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>为了恢复我们刚刚擦除的所有功能，我们需要做三件事。</p>
<ol>
<li>为 <code>AppError</code> 实现 <code>Display</code> trait，这样我们的错误变体就可以显示给用户了。</li>
<li>为 <code>AppError</code> 实现 <code>Error</code> trait。这个 trait 代表了对错误类型的基本期望，即它们实现了 <code>Display</code> 和 <code>Debug</code>，再加上获取错误底层源或原因的能力。</li>
<li>为 <code>AppError</code> 实现 <code>From&lt;io::Error&gt;</code>。这是必要的，这样我们就可以将从 <code>fs::read_to_string</code> 返回的I/O错误转换为 <code>AppError</code> 的实例。</li>
</ol>
<p>这里是我们对 <code>AppError</code> 的 <code>Display</code> trait 的实现。它将每个错误变量映射为一个字符串，并将其写入到 <code>Display</code>  formatter 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">MissingQuery</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a query string&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">MissingFilename</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">write_str</span><span class="p">(</span><span class="s">&#34;Didn&#39;t get a file name&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Could not load config: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>而这就是我们对 <code>Error</code> trait 的实现。要实现的主要方法是 <code>Error::source</code> 方法，它的目的是提供错误源的信息。对于我们的 <code>AppError</code> 类型，只有 <code>ConfigLoad</code> 会暴露任何底层源信息，即调用 <code>fs::read_to_string</code> 可能发生的I/O错误。在其他错误变体的情况下，没有底层的源信息需要暴露。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">error</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">Self</span>::<span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">source</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>返回类型的 <code>&amp;(dyn Error + 'static')</code> 部分类似于我们之前看到的 <code>Box&lt;dyn Error&gt;</code> trait 对象。这里的主要区别是，trait 对象是在一个不可变的引用后面，而不是 <code>Box</code> 指针。这里的 <code>'static</code> lifetime 意味着 trait 对象本身只包含拥有的值，也就是说，它内部不存储任何引用。这是必要的，以便让编译器确信这里没有悬空指针的机会。</p>
<p>最后，我们需要一种将 <code>io::Error</code> 转换为 <code>AppError</code> 的方法。我们将通过为 <code>AppError for From&lt;io::error&gt;</code> 来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AppError</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">source</span>: <span class="nc">io</span>::<span class="n">Error</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Self</span>::<span class="n">ConfigLoad</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个没什么好说的。如果我们得到一个 <code>io::Error</code>，我们要做的就是将其转换为 <code>AppError</code>，并将其封装在 <code>ConfigLoad</code> 变体中。</p>
<p>这就是全部了，伙计们 你可以在<a href="https://github.com/seanchen1991/error-handling-examples/tree/main/examples/minigrep">这里</a>找到这个版本的 <code>minigrep</code> 实现。</p>
<h2 id="总结">总结</h2>
<p>最后，我们讨论了《Rust编程语言》一书中介绍的原始 <code>minigrep</code> 实现在错误处理方面是如何有点欠缺的，以及如何考虑不同的错误处理用例。</p>
<p>从那里，我们展示了如何使用 <code>thiserror</code> crate 将所有可能的错误变体集中到一个类型中。</p>
<p>最后，我们剥开了 <code>thiserror</code> 提供的外衣，展示了如何手动复制同样的功能。</p>
<p>希望大家能从这篇文章中学到一些东西!</p>
<p>原文链接: <a href="https://dev.to/seanchen1991/a-beginner-s-guide-to-handling-errors-in-rust-40k2">https://dev.to/seanchen1991/a-beginner-s-guide-to-handling-errors-in-rust-40k2</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                             
                                <category scheme="https://ohmyweekly.github.io/categories/error" term="error" label="error" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Sizedness in Rust]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-11-sizedness-in-rust/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-11T00:00:00+08:00</published>
            <updated>2021-04-11T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Sizedness in Rust</blockquote><h1 id="sizedness-in-rust">Sizedness in Rust</h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#sizedness">Sizedness</a></li>
<li><a href="#sized-trait"><code>Sized</code> Trait</a></li>
<li><a href="#sized-in-generics"><code>Sized</code> in Generics</a></li>
<li><a href="#unsized-types">Unsized Types</a>
<ul>
<li><a href="#slices">Slices</a></li>
<li><a href="#trait-objects">Trait Objects</a></li>
<li><a href="#trait-object-limitations">Trait Object Limitations</a>
<ul>
<li><a href="#cannot-cast-unsized-types-to-trait-objects">Cannot Cast Unsized Types to Trait Objects</a></li>
<li><a href="#cannot-create-multi-trait-objects">Cannot create Multi-Trait Objects</a></li>
</ul>
</li>
<li><a href="#user-defined-unsized-types">User-Defined Unsized Types</a></li>
</ul>
</li>
<li><a href="#zero-sized-types">Zero-Sized Types</a>
<ul>
<li><a href="#unit-type">Unit Type</a></li>
<li><a href="#user-defined-unit-structs">User-Defined Unit Structs</a></li>
<li><a href="#never-type">Never Type</a></li>
<li><a href="#user-defined-pseudo-never-types">User-Defined Pseudo Never Types</a></li>
<li><a href="#phantomdata">PhantomData</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#discuss">Discuss</a></li>
<li><a href="#notifications">Notifications</a></li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
<h2 id="intro">Intro</h2>
<p>Sizedness是Rust中最重要的概念之一。它与其他语言特性有很多微妙的交集，只是以_&ldquo;x在编译时不知道大小&rdquo;_错误信息的形式出现，而这些错误信息是每个Rustacean都非常熟悉的。在这篇文章中，我们将探讨从大小类型，到无大小类型，再到零大小类型的各种风味，同时研究它们的用例、好处、痛点和变通方法。</p>
<p>我使用的短语表，以及它们的含义。</p>
<table>
<thead>
<tr>
<th>Phrase</th>
<th>Shorthand for</th>
</tr>
</thead>
<tbody>
<tr>
<td>sizedness</td>
<td>property of being sized or unsized</td>
</tr>
<tr>
<td>sized type</td>
<td>type with a known size at compile time</td>
</tr>
<tr>
<td>1) unsized type <em>or</em><!-- raw HTML omitted -->2) DST</td>
<td>dynamically-sized type, i.e. size not known at compile time</td>
</tr>
<tr>
<td>?sized type</td>
<td>type that may or may not be sized</td>
</tr>
<tr>
<td>unsized coercion</td>
<td>coercing a sized type into an unsized type</td>
</tr>
<tr>
<td>ZST</td>
<td>zero-sized type, i.e. instances of the type are 0 bytes in size</td>
</tr>
<tr>
<td>width</td>
<td>single unit of measurement of pointer width</td>
</tr>
<tr>
<td>1) thin pointer <em>or</em><!-- raw HTML omitted -->2) single-width pointer</td>
<td>pointer that is <em>1 width</em></td>
</tr>
<tr>
<td>1) fat pointer <em>or</em><!-- raw HTML omitted -->2) double-width pointer</td>
<td>pointer that is <em>2 widths</em></td>
</tr>
<tr>
<td>1) pointer <em>or</em><!-- raw HTML omitted -->2) reference</td>
<td>some pointer of some width, width will be clarified by context</td>
</tr>
<tr>
<td>slice</td>
<td>double-width pointer to a dynamically sized view into some array</td>
</tr>
</tbody>
</table>
<h2 id="sizedness">Sizedness</h2>
<p>在 Rust 中，如果在编译时可以确定类型的字节大小，那么就可以确定类型的大小。确定一个类型的大小对于能够在栈上为该类型的实例分配足够的空间是很重要的。固定大小的类型可以通过值或引用来传递。如果一个类型的大小不能在编译时确定，那么它被称为不确定大小类型或 DST，动态大小类型。由于不确定大小类型不能被放置在栈上，它们只能通过引用来传递。下面是一些固定大小类型和不确定大小类型的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// primitives
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// tuples
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// arrays
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// structs
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// enums
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// get pointer width, will be
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 4 bytes wide on 32-bit targets or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 8 bytes wide on 64-bit targets
</span><span class="c1"></span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// pointers to sized types are 1 width
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="k">fn</span><span class="p">(</span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">DOUBLE_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized struct
</span><span class="c1"></span><span class="w">    </span><span class="k">struct</span> <span class="nc">Unsized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">unsized_field</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// pointers to unsized types are 2 widths
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// slice
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// slice
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// trait object
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="o">&gt;&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// trait object
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">Unsized</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// user-defined unsized type
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized types
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">Unsized</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们如何确定固定大小类型的大小是直截了当的：所有原生类型和指针都有已知的大小，所有的结构体、元组、枚举和数组只是由原生类型和指针或其他嵌套的结构体、元组、枚举和数组组成，因此我们只需考虑到填充和对齐所需的额外字节，递归地计数字节即可。我们无法确定不确定大小类型的大小，原因同样简单明了：切片可以有任意数量的元素在其中，因此在运行时可以是任意大小的，trait 对象可以由任意数量的结构或枚举实现，因此在运行时也可以是任意大小的。</p>
<p><strong>专业提示</strong></p>
<ul>
<li>在Rust中，视图到数组中的动态大小的指针被称为切片。例如 <code>&amp;str</code> 是一个&quot;字符串切片&quot;, <code>&amp;[i32]</code> 一个 <em>&ldquo;i32 切片&rdquo;</em>。</li>
<li>切片是双倍宽度的，因为它们存储了一个指向数组的指针和数组中元素的数量。</li>
<li>trait 对象指针是双宽度的，因为它们存储了一个指向数据的指针和一个指向 vtable 的指针。</li>
<li>不确定大小的结构体指针是双倍宽度的，因为它们存储了一个指向结构体数据的指针和结构体的大小。</li>
<li>不确定大小的结构体只能有1个不确定大小的字段，而且必须是结构体中的最后一个字段。</li>
</ul>
<p>为了让大家真正明白关于不确定大小类型的双宽度指针的点，这里有一个比较数组和切片的注释代码示例。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">DOUBLE_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// data length stored in type
</span><span class="c1"></span><span class="w">    </span><span class="c1">// an [i32; 3] is an array of three i32s
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// can iterate over nums safely
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Rust knows it&#39;s exactly 3 elements
</span><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized coercion from [i32; 3] to [i32]
</span><span class="c1"></span><span class="w">    </span><span class="c1">// data length now stored in pointer
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">nums</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// double-width pointer required to also store data length
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// can iterate over nums safely
</span><span class="c1"></span><span class="w">    </span><span class="c1">// Rust knows it&#39;s exactly 3 elements
</span><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">num</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这里还有一个注释的代码例子，比较结构体和 trait 对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">size_of</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">DOUBLE_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct2</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;struct&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;struct2&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">print_struct</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">Struct</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// always prints &#34;struct&#34;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// this is known at compile-time
</span><span class="c1"></span><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">print_struct2</span><span class="p">(</span><span class="n">s2</span>: <span class="kp">&amp;</span><span class="nc">Struct2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// always prints &#34;struct2&#34;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// this is known at compile-time
</span><span class="c1"></span><span class="w">    </span><span class="n">s2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">Struct2</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">print_trait</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// print &#34;struct&#34; or &#34;struct2&#34; ?
</span><span class="c1"></span><span class="w">    </span><span class="c1">// this is unknown at compile-time
</span><span class="c1"></span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// Rust has to check the pointer at run-time
</span><span class="c1"></span><span class="w">    </span><span class="c1">// to figure out whether to use Struct&#39;s
</span><span class="c1"></span><span class="w">    </span><span class="c1">// or Struct2&#39;s implementation of &#34;print&#34;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// so the pointer has to be double-width
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">DOUBLE_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// single-width pointer to data
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w"> 
</span><span class="w">    </span><span class="n">print_struct</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// single-width pointer to data
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_struct2</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct2&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// unsized coercion from Struct to dyn Trait
</span><span class="c1"></span><span class="w">    </span><span class="c1">// double-width pointer to point to data AND Struct&#39;s vtable
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct&#34;
</span><span class="c1"></span><span class="w">    
</span><span class="w">    </span><span class="c1">// unsized coercion from Struct2 to dyn Trait
</span><span class="c1"></span><span class="w">    </span><span class="c1">// double-width pointer to point to data AND Struct2&#39;s vtable
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct2</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// prints &#34;struct2&#34;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>只有固定大小类型的实例才能被放置在栈上，也就是说，可以通过值来传递</li>
<li>不确定大小类型的实例不能放在栈上，必须通过引用来传递</li>
<li>指向不确定大小类型的指针是双宽度的，因为除了指向数据外，它们还需要做额外的记账工作，以跟踪数据的长度或指向一个 vtable</li>
</ul>
<h2 id="sized-trait"><code>Sized</code> Trait</h2>
<p>Rust中的 &ldquo;Sized&rdquo; trait 是一个自动 trait 和一个标记 trait。</p>
<p>自动 trait 是指当一个类型通过某些条件时，自动实现的 trait。标记 trait 是标记一个类型具有特定属性的 trait。标记 trait 没有任何 trait 项，如方法、关联函数、关联常量或关联类型。所有的自动 trait 都是标记 trait，但不是所有的标记 trait 都是自动 trait。自动 trait 必须是标记 trait，所以编译器可以为它们提供一个自动的缺省实现，如果 trait 有任何 trait 项，这是不可能的。</p>
<p>如果一个类型的所有成员也是 &ldquo;确定大小的&rdquo;，那么它就会得到一个自动的 <code>Sized</code> 实现。&ldquo;成员&quot;的含义取决于所包含的类型，例如：结构体的字段、枚举的变体、数组的元素、元组的项等等。一旦一个类型被 &ldquo;标记&rdquo; 了一个 <code>Sized</code> 的实现，这意味着在编译时就知道它的字节大小。</p>
<p>其他自动标记 trait 的例子是 <code>Send</code> 和 <code>Sync</code> trait。如果跨线程发送一个类型是安全的，那么这个类型就是可 <code>Send</code> 的。如果在线程之间共享该类型的引用是安全的，那么该类型就是可 <code>Sync</code> 的。如果一个类型的所有成员都是可 <code>Send</code> 和 <code>Sync</code> 的, 那么这个类型就会得到自动的 <code>Send</code> 和 <code>Sync</code> 实现。<code>Sized</code> 的特殊之处在于它不可能选择退出，不像其他自动标记 trait 可以选择退出。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(negative_impls)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is Sized, Send, and Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Send trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Sync trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Sized</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span></code></pre></div><p>这似乎是合理的，因为我们可能有理由不希望我们的类型被跨线程发送或共享，但是很难想象我们会希望编译器 &ldquo;忘记&rdquo; 我们类型的大小，并将其视为一个不确定大小的类型，因为这不会带来任何好处，只会让类型更难处理。</p>
<p>另外，说得迂腐一点，<code>Sized</code> 在技术上并不是一个自动 trait，因为它没有使用 <code>auto</code> 关键字来定义，但是编译器对它的特殊处理使它的行为与自动 trait 非常相似，所以在实践中，把它看作是一个自动 trait 是可以的。</p>
<p><strong>关键要点</strong></p>
<ul>
<li><code>Sized</code> 是一个自动标记 trait</li>
</ul>
<h2 id="泛型中的-sized">泛型中的 <code>Sized</code></h2>
<p>每当我们编写任何泛型代码时，每一个泛型类型参数都会被默认的 <code>Sized</code> trait 自动绑定，这一点并不明显。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// this generic function...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...desugars to...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// ...which we can opt-out of by explicitly setting ?Sized...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// ...which doesn&#39;t compile since t doesn&#39;t have
</span><span class="c1">// a known size so we must put it behind a pointer...
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">func</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span></code></pre></div><p><strong>专业提示</strong></p>
<ul>
<li><code>?Sized</code> can be pronounced <em>&ldquo;optionally sized&rdquo;</em> or <em>&ldquo;maybe sized&rdquo;</em> and adding it to a type parameter&rsquo;s bounds allows the type to be sized or unsized</li>
<li><code>?Sized</code> in general is referred to as a <em>&ldquo;widening bound&rdquo;</em> or a <em>&ldquo;relaxed bound&rdquo;</em> as it relaxes rather than constrains the type parameter</li>
<li><code>?Sized</code> is the only relaxed bound in Rust</li>
</ul>
<p>So why does this matter? Well, any time we&rsquo;re working with a generic type and that type is behind a pointer we almost always want to opt-out of the default <code>Sized</code> bound to make our function more flexible in what argument types it will accept. Also, if we don&rsquo;t opt-out of the default <code>Sized</code> bound we&rsquo;ll eventually get some surprising and confusing compile error messages.</p>
<p>Let me take you on the journey of the first generic function I ever wrote in Rust. I started learning Rust before the <code>dbg!</code> macro landed in stable so the only way to print debug values was to type out <code>println!(&quot;{:?}&quot;, some_value);</code> every time which is pretty tedious so I decided to write a <code>debug</code> helper function like this:</p>
<ul>
<li><code>?Sized</code> 可以读作 <em>&ldquo;optionally sized&rdquo;</em> 或 <em>&ldquo;maybe sized&rdquo;</em>，将它添加到类型参数的绑定中，可以让类型被确定大小或不确定大小。</li>
<li><code>?Sized</code> 一般被称为 &ldquo;拓宽绑定&rdquo; 或 &ldquo;宽松绑定&rdquo;，因为它放松而不是约束类型参数。</li>
<li><code>?Sized</code> 是 Rust 中唯一的宽松绑定。</li>
</ul>
<p>那么为什么这很重要呢？任何时候，当我们在处理泛型类型，并且该类型在一个指针后面时，我们几乎总是希望选择退出默认的 <code>Sized</code> 绑定，以使我们的函数在接受什么参数类型时更加灵活。另外，如果我们不选择退出默认的 <code>Sized</code> 绑定，我们最终会得到一些令人惊讶和困惑的编译错误信息。</p>
<p>让我带你了解一下我在 Rust 中写的第一个泛型函数的历程。在 <code>dbg!</code> 宏登陆稳定版之前，我就开始学习 Rust 了，所以打印调试值的唯一方法就是每次都要打出 <code>println!(&quot;{:?}&quot;, some_value);</code>，这是很乏味的，所以我决定写一个像这样的调试帮助函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">debug</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// T: Debug + Sized
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">debug</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// T = &amp;str, &amp;str: Debug + Sized ✔️
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>到目前为止还不错，但函数会对传递给它的任何值拥有所有权，这有点烦人，所以我把函数改为只接受引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">dbg</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// T: Debug + Sized
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">dbg</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// &amp;T = &amp;str, T = str, str: Debug + !Sized ❌
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在出现了这个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">8</span>:<span class="mi">9</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dbg</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">        </span><span class="o">-</span><span class="w"> </span><span class="n">required</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">`</span><span class="n">dbg</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">dbg</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">         </span><span class="o">^^^^^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="n">help</span>: <span class="nc">consider</span><span class="w"> </span><span class="n">relaxing</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">implicit</span><span class="w"> </span><span class="err">`</span><span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">restriction</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dbg</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">   
</span></code></pre></div><p>当我第一次看到这个问题时，我发现它令人难以置信的混乱。尽管我的函数对参数的限制比以前更严格，但现在它却莫名其妙地抛出了一个编译错误！这是怎么回事？到底发生了什么？</p>
<p>我已经在上面的代码注释中破坏了答案，但基本上。Rust 在编译过程中把 <code>T</code> 解析为具体类型时，会执行模式匹配。这里有几个表格可以帮助澄清。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>T</code></th>
<th><code>&amp;T</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;str</code></td>
<td><code>T</code> = <code>&amp;str</code></td>
<td><code>T</code> = <code>str</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Type</th>
<th><code>Sized</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>str</code></td>
<td>❌</td>
</tr>
<tr>
<td><code>&amp;str</code></td>
<td>✔️</td>
</tr>
<tr>
<td><code>&amp;&amp;str</code></td>
<td>✔️</td>
</tr>
</tbody>
</table>
<p>这也是为什么我不得不在改成取用引用后，加了一个 <code>?Sized</code> 的绑定，使函数能正常工作。下面是可以工作的函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fmt</span>::<span class="n">Debug</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">debug</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Debug</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// T: Debug + ?Sized
</span><span class="c1"></span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">debug</span><span class="p">(</span><span class="s">&#34;my str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// &amp;T = &amp;str, T = str, str: Debug + !Sized ✔️
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>所有的泛型类型参数默认都是自动绑定 <code>Sized</code>。</li>
<li>如果我们有一个泛型函数，它的参数是指针后面的一些 <code>T</code>，例如 <code>&amp;T</code>、<code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 等，那么我们几乎总是希望用<code>T: ?Sized</code> 来退出默认的 <code>Sized</code> 约束。</li>
</ul>
<h2 id="unsized-类型">Unsized 类型</h2>
<h3 id="切片">切片</h3>
<p>最常见的切片是字符串切片 <code>&amp;str</code> 和数组切片 <code>&amp;[T]</code>。切片的好处是许多其他类型也会对其进行 coerce，所以利用切片和 Rust 的自动类型 coerce，我们可以编写灵活的 API。</p>
<p>类型 coerce 可以发生在几个地方，但最明显的是在函数参数和方法调用时。我们感兴趣的类型 coerce 是 deref coerce 和 unsized coerce。deref coerce 是指当 <code>T</code> 在 deref 操作之后被 coerce 成一个 <code>U</code>，即 <code>T: Deref&lt;Target = U&gt;</code>，例如 <code>String.deref() -&gt; str</code>。不确定大小 coerce 是指 <code>T</code> 被 coerce 成 <code>U</code>，其中 <code>T</code> 是一个确定大小的类型，<code>U</code> 是一个不确定大小的类型，即 <code>T: Unsize&lt;U&gt;</code>，例如 <code>[i32; 3] -&gt; [i32]</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// can now call &#34;method&#34; on
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 1) str or
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 2) String since String: Deref&lt;Target = str&gt;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">T</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// can now call &#34;method&#34; on
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 1) any &amp;[T]
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 2) any U where U: Deref&lt;Target = [T]&gt;, e.g. Vec&lt;T&gt;
</span><span class="c1"></span><span class="w">    </span><span class="c1">// 3) [T; N] for any N, since [T; N]: Unsize&lt;[T]&gt;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">str_fun</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">slice_fun</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">str_slice</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;str slice&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">string</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;string&#34;</span><span class="p">.</span><span class="n">to_owned</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// function args
</span><span class="c1"></span><span class="w">    </span><span class="n">str_fun</span><span class="p">(</span><span class="n">str_slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">str_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">string</span><span class="p">);</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// method calls
</span><span class="c1"></span><span class="w">    </span><span class="n">str_slice</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">string</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">three_array</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">five_array</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// function args
</span><span class="c1"></span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">);</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">three_array</span><span class="p">);</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">slice_fun</span><span class="p">(</span><span class="o">&amp;</span><span class="n">five_array</span><span class="p">);</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="c1">// method calls
</span><span class="c1"></span><span class="w">    </span><span class="n">slice</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// deref coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">three_array</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">five_array</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// unsized coercion
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>利用切片和 Rust 的自动类型强制，我们可以编写灵活的 API。</li>
</ul>
<h3 id="trait-对象">Trait 对象</h3>
<p>Traits 默认是 <code>?Sized</code> 的。这个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>抛出这个错误:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span>: <span class="err">`</span><span class="o">?</span><span class="n">Trait</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">permitted</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">supertraits</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">1</span>:<span class="mi">14</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">              </span><span class="o">^^^^^^</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">traits</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="err">`</span><span class="o">?</span><span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">default</span><span class="w">
</span></code></pre></div><p>我们很快就会讨论为什么 trait 默认为 <code>?Sized</code>，但首先让我们问问自己，一个 trait 被 <code>?Sized</code> 的含义是什么？让我们把上面的例子去掉。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>好的，默认情况下，trait 允许 <code>self</code> 是一个不确定大小的类型。正如我们前面所学，我们不能通过值来传递不确定大小的类型，所以这限制了我们在 trait 中定义方法的种类。应该是不可能写出一个通过取值来获取或返回 <code>self</code> 的方法，然而这令人惊讶的是，它的编译:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>然而，当我们试图实现该方法时，无论是通过提供一个默认的实现，还是通过实现一个不确定大小类型的 trait，我们都会得到编译错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="n">Self</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">2</span>:<span class="mi">15</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">               </span><span class="o">^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="n">Self</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">all</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">statically</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">size</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">unsized</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">gated</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">unstable</span><span class="w"> </span><span class="n">feature</span><span class="w">
</span><span class="w"></span><span class="n">help</span>: <span class="nc">consider</span><span class="w"> </span><span class="n">further</span><span class="w"> </span><span class="n">restricting</span><span class="w"> </span><span class="err">`</span><span class="n">Self</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nc">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                     </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">6</span>:<span class="mi">15</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">6</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">               </span><span class="o">^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">all</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">statically</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">size</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">unsized</span><span class="w"> </span><span class="n">locals</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">gated</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">unstable</span><span class="w"> </span><span class="n">feature</span><span class="w">
</span></code></pre></div><p>如果我们决心通过值来传递 <code>self</code>，我们可以通过显式绑定 trait 与 <code>Sized</code> 来解决第一个错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">7</span>:<span class="mi">6</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">              </span><span class="o">-----</span><span class="w"> </span><span class="n">required</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="mi">7</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">      </span><span class="o">^^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span></code></pre></div><p>这并没有问题，因为我们知道，当我们将 trait 与 <code>Sized</code> 绑定后，我们就不能再为诸如 <code>str</code> 这样的不确定大小类型实现它了。另一方面，如果我们真的想为 <code>str</code> 实现 trait，另一种解决方案是保留 <code>?Sized</code> trait，并通过引用传递 <code>self</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>与其将整个 trait 标记为 <code>?Sized</code> 或 <code>Sized</code>，我们有更细化和精确的选择，将单个方法标记为 <code>Sized</code>，像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles!?
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="s">&#34;str&#34;</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>令人惊讶的是，Rust编译 <code>impl Trait for str {}</code> 时没有任何抱怨，但当我们试图在一个不确定大小的类型上调用 <code>method</code> 时，它最终还是抓到了错误，所以一切正常。这有点怪异，但为我们提供了一些灵活性，只要我们从不调用 <code>Sized</code> 方法，我们就可以用一些 <code>Sized</code> 方法为不确定大小的类型实现 trait。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// we never call &#34;method&#34; so no errors
</span><span class="c1"></span><span class="w">    </span><span class="s">&#34;str&#34;</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>现在回到最初的问题，为什么 trait 默认是 <code>?Sized</code>？答案是 trait 对象。trait 对象本质上是不确定大小的，因为任何大小的类型都可以实现 trait，因此我们只有在 <code>Trait: ?Sized</code> 的情况下，才能为 <code>dyn Trait</code> 实现 <code>Trait</code>。用代码来说：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// the above is REQUIRED for
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// compiler magic here
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// since `dyn Trait` is unsized
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">// and now we can use `dyn Trait` in our program
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compiles
</span></code></pre></div><p>如果我们尝试实际编译上述程序，我们会得到：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0371</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="n">automatically</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">5</span>:<span class="mi">1</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="o">^^^^^^^^^^^^^^^^^^^^^^^^</span><span class="w"> </span><span class="err">`</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="err">`</span><span class="w"> </span><span class="n">automatically</span><span class="w"> </span><span class="n">implements</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span></code></pre></div><p>这就是编译器告诉我们要冷静，因为它自动为 <code>dyn Trait</code> 提供了 <code>Trait</code> 的实现。同样，由于 <code>dyn Trait</code> 是不确定大小的，编译器只能在 <code>Trait: ?Sized</code> 的情况下提供这个实现。如果我们将 <code>Trait</code> 与 <code>Sized</code> 绑定，那么 <code>Trait</code> 就变成了 &ldquo;对象不安全&rdquo; 的了，这意味着我们不能将实现 <code>Trait</code> 的类型转为 <code>dyn Trait</code> 的 trait 对象。正如预期的那样，这个程序不能编译:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="c1">// compile error
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0038</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">3</span>:<span class="mi">18</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">       </span><span class="o">-----</span><span class="w">  </span><span class="o">-----</span><span class="w"> </span><span class="p">...</span><span class="n">because</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">requires</span><span class="w"> </span><span class="err">`</span><span class="n">Self</span>: <span class="nb">Sized</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">       </span><span class="n">this</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> 
</span><span class="w"></span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                </span><span class="o">^^^^^^^^^^</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">made</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">object</span><span class="w">
</span></code></pre></div><p>让我们尝试用 <code>Sized</code> 方法制作一个 <code>?Sized</code> trait，看看能否将它转一个 trait 对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">Self</span>: <span class="nb">Sized</span> <span class="p">{}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">arg</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">arg</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">arg</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>正如我们之前看到的那样，只要我们不调用 trait 对象上的 <code>Sized</code> 方法，一切都没问题。</p>
<p><strong>关键要点</strong></p>
<ul>
<li>所有的 traits 默认都是 <code>?Sized</code> 的。</li>
<li><code>Trait: ?Sized</code> 是 <code>impl Trait for dyn Trait</code> 所必需的。</li>
<li>我们可以在每个方法的基础上要求 <code>Self: Sized</code>。</li>
<li>由 <code>Sized</code> 绑定的 trait 不能成为 trait 对象。</li>
</ul>
<h3 id="trait-对象限制">trait 对象限制</h3>
<p>即使一个 traitt 是对象安全的，也会有一些与大小相关的边缘情况，这些情况限制了哪些类型可以转换为 trait 对象，以及一个 trait 对象可以表示多少个和什么样的 trait。</p>
<h4 id="不能将不确定大小的类型转换为--trait-对象">不能将不确定大小的类型转换为  Trait 对象</h4>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">generic</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">ToString</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">trait_object</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="nb">ToString</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">generic</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;String&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">generic</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">trait_object</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;String&#34;</span><span class="p">));</span><span class="w"> </span><span class="c1">// compiles, unsized coercion
</span><span class="c1"></span><span class="w">    </span><span class="n">trait_object</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error, unsized coercion impossible
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]</span>: <span class="nc">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">time</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">8</span>:<span class="mi">18</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">trait_object</span><span class="p">(</span><span class="s">&#34;str&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">  </span><span class="o">|</span><span class="w">                  </span><span class="o">^^^^^</span><span class="w"> </span><span class="n">doesn</span><span class="na">&#39;t</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">known</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">compile</span><span class="o">-</span><span class="n">time</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">help</span>: <span class="nc">the</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">std</span>::<span class="n">marker</span>::<span class="nb">Sized</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="kt">str</span><span class="err">`</span><span class="w">
</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">to</span><span class="w"> </span><span class="n">learn</span><span class="w"> </span><span class="n">more</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span>:<span class="c1">//doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
</span><span class="c1"></span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">required</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cast</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="n">dyn</span><span class="w"> </span><span class="n">std</span>::<span class="n">string</span>::<span class="nb">ToString</span><span class="err">`</span><span class="w">
</span></code></pre></div><p>为什么将一个 <code>&amp;String</code> 传给一个期望得到 <code>&amp;dyn ToString</code> 的函数，是因为类型胁迫。<code>String</code> 实现了 <code>ToString</code>，我们可以通过不确定大小的胁迫将 <code>String</code> 这样的确定大小的类型转换成 <code>dyn ToString</code> 这样的不确定大小的类型。<code>str</code> 也实现了 <code>ToString</code>，将 <code>str</code> 转换为 <code>dyn ToString</code> 也需要一个不确定大小的胁迫，但 <code>str</code> 已经是不确定大小的了！我们如何将一个已经是不确定大小的类型，变成另一个不确定大小的类型？</p>
<p><code>&amp;str</code> 指针是双宽的，存储一个数据指针和数据长度。<code>&amp;dyn ToString</code> 指针也是双宽度的，存储一个指向数据的指针和一个指向 vtable 的指针。要把一个 <code>&amp;str</code> 胁迫成一个 <code>&amp;dyn toString</code>，就需要一个三倍宽度的指针来存储一个指向数据的指针、数据长度和一个指向 vtable 的指针。Rust 不支持三倍宽度指针，所以不可能将一个不确定大小的类型转换成一个 trait 对象。</p>
<p>前面2段用表格总结了一下。</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Pointer to Data</th>
<th>Data Length</th>
<th>Pointer to VTable</th>
<th>Total Width</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;String</code></td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td>1 ✔️</td>
</tr>
<tr>
<td><code>&amp;str</code></td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>2 ✔️</td>
</tr>
<tr>
<td><code>&amp;String as &amp;dyn ToString</code></td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td>2 ✔️</td>
</tr>
<tr>
<td><code>&amp;str as &amp;dyn ToString</code></td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>3 ❌</td>
</tr>
</tbody>
</table>
<h4 id="不能创建-multi-trait-对象">不能创建 Multi-Trait 对象</h4>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0225</span><span class="p">]</span>: <span class="nc">only</span><span class="w"> </span><span class="n">auto</span><span class="w"> </span><span class="n">traits</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">additional</span><span class="w"> </span><span class="n">traits</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">object</span><span class="w">
</span><span class="w"> </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">lib</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">4</span>:<span class="mi">30</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">-----</span><span class="w">   </span><span class="o">^^^^^^</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">|</span><span class="w">       </span><span class="n">additional</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="o">|</span><span class="w">       </span><span class="k">trait</span><span class="w"> </span><span class="n">alias</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="p">(</span><span class="n">additional</span><span class="w"> </span><span class="k">use</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="n">first</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">auto</span><span class="w"> </span><span class="k">trait</span><span class="w">
</span><span class="w">  </span><span class="o">|</span><span class="w">                      </span><span class="k">trait</span><span class="w"> </span><span class="n">alias</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="k">type</span> <span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="k">use</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>请记住，trait 对象指针是双宽度的：存储1个指向数据的指针和另一个指向 vtable 的指针，但这里有2个trait，所以有2个 vtable，这就需要 <code>&amp;(dyn Trait + Trait2)</code> 指针是3个宽度。像 <code>Send</code> 和 <code>Sync</code> 这样的自动 trait 是允许的，因为它们没有方法，因此没有 vtable。</p>
<p>这方面的变通方法是通过使用另一个 trait 来组合 vtable，比如这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait3</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// auto blanket impl Trait3 for any type that also impls Trait &amp; Trait2
</span><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// from `dyn Trait + Trait2` to `dyn Trait3` 
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">method</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个变通方法的一个缺点是，Rust 不支持 supertrait 向上转换。这意味着，如果我们有一个 <code>dyn Trait3</code>，我们不能在需要 <code>dyn Trait</code> 或 <code>dyn Trait2</code> 的地方使用它。这个程序不能编译。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">method2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait3</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait2</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">takes_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_trait2</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// compile error
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>抛出:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w">
</span><span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">22</span>:<span class="mi">17</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">22</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">takes_trait</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">                 </span><span class="o">^</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">expected</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="err">`</span><span class="w">
</span><span class="w">              </span><span class="n">found</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">error</span><span class="p">[</span><span class="n">E0308</span><span class="p">]</span>: <span class="nc">mismatched</span><span class="w"> </span><span class="n">types</span><span class="w">
</span><span class="w">  </span><span class="o">-</span>-&gt; <span class="nc">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">23</span>:<span class="mi">18</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w"></span><span class="mi">23</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">takes_trait2</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">                  </span><span class="o">^</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait2</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="err">`</span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span><span class="w">   </span><span class="o">|</span><span class="w">
</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">note</span>: <span class="nc">expected</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="err">`</span><span class="w">
</span><span class="w">              </span><span class="n">found</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="err">`</span><span class="o">&amp;</span><span class="n">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="err">`</span><span class="w">
</span></code></pre></div><p>这是因为 <code>dyn Trait3</code> 是一个不同于 <code>dyn Trait</code> 和 <code>dyn Trait</code> 的类型，因为它们有不同的 vtable 布局，尽管  <code>dyn Trait3</code> 确实包含 <code>dyn Trait</code> 和 <code>dyn Trait2</code> 的所有方法。这里的变通办法是增加显式转换方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Trait3</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Trait</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Trait2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">as_trait2</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Trait2</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_trait2</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait2</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Trait3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">takes_trait</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">as_trait</span><span class="p">());</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="w">    </span><span class="n">takes_trait2</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">as_trait2</span><span class="p">());</span><span class="w"> </span><span class="c1">// compiles
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这是一个简单而直接的工作方法，似乎是 Rust 编译器可以为我们自动完成的事情。Rust 并不羞于执行类型胁迫，正如我们在 deref 和 unsized 胁迫中所看到的那样，那么为什么没有 trait 向上胁迫呢？这是一个很好的问题，有一个熟悉的答案：Rust核心团队正在研究其他更高优先级和更高影响的功能。很公平。</p>
<p><strong>关键要点</strong></p>
<ul>
<li>Rust 不支持宽度超过2的指针，所以&hellip;
<ul>
<li>我们不能将不确定大小的类型转换 trait 对象</li>
<li>我们不能有多个 trait 对象，但我们可以通过将多个 trait 强转成一个 trait 来解决这个问题。</li>
</ul>
</li>
</ul>
<h3 id="用户自定义的不确定大小类型">用户自定义的不确定大小类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Unsized</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">unsized_field</span>: <span class="p">[</span><span class="kt">i32</span><span class="p">],</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们可以通过赋予结构体一个不确定大小的字段来定义一个不确定大小的结构体。不确定大小的结构体只能有1个不确定大小的字段，而且它必须是结构体中的最后一个字段。这是一个要求，这样编译器就可以在编译时确定结构中每个字段的起始偏移量，这对高效快速的字段访问非常重要。此外，使用双宽度指针最多只能跟踪一个不确定大小的字段，因为更多的不确定大小的字段将需要更多的宽度。</p>
<p>那么我们到底该如何实例化这个东西呢？和我们处理任何不确定大小类型的方式一样：先做一个可确定大小的版本，然后胁迫它变成不确定大小的版本。然而，<code>Unsized</code> 的定义总是不确定大小的，没有办法制作它的可确定大小版本！唯一的变通办法是使结构体通用化，使它可以存在于确定大小的版本中和不确定大小的版本中。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">MaybeSized</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">maybe_sized</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// unsized coercion from MaybeSized&lt;[i32; 3]&gt; to MaybeSized&lt;[i32]&gt;
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ms</span>: <span class="kp">&amp;</span><span class="nc">MaybeSized</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">i32</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MaybeSized</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">maybe_sized</span>: <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>那么这有什么用处呢？没有什么特别引人注目的，用户定义的不确定大小的类型现在是一个非常半成品的功能，它们的局限性超过了任何好处。这里提到它们纯粹是为了全面性。</p>
<p><strong>有趣的事实：</strong> <code>std::fi::OsStr</code> 和 <code>std::path::Path</code> 是标准库中的2个不确定大小的结构，你可能已经在不知不觉中使用过了。</p>
<p><strong>关键 要点</strong></p>
<ul>
<li>用户定义的不确定大小类型现在是一个半成品的功能，它们的局限性超过了任何好处</li>
</ul>
<h2 id="zero-sized-类型">Zero-Sized 类型</h2>
<p>Zero-Sized 乍听起来很奇异，但到处都在使用。</p>
<h3 id="unit-类型">Unit 类型</h3>
<p>最常见的零大小类型是 Unit 类型: <code>()</code>. 所有的空块 <code>{}</code> 都评估为 <code>()</code>，如果块是非空的，但最后一个表达式用分号 <code>;</code> 丢弃，那么它也评估为 <code>()</code>。例子如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">5</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span>: <span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>每一个没有显式返回类型的函数都会默认返回 <code>()</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// with sugar
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// desugared
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>由于 <code>()</code> 是零字节，所以 <code>()</code> 的所有实例都是一样的，这使得 <code>Default</code>、<code>PartialEq</code> 和 <code>Ord</code> 的实现非常简单。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cmp</span>::<span class="n">Ordering</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">PartialEq</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">eq</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_other</span>: <span class="kp">&amp;</span><span class="p">())</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kc">true</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">ne</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_other</span>: <span class="kp">&amp;</span><span class="p">())</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kc">false</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Ord</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_other</span>: <span class="kp">&amp;</span><span class="p">())</span><span class="w"> </span>-&gt; <span class="nc">Ordering</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">Ordering</span>::<span class="n">Equal</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>编译器理解 <code>()</code> 是零大小的，并优化了与 <code>()</code> 实例的交互。例如，<code>Vec&lt;()&gt;</code> 永远不会进行任何堆分配，从 <code>Vec</code> 中推送和弹出 <code>()</code> 只是增加和减少它的 <code>len</code> 字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// zero capacity is all the capacity we need to &#34;store&#34; infinitely many ()
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// causes no heap allocations or vec capacity changes
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(());</span><span class="w"> </span><span class="c1">// len++
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(());</span><span class="w"> </span><span class="c1">// len++
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(());</span><span class="w"> </span><span class="c1">// len++
</span><span class="c1"></span><span class="w">    </span><span class="n">vec</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"> </span><span class="c1">// len--
</span><span class="c1"></span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>上面的例子没有实际应用，但是有没有什么情况下，我们可以有意义地利用上面的想法呢？令人惊讶的是，是的，我们可以通过将 <code>Value</code> 设置为 <code>()</code>，从 <code>HashMap&lt;Key，Value&gt;</code> 中得到一个高效的 <code>HashSet&lt;Key&gt;</code> 实现，这正是 Rust 标准库中 <code>HashSet</code> 的工作原理。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// std::collections::HashSet
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">map</span>: <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li>ZST 的所有实例都是彼此相等的。</li>
<li>Rust 编译器知道优化与 ZSTs 的交互。</li>
</ul>
<h3 id="用户自定义的-unit-结构体">用户自定义的 Unit 结构体</h3>
<p>Unit 结构体是指不含任何字段的结构体，如</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>属性，使 Unit 结构体比 <code>()</code> 更有用。</p>
<ul>
<li>我们可以在自己的 Unit 结构体上实现任何我们想要的 trait，Rust 的 trait 孤儿规则阻止我们实现标准库中定义的 <code>()</code> 的 trait。</li>
<li>在我们的程序中，Unit 结构体可以被赋予有意义的名称。</li>
<li>Unit 结构体，就像所有结构体一样，默认情况下是不可复制的，这在我们的程序中可能很重要。</li>
</ul>
<h3 id="never-类型">Never 类型</h3>
<p>第二种最常见的 ZST 是 never 类型: <code>!</code>。 之所以称为 never 类型，是因为它代表的是永远不会解析到任何值的计算。</p>
<p><code>!</code> 的几个有趣的特性使它不同于 <code>()</code>。</p>
<ul>
<li><code>!</code> 可以被胁迫成任何其他类型。</li>
<li>不可能创建 <code>!</code> 的实例。</li>
</ul>
<p>第一个有趣的属性对人体工程学非常有用，允许我们使用像这样的方便的宏。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// nice for quick prototyping
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">example</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">()</span><span class="w"> </span><span class="c1">// ! coerced to Vec&lt;T&gt;
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example2</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// we know this parse call will never fail
</span><span class="c1"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="s">&#34;123&#34;</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">unreachable</span><span class="o">!</span><span class="p">(),</span><span class="w"> </span><span class="c1">// ! coerced to i32
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example3</span><span class="p">(</span><span class="n">some_condition</span>: <span class="kt">bool</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">some_condition</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">panic</span><span class="o">!</span><span class="p">()</span><span class="w"> </span><span class="c1">// ! coerced to &amp;str
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;str&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>break</code>, <code>continue</code> 和 <code>return</code> 表达式也拥有类型 <code>!</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">example</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// we can set the type of x to anything here
</span><span class="c1"></span><span class="w">    </span><span class="c1">// since the block never evaluates to any value
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">123</span><span class="w"> </span><span class="c1">// ! coerced to String
</span><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">example2</span><span class="p">(</span><span class="n">nums</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">filtered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">filtered</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">break</span><span class="w"> </span><span class="c1">// ! coerced to i32
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="o">*</span><span class="n">num</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">continue</span><span class="w"> </span><span class="c1">// ! coerced to i32
</span><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="n">filtered</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>!</code> 的第二个有趣的属性允许我们在类型层面上将某些状态标记为不可能。让我们以这个函数签名为例。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Success</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>我们知道，如果函数返回并成功，<code>Result</code> 将包含一些类型为 <code>Success</code> 的实例，如果函数出错，<code>Result</code> 将包含一些类型为 <code>Error</code> 的实例。现在我们来对比一下这个函数的签名。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Success</span><span class="p">,</span><span class="w"> </span><span class="o">!&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>我们知道，如果函数返回并且成功了，<code>Result</code> 将持有一些类型为 <code>Success</code> 的实例，如果出错了&hellip;但等等，它永远不会出错，因为不可能创建 <code>!</code> 的实例。鉴于上面的函数签名，我们知道这个函数永远不会出错。那这个函数签名呢:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;!</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>前面的反义词现在是真的：如果这个函数返回，我们知道它肯定出错了，因为成功是不可能的。</p>
<p>前一个例子的实际应用是 <code>FromStr</code> 对 <code>String</code> 的实现，因为将 <code>&amp;str</code> 转换为 <code>String</code> 是不可能失败的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(never_type)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">FromStr</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>后一个例子的实际应用是一个运行无限循环的函数，这个函数永远不打算返回，就像服务器响应客户端的请求一样，除非有一些错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(never_type)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">run_server</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;!</span><span class="p">,</span><span class="w"> </span><span class="n">ConnectionError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_request</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">process</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">response</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个 <code>feature</code> 标记是必要的，因为当 never 类型存在并在 Rust 内部工作时，在用户代码中使用它仍然被认为是实验性的。</p>
<p><strong>要点</strong></p>
<ul>
<li><code>!</code> 可以被胁迫成任何其他类型。</li>
<li>不可能创建 <code>!</code> 的实例，我们可以用它来标记某些状态，在类型级别上是不可能的。</li>
</ul>
<h3 id="用户定义的伪-never-类型">用户定义的伪 Never 类型</h3>
<p>虽然不可能定义一个可以强制到任何其他类型的类型，但可以定义一个不可能创建实例的类型，比如一个 <code>enum</code>，没有任何变体。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>这使得我们可以从前面的2个例子中移除 <code>feature</code> 标记，并使用稳定的 Rust 实现它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">Void</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example 1
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">FromStr</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">type</span> <span class="nb">Err</span> <span class="o">=</span><span class="w"> </span><span class="n">Void</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="n">Self</span>::<span class="nb">Err</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// example 2
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">run_server</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Void</span><span class="p">,</span><span class="w"> </span><span class="n">ConnectionError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_request</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">request</span><span class="p">.</span><span class="n">process</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">response</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这是 Rust 标准库使用的技术，因为 <code>String</code> 的 <code>FromStr</code> 实现的 <code>Err</code> 类型是 <code>std::convert::Infallible</code>，它被定义为:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Infallible</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><h3 id="phantomdata">PhantomData</h3>
<p>第三种最常用的 ZST 可能是 <code>PhantomData</code>。<code>PhantomData</code> 是一个零大小的标记结构，它可以用来 &ldquo;标记&rdquo; 一个包含的结构体具有某些属性。它和它的自动标记 trait 表亲如 <code>Sized</code>、<code>Send</code>、<code>Sync</code> 等在目的上是相似的，但作为一个标记结构体的使用方式有点不同。对 <code>PhantomData</code> 进行彻底的解释并探索它的所有用例不在本文的范围内，所以我们只简单地介绍一个简单的例子。回顾一下前面介绍的这个代码片段。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#![feature(negative_impls)]</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is Send and Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Send trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// opt-out of Sync trait
</span><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="o">!</span><span class="nb">Sync</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Struct</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></code></pre></div><p>很不幸，我们必须使用一个 <code>feature</code> 标记，我们是否可以只使用稳定的 Rust 来达到同样的结果？我们已经了解到，一个类型只有当它的所有成员也是 <code>Send</code> 和 <code>Sync</code> 时才是 <code>Send</code> 和 <code>Sync</code> 的，所以我们可以像 <code>Rc&lt;()&gt;</code> 一样在 <code>Struct</code> 中添加一个 <code>!Send</code> 和 <code>!Sync</code> 成员。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is not Send or Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// adds 8 bytes to every instance
</span><span class="c1"></span><span class="w">    </span><span class="n">_not_send_or_sync</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这不太理想，因为它增加了 <code>Struct</code> 的每个实例的大小，而且我们现在每次要创建一个 <code>Struct</code> 时，还得凭空想象出一个  <code>Rc&lt;()&gt;</code>。由于 <code>PhantomData</code> 是一个 ZST，它解决了这两个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomData</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">NotSendOrSyncPhantom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// this type is not Send or Sync
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">Struct</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// adds no additional size to instances
</span><span class="c1"></span><span class="w">    </span><span class="n">_not_send_or_sync</span>: <span class="nc">NotSendOrSyncPhantom</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><strong>关键要点</strong></p>
<ul>
<li><code>PhantomData</code> 是一个零大小的标记结构，它可以用来 &ldquo;标记&rdquo; 一个包含的结构体具有某些属性。</li>
</ul>
<h2 id="结论">结论</h2>
<ul>
<li>只有确定大小类型的实例才能被放置在栈上，也就是说，可以通过值来传递</li>
<li>不确定大小类型的实例不能放在栈上，必须通过引用来传递。</li>
<li>指向不确定大小类型的指针是双宽度的，因为除了指向数据外，它们还需要做额外的记账工作，以跟踪数据的长度或指向一个  vtable。</li>
<li><code>Sized</code> 是一个 &ldquo;自动&rdquo; 标记 trait。</li>
<li>所有的泛型类型参数默认都是自动绑定 <code>Sized</code> 的。</li>
<li>如果我们有一个泛型函数，它的参数是指针后面的一些 <code>T</code>，例如 <code>&amp;T</code>、<code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 等，那么我们几乎总是希望用 <code>T: ?Sized</code> 来退出默认的 <code>Sized</code> 约束。</li>
<li>利用切片和 Rust 的自动类型强制，我们可以编写灵活的 API。</li>
<li>所有的 trait 默认为 <code>Sized</code>。</li>
<li><code>Trait: ?Sized</code> 是 <code>impl Trait for dyn Trait</code> 所必需的。</li>
<li>我们可以根据每个方法要求 <code>Self: Sized</code>。</li>
<li>由 <code>Sized </code> 绑定的 trait 不能被制作成 trait 对象。</li>
<li>Rust 不支持宽度超过2的指针，所以&hellip;
<ul>
<li>我们不能将不确定大小的类型转换为 trait 对象</li>
<li>我们不能有多 trait 对象，但我们可以通过将多个 trait 转化成一个 trait 来解决这个问题。</li>
</ul>
</li>
<li>用户定义的不确定大小的类型现在是一个半成品的功能，它们的局限性超过了任何好处</li>
<li>ZST 的所有实例都是彼此相等的。</li>
<li>Rust 编译器知道优化与 ZSTs 的交互。</li>
<li><code>!</code> 可以被胁迫成任何其他类型。</li>
<li>不可能创建 <code>!</code> 的实例，我们可以用它来标记某些状态，在类型级别上是不可能的。</li>
<li><code>PhantomData</code> 是一个零大小的标记结构，它可以用来 &ldquo;标记&rdquo; 一个包含的结构体具有某些属性。</li>
</ul>
<h2 id="讨论">讨论</h2>
<p>在这里讨论本文:</p>
<ul>
<li><a href="https://users.rust-lang.org/t/blog-post-sizedness-in-rust/46293?u=pretzelhammer">official Rust users forum</a></li>
<li><a href="https://www.reddit.com/r/learnrust/comments/hx2jd0/sizedness_in_rust/">learnrust subreddit</a></li>
<li><a href="https://twitter.com/pretzelhammer/status/1286669073137491973">Twitter</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/hxips7/sizedness_in_rust/">rust subreddit</a></li>
<li><a href="https://github.com/pretzelhammer/rust-blog/discussions">Github</a></li>
</ul>
<h2 id="通知">通知</h2>
<p>当发表下一篇博文时，会收到通知:</p>
<ul>
<li><a href="https://twitter.com/pretzelhammer">Following pretzelhammer on Twitter</a> or</li>
<li>Watching this repo&rsquo;s releases (click <code>Watch</code> -&gt; click <code>Custom</code> -&gt; select <code>Releases</code> -&gt; click <code>Apply</code>)</li>
</ul>
<h2 id="更多阅读">更多阅读</h2>
<ul>
<li><a href="./common-rust-lifetime-misconceptions.md">Common Rust Lifetime Misconceptions</a></li>
<li><a href="./tour-of-rusts-standard-library-traits.md">Tour of Rust&rsquo;s Standard Library Traits</a></li>
<li><a href="./learning-rust-in-2020.md">Learning Rust in 2020</a></li>
<li><a href="./too-many-brainfuck-compilers.md">Learn Assembly with Entirely Too Many Brainfuck Compilers</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/sizedness" term="sizedness" label="Sizedness" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[For the Love of Macros]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>For the Love of Macros</blockquote><p>我一直在重读 Ted Kaminski 关于软件设计的博客。我强烈推荐所有的文章，尤其是早期的文章（这是<a href="https://www.tedinski.com/2018/01/16/how-humans-write-programs.html">第一篇</a>）。他设法提供了既不平凡又合理的设计建议（当然是主观判断），这是一个难得的标本!</p>
<p>无论如何，这一系列的见解之一是，当设计一个抽象的概念时，我们总是要面对权力和属性之间的内在权衡。我们使用一个特定的抽象能表达的越多，我们对使用它的代码能说的就越少。然而，我们人类对更多表达能力的偏爱并非与生俱来。这一点在编程语言社区中很明显，用户不停地要求提供新功能，而语言设计者却说不。</p>
<p>宏是一个在 &ldquo;更强大&quot;方面走得很远的语言功能。宏给了你一种在源代码上抽象的能力。作为交换，你放弃了（自动）推理表面语法的能力。作为一个具体的<a href="https://rust-analyzer.github.io/blog/2020/03/30/macros-vs-rename.html">例子</a>，重命名重构在具有强大宏系统的语言中并不能 100% 可靠地工作。</p>
<p>我确实认为，在理想的世界里，对于一个想要扩展到巨大项目的语言来说，这是一个错误的交易。当你增加了更多的程序员、更多的年限和更多的数百万行代码时，自动推理和转换源代码的能力就会变得越来越重要。但是，请谨慎对待这一点 - 我显然是有偏见的，因为我花了几年时间开发 Rust IDE。</p>
<p>也就是说，宏有巨大的吸引力 - 它们是语言设计师的胶带。宏很少是最好的工具，但它们几乎可以完成任何工作。语言设计是渐进式的。宏系统通过为许多功能提供一个现成的穷人的替代品来缓解设计压力。</p>
<p>在这篇文章中，我想探讨一下 Rust 中宏的用途。目的是为了找到不放弃&quot;推理源代码&quot;属性的解决方案。</p>
<h2 id="字符串插值">字符串插值</h2>
<p>到目前为止，最常见的使用情况是 <code>format!</code> 系列的宏。这里的无宏解决方案很直接 - 字符串插值语法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;number&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">92</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="s">&#34;$key: ${values()}&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;number: 92&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>在 Rust 中，插值可能不应该直接构造一个字符串，而是可以产生一个实现 Display 的值（就像 <code>format_args!</code> 一样），这样可以避免分配。一个有趣的扩展是允许在格式字符串片段上迭代。这样一来，插值语法就可以用于 SQL 语句或命令行参数之类的东西，而不用担心引入注入漏洞。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;my dir&#34;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="s">&#34;ls $arg&#34;</span><span class="p">.</span><span class="n">to_cmd</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w"> </span><span class="s">&#34;ls &#39;my dir&#39;&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p><a href="https://julialang.org/blog/2012/03/shelling-out-sucks/">这篇</a>关于 Julia 编程语言的文章解释了这个问题。 <a href="https://github.com/matklad/xshell">xshell</a> crate 为 Rust 实现了这个想法。</p>
<h2 id="derives">Derives</h2>
<p>我认为在 Rust 中，宏的第二个最常见，也可能是最重要的用法是派生。Rust 是为数不多的能正确实现平等的语言之一（禁止比较苹果和橘子），但这关键取决于 <code>derive(Eq)</code> 的能力。这个领域常见的解决方案是编译器中的特殊 casing（Haskell 的派生）或运行时反射。</p>
<p>但我最感兴趣的解决方案是 <code>C#</code> <a href="https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/">源码生成器</a>。这并不是什么新鲜事 - 这只是老式的（源码）代码生成器，只是具有很好的实现质量。你可以提供自定义的代码，这些代码在构建过程中被运行，它可以读取现有的源码并生成额外的文件，然后再添加到编译中。</p>
<p>这个解决方案的优点在于它将所有的复杂性从语言中移出，移到了编译系统中。这意味着你可以免费获得基线工具支持。生成代码的 Goto 定义？就能用了。调试时想介入一些序列化代码？磁盘上有实际的源码，所以可以放心的去做! 你是比较喜欢用 <code>printf</code> 的人？好吧，你需要说服构建系统不要踩过你的改动，但是，否则，为什么不呢？</p>
<p>此外，源码生成器的表现力明显更强。它们可以调用到 Roslyn 编译器来分析源代码，所以它们能够生成类型导向的代码。</p>
<p>为了有用，源码生成器需要一些语言级别的支持，以便将一个实体分割到多个文件中。在 <code>C#</code> 中，部分类就扮演了这个角色。</p>
<h2 id="特定领域语言">特定领域语言</h2>
<p>宏的存在理由是嵌入式 DSL 的实现。我们希望在语言中引入自定义语法，以简洁地对程序的领域进行建模。例如，可以用宏来嵌入 Rust 代码中的 HTML 片段。</p>
<p>对我个人来说，eDSL 不是要解决的问题，只是一个问题。引入一个新的子语言（即使是小的）会花费大量的认知复杂性预算。如果你偶尔需要它，最好坚持只把有点啰嗦的函数调用链在一起。如果你经常需要它，引入外部的 DSL 是有意义的，它有一个编译器，一个语言服务器，以及所有使编程富有成效的工具。对我来说，基于宏的 DSL 只是在成本效益曲线上不落像一个有趣的点。</p>
<p>也就是说，Kotlin 编程语言很好地解决了强类型化、工具友好型 DSL 的问题（例子）。令人气愤的是，很难指出具体的解决方案是什么。就是&hellip;&hellip;主要是具体的语法。下面是一些成分。</p>
<ul>
<li>闭包的语法是 <code>{ arg -&gt; body }</code>，或者直接是 <code>{ body }</code>，所以闭包在语法上类似于块。</li>
<li>扩展方法（这只是静态方法的语法糖）。</li>
<li>Java 风格的隐式 this，它将名称引入到作用域中，而不需要显式声明。</li>
<li><a href="https://boats.gitlab.io/blog/post/the-problem-of-effects/">TCP-preserving</a> inline closures (这是唯一一个非语法特征)</li>
</ul>
<p>尽管如此，这还不足以实现 Jetpack Compose UI DSL，它还需要一个编译器插件。</p>
<h2 id="sqlx">sqlx</h2>
<p>我想调用的一个有趣的 DSL 案例是 <a href="https://docs.rs/sqlx/0.5.1/sqlx/macro.query.html">sqlx::query</a>。它允许我们写这样的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">account</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">  </span><span class="n">sqlx</span>::<span class="n">query</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;select (1) as id, &#39;Herp Derpinson&#39; as name&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">fetch_one</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// anonymous struct has `#[derive(Debug)]` for convenience
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">account</span><span class="p">.</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>这一点我想是eDSL确实很拉风的几个案例之一。没有宏的情况下，我不知道该怎么做。使用字符串插值（高级版本，以保护不被注入），可以指定查询。使用源码生成器，可以检查查询的语法和类型，例如，在这种情况下，会出现类型错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">)</span>: <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">f32</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">
</span><span class="w">  </span><span class="n">query</span><span class="p">(</span><span class="s">&#34;select (1) as id, &#39;Herp Derpinson&#39; as name&#34;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">fetch_one</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="k">await</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>但这还不足以生成一个匿名结构体，也不足以摆脱动态 casts。</p>
<h2 id="有条件编译">有条件编译</h2>
<p>Rust 还使用宏进行条件编译。这个用例令人信服地展示了&quot;缺乏属性&quot;方面的能力。处理特征组合是 Cargo 永远头痛的问题。当特征标志改变时，用户不得不反复重新编译大块的装箱图。在 CI 上用 <code>Cargo test --no-default-features</code> 捕捉类型错误是非常恼人的，尤其是当你在提交 PR 之前确实运行了 <code>Cargo test</code>。&ldquo;添加特性&quot;是一个无法选中的一厢情愿。</p>
<p>在这种情况下，我不知道有什么好的无宏选择。但是，原则上，这似乎是可行的，如果将条件编译进一步推到编译器流水线的下游，推到代码生成和链接阶段。编译器可以在为一个函数生成机器代码之前，选择特定平台的版本，而不是在解析过程中提前丢弃一些代码。在此之前，它会检查该函数的所有条件编译版本是否具有相同的接口。这样一来，平台特定的类型错误就不可能出现了。</p>
<h2 id="占位符语法">占位符语法</h2>
<p>最后一个我想介绍的用例是占位符语法。Rust 的 <code>macro_call!(...)</code> 语法开辟了一个很好的隔离区域，只要小括号是平衡的，任何东西都可以用。理论上，这允许语言设计者在确定某些东西之前先试验临时语法。在实践中，这看起来好像并没有什么好处？有人反对稳定 <code>postfix .await</code>，而不通过中间期与 <code>await!</code> 宏来稳定。而且，稳定之后，所有的语法讨论都立即被遗忘了？另一方面，我们确实有 <code>try! -&gt; ?</code> 转变，但我不认为它有助于发现任何设计上的缺陷？至少，我们成功地稳定了那个<a href="https://internals.rust-lang.org/t/can-try-and-use-the-into-trait-instead-of-from/6714">不必要的限制性</a>去语法糖。</p>
<p>对于结论，我想绕回源码生成器。究竟是什么让它们比宏更容易被工具化？我认为有以下三个特性。第一，无论是输入还是输出，从根本上说，都是文本。没有中间的表示方式（比如 token 树），而这个元程序设施使用的是中间的表示方式。这意味着，它不需要与编译器深度集成。当然，在内部，该工具可以自由地对代码进行任意解析、类型检查和转换。其次，有一个阶段性的区分。源码生成器是一次执行，无序的。在元编程和名称解析之间没有来回，这又可以将&quot;元&quot;的部分保留在外面。第三，源码生成器只能添加代码，不能改变现有代码的含义。这意味着，在代码生成器的存在下，语义上合理的源码转换依然如此。</p>
<p>就这样吧! 在 <a href="https://old.reddit.com/r/rust/comments/ljnkwg/blog_post_for_the_love_of_macros/">/r/rust</a> 上讨论。</p>
<p>原文链接: <a href="https://matklad.github.io/2021/02/14/for-the-love-of-macros.html">https://matklad.github.io/2021/02/14/for-the-love-of-macros.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Std Error in Rust]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="related" type="text/html" title="Two Beautiful Rust Programs" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Std Error in Rust</blockquote><h1 id="学习-stdioerror">学习 std::io::Error</h1>
<p>在这篇文章中，我们将剖析 Rust 标准库中 std::io::Error 类型的实现。相关代码在这里：<code>library/std/src/io/error.rs</code>。</p>
<p>你可以把这篇文章看成是其中之一。</p>
<ul>
<li>一个标准库的特定位的研究</li>
<li>一个高级错误管理指南</li>
<li>一个漂亮的 API 设计案例</li>
</ul>
<p>文章要求基本熟悉 Rust 错误处理。</p>
<p>在设计一个用于 <code>Result&lt;T，E&gt;</code> 的 Error 类型时，主要的问题是&quot;如何使用这个错误？&quot;。通常，以下情况之一为真。</p>
<ul>
<li>错误被程序化处理。消费者检查错误，所以它的内部结构需要在合理的程度上暴露出来。</li>
<li>错误被传播并显示给用户。消费者不检查 <code>fmt::Display</code> 之外的错误；所以它的内部结构可以被封装。</li>
</ul>
<p>请注意，暴露实现细节和封装细节之间存在紧张关系。实现第一种情况的常见反模式是定义一个厨房水槽枚举。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">Tokio</span><span class="p">(</span><span class="n">tokio</span>::<span class="n">io</span>::<span class="n">Error</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">ConnectionDiscovery</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">path</span>: <span class="nc">PathBuf</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">reason</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">stderr</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">},</span><span class="w">
</span><span class="w">  </span><span class="n">Deserialize</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">source</span>: <span class="nc">serde_json</span>::<span class="n">Error</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">},</span><span class="w">
</span><span class="w">  </span><span class="p">...,</span><span class="w">
</span><span class="w">  </span><span class="n">Generic</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这种方法有很多问题。</p>
<p>首先，从底层库中暴露错误会使它们成为你的公共 API 的一部分。在你的依赖关系中的主要 semver bump 会要求你也做一个新的主要版本。</p>
<p>其次，它将所有的实现细节都固定下来。例如，如果你注意到 ConnectionDiscovery 的大小是巨大的，那么将这个变体装箱将是一个突破性的变化。</p>
<p>第三，它通常表明了一个更大的设计问题。厨房水槽错误将不同的故障模式打包成一种类型。但是，如果故障模式差异很大，处理起来可能就不合理了! 这说明情况看起来更像案例二。</p>
<p>错误厨房水槽病的一个经常有效的治疗方法是将错误推送给调用者的模式。</p>
<p>考虑这个例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">my_function</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">MyError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dep_function</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p><code>my_function</code> 调用 <code>dep_function</code>，所以 <code>MyError</code> 应该可以从 <code>DepError</code> 转换过来。更好的写法可能是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">my_function</span><span class="p">(</span><span class="n">thing</span>: <span class="nc">DepThing</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">MyError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="nb">Ok</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在这个版本中，调用者被迫调用 <code>dep_function</code> 并处理其错误。这就用更多的类型交换了更多的类型安全。<code>MyError</code> 和 <code>DepError</code> 现在是不同的类型，调用者可以分别处理它们。如果 <code>DepError</code> 是 <code>MyError</code> 的变体，那么就需要进行运行时匹配。</p>
<p>这个想法的一个极端版本是 <code>sans-io</code> 编程。大多数错误来自于 IO；如果你把所有的 IO 推给调用者，你就可以跳过大部分的错误处理。</p>
<p>无论枚举方法多么糟糕，它确实实现了第一种情况的最大可检查性。</p>
<p>以传播为中心的第二种情况下的错误管理，通常是通过使用盒状特质对象来处理。像 <code>Box&lt;dyn std::error::Error&gt;</code> 这样的类型可以从任何具体的错误中构造出来，可以通过 <code>Display</code> 打印出来，并且仍然可以选择通过动态下传来暴露底层错误。<code>Anyhow</code> crate 就是这种风格的一个很好的例子。</p>
<p><code>std::io::Error</code> 的例子很有趣，因为它想同时具备上述两种风格。</p>
<ul>
<li>这是 std，所以封装和面向未来是最重要的。</li>
<li>来自操作系统的 IO 错误往往可以被处理（比如 EWOULDBLOCK）。</li>
<li>对于系统编程语言来说，准确地暴露底层 OS 错误是很重要的。</li>
<li>未来潜在的操作系统错误集是没有限制的。</li>
<li><code>io::Error</code> 也是一种词汇类型，应该可以表示一些不完全的 os 错误。例如，Rust Paths 可以包含内部的0字节，打开这样的路径应该在进行 <code>syscall</code> 之前返回一个 <code>io::Error</code>。</li>
</ul>
<p>下面是 <code>std::io::Error</code> 的样子。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">repr</span>: <span class="nc">Repr</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">Os</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">Simple</span><span class="p">(</span><span class="n">ErrorKind</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Custom</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Custom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>首先要注意的是，它内部是一个枚举，但这是一个隐藏得很好的实现细节。为了允许检查和处理各种错误条件，有一个单独的公共无字段种类枚举。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Clone, Copy)]</span><span class="w">
</span><span class="w"></span><span class="cp">#[non_exhaustive]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">enum</span> <span class="nc">ErrorKind</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">NotFound</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">PermissionDenied</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">Interrupted</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">...</span><span class="w">
</span><span class="w">  </span><span class="n">Other</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">kind</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ErrorKind</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">sys</span>::<span class="n">decode_error_kind</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">kind</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">kind</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>虽然 ErrorKind 和 Repr 都是枚举，但公开暴露 ErrorKind 就没那么可怕了。一个 <code>#[non_exhaustive]Copy</code> 无字段枚举的设计空间是一个点 - 没有合理的替代方案或兼容性隐患。</p>
<p>有些 <code>io::Errors</code> 只是原始的操作系统错误代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">from_raw_os_error</span><span class="p">(</span><span class="n">code</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">raw_os_error</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>特定平台的 <code>sys::decode_error_kind</code> 函数负责将错误代码映射到 <code>ErrorKind</code> 枚举。所有这些都意味着代码可以通过检查 <code>.kind()</code> 来跨平台处理错误类别。然而，如果需要以一种依赖于操作系统的方式处理一个非常特殊的错误代码，这也是可能的。API 小心翼翼地提供了一个方便的抽象，而没有抽象掉重要的低级细节。</p>
<p>一个 <code>std::io::Error</code> 也可以从一个 <code>ErrorKind</code> 中构造出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="nb">From</span><span class="o">&lt;</span><span class="n">ErrorKind</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这提供了跨平台访问错误代码风格的错误处理。如果你需要尽可能快的错误，这很方便。</p>
<p>最后，还有第三种完全自定义的变体表示。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span>: <span class="nc">E</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w">
</span><span class="w">  </span><span class="k">where</span><span class="w">
</span><span class="w">    </span><span class="n">E</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Self</span>::<span class="n">_new</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">_new</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">repr</span>: <span class="nc">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">Custom</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">kind</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">})),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_ref</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">into_inner</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(..)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>需要注意的地方。</p>
<ul>
<li>
<p>通用的 <code>new</code> 函数委托给单态的 <code>_new</code> 函数。这改善了编译时间，因为在单态化过程中需要重复的代码更少。我认为这也改善了一些运行时：<code>_new</code> 函数没有被标记为内联，所以会在调用处产生一个函数调用。这是好的，因为错误构造是冷路径，节省指令缓存是受欢迎的。</p>
</li>
<li>
<p>自定义变体被框住了 - 这是为了让整体 <code>size_of</code> 更小。错误的 <code>on-the-stack</code> 大小是很重要的：即使没有错误，你也要为此付出代价!</p>
</li>
</ul>
<p>这两种类型都是指&quot;静态错误&quot;。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">type</span> <span class="nc">A</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="o">&amp;</span><span class="p">(</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">&#39;static</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>在 <code>dyn Trait + '_</code> 中，<code>'_</code> 被省略为 <code>'static</code>，除非 trait 对象是在引用后面，在这种情况下，它被省略为 <code>&amp;'a dyn Trait + 'a</code>。</p>
<p><code>get_ref</code>, <code>get_mut</code> 和 <code>into_inner</code> 提供了对底层错误的完全访问。类似于 <code>os_error</code> 的情况，抽象模糊了细节，但也提供了钩子来获取底层数据的原样。</p>
<p>同样，Display 的实现揭示了内部表示的最重要细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span>::<span class="n">os</span>::<span class="n">error_string</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{} (os error {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">detail</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>综上所述，std::io::Error:</p>
<ul>
<li>封装了它的内部表现形式，并通过框定大的枚举变体来优化它。</li>
<li>通过 <code>ErrorKind</code> 模式提供了一种方便的方法来处理基于类别的错误。</li>
<li>完全暴露底层操作系统的错误（如果有的话）。</li>
</ul>
<p>可以透明地包裹任何其他错误类型。</p>
<p>最后一点意味着 <code>io::Error</code> 可以用于临时错误，因为 <code>&amp;str</code> 和 String 可以转换为 <code>Box&lt;dyn std::error::Error&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">Other</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;something went wrong&#34;</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>它也可以作为 anyhow 的简单替换。我想一些库可能会用这个来简化他们的错误处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">io</span>::<span class="n">Error</span>::<span class="n">new</span><span class="p">(</span><span class="n">io</span>::<span class="n">ErrorKind</span>::<span class="n">InvalidData</span><span class="p">,</span><span class="w"> </span><span class="n">my_specific_error</span><span class="p">)</span><span class="w">
</span></code></pre></div><p>例如，<code>serde_json</code> 提供了以下方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>读取会因为 <code>io::Error</code> 而失败，所以 <code>serde_json::Error</code> 需要能够在内部表示 <code>io::Error</code>。我认为这是倒退的 (但我不知道整个上下文，如果被证明是错的我会很高兴！)，签名应该是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>那么，<code>serde_json::Error</code> 就不会有 <code>Io</code> 的变体，而会以 <code>InvalidData</code> 的形式被藏到 <code>io::Error</code> 中。
补遗, 2021-01-25</p>
<p>重新阅读这篇文章，我现在认为正确的返回类型应该是：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">from_reader</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="w">
</span><span class="w">  </span><span class="n">rdr</span>: <span class="nc">R</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w">
</span><span class="w">  </span><span class="n">R</span>: <span class="nc">Read</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="n">T</span>: <span class="nc">DeserializeOwned</span><span class="p">,</span><span class="w">
</span></code></pre></div><p>这迫使 IO 和反序列化错误分开处理，这在这种情况下是有意义的。IO 错误可能是程序领域之外的硬件/环境问题，而序列化错误很可能是系统中的某个错误。</p>
<p>我认为 <code>std::io::Error</code> 是一个非常了不起的类型，它能够在没有太多妥协的情况下为许多不同的用例服务。但我们是否可以做得更好呢？</p>
<p><code>std::io::Error</code> 的首要问题是，当一个文件系统操作失败时，你不知道它是为哪个路径失败的。这是可以理解的 - Rust 是一种系统语言，所以它不应该比 OS 原生提供的东西增加多少脂肪。OS 返回的是一个整数返回代码，而将其与一个堆分配的 <code>PathBuf</code> 耦合在一起，可能是一个不可接受的开销!</p>
<p>我很惊讶地得知，事实上，<code>std</code> 对每一个与路径相关的系统调用都会进行分配。</p>
<p>它需要以某种形式存在。<code>OS API</code> 需要在字符串的结尾有一个不幸的零字节. 但我想知道对短路径使用堆栈分配的缓冲区是否有意义。可能不会 - 路径通常不会那么短，而且现代分配器能有效地处理瞬时分配。</p>
<p>我不知道这里有什么明显的好办法。一个选择是在编译时（一旦我们得到 <code>std-aware cargo</code>）或运行时（<code>a-la RUST_BACKTRACE</code>）添加开关，以堆分配所有与路径相关的 IO 错误。一个类似形的问题是 <code>io::Error</code> 不携带 backtrace。</p>
<p>另一个问题是，<code>std::io::Error</code> 的效率不高。</p>
<p>它的体积是相当大的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="n">io</span>::<span class="n">Error</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size_of</span>::<span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">());</span><span class="w">
</span></code></pre></div><p>对于自定义的情况，会产生双重的间接和分配。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="k">enum</span> <span class="nc">Repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Os</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="n">Simple</span><span class="p">(</span><span class="n">ErrorKind</span><span class="p">),</span><span class="w">
</span><span class="w">      </span><span class="c1">// First Box :|
</span><span class="c1"></span><span class="w">      </span><span class="n">Custom</span><span class="p">(</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Custom</span><span class="o">&gt;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">struct</span> <span class="nc">Custom</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">kind</span>: <span class="nc">ErrorKind</span><span class="p">,</span><span class="w">
</span><span class="w">      </span><span class="c1">// Second Box :(
</span><span class="c1"></span><span class="w">      </span><span class="n">error</span>: <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">error</span>::<span class="n">Error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Sync</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我想我们现在可以解决这个问题了</p>
<p>首先，我们可以通过使用一个瘦的特质对象来摆脱双重内向性，比如失败或 anyhow。现在 GlobalAlloc 已经存在，这是一个比较直接的实现。</p>
<p>其次，我们可以利用指针是对齐的这一事实，将 Os 和 Simple 变体都用最小的有效位集储藏到 usize 中。我认为我们甚至可以发挥创意，使用第二个最小有意义的位，把第一个位留作小众。这样一来，即使是像 <code>io::Result&lt;i32&gt;</code> 这样的东西，也可以是指针大小的!</p>
<p>本篇文章到此结束。下一次你要为你的库设计一个错误类型的时候，花点时间去看看 <code>std::io::Error</code> 的源头，你可能会发现一些值得偷的东西。</p>
<p>讨论在 /r/rust.Net 上进行。</p>
<h2 id="额外的谜题">额外的谜题</h2>
<p>看看实现中的这一行。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Formatter</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">fmt</span>::<span class="nb">Result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">repr</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Os</span><span class="p">(</span><span class="n">code</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">detail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sys</span>::<span class="n">os</span>::<span class="n">error_string</span><span class="p">(</span><span class="o">*</span><span class="n">code</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{} (os error {})&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">detail</span><span class="p">,</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Simple</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">.</span><span class="n">as_str</span><span class="p">()),</span><span class="w">
</span><span class="w">      </span><span class="n">Repr</span>::<span class="n">Custom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">fmt</span><span class="p">(</span><span class="n">fmt</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>原文链接: <a href="https://matklad.github.io/2020/10/15/study-of-std-io-error.html">https://matklad.github.io/2020/10/15/study-of-std-io-error.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Two Beautiful Rust Programs]]></title>
            <link href="https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-call-site-dependency-injection/?utm_source=atom_feed" rel="related" type="text/html" title="Call Site Dependency Injection" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-for-the-love-of-macros/?utm_source=atom_feed" rel="related" type="text/html" title="For the Love of Macros" />
                <link href="https://ohmyweekly.github.io/notes/2021-04-05-std-error-in-rust/?utm_source=atom_feed" rel="related" type="text/html" title="Std Error in Rust" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-20-pest-grammars/?utm_source=atom_feed" rel="related" type="text/html" title="Pest Grammars" />
                <link href="https://ohmyweekly.github.io/notes/2021-01-19-parser-api-example-ini/?utm_source=atom_feed" rel="related" type="text/html" title="Parser API - 解析 INI" />
            
                <id>https://ohmyweekly.github.io/notes/2021-04-05-two-beautiful-rust-programs/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2021-04-05T00:00:00+08:00</published>
            <updated>2021-04-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Two Beautiful Rust Programs</blockquote><h1 id="two-beautiful-rust-programs">Two Beautiful Rust Programs</h1>
<p>这是一则 Rust 编程语言的短广告，目标是有经验的 <code>C++</code> 开发者。作为一则广告，它只能吊起你的胃口，具体内容请参考其他资源。</p>
<p>第一个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="n">xs</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">92</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个程序创建了一个 32 位整数的向量(<code>std::vector&lt;int32_t&gt;</code>)，接收第一个元素 <code>x</code> 的引用，再向向量推送一个数字，然后使用 <code>x</code>。这个程序是错误的：扩展向量可能会使对元素的引用无效，而且 <code>*x</code> 可能会取消引用一个 danging 指针。</p>
<p>这个程序的好处是它不会被编译。</p>
<pre><code>error[E0502]: cannot borrow xs as mutable
    because it is also borrowed as immutable
 --&gt; src/main.rs:4:5

     let x: &amp;i32 = &amp;xs[0];
                    -- immutable borrow occurs here
     xs.push(92);
     ^^^^^^^^^^^ mutable borrow occurs here
     println!(x);
              - immutable borrow later used here
</code></pre><p>Rust 编译器跟踪每块数据的别名状态，并禁止潜在的别名数据的突变。在这个例子中，<code>x</code> 和 <code>xs</code> 别名了向量在堆中存储的第一个整数。</p>
<p>Rust 不允许做傻事。</p>
<p>第二个程序:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">crossbeam</span>::<span class="n">scope</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">parking_lot</span>::<span class="p">{</span><span class="n">Mutex</span><span class="p">,</span><span class="w"> </span><span class="n">MutexGuard</span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="n">scope</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">s</span><span class="p">.</span><span class="n">spawn</span><span class="p">(</span><span class="o">|</span><span class="n">_</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">          </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">guard</span>: <span class="nc">MutexGuard</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w">
</span><span class="w">          </span><span class="o">*</span><span class="n">guard</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">      </span><span class="p">});</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="p">}).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">total</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">get_mut</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;total = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">total</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这个程序创建一个由 mutex 保护的整数计数器，生成10个线程，从每个线程开始将计数器递增10次，并打印出总数。</p>
<p>计数器变量位于堆栈中，这些堆栈数据的指针与其他线程共享。线程必须锁定 mutex 才能进行增量。打印总数时，绕过 mutex 读取计数器，没有任何同步。</p>
<p>这个程序的妙处在于，它的正确性依赖于几位精妙的推理，每一个推理都会被编译器检查。</p>
<p>子线程不会逃离主函数 所以可以从它的堆栈中读取计数器</p>
<p>子线程只通过 mutex 访问 counter。</p>
<p>子线程将在我们从计数器中读出总数而不使用 mutex 时终止。</p>
<p>如果这些约束中的任何一个被破坏，编译器就会拒绝该代码。没有必要使用 <code>std::shared_ptr</code> 只是为了防御性地确保内存不会在你的脚下被释放。</p>
<p>Rust 允许做危险的、聪明的、快速的事情，而不用担心引入未定义的行为。</p>
<p>如果你喜欢你所看到的，这里有两本我推荐的书，可以让你更深入地了解 Rust。</p>
<p>原文链接: <a href="https://matklad.github.io/2020/07/15/two-beautiful-programs.html">https://matklad.github.io/2020/07/15/two-beautiful-programs.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/rustlang" term="rustlang" label="rustlang" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/rust" term="rust" label="Rust" />
                            
                        
                    
                
            
        </entry>
    
</feed>
