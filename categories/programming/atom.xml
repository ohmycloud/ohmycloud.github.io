<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
    <generator uri="https://gohugo.io/" version="0.63.2">Hugo</generator><title type="html"><![CDATA[programming on 焉知非鱼]]></title>
    
        <subtitle type="html"><![CDATA[rakulang, dartlang, nimlang, golang, rustlang, lang lang no see]]></subtitle>
    
    
    
            <link href="https://ohmyweekly.github.io/categories/programming/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://ohmyweekly.github.io/categories/programming/index.xml" rel="alternate" type="application/rss+xml" title="RSS" />
            <link href="https://ohmyweekly.github.io/categories/programming/atom.xml" rel="self" type="application/atom+xml" title="Atom" />
            <link href="https://ohmyweekly.github.io/categories/programming/jf2feed.json" rel="alternate" type="application/jf2feed+json" title="jf2feed" />
    <updated>2020-09-04T12:46:33+08:00</updated>
    
    
    
    
        <id>https://ohmyweekly.github.io/categories/programming/</id>
    
        
        <entry>
            <title type="html"><![CDATA[Event Time]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-21-event-time/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-flink-datastream-api-programming-guide/?utm_source=atom_feed" rel="related" type="text/html" title="Flink Datastream API 编程指南" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-generating-watermarks/?utm_source=atom_feed" rel="related" type="text/html" title="Generating Watermarks" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-working-with-state/?utm_source=atom_feed" rel="related" type="text/html" title="使用状态" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-built-in-watermark-generators/?utm_source=atom_feed" rel="related" type="text/html" title="内置的水印生成器" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-state-and-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="状态和容错性" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-21-event-time/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-21T00:00:00+08:00</published>
            <updated>2020-08-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Event Time</blockquote><h2 id="event-timehttpsciapacheorgprojectsflinkflink-docs-release-111devevent_timehtml"><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html">Event Time</a></h2>
<p>在本节中，您将学习如何编写时间感知(time-aware)的 Flink 程序。请看一下<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html">及时流处理</a>，了解及时流处理背后的概念。</p>
<p>关于如何在 Flink 程序中使用时间的信息请参考 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">windowing</a> 和 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/process_function.html">ProcessFunction</a>。</p>
<p>使用事件时间处理的先决条件是设置正确的时间特性(<em>time characteristic</em>)。该设置定义了数据流源的行为（例如，它们是否会分配时间戳），以及像 <code>KeyedStream.timeWindow(Time.seconds(30))</code> 这样的窗口操作应该使用什么时间概念。</p>
<p>你可以使用 <code>StreamExecutionEnvironment.setStreamTimeCharacteristic()</code> 设置时间特性:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>

<span class="n">env</span><span class="o">.</span><span class="n">setStreamTimeCharacteristic</span><span class="o">(</span><span class="nc">TimeCharacteristic</span><span class="o">.</span><span class="nc">EventTime</span><span class="o">)</span>

<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">MyEvent</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FlinkKafkaConsumer</span><span class="o">[</span><span class="kt">MyEvent</span><span class="o">]</span><span class="o">(</span><span class="n">topic</span><span class="o">,</span> <span class="n">schema</span><span class="o">,</span> <span class="n">props</span><span class="o">)</span><span class="o">)</span>

<span class="n">stream</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span> <span class="k">_</span><span class="o">.</span><span class="n">getUser</span> <span class="o">)</span>
    <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">hours</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">(</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">)</span>
    <span class="o">.</span><span class="n">addSink</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
</code></pre></div><p>需要注意的是，为了在事件时间(<em>event time</em>)中运行这个例子，程序需要使用直接为数据定义事件时间并自己发射水印的源，或者程序必须在源之后注入一个时间戳分配器(<em>Timestamp Assigner</em>)与水印生成器(<em>Watermark Generator</em>)。这些函数描述了如何访问事件时间戳，以及事件流表现出何种程度的无序性。</p>
<h2 id="下一步该怎么走">下一步该怎么走？</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html">生成水印</a>。展示了如何编写时间戳分配器和水印生成器，这些都是事件时间(event-time)感知 Flink 应用所需要的。</li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamp_extractors.html">内置的水印生成器</a>。概述了内置的水印生成器。</li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/debugging_event_time.html">调试窗口和事件时间</a>：展示如何调试事件时间 Flink 应用程序中围绕水印和时间戳的问题。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Flink 官方文档" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/datastream-api" term="datastream-api" label="DataStream API" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Flink Datastream API 编程指南]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-21-flink-datastream-api-programming-guide/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-event-time/?utm_source=atom_feed" rel="related" type="text/html" title="Event Time" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-generating-watermarks/?utm_source=atom_feed" rel="related" type="text/html" title="Generating Watermarks" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-working-with-state/?utm_source=atom_feed" rel="related" type="text/html" title="使用状态" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-built-in-watermark-generators/?utm_source=atom_feed" rel="related" type="text/html" title="内置的水印生成器" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-state-and-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="状态和容错性" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-21-flink-datastream-api-programming-guide/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-21T00:00:00+08:00</published>
            <updated>2020-08-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Flink Datastream API Programming Guide</blockquote><h2 id="flink-datastream-api-编程指南httpsciapacheorgprojectsflinkflink-docs-release-111devdatastream_apihtml"><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html">Flink DataStream API 编程指南</a></h2>
<p>Flink 中的 DataStream 程序是对数据流实现转换的常规程序（如过滤、更新状态、定义窗口、聚合）。数据流最初是由各种源（如消息队列、套接字流、文件）创建的。结果通过接收器(sink)返回，例如可以将数据写入文件，或标准输出（例如命令行终端）。Flink 程序可以在各种环境下运行，独立运行，或者嵌入到其他程序中。执行可以发生在本地 JVM 中，也可以发生在许多机器的集群中。</p>
<p>为了创建你自己的 Flink DataStream 程序，我们鼓励你从<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#anatomy-of-a-flink-program">一个 Flink 程序的骨架</a>开始，并逐步添加你自己的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/index.html">流转换</a>。其余部分作为额外操作和高级功能的参考。</p>
<h2 id="什么是-datastream">什么是 DataStream？</h2>
<p>DataStream API 的名字来自于特殊的 <code>DataStream</code> 类，它用于表示 Flink 程序中的数据集合。你可以把它们看作是不可改变的数据集合，可以包含重复的数据。这些数据既可以是有限的，也可以是无边界的，你用来处理它们的 API 是一样的。</p>
<p>DataStream 在用法上与普通的 Java Collection 类似，但在一些关键方面却有很大不同。它们是不可改变的，这意味着一旦它们被创建，你就不能添加或删除元素。你也不能简单地检查里面的元素，而只能使用 DataStream API 操作对它们进行操作，这也被称为转换。</p>
<p>你可以通过在 Flink 程序中添加一个源来创建一个初始的 DataStream。然后你可以从中派生新的流，并通过使用 API 方法，如 <code>map</code>、<code>filter</code> 等来组合它们。</p>
<h2 id="flink-程序的骨架">Flink 程序的骨架</h2>
<p>Flink 程序看起来就像转换 DataStream 的普通程序。每个程序由相同的基本部分组成。</p>
<ol>
<li>获取一个执行环境</li>
<li>加载/创建初始数据。</li>
<li>指定该数据的转换。</li>
<li>指定计算结果的位置。</li>
<li>触发程序执行</li>
</ol>
<p>现在我们将对其中的每一个步骤进行概述，更多细节请参考相关章节。注意，Scala DataStream API 的所有核心类都可以在 <a href="https://github.com/apache/flink/blob/master//flink-streaming-scala/src/main/scala/org/apache/flink/streaming/api/scala">org.apache.flink.stream.api.scala</a> 中找到。</p>
<p><code>StreamExecutionEnvironment</code> 是所有 Flink 程序的基础。你可以使用 <code>StreamExecutionEnvironment</code> 上的这些静态方法获得一个。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span>

<span class="n">createLocalEnvironment</span><span class="o">(</span><span class="o">)</span>

<span class="n">createRemoteEnvironment</span><span class="o">(</span><span class="n">host</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">jarFiles</span><span class="k">:</span> <span class="kt">String</span><span class="kt">*</span><span class="o">)</span>
</code></pre></div><p>通常情况下，你只需要使用 <code>getExecutionEnvironment()</code>，因为这将根据上下文做正确的事情：如果你在 IDE 里面执行你的程序，或者作为一个普通的 Java 程序，它将创建一个本地环境，在你的本地机器上执行你的程序。如果你从你的程序中创建了一个 JAR 文件，并通过<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/cli.html">命令行</a>调用它，Flink 集群管理器将执行你的主方法，并且 <code>getExecutionEnvironment()</code> 将返回一个在集群上执行你的程序的执行环境。</p>
<p>对于指定数据源，执行环境有几种方法可以使用不同的方法从文件中读取数据：你可以只是逐行读取，作为 CSV 文件，或者使用任何其他提供的数据源。如果只是将文本文件作为一个行的序列来读取，你可以使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span>

<span class="k">val</span> <span class="n">text</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readTextFile</span><span class="o">(</span><span class="s">&#34;file:///path/to/file&#34;</span><span class="o">)</span>
</code></pre></div><p>这将为您提供一个 DataStream，然后您可以在其上应用转换来创建新的派生 DataStream。</p>
<p>你可以通过调用 DataStream 上的方法和转换函数来应用转换。例如，一个 <code>map</code> 转换看起来像这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">DataSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="k">val</span> <span class="n">mapped</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">toInt</span> <span class="o">}</span>
</code></pre></div><p>这将通过将原始集合中的每一个字符串转换为一个 Integer 来创建一个新的 DataStream。</p>
<p>一旦你有了一个包含最终结果的 DataStream，你就可以通过创建一个接收器(sink)将其写入外部系统。这些只是创建接收器的一些示例方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">writeAsText</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="n">print</span><span class="o">(</span><span class="o">)</span>
</code></pre></div><p>一旦你指定了完整的程序，你需要通过调用 <code>StreamExecutionEnvironment</code> 上的 <code>execution()</code> 来触发程序的执行。根据 <code>ExecutionEnvironment</code> 的类型，将在你的本地机器上触发执行，或者将你的程序提交到集群上执行。</p>
<p><code>execute()</code> 方法将等待作业完成，然后返回一个 <code>JobExecutionResult</code>，这个包含执行时间和累加器结果。</p>
<p>如果你不想等待作业完成，你可以在 <code>StreamExecutionEnvironment</code> 上调用 <code>executeAysnc()</code> 来触发异步作业执行。它将返回一个 <code>JobClient</code>，你可以用它与刚刚提交的作业进行通信。例如，下面是如何通过使用 <code>executeAsync()</code> 来实现 <code>execute()</code> 的语义。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">JobClient</span> <span class="n">jobClient</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">executeAsync</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

<span class="kd">final</span> <span class="n">JobExecutionResult</span> <span class="n">jobExecutionResult</span> <span class="o">=</span> <span class="n">jobClient</span><span class="o">.</span><span class="na">getJobExecutionResult</span><span class="o">(</span><span class="n">userClassloader</span><span class="o">)</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>最后这部分关于程序执行的内容对于理解 Flink 操作何时以及如何执行至关重要。所有的 Flink 程序都是懒惰地执行的。当程序的主方法被执行时，数据加载和转换不会直接发生。相反，每个操作都被创建并添加到一个数据流图(dataflow graph)中。当执行环境上的 <code>execute()</code> 调用明确触发执行时，这些操作才会被实际执行。程序是在本地执行还是在集群上执行，取决于执行环境的类型</p>
<p>惰性求值可以让您构建复杂的程序，Flink 作为一个整体规划的单元来执行。</p>
<h2 id="示例程序">示例程序</h2>
<p>下面的程序是一个完整的，工作的流媒体窗口单词计数应用程序的例子，它可以在5秒的窗口中计算来自 Web Socket 的单词。你可以复制和粘贴代码在本地运行它。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.scala._</span>
<span class="k">import</span> <span class="nn">org.apache.flink.streaming.api.windowing.time.Time</span>

<span class="k">object</span> <span class="nc">WindowWordCount</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
    <span class="k">val</span> <span class="n">text</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">socketTextStream</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">,</span> <span class="mi">9999</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">toLowerCase</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&#34;\\W+&#34;</span><span class="o">)</span> <span class="n">filter</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">}</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span><span class="o">)</span>
      <span class="o">.</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

    <span class="n">counts</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span>

    <span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="s">&#34;Window Stream WordCount&#34;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>To run the example program, start the input stream with netcat first from a terminal:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">nc -lk <span class="m">9999</span>
</code></pre></div><p>只需输入一些单词，按回车键输入一个新单词。这些词将被输入到单词计数程序中。如果你想看到大于1的计数，请在5秒内反复输入同一个单词（如果你打字没那么快，请从5秒开始增加窗口大小☺）。</p>
<h2 id="数据源">数据源</h2>
<p>源是你的程序读取其输入的地方。你可以通过使用 <code>StreamExecutionEnvironment.addSource(sourceFunction)</code> 将一个源附加到你的程序中。Flink 提供了许多预先实现的 <code>SourceFunction</code>，但是你可以通过实现非并行源的 <code>SourceFunction</code>，或者实现并行源的 <code>ParallelSourceFunction</code> 接口或扩展 <code>RichParallelSourceFunction</code> 来编写自己的自定义源。</p>
<p>有几种预定义的流源(stream sources)可以从 <code>StreamExecutionEnvironment</code> 中访问。</p>
<p>基于文件的。</p>
<ul>
<li>
<p><code>readTextFile(path)</code> - 逐行读取文本文件，即遵循 <code>TextInputFormat</code> 规范的文件，并将其作为字符串返回。</p>
</li>
<li>
<p><code>readFile(fileInputFormat, path)</code> - 根据指定的文件输入格式读取（一次）文件。</p>
</li>
<li>
<p><code>readFile(fileInputFormat, path, watchType, interval, pathFilter)</code> - 这是前面两个方法内部调用的方法。它根据给定的 <code>fileInputFormat</code> 读取路径中的文件。根据所提供的 <code>watchType</code>，这个源可能会周期性地监视(每隔 interval 毫秒)路径中的新数据(<code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>)，或者处理一次当前路径中的数据并退出(<code>FileProcessingMode.PROCESS_ONCE</code>)。使用 <code>pathFilter</code>，用户可以进一步排除被处理的文件。</p>
</li>
</ul>
<p><em>实现</em>:</p>
<p>在底层下，Flink 将文件读取过程分成两个子任务(sub-tasks)，即目录监控和数据读取。这些子任务中的每一个都是由一个单独的实体实现的。监控由一个单一的、非并行（并行度=1）的任务实现，而读取则由多个任务(task)并行运行。后者的并行度等于作业的并行度(job parallelism)。单个监控任务的作用是扫描目录（根据 <code>watchType</code> 的不同，定期或只扫描一次），找到要处理的文件，将其分割，并将这些分割的文件分配给下游的读取器。读取器是那些将读取实际数据的东西。每个分片只能由一个读取器读取，而一个读取器可以读取多个分片，一个接一个。</p>
<p><em>重要提示</em>:</p>
<ol>
<li>
<p>如果 <code>watchType</code> 被设置为 <code>FileProcessingMode.PROCESS_CONTINUOUSLY</code>，当一个文件被修改时，它的内容会被完全重新处理。这可能会打破&quot;精确地一次&rdquo;(exactly-once)的语义，因为在文件末尾追加数据会导致其所有内容被重新处理。</p>
</li>
<li>
<p>如果 <code>watchType</code> 被设置为 <code>FileProcessingMode.PROCESS_ONCE</code>，那么源就会对路径扫描一次并退出，而不会等待读取器完成对文件内容的读取。当然，读取器会继续读取，直到读取完所有文件内容。关闭源会导致在这之后不再有检查点。这可能会导致节点故障后的恢复速度变慢，因为作业(job)将从最后一个检查点开始恢复读取。</p>
</li>
</ol>
<p>基于 Socket 的:</p>
<ul>
<li><code>socketTextStream</code> - 从套接字读取。元素可以用定界符分开。</li>
</ul>
<p>基于集合的:</p>
<ul>
<li>
<p><code>fromCollection(Seq)</code> - 从 <code>Java Java.util.Collection</code> 中创建数据流。集合中的所有元素必须是相同的类型。</p>
</li>
<li>
<p><code>fromCollection(Iterator)</code> - 从迭代器中创建一个数据流。该类指定迭代器返回的元素的数据类型。</p>
</li>
<li>
<p><code>fromElements(elements: _*)</code> - 从给定的对象序列中创建一个数据流。所有对象必须是相同的类型。</p>
</li>
<li>
<p><code>fromParallelCollection(SplittableIterator)</code> - 从迭代器中并行创建数据流。该类指定了迭代器返回的元素的数据类型。</p>
</li>
<li>
<p><code>generateSequence(from, to)</code> - 在给定的区间内并行生成数字序列。</p>
</li>
</ul>
<p>自定义的:</p>
<ul>
<li><code>addSource</code> - 附加一个新的源函数。例如，要从 Apache Kafka 读取数据，你可以使用 <code>addSource(new FlinkKafkaConsumer010&lt;&gt;(...))</code>。更多细节请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/">连接器</a>。</li>
</ul>
<h2 id="数据流转换">数据流转换</h2>
<p>请参阅 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/index.html">operators</a> 以了解可用的流转换的概述。</p>
<h2 id="数据接收器">数据接收器</h2>
<p>数据接收器消耗 DataStream，并将其转发到文件、套接字、外部系统或打印。Flink 带有各种内置的输出格式，这些格式被封装在 DataStream 的操作后面。</p>
<ul>
<li>
<p><code>writeAsText()</code> / <code>TextOutputFormat</code> - 将元素逐行写入字符串。这些字符串是通过调用每个元素的 <code>toString()</code> 方法获得的。</p>
</li>
<li>
<p><code>writeAsCsv(...)</code> / <code>CsvOutputFormat</code> - 将元组写成逗号分隔的值文件。行和字段定界符是可配置的。每个字段的值来自对象的 <code>toString()</code> 方法。</p>
</li>
<li>
<p><code>print()</code> / <code>printToErr()</code> - 将每个元素的 <code>toString()</code> 值打印在标准输出/标准错误流上。可以选择提供一个前缀(msg)，这个前缀被添加到输出中。这可以帮助区分不同的 <code>print</code> 调用。如果并行度大于1，输出也将被预置为产生输出的任务(task)的标识符。</p>
</li>
<li>
<p><code>writeUsingOutputFormat()</code> / <code>FileOutputFormat</code> - 用于自定义文件输出的方法和基类。支持自定义对象到字节的转换。</p>
</li>
<li>
<p><code>writeToSocket</code> - 根据 <code>SerializationSchema</code> 将元素写入 socket。</p>
</li>
<li>
<p>addSink - 调用一个自定义的 sink 函数。Flink 捆绑了连接其他系统（如 Apache Kafka）的连接器，这些连接器被实现为 sink 函数。</p>
</li>
</ul>
<p>请注意，DataStream 上的 <code>write*()</code> 方法主要是为了调试的目的。它们不参与 Flink 的检查点，这意味着这些函数通常具有最多一次(at-least-once)的语义。数据冲洗到目标系统取决于 <code>OutputFormat</code> 的实现。这意味着并非所有发送到 <code>OutputFormat</code> 的元素都会立即在目标系统中显示出来。另外，在失败的情况下，这些记录可能会丢失。</p>
<p>为了可靠地、精确地一次性将流传送到文件系统中，请使用 <code>flink-connector-filesystem</code>。此外，通过 <code>.addSink(...)</code> 方法的自定义实现可以参与 Flink 的检查点，以实现精确的一次语义。</p>
<h2 id="迭代">迭代</h2>
<p>迭代流程序实现了一个步骤函数，并将其嵌入到 <code>IterativeStream</code> 中。由于 DataStream 程序可能永远不会结束，所以没有最大的迭代次数。相反，你需要指定流的哪一部分被馈入到迭代中，哪一部分使用 <code>split</code> 转换或 <code>filter</code> 转发到下游。在这里，我们展示了一个迭代的例子，其中主体（重复计算的部分）是一个简单的 <code>map</code> 转换，而反馈回来的元素是通过使用 <code>filter</code> 转发到下游的元素来区分的。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">iteratedStream</span> <span class="k">=</span> <span class="n">someDataStream</span><span class="o">.</span><span class="n">iterate</span><span class="o">(</span>
  <span class="n">iteration</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">iterationBody</span> <span class="k">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="cm">/*</span><span class="cm"> this is executed many times </span><span class="cm">*/</span><span class="o">)</span>
    <span class="o">(</span><span class="n">iterationBody</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="cm">/*</span><span class="cm"> one part of the stream </span><span class="cm">*/</span><span class="o">)</span><span class="o">,</span> <span class="n">iterationBody</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="cm">/*</span><span class="cm"> some other part of the stream </span><span class="cm">*/</span><span class="o">)</span><span class="o">)</span>
<span class="o">}</span><span class="o">)</span>
</code></pre></div><p>例如，这里的程序是从一系列整数中连续减去1，直到它们达到零。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">someIntegers</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">generateSequence</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">)</span>

<span class="k">val</span> <span class="n">iteratedStream</span> <span class="k">=</span> <span class="n">someIntegers</span><span class="o">.</span><span class="n">iterate</span><span class="o">(</span>
  <span class="n">iteration</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">minusOne</span> <span class="k">=</span> <span class="n">iteration</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">stillGreaterThanZero</span> <span class="k">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">lessThanZero</span> <span class="k">=</span> <span class="n">minusOne</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">(</span><span class="n">stillGreaterThanZero</span><span class="o">,</span> <span class="n">lessThanZero</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">)</span>
</code></pre></div><h2 id="执行参数">执行参数</h2>
<p><code>StreamExecutionEnvironment</code> 包含了 <code>ExecutionConfig</code>，它允许为运行时设置作业特定(job specific)的配置值。</p>
<p>请参考<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/execution_configuration.html">执行配置</a>，了解大多数参数的解释。这些参数专门与 DataStream API 有关。</p>
<ul>
<li><code>setAutoWatermarkInterval(long milliseconds)</code>: 设置自动发射水印的时间间隔。你可以通过 <code>long getAutoWatermarkInterval()</code> 来获取当前值。</li>
</ul>
<h3 id="容错">容错</h3>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/checkpointing.html">状态和检查点</a>介绍了如何启用和配置 Flink 的检查点机制。</p>
<h3 id="控制延迟">控制延迟</h3>
<p>默认情况下，元素不会在网络上逐一传输（会造成不必要的网络流量），而是被缓冲。缓冲区（实际在机器之间传输）的大小可以在 Flink 配置文件中设置。虽然这种方法有利于优化吞吐量，但当传入的数据流速度不够快时，会造成延迟问题。为了控制吞吐量和延迟，你可以在执行环境上（或者在单个 operator 上）使用 <code>env.setBufferTimeout(timeoutMillis)</code> 来设置缓冲区填满的最大等待时间。过了这个时间，即使缓冲区没有满，也会自动发送。该超时的默认值为 100 ms。</p>
<p>使用方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span><span class="k">:</span> <span class="kt">LocalStreamEnvironment</span> <span class="o">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span>
<span class="n">env</span><span class="o">.</span><span class="n">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">)</span>

<span class="n">env</span><span class="o">.</span><span class="n">generateSequence</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">)</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">myMap</span><span class="o">)</span><span class="o">.</span><span class="n">setBufferTimeout</span><span class="o">(</span><span class="n">timeoutMillis</span><span class="o">)</span>
</code></pre></div><p>为了最大限度地提高吞吐量，设置 <code>setBufferTimeout(-1)</code>，这将消除超时，缓冲区只有在满时才会被刷新。为了最大限度地减少延迟，将超时设置为接近0的值（例如5或10毫秒）。应该避免缓冲区超时为0，因为它会导致严重的性能下降。</p>
<h2 id="调试">调试</h2>
<p>在分布式集群中运行一个流程序之前，最好先确保实现的算法能够按照预期的方式运行。因此，实现数据分析程序通常是一个检查结果、调试和改进的渐进过程。</p>
<p>Flink 提供了一些功能，通过支持 IDE 内的本地调试、测试数据的注入和结果数据的收集，大大简化了数据分析程序的开发过程。本节给出一些提示，如何简化 Flink 程序的开发。</p>
<h3 id="本地执行环境">本地执行环境</h3>
<p><code>LocalStreamEnvironment</code> 在它创建的同一个 JVM 进程中启动 Flink 系统。如果你从 IDE 中启动 <code>LocalEnvironment</code>，你可以在代码中设置断点，轻松调试你的程序。</p>
<p><code>LocalEnvironment</code> 的创建和使用方法如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">(</span><span class="o">)</span>

<span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="cm">/*</span><span class="cm"> some source </span><span class="cm">*/</span><span class="o">)</span>
<span class="c1">// build your program
</span><span class="c1"></span>
<span class="n">env</span><span class="o">.</span><span class="n">execute</span><span class="o">(</span><span class="o">)</span>
</code></pre></div><h3 id="收集数据源">收集数据源</h3>
<p>Flink 提供了特殊的数据源，这些数据源由 Java 集合支持，以方便测试。一旦程序被测试，源和接收器就可以很容易地被从外部系统读取/写入的源和接收器所替代。</p>
<p>集合数据源的使用方法如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">createLocalEnvironment</span><span class="o">(</span><span class="o">)</span>

<span class="c1">// 从元素列表中创建一个 DataStream
</span><span class="c1"></span><span class="k">val</span> <span class="n">myInts</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromElements</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="c1">// 从任何集合中创建一个 DataStream
</span><span class="c1"></span><span class="k">val</span> <span class="n">data</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="k">val</span> <span class="n">myTuples</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>

<span class="c1">// 从迭代器中创建一个 DataStream
</span><span class="c1"></span><span class="k">val</span> <span class="n">longIt</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="k">val</span> <span class="n">myLongs</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">longIt</span><span class="o">)</span>
</code></pre></div><p>注：目前，集合数据源要求数据类型和迭代器实现 <code>Serializable</code>。此外，集合数据源不能并行执行( parallelism = 1)。</p>
<h3 id="迭代器数据接收器">迭代器数据接收器</h3>
<p>Flink 还提供了一个收集 DataStream 结果的接收器(sink)，用于测试和调试目的。它的使用方法如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">org.apache.flink.streaming.experimental.DataStreamUtils</span>
<span class="k">import</span> <span class="nn">scala.collection.JavaConverters.asScalaIteratorConverter</span>

<span class="k">val</span> <span class="n">myResult</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="k">val</span> <span class="n">myOutput</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DataStreamUtils</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="n">myResult</span><span class="o">.</span><span class="n">javaStream</span><span class="o">)</span><span class="o">.</span><span class="n">asScala</span>
</code></pre></div><p>注意：<code>flink-streaming-contrib</code> 模块从 Flink 1.5.0 中移除。它的类被移到 <code>flink-streaming-java</code> 和 <code>flink-streaming-scala</code> 中。</p>
<h2 id="下一步怎么走">下一步怎么走？</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/index.html">运算符</a>: 规范可用的流式运算符。</li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html">事件时间</a>: 介绍 Flink 的时间概念。</li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/index.html">状态和容错</a>: 解释如何开发有状态的应用。</li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/index.html">连接器</a>: 描述可用的输入和输出连接器。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Flink 官方文档" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/datastream-api" term="datastream-api" label="DataStream API" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Generating Watermarks]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-21-generating-watermarks/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-event-time/?utm_source=atom_feed" rel="related" type="text/html" title="Event Time" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-flink-datastream-api-programming-guide/?utm_source=atom_feed" rel="related" type="text/html" title="Flink Datastream API 编程指南" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-working-with-state/?utm_source=atom_feed" rel="related" type="text/html" title="使用状态" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-built-in-watermark-generators/?utm_source=atom_feed" rel="related" type="text/html" title="内置的水印生成器" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-state-and-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="状态和容错性" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-21-generating-watermarks/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-21T00:00:00+08:00</published>
            <updated>2020-08-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Generating Watermarks</blockquote><h2 id="生成水印httpsciapacheorgprojectsflinkflink-docs-release-111devevent_timestamps_watermarkshtml"><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html">生成水印</a></h2>
<p>在本节中，您将了解 Flink 提供的 API，用于处理事件时间时间戳和水印。关于事件时间、处理时间和摄取时间的介绍，请参考<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html">事件时间的介绍</a>。</p>
<h3 id="水印策略介绍">水印策略介绍</h3>
<p>为了使用事件时间，Flink 需要知道事件的时间戳，这意味着流中的每个元素都需要分配其事件时间戳(event timestamp)。这通常是通过使用 <code>TimestampAssigner</code> 从元素中的某个字段访问/提取时间戳(timestamp)来完成的。</p>
<p>时间戳分配与生成水印是同步进行的，水印告诉系统事件时间的进展。你可以通过指定一个 <code>WatermarkGenerator</code> 来配置。</p>
<p>Flink API 期望一个 <code>WatermarkStrategy</code>，其中包含一个 <code>TimestampAssigner</code> 和 <code>WatermarkGenerator</code>。一些常见的策略作为 <code>WatermarkStrategy</code> 上的静态方法是开箱即用的，但用户也可以在需要时建立自己的策略。</p>
<p>为了完整起见，这里是接口:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">WatermarkStrategy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">TimestampAssignerSupplier</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">,</span> <span class="n">WatermarkGeneratorSupplier</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">{</span>

    <span class="cm">/**
</span><span class="cm">     * Instantiates a {@link TimestampAssigner} for assigning timestamps according to this
</span><span class="cm">     * strategy.
</span><span class="cm">     */</span>
    <span class="nd">@Override</span>
    <span class="n">TimestampAssigner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">createTimestampAssigner</span><span class="o">(</span><span class="n">TimestampAssignerSupplier</span><span class="o">.</span><span class="na">Context</span> <span class="n">context</span><span class="o">)</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Instantiates a WatermarkGenerator that generates watermarks according to this strategy.
</span><span class="cm">     */</span>
    <span class="nd">@Override</span>
    <span class="n">WatermarkGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">createWatermarkGenerator</span><span class="o">(</span><span class="n">WatermarkGeneratorSupplier</span><span class="o">.</span><span class="na">Context</span> <span class="n">context</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>如前所述，你通常不会自己实现这个接口，而是使用 <code>WatermarkStrategy</code> 上的静态帮助方法来实现常见的水印策略，或者将自定义的 <code>TimestampAssigner</code> 与 <code>WatermarkGenerator</code> 捆绑在一起。例如，要使用有界无序水印和 lambda 函数作为时间戳分配器，你可以使用这个方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">WatermarkStrategy</span>
  <span class="o">.</span><span class="n">forBoundedOutOfOrderness</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">String</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">ofSeconds</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withTimestampAssigner</span><span class="o">(</span><span class="k">new</span> <span class="nc">SerializableTimestampAssigner</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">String</span><span class="o">)</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">extractTimestamp</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span><span class="o">,</span> <span class="n">recordTimestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">_1</span>
  <span class="o">}</span><span class="o">)</span>
</code></pre></div><p>(在这里使用 Scala Lambdas 目前是行不通的，因为 Scala 很笨，很难支持这个。#fus)</p>
<p>指定一个 <code>TimestampAssigner</code> 是可选的，在大多数情况下，你其实并不想指定一个。例如，当使用 Kafka 或 Kinesis 时，你会直接从 Kafka/Kinesis 记录中获取时间戳。</p>
<p>我们将在后面的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html#writing-watermarkgenerators">Writing WatermarkGenerator</a>中查看 <code>WatermarkGenerator</code> 接口。</p>
<p>注意：时间戳和水印都被指定为自 1970-01-01T00:00:00Z 的 Java 纪元以来的毫秒。</p>
<h3 id="使用水印策略">使用水印策略</h3>
<p>在 Flink 应用中，有两个地方可以使用 <code>WatermarkStrategy</code>。1）直接在源上使用，2）在非源操作后使用。</p>
<p>第一个选项是比较好的，因为它允许源在水印逻辑中利用关于碎片/分区/分割的知识。源通常可以更精细地跟踪水印，源产生的整体水印也会更准确。直接在源上指定 <code>WatermarkStrategy</code> 通常意味着你必须使用源的特定接口/请参阅 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html#watermark-strategies-and-the-kafka-connector">Watermark Strategies 和 Kafka Connector</a>，以了解在 Kafka Connector 上如何工作，以及关于每个分区水印如何工作的更多细节。</p>
<p>第二个选项（在任意操作后设置 <code>WatermarkStrategy</code>）只应在不能直接在源上设置策略时使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">env</span> <span class="k">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="n">getExecutionEnvironment</span>
<span class="n">env</span><span class="o">.</span><span class="n">setStreamTimeCharacteristic</span><span class="o">(</span><span class="nc">TimeCharacteristic</span><span class="o">.</span><span class="nc">EventTime</span><span class="o">)</span>

<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">MyEvent</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readFile</span><span class="o">(</span>
         <span class="n">myFormat</span><span class="o">,</span> <span class="n">myFilePath</span><span class="o">,</span> <span class="nc">FileProcessingMode</span><span class="o">.</span><span class="nc">PROCESS_CONTINUOUSLY</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span>
         <span class="nc">FilePathFilter</span><span class="o">.</span><span class="n">createDefaultFilter</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>

<span class="k">val</span> <span class="n">withTimestampsAndWatermarks</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">MyEvent</span><span class="o">]</span> <span class="k">=</span> <span class="n">stream</span>
        <span class="o">.</span><span class="n">filter</span><span class="o">(</span> <span class="k">_</span><span class="o">.</span><span class="n">severity</span> <span class="o">==</span> <span class="nc">WARNING</span> <span class="o">)</span>
        <span class="o">.</span><span class="n">assignTimestampsAndWatermarks</span><span class="o">(</span><span class="o">&lt;</span><span class="n">watermark</span> <span class="n">strategy</span><span class="o">&gt;</span><span class="o">)</span>

<span class="n">withTimestampsAndWatermarks</span>
        <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span> <span class="k">_</span><span class="o">.</span><span class="n">getGroup</span> <span class="o">)</span>
        <span class="o">.</span><span class="n">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="n">seconds</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="n">reduce</span><span class="o">(</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">)</span>
        <span class="o">.</span><span class="n">addSink</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
</code></pre></div><p>以这种方式使用 <code>WatermarkStrategy</code>，可以获取一个流并生成一个带有时间戳元素和水印的新流。如果原始流已经有时间戳和/或水印了，时间戳分配器就会覆盖它们。</p>
<h3 id="处理闲置源">处理闲置源</h3>
<p>如果其中一个输入分割/分区/碎片在一段时间内没有携带事件，这意味着 <code>WatermarkGenerator</code> 也没有得到任何新的信息来作为水印的基础。我们称之为空闲输入或空闲源。这是一个问题，因为有可能发生你的一些分区仍然携带事件。在这种情况下，水印将被保留下来，因为它是作为所有不同的并行水印的最小值计算的。</p>
<p>为了处理这个问题，你可以使用 <code>WatermarkStrategy</code> 来检测空闲，并将一个输入标记为空闲。<code>WatermarkStrategy</code> 为此提供了一个方便的助手。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">WatermarkStrategy</span>
  <span class="o">.</span><span class="n">forBoundedOutOfOrderness</span><span class="o">[</span><span class="o">(</span><span class="kt">Long</span>, <span class="kt">String</span><span class="o">)</span><span class="o">]</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">ofSeconds</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withIdleness</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">ofMinutes</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="o">)</span>
</code></pre></div><h3 id="编写水印生成器">编写水印生成器</h3>
<p>时间戳分配器(TimestampAssigner)是一个从事件中提取字段的简单函数，因此我们不需要详细研究它们。而 <code>WatermarkGenerator</code> 的编写就比较复杂了，我们将在接下来的两节中看如何做。这就是 <code>WatermarkGenerator</code> 的接口。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * The {@code WatermarkGenerator} generates watermarks either based on events or
</span><span class="cm"> * periodically (in a fixed interval).
</span><span class="cm"> *
</span><span class="cm"> * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This WatermarkGenerator subsumes the previous distinction between the
</span><span class="cm"> * {@code AssignerWithPunctuatedWatermarks} and the {@code AssignerWithPeriodicWatermarks}.
</span><span class="cm"> */</span>
<span class="nd">@Public</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">WatermarkGenerator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="cm">/**
</span><span class="cm">     * Called for every event, allows the watermark generator to examine and remember the
</span><span class="cm">     * event timestamps, or to emit a watermark based on the event itself.
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">onEvent</span><span class="o">(</span><span class="n">T</span> <span class="n">event</span><span class="o">,</span> <span class="kt">long</span> <span class="n">eventTimestamp</span><span class="o">,</span> <span class="n">WatermarkOutput</span> <span class="n">output</span><span class="o">)</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * Called periodically, and might emit a new watermark, or not.
</span><span class="cm">     *
</span><span class="cm">     * &lt;p&gt;The interval in which this method is called and Watermarks are generated
</span><span class="cm">     * depends on {@link ExecutionConfig#getAutoWatermarkInterval()}.
</span><span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">onPeriodicEmit</span><span class="o">(</span><span class="n">WatermarkOutput</span> <span class="n">output</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>有两种不同风格的水印生成器：周期性和打点式。</p>
<p>周期性生成器通常通过 <code>onEvent()</code> 观察到传入的事件，然后当框架调用 <code>onPeriodicEmit()</code> 时，发射水印。</p>
<p>标点式生成器会观察 <code>onEvent()</code> 中的事件，并等待流中携带水印信息的特殊标记事件或标点。当它看到这些事件之一时，就会立即发出一个水印。通常，标点生成器不会从 <code>onPeriodicEmit()</code> 发出水印。</p>
<p>接下来我们将看看如何实现每种样式的生成器。</p>
<h4 id="编写周期性水印生成器">编写周期性水印生成器</h4>
<p>周期性生成器观察流事件并周期性地生成水印（可能取决于流元素，或者纯粹基于处理时间）。</p>
<p>生成水印的间隔（每n毫秒）通过 <code>ExecutionConfig.setAutoWatermarkInterval(...)</code> 来定义。每次都会调用生成器的 <code>onPeriodicEmit()</code> 方法，如果返回的水印是非空的，并且大于前一个水印，就会发出一个新的水印。</p>
<p>这里我们展示了两个使用周期性水印生成器的简单例子。请注意，Flink 提供了 <code>BoundedOutfOrdernessWatermarks</code>，这是一个 <code>WatermarkGenerator</code>，它的工作原理与下面所示的 <code>BoundedOutfOrdernessGenerator</code> 类似。你可以在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamp_extractors.html#assigners-allowing-a-fixed-amount-of-lateness">这里</a>阅读关于如何使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> This generator generates watermarks assuming that elements arrive out of order,
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> but only to a certain degree. The latest elements for a certain timestamp t will arrive
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> at most n milliseconds after the earliest elements for timestamp t.
</span><span class="cm"> </span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">BoundedOutOfOrdernessGenerator</span> <span class="k">extends</span> <span class="nc">AssignerWithPeriodicWatermarks</span><span class="o">[</span><span class="kt">MyEvent</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">maxOutOfOrderness</span> <span class="k">=</span> <span class="mi">3500L</span> <span class="c1">// 3.5 seconds
</span><span class="c1"></span>
    <span class="k">var</span> <span class="n">currentMaxTimestamp</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="k">_</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">MyEvent</span><span class="o">,</span> <span class="n">eventTimestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="n">currentMaxTimestamp</span> <span class="k">=</span> <span class="n">max</span><span class="o">(</span><span class="n">eventTimestamp</span><span class="o">,</span> <span class="n">currentMaxTimestamp</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">onPeriodicEmit</span><span class="o">(</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// emit the watermark as current highest timestamp minus the out-of-orderness bound
</span><span class="c1"></span>        <span class="n">output</span><span class="o">.</span><span class="n">emitWatermark</span><span class="o">(</span><span class="k">new</span> <span class="nc">Watermark</span><span class="o">(</span><span class="n">currentMaxTimestamp</span> <span class="o">-</span> <span class="n">maxOutOfOrderness</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*</span><span class="cm">*</span><span class="cm">
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> This generator generates watermarks that are lagging behind processing time by a fixed amount.
</span><span class="cm"> </span><span class="cm">*</span><span class="cm"> It assumes that elements arrive in Flink after a bounded delay.
</span><span class="cm"> </span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">TimeLagWatermarkGenerator</span> <span class="k">extends</span> <span class="nc">AssignerWithPeriodicWatermarks</span><span class="o">[</span><span class="kt">MyEvent</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">maxTimeLag</span> <span class="k">=</span> <span class="mi">5000L</span> <span class="c1">// 5 seconds
</span><span class="c1"></span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">MyEvent</span><span class="o">,</span> <span class="n">eventTimestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// don&#39;t need to do anything because we work on processing time
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">onPeriodicEmit</span><span class="o">(</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="n">output</span><span class="o">.</span><span class="n">emitWatermark</span><span class="o">(</span><span class="k">new</span> <span class="nc">Watermark</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span> <span class="n">maxTimeLag</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h4 id="编写一个标点水印生成器">编写一个标点水印生成器</h4>
<p>标点水印生成器将观察事件流，每当它看到一个携带水印信息的特殊元素时，就会发出一个水印。</p>
<p>这就是如何实现一个标点水印生成器，每当一个事件表明它携带某个标记时，它就会发射一个水印。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">PunctuatedAssigner</span> <span class="k">extends</span> <span class="nc">AssignerWithPunctuatedWatermarks</span><span class="o">[</span><span class="kt">MyEvent</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">onEvent</span><span class="o">(</span><span class="n">element</span><span class="k">:</span> <span class="kt">MyEvent</span><span class="o">,</span> <span class="n">eventTimestamp</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="n">hasWatermarkMarker</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">output</span><span class="o">.</span><span class="n">emitWatermark</span><span class="o">(</span><span class="k">new</span> <span class="nc">Watermark</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="n">getWatermarkTimestamp</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">onPeriodicEmit</span><span class="o">(</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
        <span class="c1">// don&#39;t need to do anything because we emit in reaction to events above
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>注：可以对每个事件生成一个水印。然而，由于每个水印都会引起下游的一些计算，因此过多的水印会降低性能。</p>
<h3 id="水印策略和-kafka-连接器">水印策略和 Kafka 连接器</h3>
<p>当使用 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/kafka.html">Apache Kafka</a> 作为数据源时，每个 Kafka 分区可能有一个简单的事件时间模式（升序时间戳或有界失序）。然而，当消耗来自 Kafka 的流时，多个分区经常会被并行消耗，交织来自分区的事件，并破坏每个分区的模式（这是 Kafka 的消费者客户端的固有工作方式）。</p>
<p>在这种情况下，你可以使用 Flink 的 Kafka-partition-aware 水印生成功能。使用该功能，在 Kafka 消费者内部，按 Kafka 分区生成水印，每个分区水印的合并方式与流洗牌的水印合并方式相同。</p>
<p>例如，如果每个 Kafka 分区的事件时间戳是严格的升序，那么用<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamp_extractors.html#assigners-with-ascending-timestamps">升序时间戳水印生成器</a>生成每个分区的水印，会得到完美的整体水印。请注意，我们在示例中并没有提供 TimestampAssigner，而是使用 Kafka 记录本身的时间戳。</p>
<p>下面的插图展示了如何使用 per-Kafka-partition 水印生成器，以及在这种情况下水印如何通过流式数据流传播。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">kafkaSource</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FlinkKafkaConsumer</span><span class="o">[</span><span class="kt">MyType</span><span class="o">]</span><span class="o">(</span><span class="s">&#34;myTopic&#34;</span><span class="o">,</span> <span class="n">schema</span><span class="o">,</span> <span class="n">props</span><span class="o">)</span>
<span class="n">kafkaSource</span><span class="o">.</span><span class="n">assignTimestampsAndWatermarks</span><span class="o">(</span>
  <span class="nc">WatermarkStrategy</span>
    <span class="o">.</span><span class="n">forBoundedOutOfOrderness</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">ofSeconds</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>

<span class="k">val</span> <span class="n">stream</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">MyType</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="n">kafkaSource</span><span class="o">)</span>
</code></pre></div><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/parallel_kafka_watermarks.svg" alt="img"></p>
<h3 id="运算符如何处理水印">运算符如何处理水印</h3>
<p>作为一般规则，运算符(operator)在向下游转发一个给定的水印之前，需要对其进行完全处理。例如，<code>WindowOperator</code> 将首先评估所有应该被发射的窗口，只有在产生所有由水印触发的输出之后，水印本身才会被发送到下游。换句话说，所有因发生水印而产生的元素将在水印之前被发射。</p>
<p>同样的规则也适用于 <code>TwoInputStreamOperator</code>。然而，在这种情况下，运算符的当前水印被定义为其两个输入的最小值。</p>
<p>这种行为的细节由 <code>OneInputStreamOperator#processWatermark</code>、<code>TwoInputStreamOperator#processWatermark1</code> 和 <code>TwoInputStreamOperator#processWatermark2</code> 方法的实现来定义。</p>
<h3 id="废弃的-assignerwithperiodicwatermarks-和-assignerwithpunctuatedwatermarks-方法">废弃的 AssignerWithPeriodicWatermarks 和 AssignerWithPunctuatedWatermarks 方法</h3>
<p>在引入当前的 <code>WatermarkStrategy</code>、<code>TimestampAssigner</code> 和 <code>WatermarkGenerator</code> 抽象之前，Flink 使用了 <code>AssignerWithPeriodicWatermarks</code> 和 <code>AssignerWithPeriodicWatermarks</code>。你仍然会在 API 中看到它们，但建议使用新的接口，因为它们提供了更清晰的分离关注点，也统一了水印生成的周期和标点样式。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Flink 官方文档" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/datastream-api" term="datastream-api" label="DataStream API" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/event-time" term="event-time" label="Event Time" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[内置的水印生成器]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-21-built-in-watermark-generators/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-event-time/?utm_source=atom_feed" rel="related" type="text/html" title="Event Time" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-flink-datastream-api-programming-guide/?utm_source=atom_feed" rel="related" type="text/html" title="Flink Datastream API 编程指南" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-generating-watermarks/?utm_source=atom_feed" rel="related" type="text/html" title="Generating Watermarks" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-working-with-state/?utm_source=atom_feed" rel="related" type="text/html" title="使用状态" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-21-state-and-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="状态和容错性" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-21-built-in-watermark-generators/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-21T00:00:00+08:00</published>
            <updated>2020-08-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Builtin Watermark Generators</blockquote><h2 id="内置水印生成器httpsciapacheorgprojectsflinkflink-docs-release-111devevent_timestamp_extractorshtml"><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamp_extractors.html">内置水印生成器</a></h2>
<p>正如在 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_timestamps_watermarks.html">Generating Watermarks</a> 一文中所描述的，Flink 提供了抽象，允许程序员分配自己的时间戳和发射自己的水印。更具体地说，可以通过实现 WatermarkGenerator 接口来实现。</p>
<p>为了进一步简化此类任务的编程工作，Flink 自带了一些预先实现的时间戳分配器。本节提供了它们的列表。除了它们的开箱即用的功能外，它们的实现可以作为自定义实现的范例。</p>
<h2 id="单调地增加时间戳">单调地增加时间戳</h2>
<p>周期性水印生成的最简单的特殊情况是当给定源任务(task)看到的时间戳以升序出现时。在这种情况下，当前的时间戳总是可以作为水印，因为不会有更早的时间戳到达。</p>
<p>请注意，只需要每个并行数据源任务的时间戳是升序的。例如，如果在一个特定的设置中，一个 Kafka 分区被一个并行数据源实例读取，那么只需要在每个 Kafka 分区中时间戳是升序的。每当并行流被洗牌、联合、连接(connected)或合并时，Flink 的水印合并机制都会生成正确的水印。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">WatermarkStrategy</span><span class="o">.</span><span class="n">forMonotonousTimestamps</span><span class="o">(</span><span class="o">)</span>
</code></pre></div><h2 id="固定的延迟量">固定的延迟量</h2>
<p>周期性水印生成的另一个例子是，当水印滞后于流中看到的最大（事件时间）时间戳的固定时间量时。这种情况涵盖了预先知道流中可能遇到的最大延迟的场景，例如，当创建一个包含时间戳分布在固定时间段内的元素的自定义源进行测试时。对于这些情况，Flink 提供了 BoundedOutOfOrdernessWatermarks 生成器，它以 maxOutOfOrderness 作为参数，即在计算给定窗口的最终结果时，一个元素在被忽略之前允许迟到的最大时间。Lateness 对应于 <em>t - t_w</em> 的结果，其中 <em>t</em> 是一个元素的（事件-时间）时间戳，<em>t_w</em> 是之前的水印。如果 <em>lateness &gt; 0</em>，那么该元素被认为是迟到的，并且默认情况下，在计算其对应窗口的作业结果时被忽略。请参阅关于允许延迟的文档，以获得更多关于处理迟到元素的信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">WatermarkStrategy</span>
  <span class="o">.</span><span class="n">forBoundedOutOfOrderness</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="n">ofSeconds</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="o">)</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" term="flink-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3" label="Flink 官方文档" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/datastream-api" term="datastream-api" label="DataStream API" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Flink 的架构]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-20-flink-architecture/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语表" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-timely-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="及时的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-stateful-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="有状态的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-concepts-overview/?utm_source=atom_feed" rel="related" type="text/html" title="概念" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-20-flink-architecture/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-20T00:00:00+08:00</published>
            <updated>2020-08-20T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Flink Architecture</blockquote><p>Flink 是一个分布式系统，为了执行流式应用，需要对计算资源进行有效的分配和管理。它集成了所有常见的集群资源管理器，如 <a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/YARN.html">Hadoop YARN</a>、<a href="https://mesos.apache.org/">Apache Mesos</a> 和 <a href="https://kubernetes.io/">Kubernetes</a>，但也可以设置为独立集群甚至作为库运行。</p>
<p>本节包含 Flink 架构的概述，并描述了其主要组件如何交互执行应用程序并从故障中恢复。</p>
<h2 id="flink-集群的解剖">Flink 集群的解剖</h2>
<p>Flink 运行时由两种类型的进程组成：一个 JobManager 和一个或多个 TaskManagers。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/processes.svg" alt="img"></p>
<p>客户端不是运行时和程序执行的一部分，而是用来准备并向 JobManager 发送数据流。之后，客户端可以断开连接（分离模式），或者保持连接以接收进度报告（附加模式）。客户端既可以作为触发执行的 Java/Scala 程序的一部分运行，也可以在命令行进程 <code>./bin/flink run</code> &hellip;中运行。</p>
<p>JobManager 和 TaskManagers 可以以各种方式启动：直接在机器上作为一个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/cluster_setup.html">独立的集群</a>，在容器中，或由 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/yarn_setup.html">YARN</a> 或 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/deployment/mesos.html">Mesos</a> 等资源框架管理。TaskManagers 连接到 JobManagers，宣布自己可用，并被分配工作。</p>
<h3 id="jobmanager">JobManager</h3>
<p>JobManager 有一些与协调 Flink 应用的分布式执行有关的职责：它决定何时安排下一个任务（或一组任务），对已完成的任务或执行失败作出反应，协调检查点，并协调失败时的恢复等。这个过程由三个不同的组件组成。</p>
<ul>
<li><strong>资源管理器(ResourceManager)</strong></li>
</ul>
<p>ResourceManager 负责 Flink 集群中的资源去/分配和供应&ndash;它管理任务槽(<strong>task slots</strong>)，任务槽是 Flink 集群中资源调度的单位（见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/flink-architecture.html#taskmanagers">TaskManagers</a>）。Flink 针对不同的环境和资源提供者（如 YARN、Mesos、Kubernetes 和独立部署）实现了多个 ResourceManagers。在独立设置中，ResourceManager 只能分配可用的 TaskManagers 的槽位，不能自行启动新的 TaskManagers。</p>
<ul>
<li><strong>Dispatcher</strong></li>
</ul>
<p>Dispatcher 提供了一个 REST 接口来提交 Flink 应用执行，并为每个提交的作业启动一个新的 JobMaster。它还运行 Flink WebUI 来提供作业执行的信息。</p>
<ul>
<li><strong>JobMaster</strong></li>
</ul>
<p>一个 JobMaster 负责管理一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#logical-graph">JobGraph</a> 的执行。在一个 Flink 集群中可以同时运行多个作业，每个作业都有自己的 JobMaster。</p>
<p>总是至少有一个 JobManager。一个高可用性设置可能有多个 JobManagers，其中一个总是领导者，其他的是备用的（见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/jobmanager_high_availability.html">高可用性（HA）</a>）。</p>
<h3 id="taskmanagers">TaskManagers</h3>
<p>任务管理器（TaskManagers）（也叫 worker）执行数据流的任务，并缓冲和交换数据流。</p>
<p>必须始终有至少一个TaskManager。TaskManager中资源调度的最小单位是一个任务槽。一个任务管理器中任务槽的数量表示并发处理任务的数量。请注意，一个任务槽中可以执行多个操作者（参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/flink-architecture.html#tasks-and-operator-chains">Tasks 和 Operator 链</a>）。</p>
<h3 id="tasks-和-operator-chains">Tasks 和 Operator Chains</h3>
<p>对于分布式执行，Flink 将操作者的子任务链成任务。每个任务由一个线程执行。将运算符一起链入任务是一种有用的优化：它减少了线程到线程的交接和缓冲的开销，增加了整体的吞吐量，同时降低了延迟。链锁行为可以配置，详情请看<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/#task-chaining-and-resource-groups">chaining 文档</a>。</p>
<p>下图中的示例数据流是以五个子任务，也就是五个并行线程来执行的。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/tasks_chains.svg" alt="img"></p>
<h2 id="任务槽和资源task-slots-和-resources">任务槽和资源(Task Slots 和 Resources)</h2>
<p>每个 worker（TaskManager）都是一个 JVM 进程，可以在单独的线程中执行一个或多个子任务。为了控制一个任务管理器接受多少任务，它有所谓的任务槽（至少一个）。</p>
<p>每个任务槽代表任务管理器的一个固定的资源子集。例如，一个有三个槽的任务管理器，将把其管理内存的1/3奉献给每个槽。槽位资源意味着一个子任务不会与其他任务的子任务争夺管理内存，而是拥有一定量的预留管理内存。需要注意的是，这里并没有发生 CPU 隔离，目前插槽只是将任务的管理内存分开。</p>
<p>通过调整任务槽的数量，用户可以定义子任务之间的隔离方式。每个任务管理器有一个插槽意味着每个任务组都在一个单独的 JVM 中运行（例如可以在一个单独的容器中启动）。拥有多个插槽意味着更多的子任务共享同一个 JVM。同一 JVM 中的任务共享 TCP 连接（通过多路复用）和心跳消息。它们还可以共享数据集和数据结构，从而减少每个任务的开销。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/tasks_slots.svg" alt="img"></p>
<p>默认情况下，Flink 允许子任务共享槽，即使它们是不同任务的子任务，只要它们来自同一个作业。其结果是，一个槽可以容纳整个作业的流水线。允许这种槽位共享有两个主要好处。</p>
<ul>
<li>
<p>一个 Flink 集群需要的任务槽数量正好与作业中使用的最高并行度相同。不需要计算一个程序总共包含多少个任务（具有不同的并行度）。</p>
</li>
<li>
<p>更容易获得更好的资源利用率。如果没有槽位共享，非密集型的 <code>source/map()</code> 子任务和资源密集型的 window 子任务一样，会阻塞很多资源。有了槽位共享，在我们的例子中，将基础并行度从2个增加到6个，就会产生槽位资源的充分利用，同时确保重度子任务在 TaskManager 中公平分配。</p>
</li>
</ul>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/slot_sharing.svg" alt="img"></p>
<h2 id="flink-应用执行">Flink 应用执行</h2>
<p>Flink 应用程序是任何从其 <code>main()</code> 方法中生成一个或多个 Flink 作业的用户程序。这些作业的执行可以发生在本地 JVM（LocalEnvironment）中，也可以发生在多台机器的远程集群设置（RemoteEnvironment）中。对于每个程序，ExecutionEnvironment 提供了控制作业执行的方法（例如设置并行性）和与外界交互的方法（参见 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#anatomy-of-a-flink-program">Anatomy of a Flink Program</a>）。</p>
<p>Flink 应用的作业可以提交到一个长期运行的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-session-cluster">Flink 会话集群</a>、一个专门的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job-cluster">Flink 作业集群</a>或一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-application-cluster">Flink 应用集群</a>。这些选项之间的区别主要与集群的生命周期和资源隔离保证有关。</p>
<h3 id="flink-会话集群">Flink 会话集群</h3>
<ul>
<li>
<p>集群生命周期：在 Flink 会话集群中，客户端连接到一个预先存在的、长期运行的集群，可以接受多个作业提交。即使在所有作业完成后，集群（和 JobManager）将继续运行，直到会话被手动停止。因此，一个 Flink 会话集群的寿命不受任何 Flink 作业寿命的约束。</p>
</li>
<li>
<p>资源隔离。TaskManager 插槽由 ResourceManager 在作业提交时分配，作业完成后释放。因为所有作业都共享同一个集群，所以对集群资源有一定的竞争&ndash;比如提交作业阶段的网络带宽。这种共享设置的一个限制是，如果一个任务管理器崩溃，那么所有在这个任务管理器上有任务运行的作业都会失败；同样，如果在作业管理器上发生一些致命的错误，也会影响集群中运行的所有作业。</p>
</li>
<li>
<p>其他考虑因素：拥有一个预先存在的集群，可以节省大量申请资源和启动 TaskManagers 的时间。这在作业的执行时间非常短，高启动时间会对端到端的用户体验产生负面影响的场景中非常重要&ndash;就像对短查询的交互式分析一样，希望作业能够利用现有资源快速执行计算。</p>
</li>
</ul>
<p>注：以前，Flink 会话集群也被称为会话模式下的 Flink 集群。</p>
<h3 id="flink-作业集群">Flink 作业集群</h3>
<ul>
<li>
<p>集群生命周期：在 Flink Job Cluster 中，可用的集群管理器（如 YARN 或 Kubernetes）为每个提交的作业旋转一个集群，这个集群只对该作业可用。在这里，客户端首先向集群管理器请求资源来启动 JobManager，并将作业提交给运行在这个进程内部的 Dispatcher。然后根据作业的资源需求，懒惰地分配 TaskManager。作业完成后，Flink Job Cluster 就会被拆掉。</p>
</li>
<li>
<p>资源隔离：JobManager 的致命错误只影响该 Flink Job Cluster 中运行的一个作业。</p>
</li>
</ul>
<p>其他考虑因素：由于 ResourceManager 需要申请并等待外部资源管理组件来启动 TaskManager 进程并分配资源，因此 Flink Job Cluster 更适合运行时间长、稳定性要求高、对启动时间较长不敏感的大型作业。</p>
<p>注：以前，Flink Job Cluster 也被称为作业（或每作业）模式下的 Flink Cluster。</p>
<h3 id="flink-应用集群flink-application-cluster">Flink 应用集群(Flink Application Cluster)</h3>
<ul>
<li>
<p>集群生命周期：Flink 应用集群是一个专用的 Flink 集群，它只执行来自一个 Flink 应用的作业，并且 <code>main()</code> 方法运行在集群上而不是客户端上。作业提交是一个一步到位的过程：你不需要先启动一个 Flink 集群，然后向现有的集群会话提交作业，而是将你的应用逻辑和依赖关系打包成一个可执行的作业 JAR，集群入口点(ApplicationClusterEntryPoint)负责调用 <code>main()</code> 方法来提取作业图。这样你就可以像在 Kubernetes 上部署其他应用一样部署 Flink 应用，例如。因此，Flink Application Cluster 的寿命与 Flink Application 的寿命是绑定的。</p>
</li>
<li>
<p>资源隔离：在 Flink Application Cluster 中，ResourceManager 和 Dispatcher 的范围是单一的 Flink Application，这比 Flink Session Cluster 提供了更好的分离关注点。</p>
</li>
</ul>
<p>注：Flink Job Cluster 可以看作是 Flink Application Cluster 的 &ldquo;run-on-client&rdquo; 替代品。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/architecture" term="architecture" label="architecture" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[及时的流处理]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-20-timely-stream-processing/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-flink-architecture/?utm_source=atom_feed" rel="related" type="text/html" title="Flink 的架构" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-stateful-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="有状态的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语表" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-concepts-overview/?utm_source=atom_feed" rel="related" type="text/html" title="概念" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-20-timely-stream-processing/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-20T00:00:00+08:00</published>
            <updated>2020-08-20T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Timely Stream Processing</blockquote><h2 id="介绍">介绍</h2>
<p>及时流处理是<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html">有状态流处理</a>的一种扩展，其中时间在计算中起着一定的作用。其中，当你做时间序列分析时，当做基于特定时间段（通常称为窗口）的聚合时，或者当你做事件处理时，事件发生的时间很重要时，都是这种情况。</p>
<p>在下面的章节中，我们将着重介绍一些您在使用及时 Flink 应用时应该考虑的主题。</p>
<h2 id="时间的概念事件时间和处理时间">时间的概念：事件时间和处理时间</h2>
<p>当在流程序中提到时间时（例如定义窗口），可以提到不同的时间概念。</p>
<ul>
<li>处理时间。处理时间指的是正在执行相应操作的机器的系统时间。</li>
</ul>
<p>当流程序在处理时间上运行时，所有基于时间的操作(如时间窗口)将使用运行各操作的机器的系统时钟。一个小时的处理时间窗口将包括在系统时钟指示整小时的时间之间到达特定操作者的所有记录。例如，如果一个应用程序在上午9:15开始运行，则第一个小时处理时间窗口将包括上午9:15到10:00之间处理的事件，下一个窗口将包括上午10:00到11:00之间处理的事件，以此类推。</p>
<p>处理时间是最简单的时间概念，不需要流和机器之间的协调。它提供了最好的性能和最低的延迟。然而，在分布式和异步环境中，处理时间并不能提供确定性，因为它很容易受到记录到达系统的速度（例如从消息队列）、记录在系统内部的操作员之间流动的速度以及中断（计划性的或其他）的影响。</p>
<ul>
<li>事件时间。事件时间是指每个事件在其生产设备上发生的时间。这个时间通常在记录进入 Flink 之前就被嵌入到记录中，该事件时间戳可以从每个记录中提取出来。在事件时间中，时间的进展取决于数据，而不是任何挂钟。事件时间程序必须指定如何生成事件时间水印，这是事件时间中信号进度的机制。这个水印机制将在后面的章节中描述，<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#event-time-and-watermarks">下面</a>。</li>
</ul>
<p>在一个完美的世界里，事件时间处理将产生完全一致和确定的结果，不管事件何时到达，或它们的顺序如何。然而，除非已知事件是按顺序到达的（通过时间戳），否则事件时间处理在等待失序事件时就会产生一些延迟。由于只能在有限的时间内等待，这就对事件时间应用的确定性提出了限制。</p>
<p>假设所有的数据都已经到达，事件时间操作将按照预期的方式进行，即使在处理失序或迟到的事件时，或者在重新处理历史数据时，也能产生正确和一致的结果。例如，每小时事件时间窗口将包含所有携带事件时间戳的记录，这些记录属于该小时，无论它们到达的顺序如何，也无论它们何时被处理。更多信息请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html#late-elements">&ldquo;迟到事件&rdquo;</a>一节）。</p>
<p>需要注意的是，有时事件时间程序在实时处理实时数据时，会使用一些处理时间操作来保证其及时进行。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/event_processing_time.svg" alt="img"></p>
<h2 id="事件时间和水印">事件时间和水印</h2>
<p>注：Flink 实现了 Dataflow 模型中的许多技术。对于事件时间和水印的介绍，可以看看下面的文章。</p>
<ul>
<li>Tyler Akidau 的 <a href="https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101">Streaming 101</a>。</li>
<li><a href="https://research.google.com/pubs/archive/43864.pdf">数据流模型论文</a></li>
</ul>
<p>一个支持事件时间的流处理器需要一种方法来测量事件时间的进度。例如，当事件时间已经超过一小时结束时，需要通知建立小时窗口的窗口操作员，以便操作员可以关闭正在进行的窗口。</p>
<p>事件时间的进展可以独立于处理时间(由挂钟测量)。例如，在一个程序中，操作者的当前事件时间可能略微落后于处理时间(考虑到接收事件的延迟)，而两者以相同的速度进行。另一方面，另一个流程序可能通过快进一些已经缓冲在 Kafka 主题（或另一个消息队列）中的历史数据，只用几秒钟的处理时间就可以完成几周的事件时间的进展。</p>
<p>Flink 中衡量事件时间进度的机制是水印。水印作为数据流的一部分流动，并携带一个时间戳 <em>t</em>，一个 Watermark(t) 声明该数据流中的事件时间已经达到了时间 <em>t</em>，也就是说该数据流中不应该再有时间戳 <em>t'&lt;=t</em> 的元素（即事件的时间戳大于或等于水印）。</p>
<p>下图显示了一个带有（逻辑）时间戳的事件流，以及水印的内联流。在这个例子中，事件是按顺序排列的（相对于它们的时间戳），这意味着水印只是流中的周期性标记。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_watermark_in_order.svg" alt="img"></p>
<p>水印对于无序流来说是至关重要的，如下图所示，在这种情况下，事件不是按照时间戳来排序的。一般来说，水印是一种声明，即在流中的那一点上，所有事件在某个时间戳之前都应该已经到达。一旦水印到达操作者，操作者可以将其内部事件时间时钟提前到水印的值。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_watermark_out_of_order.svg" alt="img"></p>
<p>请注意，事件时间是由新创建的流元素（或元素）从产生它们的事件或触发创建这些元素的水印中继承的。</p>
<h3 id="并行流中的水印">并行流中的水印</h3>
<p>水印是在源函数处或直接在源函数后生成的。源函数的每个并行子任务通常都会独立地生成其水印。这些水印定义了该特定并行源的事件时间。</p>
<p>当水印流经流程序时，它们会在它们到达的操作符处提前事件时间。每当一个操作者提前其事件时间时，它就会在下游为其后续操作者生成一个新的水印。</p>
<p>有些运算符会消耗多个输入流；例如，一个联合，或者在 <code>keyBy(...)</code> 或 <code>partition(...)</code> 函数之后的运算符。这种运算符的当前事件时间是其输入流事件时间的最小值。当它的输入流更新它们的事件时间时，该运算符也会更新。</p>
<p>下图显示了事件和水印在并行流中流动的例子，以及运算符跟踪事件时间的例子。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/parallel_streams_watermarks.svg" alt="img"></p>
<h2 id="延时">延时</h2>
<p>某些元素有可能会违反水印条件，也就是说，即使在水印(t)发生后，也会有更多时间戳 <em>t'&lt;=t</em> 的元素发生。事实上，在许多现实世界的设置中，某些元素可以任意延迟，这使得无法指定某个事件时间戳的所有元素在什么时候发生。此外，即使延迟时间可以被限定，但延迟水印的时间过长往往是不可取的，因为它对事件时间窗口的评估造成过多的延迟。</p>
<p>出于这个原因，流媒体程序可能会显式地期望一些迟到的元素。晚期元素是指在系统的事件时间时钟（由水印发出的信号）已经过了晚期元素的时间戳之后到达的元素。有关如何在事件时间窗口中处理迟到元素的更多信息，请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#allowed-lateness">允许的延时</a>。</p>
<h2 id="窗口">窗口</h2>
<p>聚合事件（如计数、求和）在流上的工作方式与批处理中的工作方式不同。例如，不可能对一个流中的所有元素进行计数，因为流一般是无限的（无边界的）。相反，流上的聚合（计数、求和等）是由窗口来限定范围的，比如 &ldquo;过去5分钟的计数&rdquo;，或者&quot;过去100个元素的总和&rdquo;。</p>
<p>窗口可以是时间驱动的（例如：每30秒），也可以是数据驱动的（例如：每100个元素）。人们通常会区分不同类型的窗口，如翻滚窗口（无重叠）、滑动窗口（有重叠）和会话窗口（以不活动的间隙为点）。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/windows.svg" alt="img"></p>
<p>请查看这篇<a href="https://flink.apache.org/news/2015/12/04/Introducing-windows.html">博客文章</a>，了解更多的窗口示例，或查看 DataStream API 的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">窗口文档</a>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/stream" term="stream" label="stream" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[有状态的流处理]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-20-stateful-stream-processing/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-flink-architecture/?utm_source=atom_feed" rel="related" type="text/html" title="Flink 的架构" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-timely-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="及时的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语表" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-concepts-overview/?utm_source=atom_feed" rel="related" type="text/html" title="概念" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-20-stateful-stream-processing/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-20T00:00:00+08:00</published>
            <updated>2020-08-20T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Stateful Stream Processing</blockquote><h2 id="什么是状态">什么是状态？</h2>
<p>虽然数据流中的许多操作一次只看一个单独的事件（例如事件分析器），但有些操作会记住多个事件的信息（例如窗口 operator ）。这些操作被称为有状态操作。</p>
<p>一些有状态操作的例子:</p>
<ul>
<li>当一个应用程序搜索某些事件模式时，状态将存储到目前为止遇到的事件序列。</li>
<li>当按分钟/小时/天聚合事件时，状态会保存待聚合的事件。</li>
<li>当在数据点流上训练机器学习模型时，状态会保存模型参数的当前版本。</li>
<li>当需要管理历史数据时，状态可以有效访问过去发生的事件。</li>
</ul>
<p>Flink 需要了解状态，以便使用<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11//ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/checkpointing.html">检查点</a>和<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11//ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/savepoints.html">保存点</a>使其具有容错性。</p>
<p>关于状态的知识还允许重新缩放 Flink 应用，这意味着 Flink 负责在并行实例之间重新分配状态。</p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/queryable_state.html">可查询状态</a>允许你在运行时从 Flink 外部访问状态。</p>
<p>在处理状态时，阅读一下 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/state_backends.html">Flink 的状态后端</a>可能也很有用。Flink 提供了不同的状态后端，指定了状态的存储方式和位置。</p>
<h2 id="keyed-state">Keyed State</h2>
<p>Keyed state 被维护在可以被认为是一个嵌入式键/值存储中。该状态严格地与有状态 operator 读取的流一起被分割和分配。因此，对键/值状态的访问只有在 <em>keyed streams</em> 上，即在 keyed/分区数据交换之后才有可能，并且仅限于与当前事件的键相关联的值。将流和状态的键对齐，可以确保所有的状态更新都是本地操作，保证了一致性，而没有事务开销。这种对齐方式还允许 Flink 透明地重新分配状态和调整流分区。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/state_partitioning.svg" alt="img"></p>
<p>Keyed State 被进一步组织成所谓的 Key Groups。Key Groups 是 Flink 可以重新分配 Keyed State 的原子单位；Key Groups 的数量正好与定义的最大并行度相同。在执行过程中，keyed operator 的每个并行实例都与一个或多个 Key Groups 的键一起工作。</p>
<h2 id="状态持久化">状态持久化</h2>
<p>Flink 使用流重放(<strong>stream replay</strong>)和检查点(<strong>checkpointing</strong>)的组合来实现容错。一个检查点标记了每个输入流中的一个特定点以及每个 operator 的相应状态。通过恢复运算符的状态，从检查点开始重放记录，可以从检查点恢复流数据流，同时保持一致性（精确的一次处理语义）。</p>
<p>检查点间隔是用恢复时间（需要重放的记录数量）来交换执行过程中容错的开销的一种手段。</p>
<p>容错机制不断地绘制分布式流数据流的快照。对于状态较小的流媒体应用，这些快照非常轻量级，可以频繁地绘制，而不会对性能产生太大的影响。流应用的状态存储在一个可配置的地方，通常是在一个分布式文件系统中。</p>
<p>在程序失败的情况下（由于机器、网络或软件故障），Flink会停止分布式流数据流。然后系统会重新启动 operator ，并将其重置到最新的成功检查点。输入流被重置到状态快照的点。作为重新启动的并行数据流的一部分处理的任何记录都保证不影响之前的检查点状态。</p>
<p>注: 默认情况下，检查点被禁用。有关如何启用和配置检查点的详细信息，请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/checkpointing.html">检查点</a>。</p>
<p>注: 为了实现这种机制的完全保证，数据流源（如消息队列或 broker）需要能够将数据流倒退到一个定义的最近点。<a href="http://kafka.apache.org/">Apache Kafka</a> 具有这种能力，Flink 的 Kafka 连接器利用了这一点。参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/guarantees.html">数据源和接收器的容错保证</a>，了解更多关于 Flink 连接器提供的保证的信息。</p>
<p>注: 因为 Flink 的检查点是通过分布式快照实现的，所以我们互换使用快照和检查点这两个词。通常我们也使用术语快照来表示检查点或保存点。</p>
<h3 id="检查点">检查点</h3>
<p>Flink 容错机制的核心部分是绘制分布式数据流和 operator 状态的一致快照。这些快照作为一致的检查点，系统在发生故障时可以回退。Flink 绘制这些快照的机制在 <a href="http://arxiv.org/abs/1506.08603">&ldquo;Lightweight Asynchronous Snapshots for Distributed Dataflows&rdquo;</a> 中描述。它的灵感来自于分布式快照的标准 <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf">Chandy-Lamport 算法</a>，并专门为 Flink 的执行模型量身定做。</p>
<p>请记住，所有与检查点有关的事情都可以异步完成。检查点屏障不按锁步走，操作可以异步快照其状态。</p>
<p>自 Flink 1.11 以来，检查点可以在有或没有对齐的情况下进行。在本节中，我们先介绍对齐的检查点。</p>
<h4 id="屏障">屏障</h4>
<p>Flink 的分布式快照中的一个核心元素是流屏障。这些屏障被注入到数据流中，并作为数据流的一部分与记录一起流动。屏障永远不会超越记录，它们严格按照线路流动。屏障将数据流中的记录分为进入当前快照的记录集和进入下一个快照的记录。每个屏障都带有其记录被推到前面的快照的ID。屏障不会中断数据流的流动，因此非常轻量级。不同快照的多个屏障可以同时出现在流中，这意味着不同的快照可以同时发生。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_barriers.svg" alt="img"></p>
<p>流屏障是在流源处注入并行数据流。快照n的屏障被注入的点（我们称它为 Sₙ）是源流中快照覆盖数据的位置。例如，在 Apache Kafka 中，这个位置将是分区中最后一条记录的偏移。这个位置 Sₙ 被报告给检查点协调器（Flink 的 JobManager）。</p>
<p>然后，屏障就会流向下游。当一个中间 operator 从它的所有输入流中接收到一个快照n的屏障时，它就会向它的所有输出流中发出一个快照n的屏障。一旦一个汇 operator （流 DAG 的末端）从它的所有输入流中接收到屏障n，它就会向检查点协调器确认该快照n。在所有的接收器(sink)确认了一个快照之后，它就被认为完成了。</p>
<p>一旦快照n完成后，作业再也不会向源头询问 Sₙ 之前的记录，因为此时这些记录（以及它们的子孙记录）将通过整个数据流拓扑。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_aligning.svg" alt="img"></p>
<p>接收多个输入流的 operator 需要将输入流对准快照屏障。上图就说明了这一点。</p>
<ul>
<li>一旦 operator 从一个输入流中接收到快照屏障n，它就不能再处理该流的任何记录，直到它也从其他输入中接收到屏障n。否则，它就会把属于快照n的记录和属于快照n+1的记录混在一起。</li>
<li>一旦最后一个流收到了屏障n， operator 就会发出所有的待发记录，然后自己发出快照n的屏障。</li>
<li>它快照状态并恢复处理所有输入流的记录，在处理流的记录之前，先处理输入缓冲区的记录。</li>
<li>最后， operator 将状态异步写入状态后端。</li>
</ul>
<p>需要注意的是，所有具有多个输入的 operator 和洗牌后的 operator 在消耗多个上游子任务的输出流时，都需要进行对齐。</p>
<h4 id="快照-operator-state">快照 Operator State</h4>
<p>当 operator 包含任何形式的状态时，这个状态也必须是快照的一部分。</p>
<p>Operator 在从输入流接收到所有快照屏障后，在向输出流发出屏障之前，在这个时间点快照其状态。这时，所有来自屏障之前的记录对状态的更新都已经进行了，而没有依赖于屏障之后的记录的更新。由于快照的状态可能很大，所以它被存储在一个可配置的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11//ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/state_backends.html">状态后端</a>。默认情况下，这是 JobManager 的内存，但对于生产使用，应该配置一个分布式的可靠存储（如 HDFS）。状态存储完毕后， operator 确认检查点，向输出流发出快照屏障，然后继续进行。</p>
<p>现在产生的快照包含。</p>
<ul>
<li>对于每个并行流数据源，当快照开始时，流中的偏移量/位置。</li>
<li>对于每个 operator，一个指向作为快照的一部分存储的状态的指针。</li>
</ul>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/checkpointing.svg" alt="img"></p>
<h4 id="恢复">恢复</h4>
<p>这种机制下的恢复是直接的。系统会重新部署整个分布式数据流，并给每个 operator 提供快照的状态，作为检查点 <em>k</em> 的一部分。 来源被设置为从位置 Sₖ 开始读取数据流。例如在 Apache Kafka 中，这意味着告诉消费者从偏移量 Sₖ 开始获取。</p>
<p>如果状态是增量快照的，则运算符从最新的完整快照的状态开始，然后对该状态应用一系列增量快照更新。</p>
<p>更多信息请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/task_failure_recovery.html#restart-strategies">重启策略</a>。</p>
<h3 id="不对齐检查点">不对齐检查点</h3>
<p>从 Flink 1.11 开始，检查点也可以在不对齐的情况下进行。基本思路是，只要飞行中的数据成为 operator 状态的一部分，检查点就可以覆盖所有飞行中的数据。</p>
<p>请注意，这种方法实际上更接近 <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf">Chandy-Lamport 算法</a> ，但 Flink 仍然在源中插入屏障，以避免超载检查点协调器。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_unaligning.svg" alt="img"></p>
<p>该图描述了一个 operator 如何处理不对齐的检查点屏障。</p>
<ul>
<li>operator 对输入缓冲区中存储的第一个屏障作出反应。</li>
<li>它立即将屏障转发给下游 operator ，将其添加到输出缓冲区的末尾。</li>
<li>operator 将所有被超越的记录标记为异步存储，并创建自己状态的快照。</li>
</ul>
<p>因此， operator 只短暂地停止对输入的处理以标记缓冲区，转发屏障，并创建其他状态的快照。</p>
<p>不对齐的检查点确保屏障以最快的速度到达汇流排。它特别适合于至少有一条缓慢移动的数据路径的应用，在这种应用中，对齐时间可能达到数小时。然而，由于它增加了额外的I/O压力，所以当状态后端的I/O是瓶颈时，它并没有帮助。关于其他的局限性，请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/checkpoints.html#unaligned-checkpoints">运维</a>中更深入的讨论。</p>
<p>请注意，保存点将始终是对齐的。</p>
<h4 id="未对齐的恢复">未对齐的恢复</h4>
<p>operator 首先恢复飞行中的数据，然后才开始处理来自上游 operator 在不结盟检查点的任何数据。除此之外，它执行的步骤与<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html#recovery">恢复对齐检查点</a>时相同。</p>
<h3 id="状态后端">状态后端</h3>
<p>键/值索引的具体数据结构取决于所选择的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/state_backends.html">状态后端</a>。一种状态后端将数据存储在内存中的哈希图中，另一种状态后端使用 <a href="http://rocksdb.org/">RocksDB</a> 作为键/值存储。除了定义持有状态的数据结构外，状态后端还实现了对键/值状态进行时间点快照的逻辑，并将该快照作为检查点的一部分进行存储。状态后端可以在不改变应用逻辑的情况下进行配置。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/checkpoints.svg" alt="img"></p>
<h3 id="保存点">保存点</h3>
<p>所有使用检查点的程序都可以从保存点(<strong>savepoint</strong>)恢复执行。保存点允许在不丢失任何状态的情况下同时更新你的程序和 Flink 集群。</p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/savepoints.html">保存点</a>是<strong>手动触发的检查点</strong>，它采取程序的快照并将其写入状态后端。它们依靠常规的检查点机制来实现。</p>
<p>保存点与检查点类似，只是它们是<strong>由用户触发的</strong>，当新的检查点完成后，它们<strong>不会自动失效</strong>。</p>
<h3 id="完全一次与至少一次">完全一次与至少一次</h3>
<p>对齐步骤可能会给流媒体程序增加延迟。通常，这种额外的延迟是在几毫秒的数量级，但我们已经看到一些异常值的延迟明显增加的情况。对于要求所有记录持续超低延迟（几毫秒）的应用，Flink 有一个开关，可以在检查点期间跳过流对齐。只要 operator 从每个输入中看到检查点屏障，检查点快照仍然会被绘制。</p>
<p>当跳过对齐时， operator 会继续处理所有的输入，甚至在一些检查点 <em>n</em> 的检查点屏障到达后， operator 也会继续处理。这样一来， operator 也会在检查点 <em>n</em> 的状态快照被采集之前处理属于检查点 <em>n+1</em> 的元素。在还原时，这些记录将作为重复发生，因为它们都包含在检查点 <em>n</em> 的状态快照中，并将在检查点 <em>n</em> 之后作为数据的一部分重放。</p>
<p>注意对齐只发生在有多个前辈的 operator （连接）以及有多个发送者的 operator （流重新分区/洗牌后）。正因为如此，即使在至少一次的模式下，只有令人尴尬的并行流操作(<code>map()</code>, <code>flatMap()</code>, <code>filter()</code>, &hellip;)的数据流实际上也会给出精确的一次保证。</p>
<h2 id="批量程序中的状态和容错能力">批量程序中的状态和容错能力</h2>
<p>Flink 执行<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/index.html">批处理程序</a>是流程序的一种特殊情况，其中流是有界的（元素数量有限）。一个 DataSet 在内部被当作一个数据流。因此，上述概念适用于批处理程序的方式与适用于流程序的方式相同，但有一些小的例外。</p>
<ul>
<li>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/fault_tolerance.html">批处理程序的容错</a>不使用检查点。恢复是通过完全重放流发生的。这是可能的，因为输入是有界的。这将成本更多地推向恢复，但使常规处理更便宜，因为它避免了检查点。</p>
</li>
<li>
<p>DataSet API 中的有状态操作使用简化的内存内/核心外数据结构，而不是键/值索引。</p>
</li>
<li>
<p>DataSet API 引入了特殊的同步（基于superstep的）迭代，只有在有界流上才能实现。详情请查看<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/iterations.html">迭代文档</a>。</p>
</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/stateful" term="stateful" label="stateful" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[术语表]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-20-glossary/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-flink-architecture/?utm_source=atom_feed" rel="related" type="text/html" title="Flink 的架构" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-timely-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="及时的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-stateful-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="有状态的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-concepts-overview/?utm_source=atom_feed" rel="related" type="text/html" title="概念" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-20-glossary/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-20T00:00:00+08:00</published>
            <updated>2020-08-20T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Glossary</blockquote><p><strong>Flink Application Cluster</strong></p>
<p>Flink 应用集群是一个专用的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-cluster">Flink 集群</a>，它只执行一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-application">Flink 应用</a>的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job">Flink 作业</a>。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-cluster">Flink 集群</a>的寿命与 Flink 应用的寿命绑定。</p>
<p><strong>Flink Job Cluster</strong></p>
<p>Flink Job Cluster 是一个专用的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-cluster">Flink Cluster</a>，它只执行一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job">Flink Job</a>。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-cluster">Flink Cluster</a> 的寿命与 Flink Job 的寿命绑定。</p>
<p><strong>Flink Cluster</strong></p>
<p>一个分布式系统由（通常）一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-jobmanager">JobManager</a> 和一个或多个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-taskmanager">Flink TaskManager</a> 进程组成。</p>
<p><strong>Event</strong></p>
<p>事件是关于应用程序所模拟的域的状态变化的声明。事件可以是流或批处理应用程序的输入和/或输出。事件是特殊类型的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#Record">记录</a>。</p>
<p><strong>ExecutionGraph</strong></p>
<p>参见物理图(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#physical-graph">Physical Graph</a>)</p>
<p><strong>Function</strong></p>
<p>函数由用户实现，封装了 Flink 程序的应用逻辑。大多数 Functions 都由相应的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 封装。</p>
<p><strong>Instance</strong></p>
<p>术语 instance 用于描述运行时特定类型（通常是 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 或 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#function">Function</a>）的具体实例。由于 Apache Flink 大部分是用 Java 编写的，所以对应于 Java 中的 Instance 或 Object 的定义。在 Apache Flink 的上下文中，并行实例这个术语也经常被用来强调同一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 或 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#function">Function</a> 类型的多个实例在并行运行。</p>
<p><strong>Flink Application</strong></p>
<p>Flink 应用程序是一个 Java 应用程序，它从 <code>main()</code> 方法(或通过其他方式)提交一个或多个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job">Flink 作业</a>。提交作业通常是通过调用执行环境上的 <code>execute()</code> 来完成的。</p>
<p>应用程序的作业可以提交到一个长期运行的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-session-cluster">Flink 会话集群</a>，也可以提交到一个专门的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-application-cluster">Flink 应用集群</a>，或者提交到一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job-cluster">Flink 作业集群</a>。</p>
<p><strong>Flink Job</strong></p>
<p>Flink Job 是指在 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-application">Flink 应用</a>中通过调用 <code>execute()</code> 来创建和提交的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#logical-graph">逻辑图</a>（也常称为数据流图）的运行时表示。</p>
<p><strong>JobGraph</strong></p>
<p>参见逻辑图(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#logical-graph">Logical Graph</a>)</p>
<p><strong>Flink JobManager</strong></p>
<p>JobManager 是 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-cluster">Flink 集群</a>的协调器。它包含了三个不同的组件：Flink 资源管理器、Flink 调度器和每个运行的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job">Flink 作业</a> 一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-jobmaster">Flink JobMaster</a>。</p>
<p><strong>Flink JobMaster</strong></p>
<p>JobMasters 是运行在 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-jobmanager">JobManager</a> 中的组件之一。一个 JobMaster 负责监督单个作业的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#task">Tasks</a> 的执行情况。</p>
<p><strong>Logical Graph</strong></p>
<p>逻辑图是一个有向图，其中节点是 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operators</a>，边缘定义了 operator 的输入/输出关系，并对应数据流或数据集。逻辑图是通过从 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-application">Flink 应用程序</a>提交作业来创建的。</p>
<p>逻辑图也常被称为数据流图。</p>
<p><strong>Managed State</strong></p>
<p>Managed State 描述的是已经在框架中注册的应用状态。对于托管状态，Apache Flink 将负责处理持久性和重新缩放等问题。</p>
<p><strong>Operator</strong></p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#logical-graph">逻辑图</a>的节点。Operator 执行某种操作，通常由 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#function">Function</a> 执行。源和接收器是数据摄入和数据输出的特殊 Operator。</p>
<p><strong>Operator Chain</strong></p>
<p>一个 Operator 链由两个或多个连续的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 组成，中间没有任何重新分区。同一 Operator 链内的 operattor 直接相互转发记录，而不需要经过序列化或 Flink 的网络栈。</p>
<p><strong>Partition</strong></p>
<p>分区是整个数据流或数据集的一个独立子集。通过将每条<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#Record">记录</a>分配到一个或多个分区，将数据流或数据集划分为多个分区。数据流或数据集的分区在运行时由<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#task">Tasks</a>消耗。改变数据流或数据集分区方式的转换通常称为重新分区。</p>
<p><strong>Physical Graph</strong></p>
<p>物理图是翻译<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#logical-graph">逻辑图</a>的结果，以便在分布式运行时执行。节点是<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#task">Tasks</a>，边缘表示输入/输出关系或数据流或数据集的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#partition">分区</a>。</p>
<p><strong>Record</strong></p>
<p>记录是数据集或数据流的组成元素。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 和 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#Function">Functions</a> 接收记录作为输入，并发出记录作为输出。</p>
<p><strong>Flink Session Cluster</strong></p>
<p>一个长期运行的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-cluster">Flink Cluster</a>，它接受多个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job">Flink Job</a> 的执行。该  Flink Cluster 的寿命不受任何 Flink Job 寿命的约束。以前，Flink Session Cluster 也被称为会话模式下的 Flink Cluster。与 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-application-cluster">Flink Application Cluster</a> 比较。</p>
<p><strong>State Backend</strong></p>
<p>对于流处理程序来说，<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job">Flink Job</a> 的状态后端决定了它的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#managed-state">状态</a>如何存储在每个 TaskManager 上（TaskManager 的 Java 堆或（嵌入式）RocksDB），以及它在检查点时的写入位置（<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-jobmanager">JobManager</a> 的 Java 堆或 Filesystem）。</p>
<p><strong>Sub-Task</strong></p>
<p>子任务( Sub-Task)是指负责处理数据流的一个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#partition">分区</a>的任务(<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#task">Task</a>)。术语&quot;子任务&quot;强调同一 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 或 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator-chain">Operator 链</a>有多个并行的 Task。</p>
<p><strong>Task</strong></p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#physical-graph">物理图</a>的节点。Task 是工作的基本单位，由 Flink 的运行时执行。任务正好封装了一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 或 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator-chain">Operator 链</a> 的一个并行实例。</p>
<p><strong>Flink TaskManager</strong></p>
<p>TaskManager 是 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-cluster">Flink Cluster</a> 的工作进程。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#task">Tasks</a> 被安排给 TaskManagers 执行。它们相互通信，在后续的 Task 之间交换数据。</p>
<p><strong>Transformation</strong></p>
<p>变换应用于一个或多个数据流或数据集，并产生一个或多个输出数据流或数据集。变换可能会在每条记录的基础上改变数据流或数据集，但也可能只改变其分区或执行聚合。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 或 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#function">Functions</a>是 Flink 的 API 的 &ldquo;物理&quot;部分，而变换只是一个 API 概念。具体来说，大多数变换是由某些 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#operator">Operator</a> 实现的。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/architecture" term="architecture" label="architecture" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[概念]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-20-concepts-overview/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-flink-architecture/?utm_source=atom_feed" rel="related" type="text/html" title="Flink 的架构" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-timely-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="及时的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-stateful-stream-processing/?utm_source=atom_feed" rel="related" type="text/html" title="有状态的流处理" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-20-glossary/?utm_source=atom_feed" rel="related" type="text/html" title="术语表" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-20-concepts-overview/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-20T00:00:00+08:00</published>
            <updated>2020-08-20T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Concepts</blockquote><h2 id="概念">概念</h2>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/">实践培训</a>解释了作为 Flink 的 API 基础的有状态和及时流处理的基本概念，并提供了这些机制如何在应用中使用的例子。有状态的流处理是在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/etl.html#stateful-transformations">数据管道</a>和ETL的背景下介绍的，并在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/fault_tolerance.html">容错</a>部分进一步发展。在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html">&ldquo;流分析&rdquo;</a>一节中介绍了及时的流处理。</p>
<p>本概念深度部分提供了对 Flink 的架构和运行时如何实现这些概念的更深入的理解。</p>
<h2 id="flink-的-api">Flink 的 API</h2>
<p>Flink 为开发流式/批量应用提供了不同层次的抽象。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/levels_of_abstraction.svg" alt="img"></p>
<ul>
<li>
<p>最底层的抽象只是提供<strong>有状态和及时的流处理</strong>。它通过 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/process_function.html">Process Function</a> 嵌入到 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html">DataStream API</a> 中。它允许用户自由处理来自一个或多个流的事件，并提供一致的、容错的状态。此外，用户还可以注册事件时间和处理时间的回调，使程序可以实现复杂的计算。</p>
</li>
<li>
<p>在实际应用中，很多应用程序并不需要上述的低级抽象，而是可以针对 <strong>Core APIs</strong> 进行编程：<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html">DataStream API</a>（有界/无界流）和 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/batch/">DataSet API</a>（有界数据集）。这些流畅的 API 为数据处理提供了常见的构件，比如各种形式的用户指定的转换、连接、聚合、窗口、状态等。在这些 API 中处理的数据类型在各自的编程语言中被表示为类。</p>
</li>
</ul>
<p>低级 Process Function 与 DataStream API 相集成，因此可以根据需要使用低级抽象。DataSet API 提供了关于有界数据集的附加原语，如循环/迭代。</p>
<ul>
<li><strong>Table API</strong> 是以表为中心的声明式 DSL，它可能是动态变化的表（当表示流时）。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/">Table API</a> 遵循（扩展的）关系模型。表有一个附加的模式（类似于关系数据库中的表），API 提供了可比较的操作，如select、project、join、group-by、aggregation 等。Table API 程序声明式地定义了应该做什么逻辑操作，而不是具体规定操作的代码是怎样的。虽然 Table API 可以通过各种类型的用户定义函数进行扩展，但它的表现力不如 Core API，使用起来更简洁（写的代码更少）。此外，Table API 程序在执行前还要经过一个优化器，应用优化规则。</li>
</ul>
<p>人们可以在表和 DataStream/DataSet 之间无缝转换，允许程序将 Table API 与 DataStream 和 DataSet API 混合使用。</p>
<ul>
<li>Flink 提供的最高级抽象是 <strong>SQL</strong>。这个抽象在语义和表现形式上都与 Table API 相似，但将程序表示为 SQL 查询表达式。<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11//ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/#sql">SQL</a> 抽象与 Table API 紧密交互，SQL 查询可以在 Table API 中定义的表上执行。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/%E6%A6%82%E5%BF%B5" term="%E6%A6%82%E5%BF%B5" label="概念" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[DataStream API 介绍]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Intro to the DataStream API</blockquote><p>本次培训的重点是广泛地介绍 DataStream API，使你能够开始编写流式应用程序。</p>
<h2 id="什么可以被流式化">什么可以被流式化？</h2>
<p>Flink 的 DataStream API(Java 和 Scala)可以让你流化任何可以序列化的东西。Flink 自己的序列化器用于:</p>
<ul>
<li>基本类型，即 String, Long, Integer, Boolean, Array</li>
<li>复合类型。Tuples, POJOs 和 Scala case classes</li>
</ul>
<p>而 Flink 又回到了 Kryo 的其他类型。也可以在 Flink 中使用其他序列化器。特别是 Avro，得到了很好的支持。</p>
<h3 id="java-元组-和-pojo">Java 元组 和 POJO</h3>
<p>Flink 的本地序列化器可以有效地操作元组和 POJO。</p>
<p><strong>元组</strong></p>
<p>对于 Java，Flink 定义了自己的 Tuple0 到 Tuple25 类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Tuple2</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">;</span>

<span class="c1">// zero based index!  
</span><span class="c1"></span><span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="na">f0</span><span class="o">;</span>
<span class="n">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="na">f1</span><span class="o">;</span>
</code></pre></div><p><strong>POJO</strong></p>
<p>如果满足以下条件，Flink 将数据类型识别为 POJO 类型（并允许&quot;按名称&quot;字段引用）。</p>
<ul>
<li>类是公共的和独立的（没有非静态的内部类）。</li>
<li>该类有一个公共的无参数构造函数。</li>
<li>类（以及所有超级类）中的所有非静态、非瞬态字段要么是公共的（而且是非最终的），要么有公共的 getter- 和 setter- 方法，这些方法遵循 Java beans 中 getter 和 setter 的命名约定。</li>
</ul>
<p>例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span><span class="o">;</span>  
<span class="o">}</span>  

<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Fred Flintstone&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>Flink 的序列化器<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/schema_evolution.html#pojo-types">支持 POJO 类型的模式进化</a>。</p>
<h3 id="scala-元组和-case-class">Scala 元组和 case class</h3>
<p>这些工作就像你期望的那样。</p>
<h2 id="一个完整的例子">一个完整的例子</h2>
<p>这个例子将一个关于人的记录流作为输入，并将其过滤为只包括成年人。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.environment.StreamExecutionEnvironment</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.datastream.DataStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.api.common.functions.FilterFunction</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Example</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span>
                <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">flintstones</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span>
                <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">,</span>
                <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Wilma&#34;</span><span class="o">,</span> <span class="n">35</span><span class="o">)</span><span class="o">,</span>
                <span class="k">new</span> <span class="n">Person</span><span class="o">(</span><span class="s">&#34;Pebbles&#34;</span><span class="o">,</span> <span class="n">2</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

        <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">adults</span> <span class="o">=</span> <span class="n">flintstones</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">new</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Person</span> <span class="n">person</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">person</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">18</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="o">)</span><span class="o">;</span>

        <span class="n">adults</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">public</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span><span class="o">;</span>

        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;: age &#34;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="流执行环境">流执行环境</h2>
<p>每个 Flink 应用都需要一个执行环境，本例中的 env。流式应用需要使用一个 StreamExecutionEnvironment。</p>
<p>在你的应用程序中进行的 DataStream API 调用建立了一个作业图(job graph)，这个作业图被附加到 StreamExecutionEnvironment 上。当调用 env.execute() 时，这个图会被打包并发送给 JobManager，JobManager 将作业并行化，并将它的片断分配给 Task Manager 执行。你的作业的每个并行片断将在一个任务槽(task slot)中执行。</p>
<p>注意，如果你不调用 execute()，你的应用程序将不会被运行。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/distributed-runtime.svg" alt="img"></p>
<p>这种分布式运行时取决于你的应用程序是可序列化的。它还要求所有的依赖关系都能在集群中的每个节点上使用。</p>
<h3 id="基本的流源">基本的流源</h3>
<p>上面的例子使用 <code>env.fromElements(...)</code> 构造了一个 <code>DataStream[Person]</code>。这是一种方便的方法，可以将一个简单的流组合起来，用于原型或测试。StreamExecutionEnvironment 上还有一个 fromCollection(Collection) 方法。所以，你可以用这个方法来代替。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">people</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

<span class="n">people</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Fred&#34;</span><span class="o">,</span> <span class="mi">35</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="n">people</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Wilma&#34;</span><span class="o">,</span> <span class="mi">35</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="n">people</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&#34;Pebbles&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="k">val</span> <span class="n">flintstones</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">fromCollection</span><span class="o">(</span><span class="n">people</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>另一种方便的方法是在原型开发时将一些数据导入流中，使用 socket:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lines</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">socketTextStream</span><span class="o">(</span><span class="s">&#34;localhost&#34;</span><span class="o">,</span> <span class="mi">9999</span><span class="o">)</span>
</code></pre></div><p>或从文件中读取:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">lines</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">readTextFile</span><span class="o">(</span><span class="s">&#34;file:///path&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>在实际应用中，最常用的数据源是那些支持低延迟、高吞吐量并行读取并结合倒带和重放的数据源&ndash;这是高性能和容错的先决条件&ndash;如 Apache Kafka、Kinesis 和各种文件系统。REST API 和数据库也经常被用于流的丰富。</p>
<h3 id="基本的流式接收器">基本的流式接收器</h3>
<p>上面的例子使用 <code>adults.print()</code> 将其结果打印到 task manager 的日志中（当在 IDE 中运行时，它将出现在你的 IDE 的控制台中）。这将在流的每个元素上调用 <code>toString()</code>。</p>
<p>输出结果看起来像这样：</p>
<pre><code>1&gt; Fred: age 35
2&gt; Wilma: age 35
</code></pre><p>其中 <code>1&gt;</code> 和 <code>2&gt;</code> 表示哪个子任务（即线程）产生的输出。</p>
<p>在生产中，常用的接收器括 StreamingFileSink、各种数据库和一些 pub-sub 系统。</p>
<h2 id="调试">调试</h2>
<p>在生产中，你的应用程序将在远程集群或一组容器中运行。而如果它失败了，它将会远程失败。JobManager 和 TaskManager 日志对调试此类故障非常有帮助，但在 IDE 内部进行本地调试要容易得多，Flink 支持这一点。你可以设置断点，检查本地变量，并逐步检查你的代码。你也可以步入 Flink 的代码，如果你好奇 Flink 是如何工作的，这可以是一个很好的方式来了解它的内部结构。</p>
<h2 id="实践">实践</h2>
<p>在这一点上，你知道了足够的知识，可以开始编码和运行一个简单的 DataStream 应用程序。克隆 <a href="https://github.com/apache/flink-training/tree/release-1.11">flink-training</a> repo，按照 README 中的说明操作后，进行第一个练习。<a href="https://github.com/apache/flink-training/tree/release-1.11/ride-cleansing">过滤一个流（Ride Cleansing）</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://flink.apache.org/news/2020/04/15/flink-serialization-tuning-vol-1.html">Flink序列化调优第一卷：选择你的序列化器&ndash;如果你可以的话</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#anatomy-of-a-flink-program">Flink 程序的解剖</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#data-sources">数据源</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/datastream_api.html#data-sinks">数据接收器</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/">DataStream 连接器</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[事件驱动型应用程序]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Event-driven Applications</blockquote><h2 id="process-functions">Process Functions</h2>
<h3 id="介绍">介绍</h3>
<p>ProcessFunction 将事件处理与定时器和状态结合起来，使其成为流处理应用的强大构件。这是用 Flink 创建事件驱动应用的基础。它与 RichFlatMapFunction 非常相似，但增加了定时器。</p>
<h3 id="实例">实例</h3>
<p>如果你做过<a href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics">流分析</a>培训中的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html#hands-on">实战练习</a>，你会记得它使用 TumblingEventTimeWindow 来计算每个司机在每个小时内的小费之和，就像这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// compute the sum of the tips per hour for each driver
</span><span class="c1"></span><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">hourlyTips</span> <span class="o">=</span> <span class="n">fares</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">(</span><span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">fare</span><span class="o">.</span><span class="na">driverId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">hours</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">AddTips</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>用 KeyedProcessFunction 做同样的事情是相当直接的，也是很有教育意义的。让我们先把上面的代码替换成这样:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// compute the sum of the tips per hour for each driver
</span><span class="c1"></span><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">hourlyTips</span> <span class="o">=</span> <span class="n">fares</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">(</span><span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">fare</span><span class="o">.</span><span class="na">driverId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">PseudoWindow</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">hours</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>在这段代码中，一个名为 PseudoWindow 的 KeyedProcessFunction 被应用于一个 keyed 流，其结果是一个 <code>DataStream&lt;Tuple3&lt;Long，Long，Float&gt;&gt;</code>（就是使用 Flink 内置时间窗口的实现所产生的那种流）。</p>
<p>PseudoWindow 的整体轮廓是这样的形状:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Compute the sum of the tips for each driver in hour-long windows.
</span><span class="c1"></span><span class="c1">// The keys are driverIds.
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">PseudoWindow</span> <span class="kd">extends</span> 
        <span class="n">KeyedProcessFunction</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">TaxiFare</span><span class="o">,</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">durationMsec</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PseudoWindow</span><span class="o">(</span><span class="n">Time</span> <span class="n">duration</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">durationMsec</span> <span class="o">=</span> <span class="n">duration</span><span class="o">.</span><span class="na">toMilliseconds</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="c1">// Called once during initialization.
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="c1">// Called as each fare arrives to be processed.
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span>
            <span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">,</span>
            <span class="n">Context</span> <span class="n">ctx</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="c1">// Called when the current watermark indicates that a window is now complete.
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onTimer</span><span class="o">(</span><span class="kt">long</span> <span class="n">timestamp</span><span class="o">,</span> 
            <span class="n">OnTimerContext</span> <span class="n">context</span><span class="o">,</span> 
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>需要注意的事情。</p>
<ul>
<li>
<p>ProcessFunctions 有好几种类型&ndash;这是一个 KeyedProcessFunctions，但还有 CoProcessFunctions、BroadcastProcessFunctions 等。</p>
</li>
<li>
<p>KeyedProcessFunction 是 RichFunction的一种。作为一个 RichFunction，它可以访问在管理 keyed state 下工作所需的 <code>open</code> 和 <code>getRuntimeContext</code> 方法。</p>
</li>
<li>
<p>有两个回调要实现：<code>processElement</code> 和 <code>onTimer</code>。<code>processElement</code> 在每次传入事件时被调用；<code>onTimer</code> 在定时器发射时被调用。这些定时器可以是事件时间，也可以是处理时间定时器。<code>processElement</code> 和 <code>onTimer</code> 都提供了一个上下文对象，该对象可以用来与 <code>TimerService</code> 交互（除其他外）。两个回调都还传递了一个可以用来发出结果的 Collector。</p>
</li>
</ul>
<h4 id="open-方法">open() 方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Keyed, managed state, with an entry for each window, keyed by the window&#39;s end time.
</span><span class="c1"></span><span class="c1">// There is a separate MapState object for each driver.
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">transient</span> <span class="n">MapState</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span> <span class="n">sumOfTips</span><span class="o">;</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">MapStateDescriptor</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span> <span class="n">sumDesc</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">MapStateDescriptor</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;sumOfTips&#34;</span><span class="o">,</span> <span class="n">Long</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Float</span><span class="o">.</span><span class="na">class</span><span class="o">)</span><span class="o">;</span>
    <span class="n">sumOfTips</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getMapState</span><span class="o">(</span><span class="n">sumDesc</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>由于票价事件可能会不按顺序到达，所以有时需要处理一个小时的事件，然后再完成前一个小时的结果计算。事实上，如果水印延迟比窗口长度长得多，那么可能会同时打开许多窗口，而不是只有两个。本实现通过使用 <code>MapState</code> 来支持这一点，<code>MapState</code> 将每个窗口结束的时间戳映射到该窗口的提示之和。</p>
<h4 id="processelement-方法">processElement() 方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span>
        <span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">,</span>
        <span class="n">Context</span> <span class="n">ctx</span><span class="o">,</span>
        <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

    <span class="kt">long</span> <span class="n">eventTime</span> <span class="o">=</span> <span class="n">fare</span><span class="o">.</span><span class="na">getEventTime</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">TimerService</span> <span class="n">timerService</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">timerService</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">timerService</span><span class="o">.</span><span class="na">currentWatermark</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// This event is late; its window has already been triggered.
</span><span class="c1"></span>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// Round up eventTime to the end of the window containing this event.
</span><span class="c1"></span>        <span class="kt">long</span> <span class="n">endOfWindow</span> <span class="o">=</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">-</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">%</span> <span class="n">durationMsec</span><span class="o">)</span> <span class="o">+</span> <span class="n">durationMsec</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span><span class="o">;</span>

        <span class="c1">// Schedule a callback for when the window has been completed.
</span><span class="c1"></span>        <span class="n">timerService</span><span class="o">.</span><span class="na">registerEventTimeTimer</span><span class="o">(</span><span class="n">endOfWindow</span><span class="o">)</span><span class="o">;</span>

        <span class="c1">// Add this fare&#39;s tip to the running total for that window.
</span><span class="c1"></span>        <span class="n">Float</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">sumOfTips</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">endOfWindow</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">0F</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">fare</span><span class="o">.</span><span class="na">tip</span><span class="o">;</span>
        <span class="n">sumOfTips</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">endOfWindow</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>要考虑的事情:</p>
<ul>
<li>
<p>迟到的事件会怎样？在水印后面的事件（即迟到）会被丢弃。如果你想做一些比这更好的事情，可以考虑使用侧输出，这将在<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/event_driven.html#side-outputs">下一节</a>解释。</p>
</li>
<li>
<p>这个例子使用了一个 MapState，其中键是时间戳，并为同一个时间戳设置一个 Timer。这是一种常见的模式；它使得在定时器发射时查找相关信息变得简单而高效。</p>
</li>
</ul>
<h4 id="ontimer-方法">onTimer() 方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onTimer</span><span class="o">(</span>
        <span class="kt">long</span> <span class="n">timestamp</span><span class="o">,</span> 
        <span class="n">OnTimerContext</span> <span class="n">context</span><span class="o">,</span> 
        <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

    <span class="kt">long</span> <span class="n">driverId</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getCurrentKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="c1">// Look up the result for the hour that just ended.
</span><span class="c1"></span>    <span class="n">Float</span> <span class="n">sumOfTips</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">sumOfTips</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">timestamp</span><span class="o">)</span><span class="o">;</span>

    <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Float</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Tuple3</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">driverId</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">,</span> <span class="n">sumOfTips</span><span class="o">)</span><span class="o">;</span>
    <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">result</span><span class="o">)</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">sumOfTips</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">timestamp</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>观察:</p>
<ul>
<li>
<p>传递给 onTimer 的 OnTimerContext 上下文可以用来确定当前的键。</p>
</li>
<li>
<p>我们的伪窗口是在当前水印到达每个小时结束时被触发的，此时调用 onTimer。这个 onTimer 方法从 sumOfTips 中删除了相关的条目，这样做的效果是无法容纳迟到的事件。这相当于在使用 Flink 的时间窗口时，将 allowLateness 设置为零。</p>
</li>
</ul>
<h3 id="性能方面的考虑">性能方面的考虑</h3>
<p>Flink 提供了针对 RocksDB 优化的 MapState 和 ListState 类型。在可能的情况下，应该使用这些类型来代替持有某种集合的 ValueState 对象。RocksDB 状态后端可以追加到 ListState，而不需要经过(去)序列化，对于 MapState，每个键/值对都是一个单独的 RocksDB 对象，因此 MapState 可以有效地被访问和更新。</p>
<h2 id="侧输出">侧输出</h2>
<h3 id="介绍-1">介绍</h3>
<p>有几个很好的理由可以让 Flink operator 有一个以上的输出流，比如报告:</p>
<ul>
<li>异常</li>
<li>畸形事件</li>
<li>迟到事件</li>
<li>操作警报，如与外部服务的连接超时。</li>
</ul>
<p>侧输出是一种方便的方式。除了错误报告，侧输出也是实现流的多路分割的好方法。</p>
<h3 id="例子">例子</h3>
<p>现在，您可以对上一节中被忽略的迟到事件做些什么了。</p>
<p>一个侧输出通道与一个 <code>OutputTag&lt;T&gt;</code> 相关联。这些标签具有与侧输出的 DataStream 的类型相对应的通用类型，它们有名称。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">TaxiFare</span><span class="o">&gt;</span> <span class="n">lateFares</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">TaxiFare</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;lateFares&#34;</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">;</span>
</code></pre></div><p>上面展示的是一个静态的 <code>OutputTag&lt;TaxiFare&gt;</code>，它既可以在 PseudoWindow 的 processElement 方法中发出迟到事件时被引用。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">eventTime</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">timerService</span><span class="o">.</span><span class="na">currentWatermark</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This event is late; its window has already been triggered.
</span><span class="c1"></span>    <span class="n">ctx</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="n">lateFares</span><span class="o">,</span> <span class="n">fare</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
<span class="o">}</span>
</code></pre></div><p>并在访问这一侧输出的流时，在作业的 <code>main</code> 方法中输出:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// compute the sum of the tips per hour for each driver
</span><span class="c1"></span><span class="n">SingleOutputStreamOperator</span> <span class="n">hourlyTips</span> <span class="o">=</span> <span class="n">fares</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">(</span><span class="n">TaxiFare</span> <span class="n">fare</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">fare</span><span class="o">.</span><span class="na">driverId</span><span class="o">)</span>
        <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">PseudoWindow</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">hours</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="n">hourlyTips</span><span class="o">.</span><span class="na">getSideOutput</span><span class="o">(</span><span class="n">lateFares</span><span class="o">)</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>或者，您可以使用两个具有相同名称的 OutputTags 来引用同一侧面输出，但如果您这样做，它们必须具有相同的类型。</p>
<h2 id="结束语">结束语</h2>
<p>在这个例子中，你已经看到了如何使用 ProcessFunction 来重新实现一个直接的时间窗口。当然，如果 Flink 内置的窗口 API 满足你的需求，无论如何，请继续使用它。但如果你发现自己在考虑用 Flink 的窗口做一些变形，不要害怕推出自己的窗口。</p>
<p>此外，ProcessFunction 对于计算分析之外的许多其他用例也很有用。下面的实践练习提供了一个完全不同的例子。</p>
<p>ProcessFunction 的另一个常见用例是用于过期的陈旧状态。如果你回想一下 <a href="https://github.com/apache/flink-training/tree/release-1.11/rides-and-fares">Rides 和 Fares 练习</a>，其中使用 RichCoFlatMapFunction 来计算一个简单的连接，示例解决方案假设 TaxiRides 和 TaxiFares 是完美匹配的，每个 rideId 是一对一的。如果一个事件丢失了，同一乘车 ID 的其他事件将永远保持在状态。这可以替换为一个 KeyedCoProcessFunction 来实现，并且可以使用一个定时器来检测和清除任何陈旧的状态。</p>
<h2 id="实践">实践</h2>
<p>与本节配套的实战练习是 <a href="https://github.com/apache/flink-training/tree/release-1.11/long-ride-alerts">Long Ride Alerts 练习</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/process_function.html">ProcessFunction</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/side_output.html">侧输出</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[学习 Flink: 实践培训]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Learn Flink: Hands-on Training</blockquote><h2 id="本次培训的目标和范围">本次培训的目标和范围</h2>
<p>本培训介绍了 Apache Flink，包括足够的内容让你开始编写可扩展的流式 ETL，分析和事件驱动的应用程序，同时省略了很多（最终重要的）细节。本书的重点是为 Flink 管理状态和时间的 API 提供直接的介绍，希望在掌握了这些基础知识后，你能更好地从更详细的参考文档中获取其余需要了解的内容。每一节末尾的链接将引导你到可以学习更多知识的地方。</p>
<p>具体来说，您将学习:</p>
<ul>
<li>如何实现流数据处理管道</li>
<li>Flink 如何以及为何管理状态</li>
<li>如何使用事件时间来持续计算准确的分析结果？</li>
<li>如何在连续流上构建事件驱动的应用程序？</li>
<li>Flink 是如何提供具有精确只读语义的容错、有状态的流处理的？</li>
</ul>
<p>本培训主要介绍四个关键概念：流数据的连续处理、事件时间、有状态的流处理和状态快照。本页介绍了这些概念。</p>
<p>注: 伴随本培训的是一套实践练习，它将指导您学习如何使用所介绍的概念。每一节的最后都提供了相关练习的链接。</p>
<h2 id="流处理">流处理</h2>
<p>流是数据的天然栖息地。无论是来自网络服务器的事件，还是来自股票交易所的交易，或者是来自工厂车间机器的传感器读数，数据都是作为流的一部分被创建的。但当你分析数据时，你可以围绕有界流或无界流组织处理，而你选择哪种范式会产生深远的影响。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/bounded-unbounded.png" alt="img"></p>
<p>当你处理一个有边界的数据流时，<strong>批处理</strong>是工作的范式。在这种操作模式下，你可以选择在产生任何结果之前摄取整个数据集，这意味着，例如，可以对数据进行排序，计算全局统计，或产生一个汇总所有输入的最终报告。</p>
<p>另一方面，<strong>流处理</strong>涉及无边界的数据流。至少在概念上，输入可能永远不会结束，因此你不得不在数据到达时持续处理数据。</p>
<p>在 Flink 中，应用程序由<strong>流式数据流</strong>组成，这些数据流可以通过用户定义的<strong>运算符</strong>进行转换。这些数据流形成有向图，从一个或多个源开始，到一个或多个 sink 结束。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/program_dataflow.svg" alt="img"></p>
<p>通常，程序中的变换(transformation)和数据流(dataflow)中的运算符(operator)之间存在一对一的对应关系。但有时，一个变换可能由多个运算符(operator)组成。</p>
<p>一个应用程序可能会消耗来自流式源的实时数据，如消息队列或分布式日志，如 Apache Kafka 或 Kinesis。但 Flink 也可以消耗来自各种数据源的有界历史数据。同样，Flink 应用正在产生的结果流也可以被发送到各种各样的系统，这些系统可以作为 sink 连接。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/flink-application-sources-sinks.png" alt="img"></p>
<h3 id="并行数据流">并行数据流</h3>
<p>Flink 中的程序本质上是并行和分布式的。在执行过程中，一个流有一个或多个流分区(<strong>stream partitions</strong>)，每个运算符(operator)有一个或多个运算符子任务(<strong>operator subtasks</strong>)。运算符子任务(<strong>operator subtasks</strong>)相互独立，在不同的线程中执行，也可能在不同的机器或容器上执行。</p>
<p>运算符符子任务(<strong>operator subtasks</strong>)的数量就是该特定运算符(operator)的并行度(<strong>parallelism</strong>)。同一程序的不同运算符可能具有不同的并行度水平。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/parallel_dataflow.svg" alt="img"></p>
<p>流可以在两个运算符之间以一对一（或转发）的模式或以重分发的模式传输数据。</p>
<ul>
<li>
<p>一对一的流（例如上图中 Source 和 map() 运算符之间）保留了元素的分区和排序。这意味着 map() 运算符的 subtask[1] 将看到与 Source 运算符的 subtask[1] 所产生的元素顺序相同的元素。</p>
</li>
<li>
<p>重新分发流（如上面 map() 和 keyBy/window 之间，以及 keyBy/window 和 Sink 之间）会改变流的分区。每个运算符子任务(operator subtask)都会根据所选的转换将数据发送到不同的目标子任务。例如 keyBy()（通过散列键来重新分区）、broadcast() 或 rebalance()（随机重新分区）。在重分发交换中，元素之间的排序只在每一对发送和接收子任务中被保留（例如，map() 的 subtask[1] 和 keyBy/window 的 subtask[2]）。因此，例如，上面显示的 keyBy/window 和 Sink 运算符之间的重新分发，引入了关于不同键的聚合结果到达 Sink 的顺序的非确定性。</p>
</li>
</ul>
<h2 id="及时的流处理">及时的流处理</h2>
<p>对于大多数流式应用来说，能够用处理实时数据的相同代码重新处理历史数据是非常有价值的&ndash;无论如何，都能产生确定性的、一致的结果。</p>
<p>此外，关注事件发生的顺序，而不是事件交付处理的顺序，并且能够推理出一组事件何时（或应该）完成也是至关重要的。例如，考虑电子商务交易，或金融贸易中涉及的一系列事件。</p>
<p>通过使用记录在数据流中的事件时间戳，而不是使用处理数据的机器的时钟，可以满足这些及时流处理的要求。</p>
<h2 id="有状态的流处理">有状态的流处理</h2>
<p>Flink 的操作可以是有状态的。这意味着一个事件的处理方式可以取决于之前所有事件的累积效果。状态可以用于一些简单的事情，例如计算每分钟的事件以显示在仪表板上，或者用于一些更复杂的事情，例如计算欺诈检测模型的功能。</p>
<p>一个 Flink 应用是在分布式集群上并行运行的。一个给定的运算符的各种并行实例将以不同的线程独立执行，一般来说，它们将在不同的机器上运行。</p>
<p>一个有状态运算符的并行实例集实际上是一个分片的键值存储。每一个并行实例负责处理一组特定键的事件，这些键的状态被保存在本地。</p>
<p>下图显示了一个作业(Job)，在作业图(job graph)中的前三个运算符上运行的并行度为2，终止于一个并行度为 1 的 sink。第三个运算符是有状态的，你可以看到在第二个和第三个运算符之间发生了一个完全连接的网络洗牌。这是在通过一些键来对流进行分区，这样所有需要一起处理的事件，都会被一起处理。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/parallel-job.png" alt="img"></p>
<p>状态总是在本地访问，这有助于 Flink 应用实现高吞吐量和低延迟。你可以选择将状态保存在 JVM 堆上，如果状态太大，也可以将其保存在有效组织的磁盘数据结构中。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/local-state.png" alt="img"></p>
<h2 id="通过状态快照进行容错">通过状态快照进行容错</h2>
<p>Flink 能够通过状态快照和流重放的组合，提供容错、精确的一次性语义。这些快照捕获了分布式管道的整个状态，记录了进入输入队列的偏移以及整个作业图(job graph)中因摄取了该点数据而产生的状态。当发生故障时，源会被重放，状态被恢复，并恢复处理。如上所述，这些状态快照是异步捕获的，不会妨碍正在进行的处理。</p>
<p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/">https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[数据管道和 ETL]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Data Pipelines &amp; ETL</blockquote><p>对于 Apache Flink 来说，一个非常常见的用例是实现 ETL（提取、转换、加载）管道，从一个或多个源中获取数据，进行一些转换和/或丰富，然后将结果存储在某个地方。在这一节中，我们将看看如何使用 Flink 的 DataStream API 来实现这种应用。</p>
<p>请注意，Flink的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/">Table 和 SQL API</a>很适合许多 ETL 用例。但无论你最终是否直接使用 DataStream API，对这里介绍的基础知识有一个扎实的理解都是有价值的。</p>
<h2 id="无状态转换">无状态转换</h2>
<p>本节介绍了 map() 和 flatmap()，它们是用来实现无状态转换的基本操作。本节中的例子假设你熟悉 <a href="https://github.com/apache/flink-training/tree/release-1.11">flink-training</a> 仓库中的实战练习中使用的出租车乘车数据。</p>
<h3 id="map">map()</h3>
<p>在第一个练习中，你过滤了一个打车事件的流，在同一个代码库中，有一个 GeoUtils 类，它提供了一个静态方法 GeoUtils.mapToGridCell(float lon, float lat)，该方法将一个 location (longitude, latitude) 映射到一个网格单元，该单元指的是一个大约100x100米大小的区域。</p>
<p>现在让我们通过为每个事件添加 startCell 和 endCell 字段来丰富我们的打车对象流。你可以创建一个 EnrichedRide 对象，扩展 TaxiRide，添加这些字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">EnrichedRide</span> <span class="kd">extends</span> <span class="n">TaxiRide</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">startCell</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">endCell</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">EnrichedRide</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span>

    <span class="kd">public</span> <span class="nf">EnrichedRide</span><span class="o">(</span><span class="n">TaxiRide</span> <span class="n">ride</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rideId</span> <span class="o">=</span> <span class="n">ride</span><span class="o">.</span><span class="na">rideId</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">isStart</span> <span class="o">=</span> <span class="n">ride</span><span class="o">.</span><span class="na">isStart</span><span class="o">;</span>
        <span class="o">.</span><span class="o">.</span><span class="o">.</span>
        <span class="k">this</span><span class="o">.</span><span class="na">startCell</span> <span class="o">=</span> <span class="n">GeoUtils</span><span class="o">.</span><span class="na">mapToGridCell</span><span class="o">(</span><span class="n">ride</span><span class="o">.</span><span class="na">startLon</span><span class="o">,</span> <span class="n">ride</span><span class="o">.</span><span class="na">startLat</span><span class="o">)</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">endCell</span> <span class="o">=</span> <span class="n">GeoUtils</span><span class="o">.</span><span class="na">mapToGridCell</span><span class="o">(</span><span class="n">ride</span><span class="o">.</span><span class="na">endLon</span><span class="o">,</span> <span class="n">ride</span><span class="o">.</span><span class="na">endLat</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span> <span class="o">+</span>
            <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">startCell</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;,&#34;</span> <span class="o">+</span>
            <span class="n">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">endCell</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>然后，您可以创建一个应用程序，将流转化为:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">TaxiRide</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">TaxiRideSource</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="k">val</span> <span class="n">enrichedNYCRides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">EnrichedRide</span><span class="o">]</span>  <span class="k">=</span> <span class="n">rides</span>
    <span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">new</span> <span class="nc">RideCleansingSolution</span><span class="o">.</span><span class="nc">NYCFilter</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">new</span> <span class="nc">Enrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="n">enrichedNYCRides</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>使用这个 MapFunction:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">Enrichment</span> <span class="k">extends</span> <span class="nc">MapFunction</span><span class="o">[</span><span class="kt">TaxiRide</span>, <span class="kt">EnrichedRide</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">taxiRide</span><span class="k">:</span> <span class="kt">TaxiRide</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">EnrichedRide</span><span class="o">(</span><span class="n">taxiRide</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="flatmap">flatmap()</h3>
<p><code>MapFunction</code> 只适用于执行一对一的转换：对于每一个进入的流元素，<code>map()</code> 将发出一个转换后的元素。否则，你将需要使用 <code>flatmap()</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">rides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">TaxiRide</span><span class="o">]</span> <span class="k">=</span> <span class="n">env</span><span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">TaxiRideSource</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="k">val</span> <span class="n">enrichedNYCRides</span><span class="k">:</span> <span class="kt">DataStream</span><span class="o">[</span><span class="kt">EnrichedRide</span><span class="o">]</span> <span class="k">=</span> <span class="n">rides</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="n">enrichedNYCRides</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>加上一个 <code>FlatMapFunction</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">NYCEnrichment</span> <span class="k">extends</span> <span class="nc">FlatMapFunction</span><span class="o">[</span><span class="kt">TaxiRide</span>, <span class="kt">EnrichedRide</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">taxiRide</span><span class="k">:</span> <span class="kt">TaxiRide</span><span class="o">,</span> <span class="n">out</span><span class="k">:</span> <span class="kt">Collector</span><span class="o">[</span><span class="kt">EnrichedRide</span><span class="o">]</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">valid</span><span class="k">:</span> <span class="kt">FilterFunction</span><span class="o">[</span><span class="kt">TaxiRide</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RideCleansing</span><span class="o">.</span><span class="nc">NYCFilter</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">valid</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">taxiRide</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="n">collect</span><span class="o">(</span><span class="k">new</span> <span class="nc">EnrichedRide</span><span class="o">(</span><span class="n">taxiRide</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>通过这个接口提供的 Collector，<code>flatmap()</code> 方法可以随心所欲地发射许多流元素，包括完全不发射元素。</p>
<h2 id="keyed-streams">Keyed Streams</h2>
<h3 id="keyby">keyBy()</h3>
<p>通常，能够围绕一个属性对一个流进行分区是非常有用的，这样所有具有相同属性值的事件就会被归为一组。例如，假设你想找到从每个网格单元开始的最长的出租车乘车时间。从 SQL 查询的角度考虑，这意味着要对 startCell 进行某种 GROUP BY，而在 Flink 中，这是用 <code>keyBy(KeySelector)</code> 来完成的。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">rides</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="s">&#34;startCell&#34;</span><span class="o">)</span>
</code></pre></div><p>每一个 <code>keyBy</code> 都会引起一次网络洗牌，对流进行重新分区。一般来说，这是很昂贵的，因为它涉及到网络通信以及序列化和反序列化。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/keyBy.png" alt="img"></p>
<p>在上面的例子中，键是由一个字段名 &ldquo;startCell&rdquo; 指定的。这种键选择的风格有一个缺点，那就是编译器无法推断用于键选择的字段的类型，因此 Flink 会将键值作为元组传递，这可能会很笨拙。最好是使用一个正确类型的 <code>KeySelector</code>，例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">rides</span>
    <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span>
        <span class="k">new</span> <span class="n">KeySelector</span><span class="o">&lt;</span><span class="n">EnrichedRide</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getKey</span><span class="o">(</span><span class="n">EnrichedRide</span> <span class="n">enrichedRide</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">enrichedRide</span><span class="o">.</span><span class="na">startCell</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="o">)</span>
</code></pre></div><p>可以用 lambda 更简洁地表达出来。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">rides</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">NYCEnrichment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="n">enrichedRide</span> <span class="o">-&gt;</span> <span class="n">enrichedRide</span><span class="o">.</span><span class="n">startCell</span><span class="o">)</span>
</code></pre></div><h3 id="keys-are-computed">Keys are computed</h3>
<p>KeySelectors 并不局限于从你的事件中提取一个键，相反，它们可以用任何你想要的方式来计算键，只要产生的键是确定性的，并且有有效的 <code>hashCode()</code> 和 <code>equals()</code> 的实现。这个限制排除了生成随机数，或者返回数组或枚举的 KeySelectors，但是你可以使用元组或 POJOs 来生成复合键，例如，只要它们的元素遵循这些相同的规则。</p>
<p>键必须以确定性的方式产生，因为每当需要它们时，它们就会被重新计算，而不是附加到流记录上。</p>
<p>例如，我们不是创建一个新的 <code>EnrichedRide</code> 类，该类有一个 <code>startCell</code> 字段，然后我们将其用作键:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyBy</span><span class="o">(</span><span class="n">enrichedRide</span> <span class="o">-&gt;</span> <span class="n">enrichedRide</span><span class="o">.</span><span class="n">startCell</span><span class="o">)</span>
</code></pre></div><p>相反, 我们可以这样做:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyBy</span><span class="o">(</span><span class="n">ride</span> <span class="o">-&gt;</span> <span class="nc">GeoUtils</span><span class="o">.</span><span class="n">mapToGridCell</span><span class="o">(</span><span class="n">ride</span><span class="o">.</span><span class="n">startLon</span><span class="o">,</span> <span class="n">ride</span><span class="o">.</span><span class="n">startLat</span><span class="o">)</span><span class="o">)</span>
</code></pre></div><h3 id="keyed-流的聚合">Keyed 流的聚合</h3>
<p>这段代码为每个 end-of-ride 事件创建一个新的元组流，其中包含 <code>startCell</code> 和持续时间（分钟）。</p>
<pre><code>import org.joda.time.Interval;

DataStream&lt;Tuple2&lt;Integer, Minutes&gt;&gt; minutesByStartCell = enrichedNYCRides
    .flatMap(new FlatMapFunction&lt;EnrichedRide, Tuple2&lt;Integer, Minutes&gt;&gt;() {

        @Override
        public void flatMap(EnrichedRide ride,
                            Collector&lt;Tuple2&lt;Integer, Minutes&gt;&gt; out) throws Exception {
            if (!ride.isStart) {
                Interval rideInterval = new Interval(ride.startTime, ride.endTime);
                Minutes duration = rideInterval.toDuration().toStandardMinutes();
                out.collect(new Tuple2&lt;&gt;(ride.startCell, duration));
            }
        }
    });
</code></pre><p>现在可以产生一个流，其中只包含那些对每个 <code>startCell</code> 来说是有史以来（至此）最长的乘车记录。</p>
<p>有多种方式可以表达作为键的字段。之前你看到了一个 EnrichedRide POJO 的例子，在这个例子中，要用作键的字段是用它的名字指定的。这个例子涉及到 Tuple2 对象，元组中的索引（从0开始）被用来指定键。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">minutesByStartCell</span>
  <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// startCell
</span><span class="c1"></span>  <span class="o">.</span><span class="n">maxBy</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// duration
</span><span class="c1"></span>  <span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>现在，每当持续时间达到一个新的最大值时，输出流就会包含一个针对每个键的记录&ndash;如这里的50797单元格所示。</p>
<pre><code>...
4&gt; (64549,5M)
4&gt; (46298,18M)
1&gt; (51549,14M)
1&gt; (53043,13M)
1&gt; (56031,22M)
1&gt; (50797,6M)
...
1&gt; (50797,8M)
...
1&gt; (50797,11M)
...
1&gt; (50797,12M)
</code></pre><h3 id="implicit-state">(Implicit) State</h3>
<p>这是本次训练中第一个涉及有状态流的例子。虽然状态被透明地处理，但 Flink 必须跟踪每个不同键的最大持续时间。</p>
<p>每当状态涉及到你的应用时，你应该考虑状态可能会变得多大。每当键空间是无限制的，那么 Flink 需要的状态量也是无限制的。</p>
<p>当处理流时，一般来说，在有限的窗口上考虑聚合比在整个流上考虑更有意义。</p>
<h3 id="reduce-和其他聚合器">reduce() 和其他聚合器</h3>
<p>上文中使用的 <code>maxBy()</code> 只是 Flink 的 KeyedStreams 上众多聚合函数中的一个例子。还有一个更通用的 <code>reduce()</code> 函数，你可以用它来实现自己的自定义聚合。</p>
<h2 id="状态转换">状态转换</h2>
<h3 id="为什么-flink-要参与管理状态">为什么 Flink 要参与管理状态？</h3>
<p>你的应用程序当然能够在没有让 Flink 参与管理状态的情况下使用状态&ndash;但 Flink 为它所管理的状态提供了一些引人注目的功能。</p>
<ul>
<li>本地化。Flink 状态被保存在处理它的机器的本地，并且可以以内存速度被访问。</li>
<li>耐用。Flink 状态是容错的，即每隔一段时间就会自动检查一次，一旦失败就会恢复。</li>
<li>纵向可扩展。Flink 状态可以保存在嵌入式 RocksDB 实例中，通过增加更多的本地磁盘来扩展。</li>
<li>横向可扩展。随着集群的增长和收缩，Flink 状态会被重新分配。</li>
<li>可查询。Flink 状态可以通过<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/queryable_state.html">可查询状态 API</a> 进行外部查询。</li>
</ul>
<p>在本节中，您将学习如何使用 Flink 的 API 管理 keyed 状态。</p>
<h3 id="rich-函数">Rich 函数</h3>
<p>此时你已经看到了 Flink 的几个函数接口，包括 <code>FilterFunction</code>、<code>MapFunction</code> 和 <code>FlatMapFunction</code>。这些都是单一抽象方法模式的例子。</p>
<p>对于每一个接口，Flink 还提供了一个所谓的&quot;富&quot;变体，例如，<code>RichFlatMapFunction</code>，它有一些额外的方法，包括:</p>
<ul>
<li>open(Configuration c)</li>
<li>close()</li>
<li>getRuntimeContext()</li>
</ul>
<p><code>open()</code> 在操作符初始化期间被调用一次。这是一个加载一些静态数据的机会，或者, 例如打开一个外部服务的连接。</p>
<p><code>getRuntimeContext()</code> 提供了对一整套潜在的有趣的东西的访问，但最值得注意的是它是如何创建和访问由 Flink 管理的状态。</p>
<h3 id="一个带有-keyed-state-的例子">一个带有 Keyed State 的例子</h3>
<p>在这个例子中，想象一下，你有一个事件流，你想去掉重复，所以你只保留每个键的第一个事件。这里有一个应用程序可以做到这一点，使用一个名为 <code>Deduplicator</code> 的 <code>RichFlatMapFunction</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Event</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="o">;</span>
    <span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
  
    <span class="n">env</span><span class="o">.</span><span class="na">addSource</span><span class="o">(</span><span class="k">new</span> <span class="n">EventSource</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">e</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
        <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">Deduplicator</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
  
    <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>为了达到这个目的，Deduplicator 将需要以某种方式记住，对于每个键来说，是否已经有了该键的事件。它将使用 Flink 的 <em>keyed state</em> 接口来做到这一点。</p>
<p>当你在使用像这样的 <em>keyed</em> 流时，Flink 将为每个被管理的状态项目维护一个键/值存储。</p>
<p>Flink 支持几种不同类型的 <em>keyed state</em>，本例使用的是最简单的一种，即 <code>ValueState</code>。这意味着对于每个键，Flink 将存储一个单一的对象&ndash;在本例中，一个类型为 Boolean 的对象。</p>
<p>我们的 Deduplicator 类有两个方法：<code>open()</code> 和 <code>flatMap()</code>。<code>open</code> 方法通过定义一个 ValueStateDescriptor<!-- raw HTML omitted -->` 来建立对托管状态的使用。构造函数的参数为这个 <em>keyed state</em> 项指定了一个名称（&ldquo;keyHasBeenSeen&rdquo;），并提供了可用于序列化这些对象的信息（在本例中，Types.BOOLEAN）。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Deduplicator</span> <span class="kd">extends</span> <span class="n">RichFlatMapFunction</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">,</span> <span class="n">Event</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="n">ValueState</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">keyHasBeenSeen</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">conf</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ValueStateDescriptor</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">desc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValueStateDescriptor</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;keyHasBeenSeen&#34;</span><span class="o">,</span> <span class="n">Types</span><span class="o">.</span><span class="na">BOOLEAN</span><span class="o">)</span><span class="o">;</span>
        <span class="n">keyHasBeenSeen</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getState</span><span class="o">(</span><span class="n">desc</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Event</span> <span class="n">event</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">keyHasBeenSeen</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">event</span><span class="o">)</span><span class="o">;</span>
            <span class="n">keyHasBeenSeen</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>当 <code>flatMap</code> 方法调用 <code>keyHasBeenSeen.value()</code> 时，Flink 的运行时会在上下文中查找 key 的这块状态值，只有当它为 null 时，它才会去收集事件到输出。在这种情况下，它还会将 <code>keyHasBeenSeen</code> 更新为 true。</p>
<p>这种访问和更新 key-partitioned 状态的机制可能看起来相当神奇，因为在我们的 Deduplicator 的实现中，key 并不是显式可见的。当 Flink 的运行时调用我们的 <code>RichFlatMapFunction</code> 的 <code>open</code> 方法时，没有任何事件，因此那一刻上下文中没有 key。但是当它调用 <code>flatMap</code> 方法时，被处理的事件的 key 对运行时来说是可用的，并在幕后用于确定 Flink 的状态后端中的哪个条目被操作。</p>
<p>当部署到分布式集群时，会有很多这个 Deduplicator 的实例，每个实例将负责整个键空间的一个不相干子集。因此，当你看到一个 ValueState 的单项，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ValueState</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">keyHasBeenSeen</span><span class="o">;</span>
</code></pre></div><p>理解这不仅仅是一个单一的布尔值，而是一个分布式的、分片式的、键/值存储。</p>
<h3 id="清除状态">清除状态</h3>
<p>上面的例子有一个潜在的问题。如果键的空间是无限制的，会发生什么？Flink 是在某个地方为每一个被使用的不同键存储一个布尔的实例。如果有一个有界的键集，那么这将是很好的，但是在键集以无界的方式增长的应用中，有必要为不再需要的键清除状态。这是通过调用状态对象上的 <code>clear()</code> 来实现的，如:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">keyHasBeenSeen</span><span class="o">.</span><span class="n">clear</span><span class="o">(</span><span class="o">)</span>
</code></pre></div><p>例如，你可能想在给定键的一段时间不活动后这样做。当你在事件驱动的应用程序一节中学习 <code>ProcessFunction</code> 时，你将看到如何使用 <code>Timer</code> 来实现这一点。</p>
<p>此外，还有一个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#state-time-to-live-ttl">状态存活时间(TTL)</a>选项，你可以用状态描述符来配置，指定什么时候自动清除陈旧键的状态。</p>
<h3 id="non-keyed-state">Non-keyed State</h3>
<p>也可以在 non-keyed 的上下文中使用托管状态。这有时被称为 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/state.html#operator-state">operator state</a>。所涉及的接口有些不同，由于用户定义的函数需要 non-keyed state 是不常见的，所以这里不做介绍。这个功能最常用于源和接收器(sink)的实现。</p>
<h2 id="connected-streams">Connected Streams</h2>
<p>有时不是应用这样的预定义变换:</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/transformation.svg" alt="img"></p>
<p>你希望能够动态地改变变换的某些方面&ndash;通过流的阈值，或规则，或其他参数。Flink 中支持这种模式的是一种叫做连接流(connected streams)的东西，其中一个 operator 有两个输入流，就像这样:</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/connected-streams.svg" alt="img"></p>
<p>连接流也可以用来实现流式连接(streaming joins.)。</p>
<h3 id="例子">例子</h3>
<p>在这个例子中，控制流被用来指定必须从  streamOfWords 中过滤掉的单词。一个名为 ControlFunction 的 RichCoFlatMapFunction 被应用到连接的流中来完成这个任务。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">control</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="s">&#34;DROP&#34;</span><span class="o">,</span> <span class="s">&#34;IGNORE&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span><span class="o">;</span>
    <span class="n">DataStream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">streamOfWords</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">fromElements</span><span class="o">(</span><span class="s">&#34;Apache&#34;</span><span class="o">,</span> <span class="s">&#34;DROP&#34;</span><span class="o">,</span> <span class="s">&#34;Flink&#34;</span><span class="o">,</span> <span class="s">&#34;IGNORE&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span><span class="o">;</span>
  
    <span class="n">control</span>
        <span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">datastreamOfWords</span><span class="o">)</span>
        <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="n">ControlFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>注意，被连接的两个流必须以兼容的方式进行 keyed。keyBy 的作用是对流的数据进行分区，当 keyed 流连接时，必须以同样的方式进行分区。这样就可以保证两个流中具有相同 key 的事件都会被发送到同一个实例中。那么，这就使得将该键上的两个流连接起来成为可能，例如。</p>
<p>在这种情况下，两个流的类型都是 <code>DataStream[String]</code>，并且两个流都以字符串为键。如下所示，这个 <code>RichCoFlatMapFunction</code> 在  keyed state 下存储了一个布尔值，而这个布尔值是由两个流共享的。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ControlFunction</span> <span class="kd">extends</span> <span class="n">RichCoFlatMapFunction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ValueState</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">blocked</span><span class="o">;</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">open</span><span class="o">(</span><span class="n">Configuration</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">blocked</span> <span class="o">=</span> <span class="n">getRuntimeContext</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getState</span><span class="o">(</span><span class="k">new</span> <span class="n">ValueStateDescriptor</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;blocked&#34;</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">.</span><span class="na">class</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap1</span><span class="o">(</span><span class="n">String</span> <span class="n">control_value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">blocked</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatMap2</span><span class="o">(</span><span class="n">String</span> <span class="n">data_value</span><span class="o">,</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">blocked</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">data_value</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>RichCoFlatMapFunction 是 FlatMapFunction 的一种，它可以应用于一对连接的流，并且它可以访问富函数接口。这意味着它可以被做成有状态的。</p>
<p>屏蔽的(blocked)布尔正在被用来记住控制流上提到的键（在这里是单词），这些词被过滤出 streamOfWords 流。这就是 <em>keyed state</em>，它在两个流之间是共享的，这就是为什么两个流要共享同一个键空间。</p>
<p><code>flatMap1</code> 和 <code>flatMap2</code> 被 Flink 运行时调用，分别来自两个连接流的元素&ndash;在我们的例子中，来自控制流的元素被传入 <code>flatMap1</code>，来自 <code>streamOfWords</code> 的元素被传入 <code>flatMap2</code>。这是由使用 <code>control.connect(datastreamOfWords)</code> 连接两个流的顺序决定的。</p>
<p>重要的是要认识到，你无法控制调用 <code>flatMap1</code> 和 <code>flatMap2</code> 回调的顺序。这两个输入流在相互竞争，Flink 运行时将对来自一个流或另一个流的事件的消耗做它想做的事。在时间和/或顺序很重要的情况下，你可能会发现有必要在托管的 Flink 状态下缓冲事件，直到你的应用程序准备好处理它们。(注意：如果你真的很绝望，可以通过使用实现 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/api/java/org/apache/flink/streaming/api/operators/InputSelectable.html">InputSelectable</a> 接口的自定义 Operator 来对双输入 operator 消耗输入的顺序进行一些有限的控制。)</p>
<h2 id="实践">实践</h2>
<p>与本节配套的实践练习是<a href="https://github.com/apache/flink-training/tree/release-1.11/rides-and-fares">&ldquo;乘车与票价练习&rdquo;</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/#datastream-transformations">数据流转换</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html">有状态的流处理</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[流分析]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="related" type="text/html" title="通过状态快照进行容错" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Streaming Analytics</blockquote><h2 id="event-time-和-watermarks">Event Time 和 Watermarks</h2>
<h3 id="介绍">介绍</h3>
<p>Flink 明确支持三种不同的时间概念。</p>
<p>事件时间：事件发生的时间，由产生（或存储）该事件的设备记录的时间</p>
<p>摄取时间：Flink 在摄取事件时记录的时间戳。</p>
<p>处理时间：您的管道中的特定 operator 处理事件的时间。</p>
<p>为了获得可重复的结果，例如，在计算某一天股票在交易的第一个小时内达到的最高价格时，您应该使用事件时间(event time)。这样一来，结果就不会依赖于计算的时间。这种实时应用有时会使用处理时间(processing time)，但这样一来，结果就会由该小时内恰好处理的事件决定，而不是由当时发生的事件决定。基于处理时间的计算分析会导致不一致，并使重新分析历史数据或测试新的实现变得困难。</p>
<h3 id="使用事件时间">使用事件时间</h3>
<p>默认情况下，Flink 将使用处理时间(processing time)。要改变这一点，您可以设置时间特性(Time Characteristic)。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span>
    <span class="n">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="n">env</span><span class="o">.</span><span class="na">setStreamTimeCharacteristic</span><span class="o">(</span><span class="n">TimeCharacteristic</span><span class="o">.</span><span class="na">EventTime</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>如果你想使用事件时间，你还需要提供一个时间戳提取器和水印生成器，Flink 将使用它们来跟踪事件时间的进展。这将在下面的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html#working-with-watermarks">&ldquo;使用水印&rdquo;</a>一节中介绍，但首先我们应该解释一下什么是水印。</p>
<h3 id="水印">水印</h3>
<p>让我们通过一个简单的例子来说明为什么需要水印，以及它们是如何工作的。</p>
<p>在这个例子中，你有一个带时间戳的事件流，这些事件的到达顺序有些混乱，如下所示。显示的数字是时间戳，表示这些事件实际发生的时间。第一个到达的事件发生在时间 4，随后是更早发生的事件，在时间 2，以此类推。</p>
<pre><code>··· 23 19 22 24 21 14 17 13 12 15 9 11 7 2 4 →
</code></pre><p>现在想象一下，你正在尝试创建一个流排序器(stream sorter)。这个应用程序的目的是处理流中的每个事件，并发出一个新的流，其中包含相同的事件，但按时间戳排序。</p>
<p>一些观察:</p>
<p>(1)你的流排序器看到的第一个元素是 4， 但你不能马上把它作为排序流的第一个元素释放出来。它可能已经不按顺序到达，而更早的事件可能还没有到达。事实上，你对这个流的未来有一些神一样的知识，你可以看到，你的流排序器至少应该等到 2 到达后再产生任何结果。</p>
<p>一些缓冲，和一些延迟，是必要的。</p>
<p>(2)如果你做错了，你可能最终会永远等待。首先，排序器看到了一个来自时间 4 的事件，然后是一个来自时间 2 的事件。一个时间戳小于 2 的事件会不会永远到达？也许会，也许不会。也许不会。你可以永远等待，永远看不到 1。</p>
<p>最终你必须鼓起勇气，发出 2 作为排序流的开始。</p>
<p>(3)那么你需要的是某种策略，它定义了对于任何给定的时间戳事件，何时停止等待早期事件的到来。</p>
<p>这正是水印的作用&ndash;它们定义了何时停止等待早期(earlier)事件。</p>
<p>Flink 中的事件时间处理依赖于水印生成器，这些水印生成器将特殊的时间戳元素插入到流中，称为水印。时间 t 的水印是一种断言，即到时间 t 为止，流现在（可能）是完整的。</p>
<p>这个流排序器应该在什么时候停止等待，并推出2开始排序流？当一个时间戳为 2，或更大的水印到达时。</p>
<p>(4)你可以想象不同的策略来决定如何生成水印。</p>
<p>每一个事件都是在一些延迟之后到达的，而这些延迟是不同的，所以一些事件的延迟比其他事件更多。一个简单的方法是假设这些延迟被某个最大延迟所约束。Flink 将这种策略称为有界无序水印。很容易想象更复杂的水印方法，但对于大多数应用来说，固定的延迟已经足够好了。</p>
<h3 id="延迟与完整性">延迟与完整性</h3>
<p>关于水印的另一种思考方式是，水印让你这个流式应用的开发者能够控制延迟和完整性之间的权衡。与批处理不同的是，在批处理中，人们可以在产生任何结果之前完全了解输入，而在流式处理中，你最终必须停止等待看到更多的输入，并产生某种结果。</p>
<p>你可以积极地配置你的水印，用一个很短的延迟，从而承担在对输入不完全了解的情况下产生结果的风险&ndash;也就是说，一个可能是错误的结果，很快就产生了。或者你可以等待更长时间，并利用对输入流更完整的知识产生结果。</p>
<p>也可以实现混合解决方案，快速生成初始结果，然后在处理额外（后期）数据时对这些结果进行更新。对于某些应用来说，这是一种很好的方法。</p>
<h3 id="延迟">延迟</h3>
<p>迟到的定义是相对于水印而言的。水印(t)声明流在时间t之前是完整的；在这个水印之后的任何事件，如果时间戳 ≤t，则为延迟。</p>
<h3 id="使用水印">使用水印</h3>
<p>为了执行基于事件时间的事件处理，Flink 需要知道与每个事件相关联的时间，还需要流包含水印。</p>
<p>实践练习中使用的 Taxi 数据源为你处理了这些细节。但在你自己的应用程序中，你必须自己处理这些事情，通常是通过实现一个类来实现，该类从事件中提取时间戳，并按需生成水印。最简单的方法是使用 WatermarkStrategy:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">WatermarkStrategy</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">strategy</span> <span class="o">=</span> <span class="n">WatermarkStrategy</span>
        <span class="o">.</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span><span class="n">forBoundedOutOfOrderness</span><span class="o">(</span><span class="n">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="n">20</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withTimestampAssigner</span><span class="o">(</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">event</span><span class="o">.</span><span class="na">timestamp</span><span class="o">)</span><span class="o">;</span>

<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">withTimestampsAndWatermarks</span> <span class="o">=</span>
    <span class="n">stream</span><span class="o">.</span><span class="na">assignTimestampsAndWatermarks</span><span class="o">(</span><span class="n">strategy</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><h2 id="窗口">窗口</h2>
<p>Flink 具有非常有表现力的窗口语义。</p>
<p>在本节中，你将学习</p>
<ul>
<li>如何使用窗口来计算无边界流的聚合。</li>
<li>Flink 支持哪些类型的窗口，以及</li>
<li>如何实现一个窗口化聚合的 DataStream 程序？</li>
</ul>
<h3 id="介绍-1">介绍</h3>
<p>在做流处理的时候，自然而然地想要计算流的有界子集的聚合分析，以回答这样的问题。</p>
<ul>
<li>每分钟的页面浏览量</li>
<li>每个用户每周会话数</li>
<li>每个传感器每分钟的最高温度</li>
</ul>
<p>用 Flink 计算窗口化分析依赖于两个主要的抽象。窗口分配器（Window Assigners）将事件分配给窗口（必要时创建新的窗口对象），窗口函数（Window Functions）应用于分配给窗口的事件。</p>
<p>Flink 的窗口 API 还有 Triggers 的概念，它决定什么时候调用窗口函数，还有 Evictors，它可以删除窗口中收集的元素。</p>
<p>在它的基本形式中，你将窗口化应用到像这样的 keyed stream 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="n">keyBy</span><span class="o">(</span><span class="o">&lt;</span><span class="n">key</span> <span class="n">selector</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">window</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">|</span><span class="n">aggregate</span><span class="o">|</span><span class="n">process</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>您也可以对 non-keyed stream 使用窗口化，但请记住，在这种情况下，处理将不会并行进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="n">windowAll</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">assigner</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">reduce</span><span class="o">|</span><span class="n">aggregate</span><span class="o">|</span><span class="n">process</span><span class="o">(</span><span class="o">&lt;</span><span class="n">window</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><h3 id="窗口分配器">窗口分配器</h3>
<p>Flink 有几种内置的窗口分配器类型，下面进行说明。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/window-assigners.svg" alt="img"></p>
<p>一些例子说明这些窗口分配器的用途，以及如何指定它们:</p>
<ul>
<li>
<p>滚动时间窗口</p>
</li>
<li>
<p>每分钟浏览量</p>
</li>
<li>
<p>TumblingEventTimeWindows.of(Time.minutes(1))</p>
</li>
<li>
<p>滑动时间窗口</p>
</li>
<li>
<p>每10秒计算的每分钟页面浏览量</p>
</li>
<li>
<p>SlidingEventTimeWindows.of(Time.min(1), Time.seconds(10))</p>
</li>
<li>
<p>会话窗口</p>
</li>
<li>
<p>每节课的页面浏览量，其中每节课之间至少有30分钟的间隔。</p>
</li>
<li>
<p>EventTimeSessionWindows.withGap(Time.minutes(30))</p>
</li>
</ul>
<p>可以使用 Time.milliseconds(n), Time.seconds(n), Time.minutes(n), Time.hours(n), 和 Time.days(n) 中的一种指定持续时间。</p>
<p>基于时间的窗口分配器（包括会话窗口）有事件时间(event time)和处理时间(processing time)两种风味。这两种类型的时间窗口之间有显著的权衡。对于处理时间窗口，你必须接受这些限制:</p>
<ul>
<li>不能正确处理历史数据。</li>
<li>不能正确处理失序数据。</li>
<li>结果将是非确定性的。</li>
</ul>
<p>但具有较低延迟的优势。</p>
<p>当使用基于计数的窗口时，请记住，这些窗口将不会启动，直到一个批次完成。没有超时和处理部分窗口的选项，尽管你可以用自定义的触发器自己实现这种行为。</p>
<p>全局窗口分配器将每个事件（用相同的键）分配到同一个全局窗口。只有当你打算使用自定义触发器来做你自己的自定义窗口时，这才是有用的。在许多看似有用的情况下，您最好使用<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/event_driven.html#process-functions">另一节</a>中描述的 ProcessFunction。</p>
<h3 id="窗口函数">窗口函数</h3>
<p>对于如何处理窗口的内容，您有三个基本选项。</p>
<ol>
<li>作为一个批次，使用一个 ProcessWindowFunction，它将被传递一个包含窗口内容的 Iterable。</li>
<li>以增量方式，使用 ReduceFunction 或 AggregateFunction，当每个事件被分配到窗口时被调用。</li>
<li>或两者结合，当窗口被触发时，ReduceFunction 或 AggregateFunction 的预聚集结果被提供给 ProcessWindowFunction。</li>
</ol>
<p>这里是方法1和3的例子。每个实现都在1分钟的事件时间窗口中从每个传感器中找到峰值值，并产生一个包含(key, end-of-window-timestamp, max_value) 的 Tuples 流。</p>
<h4 id="processwindowfunction-示例">ProcessWindowFunction 示例</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">minutes</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="k">new</span> <span class="n">MyWastefulMax</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyWastefulMax</span> <span class="kd">extends</span> <span class="n">ProcessWindowFunction</span><span class="o">&lt;</span>
        <span class="n">SensorReading</span><span class="o">,</span>                  <span class="c1">// input type
</span><span class="c1"></span>        <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span><span class="o">,</span>  <span class="c1">// output type
</span><span class="c1"></span>        <span class="n">String</span><span class="o">,</span>                         <span class="c1">// key type
</span><span class="c1"></span>        <span class="n">TimeWindow</span><span class="o">&gt;</span> <span class="o">{</span>                   <span class="c1">// window type
</span><span class="c1"></span>    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span>
            <span class="n">String</span> <span class="n">key</span><span class="o">,</span>
            <span class="n">Context</span> <span class="n">context</span><span class="o">,</span> 
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">events</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">SensorReading</span> <span class="n">event</span> <span class="o">:</span> <span class="n">events</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Tuple3</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">context</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getEnd</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在这个实现中，有几件事需要注意。</p>
<ul>
<li>所有分配给窗口的事件都必须在 keyed Flink state 下被缓冲，直到窗口被触发。这可能是相当昂贵的。</li>
<li>我们的 ProcessWindowFunction 被传递了一个 Context 对象，其中包含了窗口的信息。它的接口是这样的:</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Context</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">W</span> <span class="nf">window</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">long</span> <span class="nf">currentProcessingTime</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">long</span> <span class="nf">currentWatermark</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">KeyedStateStore</span> <span class="nf">windowState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">KeyedStateStore</span> <span class="nf">globalState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>windowState 和 globalState 是您可以存储该键的所有窗口的 per-key, per-window, 或全局 per-key 信息的地方。例如，如果您想记录一些关于当前窗口的信息，并在处理后续窗口时使用这些信息，这可能会很有用。</p>
<h4 id="递增聚合示例">递增聚合示例</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">DataStream</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">=</span> <span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="n">input</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">TumblingEventTimeWindows</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">minutes</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="n">MyReducingMax</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="k">new</span> <span class="n">MyWindowFunction</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyReducingMax</span> <span class="kd">implements</span> <span class="n">ReduceFunction</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">SensorReading</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">SensorReading</span> <span class="n">r1</span><span class="o">,</span> <span class="n">SensorReading</span> <span class="n">r2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">r1</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">r2</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span> <span class="o">?</span> <span class="n">r1</span> <span class="o">:</span> <span class="n">r2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyWindowFunction</span> <span class="kd">extends</span> <span class="n">ProcessWindowFunction</span><span class="o">&lt;</span>
    <span class="n">SensorReading</span><span class="o">,</span> <span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">SensorReading</span><span class="o">&gt;</span><span class="o">,</span> <span class="n">String</span><span class="o">,</span> <span class="n">TimeWindow</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span>
            <span class="n">String</span> <span class="n">key</span><span class="o">,</span>
            <span class="n">Context</span> <span class="n">context</span><span class="o">,</span>
            <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">SensorReading</span><span class="o">&gt;</span> <span class="n">maxReading</span><span class="o">,</span>
            <span class="n">Collector</span><span class="o">&lt;</span><span class="n">Tuple3</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">,</span> <span class="n">SensorReading</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">SensorReading</span> <span class="n">max</span> <span class="o">=</span> <span class="n">maxReading</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">out</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Tuple3</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">context</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getEnd</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">max</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>请注意，<code>Iterable&lt;SensorReading&gt;</code> 将只包含一个读数&ndash;由 MyReducingMax 计算的 pre-aggregated 最大值。</p>
<h3 id="迟来的事件">迟来的事件</h3>
<p>默认情况下，当使用事件时间窗口时，迟到的事件会被丢弃。窗口 API 有两个可选部分可以让您对此有更多的控制。</p>
<p>您可以使用名为<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/event_driven.html#side-outputs">&ldquo;侧输出&rdquo;</a>的机制，安排将被丢弃的事件收集到一个备用的输出流中。下面是一个例子，说明这可能是什么样子的:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">lateTag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span><span class="o">(</span><span class="s">&#34;late&#34;</span><span class="o">)</span><span class="o">{</span><span class="o">}</span><span class="o">;</span>

<span class="n">SingleOutputStreamOperator</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">sideOutputLateData</span><span class="o">(</span><span class="n">lateTag</span><span class="o">)</span>
    <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">;</span>
  
<span class="n">DataStream</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;</span> <span class="n">lateStream</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getSideOutput</span><span class="o">(</span><span class="n">lateTag</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>您还可以指定允许的延迟时间间隔，在此期间，延迟事件将继续分配给相应的窗口（其状态将被保留）。默认情况下，每个延迟事件都会导致窗口函数再次被调用（有时称为延迟发射）。</p>
<p>换句话说，水印后面的元素会被丢弃（或发送到侧输出）。</p>
<p>比如说:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span>
    <span class="o">.</span><span class="na">allowedLateness</span><span class="o">(</span><span class="n">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="n">10</span><span class="o">)</span><span class="o">)</span>
    <span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>当允许的延迟大于零时，只有那些晚到会被丢弃的事件才会被发送到侧输出（如果已经配置了）。</p>
<h3 id="惊喜">惊喜</h3>
<p>Flink 的 windowing API 的某些方面可能并不像你所期望的那样。基于 <a href="https://flink.apache.org/community.html#mailing-lists">flink 用户邮件列表</a>和其他地方的常见问题，这里有一些关于窗口的事实可能会让你感到惊讶。</p>
<h4 id="滑动窗口会进行复制">滑动窗口会进行复制</h4>
<p>滑动窗口分配器可以创建很多窗口对象，并会将每个事件复制到每个相关窗口中。例如，如果你每15分钟有一个长度为24小时的滑动窗口，每个事件将被复制到 4*24=96 个窗口中。</p>
<h4 id="时间窗口与纪元对齐">时间窗口与纪元对齐</h4>
<p>仅仅因为你使用了一个小时的处理时间窗口，并且在 12:05 开始运行你的应用程序，并不意味着第一个窗口会在 1:05 关闭。第一个窗口将长达 55 分钟，并在 1:00 关闭。</p>
<p>但是请注意，滚动窗口和滑动窗口分配器采用一个可选的偏移参数，可以用来改变窗口的对齐方式。详情请参见<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#tumbling-windows">滚动窗口</a>和<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html#sliding-windows">滑动窗口</a>。</p>
<h4 id="窗口可以跟随窗口">窗口可以跟随窗口</h4>
<p>例如，这样做是可行的:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">stream</span>
    <span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">key</span><span class="o">)</span>
    <span class="o">.</span><span class="na">timeWindow</span><span class="o">(</span><span class="o">&lt;</span><span class="n">time</span> <span class="n">specification</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="o">&lt;</span><span class="n">reduce</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">timeWindowAll</span><span class="o">(</span><span class="o">&lt;</span><span class="n">same</span> <span class="n">time</span> <span class="n">specification</span><span class="o">&gt;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="o">&lt;</span><span class="n">same</span> <span class="n">reduce</span> <span class="n">function</span><span class="o">&gt;</span><span class="o">)</span>
</code></pre></div><p>你可能会期望 Flink 的运行时足够聪明，能够为你做这种并行的预聚合（前提是你使用的是 ReduceFunction 或 AggregateFunction），但事实并非如此。</p>
<p>之所以这样做的原因是，一个时间窗口产生的事件会根据窗口结束的时间分配时间戳。所以，例如，一个小时长的窗口产生的所有事件都会有标记一个小时结束的时间戳。任何消耗这些事件的后续窗口的持续时间应该与前一个窗口的持续时间相同，或者是其倍数。</p>
<h4 id="空的时间窗口没有结果">空的时间窗口没有结果</h4>
<p>只有当事件被分配到窗口时，才会创建窗口。因此，如果在给定的时间帧内没有事件，就不会报告结果。</p>
<h4 id="迟来的事件会导致迟来的合并">迟来的事件会导致迟来的合并</h4>
<p>会话窗口是基于可以合并的窗口的抽象。每个元素最初都被分配到一个新的窗口，之后只要窗口之间的间隙足够小，就会合并。这样一来，一个迟到的事件可以弥合分开两个之前独立的会话的差距，产生迟到的合并。</p>
<h2 id="实践">实践</h2>
<p>与本节配套的实战练习是 <a href="https://github.com/apache/flink-training/tree/release-1.11/hourly-tips">Hourly Tips Exercise</a>。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/timely-stream-processing.html">及时的流处理</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">窗口</a></li>
</ul>
<p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/streaming_analytics.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[通过状态快照进行容错]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-intro-to-the-datastream-api/?utm_source=atom_feed" rel="related" type="text/html" title="DataStream API 介绍" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-event-driven-applications/?utm_source=atom_feed" rel="related" type="text/html" title="事件驱动型应用程序" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-learn-flink-hands-on-training/?utm_source=atom_feed" rel="related" type="text/html" title="学习 Flink: 实践培训" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-data-pipelines-and-etl/?utm_source=atom_feed" rel="related" type="text/html" title="数据管道和 ETL" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-19-streaming-analytics/?utm_source=atom_feed" rel="related" type="text/html" title="流分析" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-19-fault-tolerance/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-19T00:00:00+08:00</published>
            <updated>2020-08-19T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Fault Tolerance via State Snapshots</blockquote><h2 id="状态后端">状态后端</h2>
<p>Flink 管理的 keyed state 是一种碎片化的、键/值存储，每项 keyed state 的工作副本都被保存在负责该键的 taskmanager 的本地某处。Operator 的状态也被保存在需要它的机器的本地。Flink 会定期对所有状态进行持久化快照，并将这些快照复制到某个更持久的地方，比如分布式文件系统。</p>
<p>在发生故障的情况下，Flink 可以恢复你的应用程序的完整状态，并恢复处理，就像什么都没有发生过一样。</p>
<p>Flink 管理的这种状态被存储在状态后端中。状态后端有两种实现&ndash;一种是基于 RocksDB 的，它是一个嵌入式的键/值存储，将其工作状态保存在磁盘上；另一种是基于堆的状态后端，将其工作状态保存在内存中，在 Java 堆上。这种基于堆的状态后端有两种风味：将其状态快照持久化到分布式文件系统的 FsStateBackend 和使用 JobManager 的堆的 MemoryStateBackend。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">工作状态</th>
<th align="left">状态备份</th>
<th align="left">快照</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">RocksDBStateBackend</td>
<td align="left">本地磁盘(tmp dir)</td>
<td align="left">分布式文件系统</td>
<td align="left">完全/增量</td>
</tr>
<tr>
<td align="left">支持大于可用内存的状态; 经验法则：比基于堆的后端慢10倍。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">FsStateBackend</td>
<td align="left">JVM Heap</td>
<td align="left">分布式文件系统</td>
<td align="left">Full</td>
</tr>
<tr>
<td align="left">速度快，需要大量堆积; 受制于 GC</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">MemoryStateBackend</td>
<td align="left">JVM Heap</td>
<td align="left">JobManager JVM Heap</td>
<td align="left">Full</td>
</tr>
<tr>
<td align="left">有利于小状态（地方）的测试和实验。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>当处理保存在基于堆的状态后端的状态时，访问和更新涉及到在堆上读写对象。但是对于保存在 RocksDBStateBackend 中的对象，访问和更新涉及到序列化和反序列化，因此成本更高。但是使用 RocksDB 可以拥有的状态数量只受限于本地磁盘的大小。还要注意的是，只有 RocksDBStateBackend 能够进行增量快照，这对于有大量缓慢变化的状态的应用来说是一个很大的好处。</p>
<p>所有这些状态后端都能够进行异步快照，这意味着它们可以在不妨碍正在进行的流处理的情况下进行快照。</p>
<h2 id="状态快照">状态快照</h2>
<h3 id="定义">定义</h3>
<ul>
<li>快照&ndash;一个通用术语，指的是一个 Flink 作业状态的全局、一致的图像。快照包括进入每个数据源的指针（例如，进入文件或 Kafka 分区的偏移），以及来自每个作业的有状态操作符的状态副本，这些操作符是在处理了所有事件后产生的，直到源中的这些位置。</li>
<li>检查点&ndash;Flink 为了能够从故障中恢复而自动拍摄的快照。检查点可以是增量的，并为快速恢复进行了优化。</li>
<li>外部化检查点&ndash;通常检查点不打算被用户操纵。Flink 只在作业运行时保留n个最近的检查点（n是可配置的），并在作业取消时删除它们。但你也可以配置它们被保留，在这种情况下，你可以手动从它们恢复。</li>
<li>保存点&ndash;由用户（或API调用）手动触发的快照，用于某些操作目的，例如有状态的重新部署/升级/重新缩放操作。保存点始终是完整的，并为操作的灵活性进行了优化。</li>
</ul>
<h3 id="状态快照是如何工作的">状态快照是如何工作的？</h3>
<p>Flink 使用 <a href="https://en.wikipedia.org/wiki/Chandy-Lamport_algorithm">Chandy-Lamport</a> 算法的一个变体，称为异步屏障快照。</p>
<p>当任务管理器被检查点协调器（作业管理器的一部分）指示开始检查点时，它让所有的源记录它们的偏移量，并在它们的流中插入编号的检查点障碍。这些屏障在作业图(job graph)中流动，指示每个检查点前后的流的部分。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_barriers.svg" alt="img"></p>
<p>检查点n将包含每个 operator 的状态，这些状态是由于消耗了检查点障碍n之前的每个事件，而没有消耗它之后的任何事件。</p>
<p>当作业图中的每个 operator 接收到这些障碍之一时，它就会记录其状态。具有两个输入流（如 CoProcessFunction）的 operator 执行屏障对齐，这样快照将反映消耗两个输入流的事件所产生的状态，直到（但不超过）两个屏障。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/stream_aligning.svg" alt="img"></p>
<p>Flink 的状态后端使用复制-写机制，允许在异步快照状态的旧版本时，流处理不受阻碍地继续。只有当快照被持久化后，这些旧版本的状态才会被垃圾回收。</p>
<h3 id="一次性保证">一次性保证</h3>
<p>当流处理应用中出现问题时，有可能出现丢失，或者重复的结果。在 Flink 中，根据你对应用的选择和你运行它的集群，这些结果中的任何一种都是可能的。</p>
<ul>
<li>Flink 不努力从故障中恢复（最多一次）。</li>
<li>没有任何损失，但您可能会遇到重复的结果（至少一次）。</li>
<li>没有任何东西丢失或重复（精确地一次）。</li>
</ul>
<p>鉴于 Flink 通过倒带和重放源数据流从故障中恢复，当理想情况被描述为精确一次时，这并不意味着每个事件都将被精确处理一次。相反，它意味着每一个事件都会对 Flink 所管理的状态产生一次确切的影响。</p>
<p>Barrier 对齐只需要用于提供精确的一次保证。如果你不需要这个，你可以通过配置 Flink 使用 CheckpointingMode.AT_LEAST_ONCE 来获得一些性能，它的效果是禁用屏障对齐。</p>
<h3 id="精确一次-端到端">精确一次, 端到端</h3>
<p>为了实现端到端精确的一次，让源的每个事件精确地影响汇，以下几点必须是真的。</p>
<ol>
<li>你的源必须是可重播的，并且</li>
<li>你的接收器必须是事务性的(或幂等的)</li>
</ol>
<h2 id="实践">实践</h2>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html">Flink Operations Playground</a> 包括<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html#observing-failure--recovery">观察故障和恢复</a>的部分。</p>
<h2 id="进一步阅读">进一步阅读</h2>
<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/stateful-stream-processing.html">有状态的流处理</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/state_backends.html">状态后端</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/guarantees.html">数据源和接收器的容错保证</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/state/checkpointing.html">启用和配置检查点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/checkpoints.html">检查点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/savepoints.html">保存点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/large_state_tuning.html">调整检查点和大状态</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/checkpoint_monitoring.html">监测检查点</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/task_failure_recovery.html">任务故障恢复</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/training" term="training" label="Training" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Flink 操作游乐场]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-17-flink-operations-playground/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-17-python-api-tutorial/?utm_source=atom_feed" rel="related" type="text/html" title="Python API 指南" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-05-connectors-in-flink/?utm_source=atom_feed" rel="related" type="text/html" title="Flink 中的 Connectors" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-17-flink-operations-playground/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-17T00:00:00+08:00</published>
            <updated>2020-08-17T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Flink Operations Playground</blockquote><h2 id="flink-操作游乐场">Flink 操作游乐场</h2>
<p>在各种环境中部署和操作 Apache Flink 的方法有很多。无论这种多样性如何，Flink 集群的基本构件保持不变，类似的操作原则也适用。</p>
<p>在这个操场上，你将学习如何管理和运行 Flink Jobs。您将看到如何部署和监控应用程序，体验 Flink 如何从 Job 故障中恢复，并执行日常操作任务，如升级和重新缩放。</p>
<h3 id="这个游乐场的解剖">这个游乐场的解剖</h3>
<p>这个游乐场由一个持久的 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-session-cluster">Flink Session Cluster</a>和一个 Kafka Cluster 组成。</p>
<p>一个 Flink Cluster 总是由一个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-jobmanager">JobManager</a> 和一个或多个 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-taskmanager">Flink TaskManager</a> 组成。JobManager 负责处理 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#flink-job">Job</a> 提交，监督 Job 以及资源管理。Flink TaskManager 是 worker 进程，负责执行构成 Flink Job 的实际<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/concepts/glossary.html#task">任务</a>。在这个游戏场中，你将从一个单一的 TaskManager 开始，但以后会扩展到更多的 TaskManager。此外，这个游乐场还带有一个专门的客户端容器，我们使用它来提交 Flink Job，并在以后执行各种操作任务。客户端容器不是 Flink Cluster 本身需要的，只是为了方便使用才包含在里面。</p>
<p>Kafka 集群由一个 Zookeeper 服务器和一个 Kafka Broker 组成。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/flink-docker-playground.svg" alt="img"></p>
<p>当游乐场启动时，一个名为 Flink Event Count 的 Flink Job 将被提交给 JobManager。此外，还会创建两个 Kafka 主题 <em>input</em> 和 <em>output</em>。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/click-event-count-example.svg" alt="img"></p>
<p>该作业从 <em>input</em> 主题中消耗点击事件(<strong>ClickEvent</strong>)，每个点击事件(<strong>ClickEvent</strong>)都有一个时间戳(<strong>timestamp</strong>)和一个页面(<strong>page</strong>)。然后按页面对事件进行分组(<strong>keyed by</strong>)，并在 15 秒的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">窗口</a>中进行计数。结果被写入 <em>output</em> 主题。</p>
<p>有6个不同的页面，我们在每个页面和15秒内产生1000个点击事件。因此，Flink 作业的输出应该显示每个页面和窗口有1000个浏览量。</p>
<h3 id="启动游乐场">启动游乐场</h3>
<p>游戏场环境的设置只需几步。我们将引导你完成必要的命令，并展示如何验证一切都在正确运行。</p>
<p>我们假设你的机器上安装了 <a href="https://docs.docker.com/">Docker</a>（1.12+）和 <a href="https://docs.docker.com/compose/">docker-compose</a>（2.1+）。</p>
<p>所需的配置文件可以在 <a href="https://github.com/apache/flink-playgrounds">flink-playgrounds</a> 仓库中找到。检查一下，然后对齐环境。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git clone --branch release-1.11 https://github.com/apache/flink-playgrounds.git
<span class="nb">cd</span> flink-playgrounds/operations-playground
docker-compose build
docker-compose up -d
</code></pre></div><p>之后，你可以用以下命令检查正在运行的 Docker 容器。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose ps

                    Name                                  Command               State                   Ports                
-----------------------------------------------------------------------------------------------------------------------------
operations-playground_clickevent-generator_1   /docker-entrypoint.sh java ...   Up       6123/tcp, 8081/tcp                  
operations-playground_client_1                 /docker-entrypoint.sh flin ...   Exit <span class="m">0</span>                                       
operations-playground_jobmanager_1             /docker-entrypoint.sh jobm ...   Up       6123/tcp, 0.0.0.0:8081-&gt;8081/tcp    
operations-playground_kafka_1                  start-kafka.sh                   Up       0.0.0.0:9094-&gt;9094/tcp              
operations-playground_taskmanager_1            /docker-entrypoint.sh task ...   Up       6123/tcp, 8081/tcp                  
operations-playground_zookeeper_1              /bin/sh -c /usr/sbin/sshd  ...   Up       2181/tcp, 22/tcp, 2888/tcp, 3888/tcp
</code></pre></div><p>这表明客户端容器已经成功提交了 Flink Job（Exit 0），所有集群组件以及数据生成器都在运行（Up）。</p>
<p>您可以通过调用来停止游乐场环境。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose down -v
</code></pre></div><h3 id="进入游乐场">进入游乐场</h3>
<p>在这个游乐场中，有很多东西你可以尝试和检查。在下面的两节中，我们将向您展示如何与 Flink 集群进行交互，并展示 Flink 的一些关键功能。</p>
<h4 id="flink-webui">Flink WebUI</h4>
<p>观察你的 Flink 集群最自然的出发点是在 <a href="http://localhost:8081/">http://localhost:8081</a> 下暴露的 WebUI。如果一切顺利，你会看到集群最初由一个任务管理器组成，并执行一个名为 Click Event Count 的 Job。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/playground-webui.png" alt="img"></p>
<p>Flink WebUI 包含了很多关于 Flink 集群和它的工作的有用和有趣的信息（JobGraph, Metrics, Checkpointing Statistics, TaskManager Status, &hellip;）。</p>
<h4 id="日志">日志</h4>
<h5 id="jobmanager">JobManager</h5>
<p>可以通过 <code>docker-compose</code> 对 JobManager 日志进行跟踪。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose logs -f jobmanager
</code></pre></div><p>在初始启动后，你应该主要看到每一个检查点完成的日志信息。</p>
<h5 id="taskmanager">TaskManager</h5>
<p>TaskManager 的日志也可以用同样的方式进行 tail。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose logs -f taskmanager
</code></pre></div><p>在初始启动后，你应该主要看到每个检查点完成的日志信息。</p>
<h4 id="flink-cli">Flink CLI</h4>
<p>Flink CLI 可以在客户端容器中使用。例如，要打印 Flink CLI 的帮助信息，你可以运行以下命令</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose run --no-deps client flink --help
</code></pre></div><h4 id="flink-rest-api">Flink REST API</h4>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/rest_api.html#api">Flink REST API</a> 通过主机上的 localhost:8081 或客户端容器中的 jobmanager:8081 暴露出来，例如，要列出所有当前正在运行的作业，你可以运行:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">curl localhost:8081/jobs
</code></pre></div><h4 id="kafka-topics">Kafka Topics</h4>
<p>你可以通过运行以下命令来查看写入 Kafka 主题的记录</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">//input topic <span class="o">(</span><span class="m">1000</span> records/s<span class="o">)</span>
docker-compose <span class="nb">exec</span> kafka kafka-console-consumer.sh <span class="se">\
</span><span class="se"></span>  --bootstrap-server localhost:9092 --topic input

//output topic <span class="o">(</span><span class="m">24</span> records/min<span class="o">)</span>
docker-compose <span class="nb">exec</span> kafka kafka-console-consumer.sh <span class="se">\
</span><span class="se"></span>  --bootstrap-server localhost:9092 --topic output
</code></pre></div><h4 id="time-to-play">Time to Play!</h4>
<p>现在你已经学会了如何与 Flink 和 Docker 容器进行交互，让我们来看看一些常见的操作任务，你可以在我们的游乐场上尝试一下。所有这些任务都是相互独立的，即你可以以任何顺序执行它们。大多数任务可以通过 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html#flink-cli">CLI</a> 和 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html#flink-rest-api">REST API</a> 来执行。</p>
<h5 id="列出正在运行的-job">列出正在运行的 Job</h5>
<ul>
<li>CLI</li>
</ul>
<p><strong>命令</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose run --no-deps client flink list
</code></pre></div><p><strong>期望的输出</strong></p>
<pre><code>Waiting for response...
------------------ Running/Restarting Jobs -------------------
16.07.2019 16:37:55 : &lt;job-id&gt; : Click Event Count (RUNNING)
--------------------------------------------------------------
No scheduled jobs.
</code></pre><ul>
<li>REST API</li>
</ul>
<p><strong>请求</strong></p>
<pre><code>curl localhost:8081/jobs
</code></pre><p><strong>期待的响应(美化了打印)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;jobs&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;job-id&gt;&#34;</span><span class="p">,</span>
      <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;RUNNING&#34;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>JobID 在提交时被分配给作业(Job)，并且需要通过 CLI 或 REST API 对作业(Job)执行操作。</p>
<h5 id="观察故障和恢复">观察故障和恢复</h5>
<p>Flink 在(部分)失败下提供了精确的一次处理保证。在这个游乐场中，你可以观察并在一定程度上验证这种行为。</p>
<p><strong>步骤1：观察输出</strong></p>
<p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html#anatomy-of-this-playground">如上所述</a>，在这个游乐场中的事件是这样生成的，每个窗口正好包含一千条记录。因此，为了验证 Flink 是否成功地从 TaskManager 故障中恢复，而没有数据丢失或重复，你可以跟踪 <em>output</em> 主题，并检查恢复后所有的窗口都存在，而且计数是正确的。</p>
<p>为此，从 <em>output</em> 主题开始读取，并让这个命令运行到恢复后（步骤3）。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose <span class="nb">exec</span> kafka kafka-console-consumer.sh <span class="se">\
</span><span class="se"></span>  --bootstrap-server localhost:9092 --topic output
</code></pre></div><p><strong>第二步：引入故障</strong></p>
<p>为了模拟部分故障，你可以杀死一个 TaskManager，在生产设置中，这可能对应于 TaskManager 进程、TaskManager 机器的丢失，或者仅仅是框架或用户代码抛出的瞬时异常（例如由于暂时不可用）。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose <span class="nb">kill</span> taskmanager
</code></pre></div><p>几秒钟后，JobManager 会注意到 TaskManager 的丢失，取消受影响的 Job，并立即重新提交它进行恢复。当 Job 被重新启动后，其任务仍处于 <strong>SCHEDULED</strong> 状态，由紫色的方块表示（见下面的截图）。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/playground-webui-failure.png" alt="img"></p>
<p>注意：即使作业(Job)的任务(Task)处于 <strong>SCHEDULED</strong> 状态而不是 <strong>RUNNING</strong> 状态，作业(Job)的整体状态也会显示为 <strong>RUNNING</strong>。</p>
<p>此时，Job 的任务(Task)不能从 <strong>SCHEDULED</strong> 状态转为 <strong>RUNNING</strong> 状态，因为没有资源(<strong>TaskManager</strong> 提供的 <strong>TaskSlots</strong>）来运行这些任务。在新的 TaskManager 可用之前，Job 将经历一个取消和重新提交的循环。</p>
<p>同时，数据生成器会不断地将 ClickEvents 推送到 <em>input</em> 主题中。这类似于真正的生产设置，在生产数据的同时，要处理数据的 Job 却宕机了。</p>
<p><strong>步骤3：恢复</strong></p>
<p>一旦你重新启动 TaskManager，它就会重新连接到 JobManager。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose up -d taskmanager
</code></pre></div><p>当 JobManager 被通知到新的 TaskManager 时，它将恢复中的 Job 的任务(tasks)调度到新的可用 TaskSlots。重新启动后，任务会从故障前最后一次成功的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/fault_tolerance.html">检查点</a>恢复其状态，并切换到 RUNNING 状态。</p>
<p>Job 将快速处理来自 Kafka 的全部积压输入事件(在故障期间积累的)，并以更高的速度(&gt;24条记录/分钟)产生输出，直到到达流的头部。在输出中，你会看到所有的键(页面)都存在于所有的时间窗口中，而且每个计数都是精确的 1000。由于我们是在&quot;至少一次&quot;模式下使用 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/connectors/kafka.html#kafka-producers-and-fault-tolerance">FlinkKafkaProducer</a>，所以你有可能会看到一些重复的输出记录。</p>
<p>注意：大多数生产设置依赖于资源管理器(Kubernetes、Yarn、Mesos)来自动重启失败的进程。</p>
<h5 id="升级和重新缩放作业">升级和重新缩放作业</h5>
<p>升级 Flink 作业总是涉及两个步骤。首先，用一个<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/state/savepoints.html">保存点</a>优雅地停止 Flink Job。保存点是在一个明确定义的、全局一致的时间点(类似于检查点)上的完整应用状态的一致快照。其次，升级后的 Flink Job 从 Savepoint 开始。在这种情况下，&ldquo;升级&quot;可以意味着不同的事情，包括以下内容:</p>
<ul>
<li>配置的升级（包括作业的并行性）。</li>
<li>对 Job 的拓扑结构进行升级（增加/删除 Operator）。</li>
<li>对 Job 的用户定义的函数进行升级。</li>
</ul>
<p>在开始升级之前，你可能要开始 tailing <em>output</em> 主题，以观察在升级过程中没有数据丢失或损坏。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose <span class="nb">exec</span> kafka kafka-console-consumer.sh <span class="se">\
</span><span class="se"></span>  --bootstrap-server localhost:9092 --topic output
</code></pre></div><p><strong>第一步：停止工作</strong></p>
<p>要优雅地停止作业，您需要使用 CLI 或 REST API 的 &ldquo;stop&rdquo; 命令。为此，您需要该作业的 JobID，您可以通过<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html#listing-running-jobs">列出所有正在运行的 Job</a> 或从 WebUI 中获得。有了 JobID，您就可以继续停止该作业:</p>
<ul>
<li>CLI</li>
</ul>
<p><strong>命令</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose run --no-deps client flink stop &lt;job-id&gt;
</code></pre></div><p><strong>预期的输出</strong></p>
<pre><code>Suspending job &quot;&lt;job-id&gt;&quot; with a savepoint.
Suspended job &quot;&lt;job-id&gt;&quot; with a savepoint.
</code></pre><p>Savepoint 已经被存储到 flink-conf.yaml 中配置的 state.savepoint.dir 中，它被安装在本地机器的 /tmp/flink-savepoints-directory/ 下。在下一步中，你将需要这个 Savepoint 的路径。在 REST API 的情况下，这个路径已经是响应的一部分，你将需要直接查看文件系统。</p>
<p><strong>命令</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">ls -lia /tmp/flink-savepoints-directory
</code></pre></div><p><strong>预期的输出</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">total <span class="m">0</span>
  <span class="m">17</span> drwxr-xr-x   <span class="m">3</span> root root   <span class="m">60</span> <span class="m">17</span> jul 17:05 .
   <span class="m">2</span> drwxrwxrwt <span class="m">135</span> root root <span class="m">3420</span> <span class="m">17</span> jul 17:09 ..
<span class="m">1002</span> drwxr-xr-x   <span class="m">2</span> root root  <span class="m">140</span> <span class="m">17</span> jul 17:05 savepoint-&lt;short-job-id&gt;-&lt;uuid&gt;
</code></pre></div><ul>
<li>REST API</li>
</ul>
<p><strong>请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># triggering stop</span>
curl -X POST localhost:8081/jobs/&lt;job-id&gt;/stop -d <span class="s1">&#39;{&#34;drain&#34;: false}&#39;</span>
</code></pre></div><p><strong>预期的响应(美化了打印)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;request-id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;trigger-id&gt;&#34;</span>
<span class="p">}</span>
</code></pre></div><p><strong>请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># check status of stop action and retrieve savepoint path</span>
curl localhost:8081/jobs/&lt;job-id&gt;/savepoints/&lt;trigger-id&gt;
</code></pre></div><p><strong>预期的响应(美化了打印)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;COMPLETED&#34;</span>
  <span class="p">}</span><span class="p">,</span>
  <span class="nt">&#34;operation&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;location&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;savepoint-path&gt;&#34;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>步骤2a: 重启 Job，不做任何改变</strong></p>
<p>现在您可以从该保存点重新启动升级后的作业(Job)。为了简单起见，您可以在不做任何更改的情况下重新启动它。</p>
<ul>
<li>CLI</li>
</ul>
<p><strong>命令</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose run --no-deps client flink run -s &lt;savepoint-path&gt; <span class="se">\
</span><span class="se"></span>  -d /opt/ClickCountJob.jar <span class="se">\
</span><span class="se"></span>  --bootstrap.servers kafka:9092 --checkpointing --event-time
</code></pre></div><p><strong>预期的输出</strong></p>
<pre><code>Starting execution of program
Job has been submitted with JobID &lt;job-id&gt;
</code></pre><ul>
<li>REST API</li>
</ul>
<p><strong>请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Uploading the JAR from the Client container</span>
docker-compose run --no-deps client curl -X POST -H <span class="s2">&#34;Expect:&#34;</span> <span class="se">\
</span><span class="se"></span>  -F <span class="s2">&#34;jarfile=@/opt/ClickCountJob.jar&#34;</span> http://jobmanager:8081/jars/upload
</code></pre></div><p><strong>预期的响应(美化了打印)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;filename&#34;</span><span class="p">:</span> <span class="s2">&#34;/tmp/flink-web-&lt;uuid&gt;/flink-web-upload/&lt;jar-id&gt;&#34;</span><span class="p">,</span>
  <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;success&#34;</span>
<span class="p">}</span>
</code></pre></div><p><strong>请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Submitting the Job</span>
curl -X POST http://localhost:8081/jars/&lt;jar-id&gt;/run <span class="se">\
</span><span class="se"></span>  -d <span class="s1">&#39;{&#34;programArgs&#34;: &#34;--bootstrap.servers kafka:9092 --checkpointing --event-time&#34;, &#34;savepointPath&#34;: &#34;&lt;savepoint-path&gt;&#34;}&#39;</span>
</code></pre></div><p><strong>预期的输出</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;jobid&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;job-id&gt;&#34;</span>
<span class="p">}</span>
</code></pre></div><p>一旦 Job 再次 RUNNING，你会在 <em>output</em> 主题中看到，当 Job 在处理中断期间积累的积压时，记录以较高的速度产生。此外，你会看到在升级过程中没有丢失任何数据：所有窗口都存在，数量正好是 1000。</p>
<p><strong>步骤2b: 用不同的并行度重新启动作业（重新缩放）</strong></p>
<p>另外，您也可以在重新提交时通过传递不同的并行性，从这个保存点重新缩放作业。</p>
<ul>
<li>CLI</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose run --no-deps client flink run -p <span class="m">3</span> -s &lt;savepoint-path&gt; <span class="se">\
</span><span class="se"></span>  -d /opt/ClickCountJob.jar <span class="se">\
</span><span class="se"></span>  --bootstrap.servers kafka:9092 --checkpointing --event-time
</code></pre></div><p><strong>预期的输出</strong></p>
<pre><code>Starting execution of program
Job has been submitted with JobID &lt;job-id&gt;
</code></pre><ul>
<li>REST API</li>
</ul>
<p><strong>请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Uploading the JAR from the Client container</span>
docker-compose run --no-deps client curl -X POST -H <span class="s2">&#34;Expect:&#34;</span> <span class="se">\
</span><span class="se"></span>  -F <span class="s2">&#34;jarfile=@/opt/ClickCountJob.jar&#34;</span> http://jobmanager:8081/jars/upload
</code></pre></div><p><strong>预期的响应(美化了打印)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;filename&#34;</span><span class="p">:</span> <span class="s2">&#34;/tmp/flink-web-&lt;uuid&gt;/flink-web-upload/&lt;jar-id&gt;&#34;</span><span class="p">,</span>
  <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;success&#34;</span>
<span class="p">}</span>
</code></pre></div><p><strong>请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Submitting the Job</span>
curl -X POST http://localhost:8081/jars/&lt;jar-id&gt;/run <span class="se">\
</span><span class="se"></span>  -d <span class="s1">&#39;{&#34;parallelism&#34;: 3, &#34;programArgs&#34;: &#34;--bootstrap.servers kafka:9092 --checkpointing --event-time&#34;, &#34;savepointPath&#34;: &#34;&lt;savepoint-path&gt;&#34;}&#39;</span>
</code></pre></div><p><strong>预期的响应(美化了打印)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;jobid&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;job-id&gt;&#34;</span>
<span class="p">}</span>
</code></pre></div><p>现在，作业(Job)已经被重新提交，但它不会启动，因为没有足够的 TaskSlots 在增加的并行度下执行它（2个可用，需要3个）。使用:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">docker-compose scale <span class="nv">taskmanager</span><span class="o">=</span><span class="m">2</span>
</code></pre></div><p>你可以在 Flink 集群中添加一个带有两个 TaskSlots 的第二个 TaskManager，它将自动注册到 JobManager 中。添加 TaskManager 后不久，该任务(Job)应该再次开始运行。</p>
<p>一旦 Job 再次 &ldquo;RUNNING&rdquo;，你会在 <em>output</em> Topic 中看到在重新缩放过程中没有丢失数据：所有的窗口都存在，计数正好是 1000。</p>
<h5 id="查询作业job的指标">查询作业(Job)的指标</h5>
<p>JobManager 通过其 REST API 公开系统和用户<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/metrics.html">指标</a>。</p>
<p>端点取决于这些指标的范围。可以通过 <code>jobs/&lt;job-id&gt;/metrics</code> 来列出一个作业的范围内的度量。指标的实际值可以通过 get query 参数进行查询。</p>
<p><strong>请求</strong></p>
<pre><code class="language-shells" data-lang="shells">curl &quot;localhost:8081/jobs/&lt;jod-id&gt;/metrics?get=lastCheckpointSize&quot;
</code></pre><p><strong>预期的响应(美化了打印; 没有占位符)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">[</span>
  <span class="p">{</span>
    <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;lastCheckpointSize&#34;</span><span class="p">,</span>
    <span class="nt">&#34;value&#34;</span><span class="p">:</span> <span class="s2">&#34;9378&#34;</span>
  <span class="p">}</span>
<span class="p">]</span>
</code></pre></div><p>REST API 不仅可以用来查询指标，还可以检索运行中的作业状态的详细信息。</p>
<p><strong>请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># find the vertex-id of the vertex of interest</span>
curl localhost:8081/jobs/&lt;jod-id&gt;
</code></pre></div><p><strong>预期的响应(美化了打印)</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;jid&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;job-id&gt;&#34;</span><span class="p">,</span>
  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Click Event Count&#34;</span><span class="p">,</span>
  <span class="nt">&#34;isStoppable&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nt">&#34;state&#34;</span><span class="p">:</span> <span class="s2">&#34;RUNNING&#34;</span><span class="p">,</span>
  <span class="nt">&#34;start-time&#34;</span><span class="p">:</span> <span class="mi">1564467066026</span><span class="p">,</span>
  <span class="nt">&#34;end-time&#34;</span><span class="p">:</span> <span class="mi">-1</span><span class="p">,</span>
  <span class="nt">&#34;duration&#34;</span><span class="p">:</span> <span class="mi">374793</span><span class="p">,</span>
  <span class="nt">&#34;now&#34;</span><span class="p">:</span> <span class="mi">1564467440819</span><span class="p">,</span>
  <span class="nt">&#34;timestamps&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;CREATED&#34;</span><span class="p">:</span> <span class="mi">1564467066026</span><span class="p">,</span>
    <span class="nt">&#34;FINISHED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;SUSPENDED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;FAILING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;CANCELLING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;CANCELED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;RECONCILING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;RUNNING&#34;</span><span class="p">:</span> <span class="mi">1564467066126</span><span class="p">,</span>
    <span class="nt">&#34;FAILED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;RESTARTING&#34;</span><span class="p">:</span> <span class="mi">0</span>
  <span class="p">}</span><span class="p">,</span>
  <span class="nt">&#34;vertices&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ClickEvent Source&#34;</span><span class="p">,</span>
      <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;RUNNING&#34;</span><span class="p">,</span>
      <span class="nt">&#34;start-time&#34;</span><span class="p">:</span> <span class="mi">1564467066423</span><span class="p">,</span>
      <span class="nt">&#34;end-time&#34;</span><span class="p">:</span> <span class="mi">-1</span><span class="p">,</span>
      <span class="nt">&#34;duration&#34;</span><span class="p">:</span> <span class="mi">374396</span><span class="p">,</span>
      <span class="nt">&#34;tasks&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;CREATED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FINISHED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;DEPLOYING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RUNNING&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;CANCELING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FAILED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;CANCELED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RECONCILING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;SCHEDULED&#34;</span><span class="p">:</span> <span class="mi">0</span>
      <span class="p">}</span><span class="p">,</span>
      <span class="nt">&#34;metrics&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;read-bytes&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;read-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes&#34;</span><span class="p">:</span> <span class="mi">5033461</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;read-records&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;read-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-records&#34;</span><span class="p">:</span> <span class="mi">166351</span><span class="p">,</span>
        <span class="nt">&#34;write-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Timestamps/Watermarks&#34;</span><span class="p">,</span>
      <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;RUNNING&#34;</span><span class="p">,</span>
      <span class="nt">&#34;start-time&#34;</span><span class="p">:</span> <span class="mi">1564467066441</span><span class="p">,</span>
      <span class="nt">&#34;end-time&#34;</span><span class="p">:</span> <span class="mi">-1</span><span class="p">,</span>
      <span class="nt">&#34;duration&#34;</span><span class="p">:</span> <span class="mi">374378</span><span class="p">,</span>
      <span class="nt">&#34;tasks&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;CREATED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FINISHED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;DEPLOYING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RUNNING&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;CANCELING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FAILED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;CANCELED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RECONCILING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;SCHEDULED&#34;</span><span class="p">:</span> <span class="mi">0</span>
      <span class="p">}</span><span class="p">,</span>
      <span class="nt">&#34;metrics&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;read-bytes&#34;</span><span class="p">:</span> <span class="mi">5066280</span><span class="p">,</span>
        <span class="nt">&#34;read-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes&#34;</span><span class="p">:</span> <span class="mi">5033496</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;read-records&#34;</span><span class="p">:</span> <span class="mi">166349</span><span class="p">,</span>
        <span class="nt">&#34;read-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-records&#34;</span><span class="p">:</span> <span class="mi">166349</span><span class="p">,</span>
        <span class="nt">&#34;write-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ClickEvent Counter&#34;</span><span class="p">,</span>
      <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;RUNNING&#34;</span><span class="p">,</span>
      <span class="nt">&#34;start-time&#34;</span><span class="p">:</span> <span class="mi">1564467066469</span><span class="p">,</span>
      <span class="nt">&#34;end-time&#34;</span><span class="p">:</span> <span class="mi">-1</span><span class="p">,</span>
      <span class="nt">&#34;duration&#34;</span><span class="p">:</span> <span class="mi">374350</span><span class="p">,</span>
      <span class="nt">&#34;tasks&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;CREATED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FINISHED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;DEPLOYING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RUNNING&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;CANCELING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FAILED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;CANCELED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RECONCILING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;SCHEDULED&#34;</span><span class="p">:</span> <span class="mi">0</span>
      <span class="p">}</span><span class="p">,</span>
      <span class="nt">&#34;metrics&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;read-bytes&#34;</span><span class="p">:</span> <span class="mi">5085332</span><span class="p">,</span>
        <span class="nt">&#34;read-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes&#34;</span><span class="p">:</span> <span class="mi">316</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;read-records&#34;</span><span class="p">:</span> <span class="mi">166305</span><span class="p">,</span>
        <span class="nt">&#34;read-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-records&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="nt">&#34;write-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ClickEventStatistics Sink&#34;</span><span class="p">,</span>
      <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="nt">&#34;status&#34;</span><span class="p">:</span> <span class="s2">&#34;RUNNING&#34;</span><span class="p">,</span>
      <span class="nt">&#34;start-time&#34;</span><span class="p">:</span> <span class="mi">1564467066476</span><span class="p">,</span>
      <span class="nt">&#34;end-time&#34;</span><span class="p">:</span> <span class="mi">-1</span><span class="p">,</span>
      <span class="nt">&#34;duration&#34;</span><span class="p">:</span> <span class="mi">374343</span><span class="p">,</span>
      <span class="nt">&#34;tasks&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;CREATED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FINISHED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;DEPLOYING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RUNNING&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;CANCELING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;FAILED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;CANCELED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;RECONCILING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;SCHEDULED&#34;</span><span class="p">:</span> <span class="mi">0</span>
      <span class="p">}</span><span class="p">,</span>
      <span class="nt">&#34;metrics&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;read-bytes&#34;</span><span class="p">:</span> <span class="mi">20668</span><span class="p">,</span>
        <span class="nt">&#34;read-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;write-bytes-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;read-records&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="nt">&#34;read-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nt">&#34;write-records&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nt">&#34;write-records-complete&#34;</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">]</span><span class="p">,</span>
  <span class="nt">&#34;status-counts&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;CREATED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;FINISHED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;DEPLOYING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;RUNNING&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="nt">&#34;CANCELING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;FAILED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;CANCELED&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;RECONCILING&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;SCHEDULED&#34;</span><span class="p">:</span> <span class="mi">0</span>
  <span class="p">}</span><span class="p">,</span>
  <span class="nt">&#34;plan&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;jid&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;job-id&gt;&#34;</span><span class="p">,</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Click Event Count&#34;</span><span class="p">,</span>
    <span class="nt">&#34;nodes&#34;</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;operator&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;operator_strategy&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;ClickEventStatistics Sink&#34;</span><span class="p">,</span>
        <span class="nt">&#34;inputs&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;num&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
            <span class="nt">&#34;ship_strategy&#34;</span><span class="p">:</span> <span class="s2">&#34;FORWARD&#34;</span><span class="p">,</span>
            <span class="nt">&#34;exchange&#34;</span><span class="p">:</span> <span class="s2">&#34;pipelined_bounded&#34;</span>
          <span class="p">}</span>
        <span class="p">]</span><span class="p">,</span>
        <span class="nt">&#34;optimizer_properties&#34;</span><span class="p">:</span> <span class="p">{</span><span class="p">}</span>
      <span class="p">}</span><span class="p">,</span>
      <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;operator&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;operator_strategy&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;ClickEvent Counter&#34;</span><span class="p">,</span>
        <span class="nt">&#34;inputs&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;num&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
            <span class="nt">&#34;ship_strategy&#34;</span><span class="p">:</span> <span class="s2">&#34;HASH&#34;</span><span class="p">,</span>
            <span class="nt">&#34;exchange&#34;</span><span class="p">:</span> <span class="s2">&#34;pipelined_bounded&#34;</span>
          <span class="p">}</span>
        <span class="p">]</span><span class="p">,</span>
        <span class="nt">&#34;optimizer_properties&#34;</span><span class="p">:</span> <span class="p">{</span><span class="p">}</span>
      <span class="p">}</span><span class="p">,</span>
      <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;operator&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;operator_strategy&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;Timestamps/Watermarks&#34;</span><span class="p">,</span>
        <span class="nt">&#34;inputs&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;num&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
            <span class="nt">&#34;ship_strategy&#34;</span><span class="p">:</span> <span class="s2">&#34;FORWARD&#34;</span><span class="p">,</span>
            <span class="nt">&#34;exchange&#34;</span><span class="p">:</span> <span class="s2">&#34;pipelined_bounded&#34;</span>
          <span class="p">}</span>
        <span class="p">]</span><span class="p">,</span>
        <span class="nt">&#34;optimizer_properties&#34;</span><span class="p">:</span> <span class="p">{</span><span class="p">}</span>
      <span class="p">}</span><span class="p">,</span>
      <span class="p">{</span>
        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;&lt;vertex-id&gt;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;parallelism&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="nt">&#34;operator&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;operator_strategy&#34;</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;ClickEvent Source&#34;</span><span class="p">,</span>
        <span class="nt">&#34;optimizer_properties&#34;</span><span class="p">:</span> <span class="p">{</span><span class="p">}</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>请查阅 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/rest_api.html#api">REST API 参考资料</a>，了解可能查询的完整列表，包括如何查询不同作用域的指标（如 TaskManager 指标）。</p>
<h4 id="变体">变体</h4>
<p>你可能已经注意到，Click Event Count 应用程序总是以 <code>--checkpointing</code> 和 <code>--event-time</code> 程序参数启动。通过在 docker-compose.yaml 的客户端容器的命令中省略这些，你可以改变 Job 的行为。</p>
<ul>
<li>
<p><code>--checkpointing</code> 启用了 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/learn-flink/fault_tolerance.html">checkpoint</a>，这是 Flink 的容错机制。如果你在没有它的情况下运行，并通过<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/flink-operations-playground.html#observing-failure--recovery">故障和恢复</a>，你应该会看到数据实际上已经丢失了。</p>
</li>
<li>
<p><code>--event-time</code> 启用了你的 Job 的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/event_time.html">事件时间语义</a>。当禁用时，作业将根据挂钟时间而不是 ClickEvent 的时间戳将事件分配给窗口。因此，每个窗口的事件数量将不再是精确的 1000。</p>
</li>
</ul>
<p>Click Event Count 应用程序还有另一个选项，默认情况下是关闭的，你可以启用这个选项来探索这个作业在背压下的行为。你可以在 <code>docker-compose.yaml</code> 的客户端容器的命令中添加这个选项。</p>
<ul>
<li><code>--backpressure</code> 在作业中间增加了一个额外的 operator，在偶数分钟内会造成严重的背压（例如，在10:12期间，但在10:13期间不会）。这可以通过检查各种<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/metrics.html#default-shuffle-service">网络指标</a>（如 outputQueueLength 和 outPoolUsage）和/或使用 WebUI 中的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/monitoring/back_pressure.html#monitoring-back-pressure">背压监控</a>来观察。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/playground" term="playground" label="Playground" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Python API 指南]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-17-python-api-tutorial/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-17-flink-operations-playground/?utm_source=atom_feed" rel="related" type="text/html" title="Flink 操作游乐场" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-05-connectors-in-flink/?utm_source=atom_feed" rel="related" type="text/html" title="Flink 中的 Connectors" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-17-python-api-tutorial/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-17T00:00:00+08:00</published>
            <updated>2020-08-17T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Python API Tutorial</blockquote><h2 id="python-api-指南">Python API 指南</h2>
<p>本演练将快速让你开始构建一个纯 Python Flink 项目。</p>
<p>关于如何设置 Python 执行环境，请参考 Python Table API <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/python/installation.html">安装指南</a>。</p>
<h3 id="设置一个-python-项目">设置一个 Python 项目</h3>
<p>您可以先创建一个 Python 项目，然后按照<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/python/installation.html#installation-of-pyflink">安装指南</a>安装 PyFlink 包。</p>
<h3 id="编写一个-flink-python-table-api-程序">编写一个 Flink Python Table API 程序</h3>
<p>Table API 应用程序通过声明一个表环境开始；对于批处理应用程序，可以是 BatchTableEvironment，对于流式应用程序，可以是 StreamTableEnvironment。这作为与 Flink 运行时交互的主要入口点。它可以用来设置执行参数，如重启策略、默认并行度等。表配置允许设置 Table API 的具体配置。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">exec_env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="n">get_execution_environment</span><span class="p">(</span><span class="p">)</span>
<span class="n">exec_env</span><span class="o">.</span><span class="n">set_parallelism</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t_config</span> <span class="o">=</span> <span class="n">TableConfig</span><span class="p">(</span><span class="p">)</span>
<span class="n">t_env</span> <span class="o">=</span> <span class="n">BatchTableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">exec_env</span><span class="p">,</span> <span class="n">t_config</span><span class="p">)</span>
</code></pre></div><p>在创建的表环境中，可以声明 source/sink 表。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">t_env</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">FileSystem</span><span class="p">(</span><span class="p">)</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">/tmp/input</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_format</span><span class="p">(</span><span class="n">OldCsv</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_schema</span><span class="p">(</span><span class="n">Schema</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">create_temporary_table</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySource</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">t_env</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">FileSystem</span><span class="p">(</span><span class="p">)</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">/tmp/output</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_format</span><span class="p">(</span><span class="n">OldCsv</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field_delimiter</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">count</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">BIGINT</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_schema</span><span class="p">(</span><span class="n">Schema</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">count</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">BIGINT</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">create_temporary_table</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySink</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div><p>你也可以使用 <code>TableEnvironment.sql_update()</code> 方法来注册 DDL 中定义的 source/sink 表。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_source_ddl</span> <span class="o">=</span> <span class="sa"></span><span class="s2">&#34;&#34;&#34;</span><span class="s2">
</span><span class="s2"></span><span class="s2">    create table mySource (</span><span class="s2">
</span><span class="s2"></span><span class="s2">        word VARCHAR</span><span class="s2">
</span><span class="s2"></span><span class="s2">    ) with (</span><span class="s2">
</span><span class="s2"></span><span class="s2">        </span><span class="s2">&#39;</span><span class="s2">connector.type</span><span class="s2">&#39;</span><span class="s2"> = </span><span class="s2">&#39;</span><span class="s2">filesystem</span><span class="s2">&#39;</span><span class="s2">,</span><span class="s2">
</span><span class="s2"></span><span class="s2">        </span><span class="s2">&#39;</span><span class="s2">format.type</span><span class="s2">&#39;</span><span class="s2"> = </span><span class="s2">&#39;</span><span class="s2">csv</span><span class="s2">&#39;</span><span class="s2">,</span><span class="s2">
</span><span class="s2"></span><span class="s2">        </span><span class="s2">&#39;</span><span class="s2">connector.path</span><span class="s2">&#39;</span><span class="s2"> = </span><span class="s2">&#39;</span><span class="s2">/tmp/input</span><span class="s2">&#39;</span><span class="s2">
</span><span class="s2"></span><span class="s2">    )</span><span class="s2">
</span><span class="s2"></span><span class="s2">&#34;&#34;&#34;</span>

<span class="n">my_sink_ddl</span> <span class="o">=</span> <span class="sa"></span><span class="s2">&#34;&#34;&#34;</span><span class="s2">
</span><span class="s2"></span><span class="s2">    create table mySink (</span><span class="s2">
</span><span class="s2"></span><span class="s2">        word VARCHAR,</span><span class="s2">
</span><span class="s2"></span><span class="s2">        `count` BIGINT</span><span class="s2">
</span><span class="s2"></span><span class="s2">    ) with (</span><span class="s2">
</span><span class="s2"></span><span class="s2">        </span><span class="s2">&#39;</span><span class="s2">connector.type</span><span class="s2">&#39;</span><span class="s2"> = </span><span class="s2">&#39;</span><span class="s2">filesystem</span><span class="s2">&#39;</span><span class="s2">,</span><span class="s2">
</span><span class="s2"></span><span class="s2">        </span><span class="s2">&#39;</span><span class="s2">format.type</span><span class="s2">&#39;</span><span class="s2"> = </span><span class="s2">&#39;</span><span class="s2">csv</span><span class="s2">&#39;</span><span class="s2">,</span><span class="s2">
</span><span class="s2"></span><span class="s2">        </span><span class="s2">&#39;</span><span class="s2">connector.path</span><span class="s2">&#39;</span><span class="s2"> = </span><span class="s2">&#39;</span><span class="s2">/tmp/output</span><span class="s2">&#39;</span><span class="s2">
</span><span class="s2"></span><span class="s2">    )</span><span class="s2">
</span><span class="s2"></span><span class="s2">&#34;&#34;&#34;</span>

<span class="n">t_env</span><span class="o">.</span><span class="n">sql_update</span><span class="p">(</span><span class="n">my_source_ddl</span><span class="p">)</span>
<span class="n">t_env</span><span class="o">.</span><span class="n">sql_update</span><span class="p">(</span><span class="n">my_sink_ddl</span><span class="p">)</span>
</code></pre></div><p>这将在执行环境中注册一个名为 <strong>mySource</strong> 的表和一个名为 <strong>mySink</strong> 的表。表 <strong>mySource</strong> 只有一列，即 <strong>word</strong>，它消耗从文件 <code>/tmp/input</code> 中读取的字符串。表 <strong>mySink</strong> 有两列，分别是 <strong>word</strong> 和 <strong>count</strong>，将数据写入文件 <code>/tmp/output</code>，用 <code>/t</code> 作为字段分隔符。</p>
<p>现在，你可以创建一个作业(job)，它从表 <strong>mySource</strong> 中读取输入，预先执行一些转换，并将结果写入表 <strong>mySink</strong>。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">t_env</span><span class="o">.</span><span class="n">from_path</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySource</span><span class="s1">&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word, count(1)</span><span class="s1">&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">insert_into</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySink</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div><p>最后你必须执行实际的 Flink Python Table API 作业。所有的操作，如创建源、转换和 sink 都是懒惰的。只有当 <code>t_env.execute(job_name)</code> 被调用时，作业才会被运行。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">t_env</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">tutorial_job</span><span class="s2">&#34;</span><span class="p">)</span>
</code></pre></div><p>到目前为止，完整的代码如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pyflink.dataset</span> <span class="kn">import</span> <span class="n">ExecutionEnvironment</span>
<span class="kn">from</span> <span class="nn">pyflink.table</span> <span class="kn">import</span> <span class="n">TableConfig</span><span class="p">,</span> <span class="n">DataTypes</span><span class="p">,</span> <span class="n">BatchTableEnvironment</span>
<span class="kn">from</span> <span class="nn">pyflink.table.descriptors</span> <span class="kn">import</span> <span class="n">Schema</span><span class="p">,</span> <span class="n">OldCsv</span><span class="p">,</span> <span class="n">FileSystem</span>

<span class="n">exec_env</span> <span class="o">=</span> <span class="n">ExecutionEnvironment</span><span class="o">.</span><span class="n">get_execution_environment</span><span class="p">(</span><span class="p">)</span>
<span class="n">exec_env</span><span class="o">.</span><span class="n">set_parallelism</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t_config</span> <span class="o">=</span> <span class="n">TableConfig</span><span class="p">(</span><span class="p">)</span>
<span class="n">t_env</span> <span class="o">=</span> <span class="n">BatchTableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">exec_env</span><span class="p">,</span> <span class="n">t_config</span><span class="p">)</span>

<span class="n">t_env</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">FileSystem</span><span class="p">(</span><span class="p">)</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">/tmp/input</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_format</span><span class="p">(</span><span class="n">OldCsv</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_schema</span><span class="p">(</span><span class="n">Schema</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">create_temporary_table</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySource</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">t_env</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">FileSystem</span><span class="p">(</span><span class="p">)</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">/tmp/output</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_format</span><span class="p">(</span><span class="n">OldCsv</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field_delimiter</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">count</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">BIGINT</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">with_schema</span><span class="p">(</span><span class="n">Schema</span><span class="p">(</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">STRING</span><span class="p">(</span><span class="p">)</span><span class="p">)</span>
                 <span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">count</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="n">BIGINT</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">create_temporary_table</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySink</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">t_env</span><span class="o">.</span><span class="n">from_path</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySource</span><span class="s1">&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word</span><span class="s1">&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">word, count(1)</span><span class="s1">&#39;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">insert_into</span><span class="p">(</span><span class="sa"></span><span class="s1">&#39;</span><span class="s1">mySink</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">t_env</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">tutorial_job</span><span class="s2">&#34;</span><span class="p">)</span>
</code></pre></div><h3 id="执行-flink-python-table-api-程序">执行 Flink Python Table API 程序</h3>
<p>首先，你需要在 &ldquo;/tmp/input&rdquo; 文件中准备输入数据。你可以选择以下命令行来准备输入数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">echo</span> -e  <span class="s2">&#34;flink\npyflink\nflink&#34;</span> &gt; /tmp/input
</code></pre></div><p>接下来，你可以在命令行上运行这个例子（注意：如果结果文件 &ldquo;/tmp/output&rdquo; 已经存在，你需要在运行这个例子之前删除该文件）。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ python WordCount.py
</code></pre></div><p>该命令在本地小型集群中构建并运行 Python Table API 程序。你也可以将 Python Table API 程序提交到远程集群，详情可以参考 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/ops/cli.html#job-submission-examples">Job Submission Examples</a>。</p>
<p>最后，您可以在命令行中看到执行结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ cat /tmp/output
flink	<span class="m">2</span>
pyflink	<span class="m">1</span>
</code></pre></div><p>这应该可以让你开始编写自己的 Flink Python Table API 程序。要了解更多关于 Python Table API 的信息，你可以参考 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/api/python">Flink Python Table API Docs</a> 了解更多细节。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/python" term="python" label="Python" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Flink 中的 Connectors]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-05-connectors-in-flink/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-08-05-connectors-in-flink/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-07T00:00:00+08:00</published>
            <updated>2020-08-07T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>连接器</blockquote><h1 id="apache-kafka-connector">Apache Kafka Connector</h1>
<h2 id="kafka-consumer">Kafka Consumer</h2>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">properties</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">(</span><span class="o">)</span>
<span class="n">properties</span><span class="o">.</span><span class="n">setProperty</span><span class="o">(</span><span class="s">&#34;bootstrap.servers&#34;</span><span class="o">,</span> <span class="s">&#34;localhost:9092&#34;</span><span class="o">)</span>
<span class="n">properties</span><span class="o">.</span><span class="n">setProperty</span><span class="o">(</span><span class="s">&#34;group.id&#34;</span><span class="o">,</span> <span class="s">&#34;test&#34;</span><span class="o">)</span>
<span class="n">stream</span> <span class="k">=</span> <span class="n">env</span>
    <span class="o">.</span><span class="n">addSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FlinkKafkaConsumer</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="o">(</span><span class="s">&#34;topic&#34;</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SimpleStringSchema</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">properties</span><span class="o">)</span><span class="o">)</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="Flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/connector" term="connector" label="Connector" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 模块]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 Pkg" />
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的日期和时间" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-05-modules-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-05T00:00:00+08:00</published>
            <updated>2020-08-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Modules</blockquote><h1 id="模块">模块</h1>
<p>Julia 中的模块是独立的变量工作空间，即它们引入了一个新的全局作用域。它们在语法上是有分界的，在 <code>module Name ... end</code> 里面。模块允许您创建顶层定义（也就是全局变量），而不用担心您的代码与别人的代码一起使用时的名称冲突。在一个模块中，你可以控制哪些来自其他模块的名字是可见的（通过导入），并指定哪些名字是要公开的（通过导出）。</p>
<p>下面的例子展示了模块的主要功能。这个例子并不是为了运行，而是为了说明问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span><span class="o"></span>
<span class="k">using</span> <span class="n">Lib</span><span class="o"></span>

<span class="k">using</span> <span class="n">BigLib</span><span class="o"></span><span class="o">:</span> <span class="n">thing1</span><span class="o"></span><span class="p">,</span> <span class="n">thing2</span><span class="o"></span>

<span class="k">import</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">show</span><span class="o"></span>

<span class="k">export</span> <span class="n">MyType</span><span class="o"></span><span class="p">,</span> <span class="n">foo</span><span class="o"></span>

<span class="k">struct</span> <span class="n">MyType</span><span class="o"></span>
    <span class="n">x</span><span class="o"></span>
<span class="k">end</span>

<span class="n">bar</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span><span class="o"></span>
<span class="n">foo</span><span class="o"></span><span class="p">(</span><span class="n">a</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">MyType</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">bar</span><span class="o"></span><span class="p">(</span><span class="n">a</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="n">show</span><span class="o"></span><span class="p">(</span><span class="n">io</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">IO</span><span class="p">,</span> <span class="n">a</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">MyType</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">print</span><span class="o"></span><span class="p">(</span><span class="n">io</span><span class="o"></span><span class="p">,</span> <span class="s">&#34;</span><span class="s">M</span><span class="s">y</span><span class="s">T</span><span class="s">y</span><span class="s">p</span><span class="s">e</span><span class="s"> </span><span class="si">$</span><span class="p">(</span><span class="n">a</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span><span class="p">)</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>需要注意的是，这个样式并不是要在模块的正文中缩进，因为这通常会导致整个文件被缩进。</p>
<p>这个模块定义了一个 <code>MyType</code> 类型和两个函数。函数 <code>foo</code> 和 <code>MyType</code> 类型是导出的，因此可以导入到其他模块中。函数 <code>bar</code> 是 <code>MyModule</code> 的私有函数。</p>
<p><code>using Lib</code> 语句意味着将有一个名为 <code>Lib</code> 的模块可以根据需要解析名称。当遇到一个全局变量在当前模块中没有定义时，系统会在 <code>Lib</code> 导出的变量中搜索它，如果在那里找到了，就会导入它。这意味着在当前模块内对该全局的所有使用都将解析为该变量在 <code>Lib</code> 中的定义。</p>
<p><code>using BigLib: thing1, thing2</code> 语句，只将标识符 <code>thing1</code> 和 <code>thing2</code> 从模块 <code>BigLib</code> 中带入作用域。如果这些名称指的是函数，那么将不允许向它们添加方法（你只能 &ldquo;使用 &ldquo;它们，而不是扩展它们）。</p>
<p><code>import</code> 关键字支持与 <code>using</code> 相同的语法。<code>import</code> 与 <code>using</code> 的不同之处在于，使用 <code>import</code> 导入的函数可以用新的方法进行扩展。</p>
<p>在上面的 <code>MyModule</code> 中，我们想给标准的 <code>show</code> 函数添加一个方法，所以我们必须写 <code>import Base.show</code>。只有通过 <code>using</code> 才能看到名字的函数不能被扩展。</p>
<p>一旦一个变量通过 <code>using</code> 或 <code>import</code> 变得可见，一个模块就不能创建自己的同名变量。导入的变量是只读的，分配给全局变量总是会影响到当前模块所拥有的变量，否则会引发错误。</p>
<h2 id="模块使用情况概述">模块使用情况概述</h2>
<p>要加载一个模块，可以使用两个主要的关键词：<code>using</code> 和 <code>import</code>。要了解它们的区别，请看下面的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">MyModule</span><span class="o"></span>

<span class="k">export</span> <span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span>

<span class="n">x</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;</span><span class="s">x</span><span class="s">&#34;</span>
<span class="n">y</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;</span><span class="s">y</span><span class="s">&#34;</span>
<span class="n">p</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;</span><span class="s">p</span><span class="s">&#34;</span>

<span class="k">end</span>
</code></pre></div><p>在这个模块中，我们导出了 <code>x</code> 和 <code>y</code> 函数(用关键字 <code>export</code>)，也有非导出的函数 <code>p</code>，有几种不同的方法可以将 <code>Module</code> 及其内部函数加载到当前的工作空间中。</p>
<table>
<thead>
<tr>
<th align="left">导入命令</th>
<th align="left">带入带作用域中的东西</th>
<th align="left">可用于方法扩展</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>using MyModule</code></td>
<td align="left">所有导出的名字(<code>x</code> 和 <code>y</code>), <code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td align="left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td align="left"><code>using MyModule: x, p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>import MyModule</code></td>
<td align="left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
<td align="left"><code>MyModule.x</code>, <code>MyModule.y</code> 和 <code>MyModule.p</code></td>
</tr>
<tr>
<td align="left"><code>import MyModule.x, MyModule.p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
</tr>
<tr>
<td align="left"><code>import MyModule: x, p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
<td align="left"><code>x</code> 和 <code>p</code></td>
</tr>
</tbody>
</table>
<h2 id="模块和文件">模块和文件</h2>
<p>文件和文件名大多与模块无关，模块只与模块表达式有关。一个模块可以有多个文件，一个文件可以有多个模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Foo</span><span class="o"></span>

<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">f</span><span class="s">i</span><span class="s">l</span><span class="s">e</span><span class="s">1</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">f</span><span class="s">i</span><span class="s">l</span><span class="s">e</span><span class="s">2</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>

<span class="k">end</span>
</code></pre></div><p>在不同的模块中包含相同的代码，提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码，例如，通过使用某些操作符的&quot;安全&quot;版本来测试代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Normal</span><span class="o"></span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">m</span><span class="s">y</span><span class="s">c</span><span class="s">o</span><span class="s">d</span><span class="s">e</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">module</span> <span class="n">Testing</span><span class="o"></span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">s</span><span class="s">a</span><span class="s">f</span><span class="s">e</span><span class="s">_</span><span class="s">o</span><span class="s">p</span><span class="s">e</span><span class="s">r</span><span class="s">a</span><span class="s">t</span><span class="s">o</span><span class="s">r</span><span class="s">s</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">m</span><span class="s">y</span><span class="s">c</span><span class="s">o</span><span class="s">d</span><span class="s">e</span><span class="s">.</span><span class="s">j</span><span class="s">l</span><span class="s">&#34;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><h2 id="标准模块">标准模块</h2>
<p>There are three important standard modules:</p>
<p><a href="https://docs.julialang.org/en/v1/base/base/#Core">Core</a> 包含&quot;内置于&quot;语言中的所有功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Base">Base</a> 包含几乎在所有情况下都有用的基本功能。
<a href="https://docs.julialang.org/en/v1/base/base/#Main">Main</a> 是当 Julia 被启动时的顶级模块和当前模块。</p>
<h2 id="默认的顶层定义和裸模块">默认的顶层定义和裸模块</h2>
<p>除了 <code>using Base</code> 之外，模块还自动包含 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a>和 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.include">include</a> 函数的定义，这些函数在该模块的全局作用域内评估表达式/文件。</p>
<p>如果不想要这些默认的定义，可以使用关键字 <a href="https://docs.julialang.org/en/v1/base/base/#baremodule">baremodule</a> 来代替定义模块（注意： <code>Core</code> 仍然是导入的，如上所述）。以 <code>baremodule</code> 来说，一个标准的模块是这样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">baremodule</span> <span class="n">Mod</span><span class="o"></span>

<span class="k">using</span> <span class="n">Base</span><span class="o"></span>

<span class="n">eval</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">Core</span><span class="o"></span><span class="o">.</span><span class="n">eval</span><span class="o"></span><span class="p">(</span><span class="n">Mod</span><span class="o"></span><span class="p">,</span> <span class="n">x</span><span class="o"></span><span class="p">)</span>
<span class="n">include</span><span class="o"></span><span class="p">(</span><span class="n">p</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">include</span><span class="o"></span><span class="p">(</span><span class="n">Mod</span><span class="o"></span><span class="p">,</span> <span class="n">p</span><span class="o"></span><span class="p">)</span>

<span class="o">.</span><span class="o">.</span><span class="o">.</span>

<span class="k">end</span>
</code></pre></div><h2 id="相对和绝对模块路径">相对和绝对模块路径</h2>
<p>给定 <code>using Foo</code> 语句，系统会查询内部的顶层模块表，寻找一个名为 <code>Foo</code> 的模块。如果该模块不存在，系统会尝试 <code>require(:Foo)</code>，这通常会导致从安装的包中加载代码。</p>
<p>然而，有些模块包含子模块，这意味着你有时需要访问一个非顶层模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 <code>using Base.Sort</code>。第二种是使用相对路径，这样可以更容易地导入当前模块的子模块或其任何一个外层模块。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">module</span> <span class="n">Parent</span><span class="o"></span>

<span class="k">module</span> <span class="n">Utils</span><span class="o"></span>
<span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="k">end</span>

<span class="k">using</span> <span class="o">.</span><span class="n">Utils</span><span class="o"></span>

<span class="o">.</span><span class="o">.</span><span class="o">.</span>
<span class="k">end</span>
</code></pre></div><p>这里模块 <code>Parent</code> 包含一个子模块 <code>Utils</code>，<code>Parent</code> 中的代码希望 <code>Utils</code> 的内容可见。这可以通过在 <code>using</code> 路径中使用点号来实现。添加更多的前导点号会使模块的层次结构上升。例如，<code>using ..Utils</code> 会在 <code>Parent</code> 的外层模块中查找<code>Utils</code>，而不是在 <code>Parent</code> 本身中查找。</p>
<p>注意相对导入限定符只在使用和导入语句中有效。</p>
<h2 id="命名空间杂项">命名空间杂项</h2>
<p>如果一个名字是限定的(例如 <code>Base.sin</code>)，那么即使它没有被导出，也可以被访问。这在调试时往往很有用。它也可以通过使用限定名作为函数名来添加方法。但是，由于会产生语法上的歧义，如果你想给不同模块中的一个函数添加方法，而这个函数的名称只包含符号，例如一个运算符，<code>Base.+</code>，你必须使用 <code>Base.:+</code> 来引用它。如果运算符的长度超过一个字符，你必须用括号把它括起来，比如 <code>Base.:(==)</code>。</p>
<p>在导入和导出语句中，宏的名称用 <code>@</code> 书写，例如 <code>import Mod.@mac</code>。其他模块中的宏可以用 <code>Mod.@mac</code> 或 <code>@Mod.mac</code> 来调用。</p>
<p>语法 <code>M.x = y</code> 不能用于分配其他模块中的全局，全局分配总是模块-局部的。</p>
<p>变量名可以通过声明为 <code>global x</code> 来 &ldquo;保留&quot;而不分配给它，这样可以防止加载后初始化的 globals 的名称冲突。</p>
<h2 id="模块初始化和预编译">模块初始化和预编译</h2>
<p>大型模块可能需要几秒钟的时间来加载，因为执行一个模块中的所有语句往往需要编译大量的代码。Julia 创建了模块的预编译缓存来减少这个时间。</p>
<p>当使用 <code>import</code> 或 <code>using</code> 加载模块时，会自动创建并使用增量的预编译模块文件。这将导致它在第一次导入时自动编译。另外，您也可以手动调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.compilecache">Base.compilecache(modulename)</a>。由此产生的缓存文件将存储在 <code>DEPOT_PATH[1]/compiled/</code> 中。随后，只要模块的任何依赖关系发生变化，模块就会在 <code>using</code> 或 <code>import</code> 时自动重新编译；依赖关系是指导入的模块、Julia 构建的模块、包含的文件，或者模块文件中 <a href="https://docs.julialang.org/en/v1/base/base/#Base.include_dependency">include_dependency(path)</a> 声明的显式依赖关系。</p>
<p>对于文件依赖，通过检查由 <code>include</code> 加载的文件或由 <code>include_dependency</code> 显式添加的文件的修改时间(mtime)是否保持不变，或者是否等于被截断到最接近秒的修改时间(以适应无法以亚秒级精度复制 mtime 的系统)来确定变化。它还考虑到在 <code>require</code> 中搜索逻辑选择的文件路径是否与创建预编译文件的路径匹配。它还会考虑到已经加载到当前进程中的一组依赖关系，即使这些模块的文件发生变化或消失，也不会重新编译这些模块，以避免在运行系统和预编译缓存之间产生不兼容的情况。</p>
<p>如果你知道某个模块预编译你的模块是不安全的（例如，出于下面描述的原因之一），你应该在模块文件中加上 <code>__precompile__(false)</code>（通常放在顶部）。这将导致 <code>Base.compilecache</code> 抛出一个错误，并将导致 <code>using</code> / <code>import</code> 直接将其加载到当前进程中而跳过预编译和缓存。这也因此阻止了该模块被任何其他预编译模块导入。</p>
<p>您可能需要注意创建增量共享库时固有的某些行为，在编写模块时可能需要注意。例如，外部状态不会被保存。为了适应这一点，明确地将任何必须在运行时发生的初始化步骤与可以在编译时发生的步骤分开。为此，Julia 允许您在您的模块中定义一个 <code>__init__()</code> 函数来执行任何必须在运行时发生的初始化步骤。这个函数在编译时不会被调用（<code>--output-*</code>）。实际上，你可以假设它在代码的生命周期中只运行一次。当然，如果有必要的话，你可以手动调用它，但是默认情况下，你可以假设这个函数处理的是本地机器的计算状态，它不需要&ndash;甚至不应该&ndash;在编译后的镜像中捕获。它将在模块被加载到一个进程后被调用，包括如果它被加载到增量编译中(<code>--output-incremental=yes</code>)，但如果它被加载到一个完整的编译进程中，则不会被调用。</p>
<p>特别是，如果你在一个模块中定义了一个 <code>function __init__()</code>，那么 Julia 将在模块被加载后（例如通过 <code>import</code>、<code>using</code> 或 <code>require</code>）在运行时第一次立即调用 <code>__init__()</code>（也就是说，<code>__init__</code> 只被调用一次，而且是在模块中的所有语句被执行后才被调用）。因为它是在模块完全导入之后被调用的，所以任何子模块或其它导入的模块都会在外层模块的 <code>__init__</code> 之前调用它们的 <code>__init__</code> 函数。</p>
<p><code>__init__</code> 的两个典型用途是调用外部 C 库的运行时初始化函数和初始化涉及外部库返回指针的全局常量。例如，假设我们正在调用一个 C 库 <code>libfoo</code>，它要求我们在运行时调用 <code>foo_init()</code> 初始化函数。假设我们还想定义一个全局常量 <code>foo_data_ptr</code>，用来存放 <code>libfoo</code> 定义的 <code>void *foo_data()</code> 函数的返回值&ndash;这个常量必须在运行时（而不是在编译时）初始化，因为指针地址会随着运行而改变。你可以通过在你的模块中定义下面的 <code>__init__</code> 函数来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="kd">const</span> <span class="n">foo_data_ptr</span><span class="o"></span> <span class="o">=</span> <span class="kt">Ref</span><span class="p">{</span><span class="kt">Ptr</span><span class="p">{</span><span class="n">Cvoid</span><span class="o"></span><span class="p">}</span><span class="p">}</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">function</span> <span class="n">__init__</span><span class="o"></span><span class="p">(</span><span class="p">)</span>
    <span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="o">:</span><span class="n">foo_init</span><span class="o"></span><span class="p">,</span> <span class="o">:</span><span class="n">libfoo</span><span class="o"></span><span class="p">)</span><span class="p">,</span> <span class="n">Cvoid</span><span class="o"></span><span class="p">,</span> <span class="p">(</span><span class="p">)</span><span class="p">)</span>
    <span class="n">foo_data_ptr</span><span class="o"></span><span class="p">[</span><span class="p">]</span> <span class="o">=</span> <span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="o">:</span><span class="n">foo_data</span><span class="o"></span><span class="p">,</span> <span class="o">:</span><span class="n">libfoo</span><span class="o"></span><span class="p">)</span><span class="p">,</span> <span class="kt">Ptr</span><span class="p">{</span><span class="n">Cvoid</span><span class="o"></span><span class="p">}</span><span class="p">,</span> <span class="p">(</span><span class="p">)</span><span class="p">)</span>
    <span class="nb">nothing</span>
<span class="k">end</span>
</code></pre></div><p>请注意，我们完全可以在函数内部定义一个全局，比如 <code>__init__</code>；这是使用动态语言的优势之一。但是通过在全局作用域内定义一个常量，我们可以确保编译器知道这个类型，并允许它生成更好的优化代码。显然，你的模块中任何其他依赖于 <code>foo_data_ptr</code> 的 globals 也必须在 <code>__init__</code> 中初始化。</p>
<p>涉及大多数不是由 <a href="https://docs.julialang.org/en/v1/base/c/#ccall">ccall</a> 产生的 Julia 对象的常量不需要放在 <code>__init__</code> 中：它们的定义可以被预编译并从缓存的模块映像中加载。这包括像数组这样复杂的堆分配对象。然而，任何返回原始指针值的例程都必须在运行时调用，以便预编译工作（<a href="https://docs.julialang.org/en/v1/base/c/#Core.Ptr">Ptr</a> 对象将变成空指针，除非它们被隐藏在 <a href="https://docs.julialang.org/en/v1/base/base/#Base.isbits">isbits</a> 对象中）。这包括 Julia 函数 <code>cfunction</code> 和 <a href="https://docs.julialang.org/en/v1/base/c/#Base.pointer">pointer</a> 的返回值。</p>
<p>字典和集合类型，或者一般来说任何依赖于 <code>hash(key)</code> 方法输出的东西，都是比较棘手的情况。在常见的情况下，键是数字、字符串、符号、范围、<code>Expr</code> 或这些类型的组合（通过数组、元组、集合、对等），它们可以安全地进行预编译。然而，对于其他一些关键类型，如 <code>Function</code> 或 <code>DataType</code> 和通用的用户定义类型，在这些类型中，你没有定义 <code>hash</code> 方法，回退 <code>hash</code> 方法取决于对象的内存地址（通过它的 <code>objectid</code>），因此可能会在运行时改变。如果你有这些键类型之一，或者如果你不确定，为了安全起见，你可以在你的 <code>__init__</code> 函数中初始化这个字典。或者，你也可以使用 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.IdDict">IdDict</a> 字典类型，它由预编译特别处理，所以在编译时初始化是安全的。</p>
<p>在使用预编译时，保持对编译阶段和执行阶段的清晰认识很重要。在这种模式下，往往会更清楚地认识到 Julia 是一个允许执行任意 Julia 代码的编译器，而不是一个同时生成编译代码的独立解释器。</p>
<p>其他已知的潜在故障情况包括。</p>
<ol>
<li>全局计数器（例如，用于试图唯一识别对象）。考虑以下代码片段。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">mutable</span> <span class="k">struct</span> <span class="n">UniquedById</span><span class="o"></span>
    <span class="n">myid</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Int</span>
    <span class="k">let</span> <span class="n">counter</span><span class="o"></span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">UniquedById</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="n">new</span><span class="o"></span><span class="p">(</span><span class="n">counter</span><span class="o"></span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>虽然这段代码的目的是给每个实例一个唯一的 id，但计数器的值是在编译结束时记录的。这个增量编译模块的所有后续使用将从同一个计数器值开始。</p>
<p>请注意，<code>objectid</code>（通过哈希内存指针工作）也有类似的问题（参见下面关于 <code>Dict</code> 用法的说明）。</p>
<p>一种替代方法是使用宏来捕获 <a href="https://docs.julialang.org/en/v1/base/base/#Base.@__MODULE__">@<strong>MODULE</strong></a>，并将其与当前的计数器值一起单独存储，然而，重新设计代码使其不依赖于这个全局状态可能会更好。</p>
<ol start="2">
<li>
<p>关联集合(比如 <code>Dict</code> 和 <code>Set</code>)需要在 <code>__init__</code> 中重新洗牌(将来可能会提供一个机制来注册一个初始化函数)。</p>
</li>
<li>
<p>根据编译时的副作用在加载时持续存在。例如：修改其他 Julia 模块中的数组或其他变量；维护打开的文件或设备的句柄；存储其他系统资源（包括内存）的指针。</p>
</li>
<li>
<p>通过直接引用而不是通过它的查找路径，从另一个模块创建意外的全局状态&quot;副本&rdquo;。例如，（在全局作用域内）。</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="c">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#</span>
<span class="c"># instead use accessor functions:</span>
<span class="n">getstdout</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">stdout</span><span class="o"></span> <span class="cm">#=</span><span class="cm"> </span><span class="cm">b</span><span class="cm">e</span><span class="cm">s</span><span class="cm">t</span><span class="cm"> </span><span class="cm">o</span><span class="cm">p</span><span class="cm">t</span><span class="cm">i</span><span class="cm">o</span><span class="cm">n</span><span class="cm"> </span><span class="cm">=#</span>
<span class="c"># or move the assignment into the runtime:</span>
<span class="n">__init__</span><span class="o"></span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="kd">global</span> <span class="n">mystdout</span><span class="o"></span> <span class="o">=</span> <span class="n">Base</span><span class="o"></span><span class="o">.</span><span class="n">stdout</span><span class="o"></span> <span class="cm">#=</span><span class="cm"> </span><span class="cm">a</span><span class="cm">l</span><span class="cm">s</span><span class="cm">o</span><span class="cm"> </span><span class="cm">w</span><span class="cm">o</span><span class="cm">r</span><span class="cm">k</span><span class="cm">s</span><span class="cm"> </span><span class="cm">=#</span>
</code></pre></div><p>对预编译代码时可以进行的操作进行了一些额外的限制，以帮助用户避免其他错误行为的情况。</p>
<ol>
<li>
<p>调用 <a href="https://docs.julialang.org/en/v1/base/base/#Base.MainInclude.eval">eval</a> 引起另一个模块的副作用。当增量预编译标志被设置时，这也会导致发出警告。</p>
</li>
<li>
<p>在 <code>__init__()</code> 被启动后，从本地作用域调用 <code>global const</code> 语句(参见问题 <code>#12010</code>，计划为此增加一个错误)</p>
</li>
<li>
<p>在进行增量预编译时，替换一个模块是一个运行时错误。</p>
</li>
</ol>
<p>还有几点需要注意。</p>
<ol>
<li>
<p>在对源文件本身进行修改之后，不会进行代码重载/缓存无效化（包括通过 <code>Pkg.update</code>），而且在 <code>Pkg.rm</code> 之后也不会进行清理。</p>
</li>
<li>
<p>预编译不考虑重塑数组的内存共享行为 (每个视图都有自己的副本)</p>
</li>
<li>
<p>期待文件系统在编译时和运行时之间保持不变，例如 <a href="https://docs.julialang.org/en/v1/base/file/#Base.@__FILE__">@<strong>FILE</strong></a>/<code>source_path()</code> 在运行时查找资源，或者 BinDeps 的 <code>@checked_lib</code> 宏。有时这是不可避免的。然而，在可能的情况下，在编译时将资源复制到模块中是一个很好的做法，这样它们就不需要在运行时被找到。</p>
</li>
<li>
<p><code>WeakRef</code> 对象和 finalizers 目前还没有被序列化器正确处理（这将在即将发布的版本中得到修正）。</p>
</li>
<li>
<p>通常最好避免捕获对内部元数据对象实例的引用，如 <code>Method</code>、<code>MethodInstance</code>、<code>MethodTable</code>、<code>TypeMapLevel</code>、<code>TypeMapEntry</code> 以及这些对象的字段，因为这可能会混淆序列化器，可能不会导致你想要的结果。这样做不一定会出错，但你只需要做好准备，系统会尝试复制其中的一些对象，并为其他对象创建一个唯一的实例。</p>
</li>
</ol>
<p>在模块开发过程中，有时关闭增量预编译是很有帮助的。命令行标志 <code>--compiled-modules={yes|no}</code> 可以让你开启或关闭模块预编译。当 Julia 以 <code>--compiled-modules=no</code> 启动时，当加载模块和模块依赖时，编译缓存中的序列化模块会被忽略。<code>Base.compilecache</code> 仍然可以被手动调用。这个命令行标志的状态被传递给 <code>Pkg.build</code>，以便在安装、更新和显式构建包时禁用自动预编译触发。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/module" term="module" label="module" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的 Pkg]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的日期和时间" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-04T00:00:00+08:00</published>
            <updated>2020-08-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Pkg</blockquote><h2 id="进入-pkg-模式">进入 Pkg 模式</h2>
<p>Pkg 是 Julia 中包管理工具。Pkg 来自于 REPL, 在 Julia 的 REPL 中按下 <code>]</code> 就进入 Pkg REPL 了。要回到 Julia REPL, 按退格键或 <code>^C</code>。</p>
<h2 id="使用-pkg">使用 Pkg</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">add JSON              <span class="c1"># 添加一个 package</span>
add JSON StaticArrays <span class="c1"># 添加多个 package</span>
rm JSON               <span class="c1"># 移除一个 package</span>
rm JSON StaticArrays  <span class="c1"># 移除多个 package</span>
add https://github.com/JuliaLang/Example.jl <span class="c1"># 添加一个未注册的 package</span>
rm Example            <span class="c1"># 按名字移除 package</span>
update Example        <span class="c1"># 升级一个已安装的 package</span>
update                <span class="c1"># 升级所有已安装的 package</span>
</code></pre></div><h2 id="environments">environments</h2>
<p>你可能已经注意到 Pkg REPL 提示符前面的 <code>(@v1.5)</code> 字符串了。这里的  <code>(@v1.5)</code> 就是激活环境(<strong>active environment</strong>)。激活环境是能被诸如 <code>add</code>、<code>rm</code> 和 <code>update</code> 等 Pkg 命令修改的环境。</p>
<p>我们可以设置一个新的激活环境用于实验。要设置激活环境, 使用 <code>activate</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>@v1.5<span class="o">)</span> pkg&gt; activate tutorial
Activating new environment at <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
</code></pre></div><p><code>~/tutorial/Project.toml</code> 是激活环境的项目文件。项目文件是 Pkg 存储环境的元数据的地方。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; status
Status <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span> <span class="o">(</span>empty project<span class="o">)</span>
</code></pre></div><p>现在这个新的环境是空的, 我们添加一个 package 观察下:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; add Example
   Updating registry at <span class="sb">`</span>~/.julia/registries/General<span class="sb">`</span>
   Updating git-repo <span class="sb">`</span>https://github.com/JuliaRegistries/General.git<span class="sb">`</span>
  Resolving package versions...
    Cloning <span class="o">[</span>7876af07-990d-54b4-ab0e-23690620f79a<span class="o">]</span> Example from https://github.com/JuliaLang/Example.jl.git
  Installed Example ─ v0.5.3
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> + Example v0.5.3
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> + Example v0.5.3
</code></pre></div><p>用 <code>status</code> 命令查看激活环境的信息:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; status
Status <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> Example v0.5.3
</code></pre></div><p>使用 <code>develop</code> 命令设置 <code>Example</code> package 的 一个 <code>git clone</code>, 以供我们修改这个本地仓库:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; develop --local Example
    Cloning git-repo <span class="sb">`</span>https://github.com/JuliaLang/Example.jl.git<span class="sb">`</span>
  Resolving package versions...
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.3 ⇒ v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span>
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.3 ⇒ v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span>
</code></pre></div><p>用 <code>;</code> 切换到 shell 模式, 用 vi 修改 <code>~/tutorial/dev/Example/src/Example.jl</code> 文件, 增加一个 <code>plusone</code> 函数, 保存。</p>
<p>在 Julia 的 REPL 中, 导入修改后的 <code>Example</code> package:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; import Example
<span class="o">[</span> Info: Precompiling Example <span class="o">[</span>7876af07-990d-54b4-ab0e-23690620f79a<span class="o">]</span>

julia&gt; Example.plusone<span class="o">(</span>1<span class="o">)</span>
<span class="m">2</span>

julia&gt; Example.plusone<span class="o">(</span>4<span class="o">)</span>
<span class="m">5</span>
</code></pre></div><p>可以看到我们添加的函数生效了, 这样就很方便我们添加测试新功能。如果我们已经不再需要本地的 <code>Example</code> 了, 需要使用 <code>free</code> 命令以停止使用本地克隆的 package, 转而使用已注册版本代替:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; free Example
  Resolving package versions...
Updating <span class="sb">`</span>~/tutorial/Project.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span> ⇒ v0.5.3
Updating <span class="sb">`</span>~/tutorial/Manifest.toml<span class="sb">`</span>
  <span class="o">[</span>7876af07<span class="o">]</span> ~ Example v0.5.4 <span class="sb">`</span>dev/Example<span class="sb">`</span> ⇒ v0.5.3
</code></pre></div><p>如果已经用 <code>tutorial</code> 做完实验了, 可以使用不带参数的 <code>activate</code> 回到默认环境:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>tutorial<span class="o">)</span> pkg&gt; activate
 Activating environment at <span class="sb">`</span>~/.julia/environments/v1.5/Project.toml<span class="sb">`</span>

<span class="o">(</span>@v1.5<span class="o">)</span> pkg&gt; 
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/pkg" term="pkg" label="pkg" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 中的日期和时间]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-08-04-pkg-in-julia/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 中的 Pkg" />
                <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="related" type="text/html" title="Julia 语言学习笔记" />
            
                <id>https://ohmyweekly.github.io/notes/2020-08-04-dates-in-julia/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-08-04T00:00:00+08:00</published>
            <updated>2020-08-04T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Dates in Julia</blockquote><h1 id="dates-模块的加载和使用">Dates 模块的加载和使用</h1>
<p>在 Julia 的 Pkg REPL 中, 输入 <code>add Dates</code> 添加 Dates 模块。回到 Julia 的 REPL 中, 输入:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; using Dates

julia&gt; DateTime<span class="o">(</span>2020<span class="o">)</span>
2020-01-01T00:00:00

julia&gt; typeof<span class="o">(</span>DateTime<span class="o">(</span>2020<span class="o">)</span><span class="o">)</span>
DateTime

julia&gt; DateTime<span class="o">(</span>2020,8,1<span class="o">)</span>
2020-08-01T00:00:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12<span class="o">)</span>
2020-08-01T12:00:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30<span class="o">)</span>
2020-08-01T12:30:00

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30,59<span class="o">)</span>
2020-08-01T12:30:59

julia&gt; DateTime<span class="o">(</span>2020,8,1,12,30,59, 999<span class="o">)</span>
2020-08-01T12:30:59.999

julia&gt; Date<span class="o">(</span>2020, 8<span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>2020, 8, 1<span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>Dates.Year<span class="o">(</span>2020<span class="o">)</span>,Dates.Month<span class="o">(</span>8<span class="o">)</span>,Dates.Day<span class="o">(</span>1<span class="o">)</span><span class="o">)</span>
2020-08-01

julia&gt; Date<span class="o">(</span>Dates.Month<span class="o">(</span>8<span class="o">)</span>,Dates.Year<span class="o">(</span>2020<span class="o">)</span><span class="o">)</span>
2020-08-01
</code></pre></div><h1 id="date-和-datetime-的算术操作">Date 和 DateTime 的算术操作</h1>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">dt</span> <span class="o">=</span> Date<span class="o">(</span>2012,2,29<span class="o">)</span>
2012-02-29

julia&gt; <span class="nv">dt2</span> <span class="o">=</span> Date<span class="o">(</span>2000,2,1<span class="o">)</span>
2000-02-01

julia&gt; dump<span class="o">(</span>dt<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">734562</span>

julia&gt; dump<span class="o">(</span>dt2<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">730151</span>

julia&gt; dt &gt; dt2
<span class="nb">true</span>

julia&gt; dt !<span class="o">=</span> dt2
<span class="nb">true</span>

julia&gt; dt + dt2
ERROR: MethodError: no method matching +<span class="o">(</span>::Date, ::Date<span class="o">)</span>
<span class="o">[</span>...<span class="o">]</span>

julia&gt; dt * dt2
ERROR: MethodError: no method matching *<span class="o">(</span>::Date, ::Date<span class="o">)</span>
<span class="o">[</span>...<span class="o">]</span>

julia&gt; dt / dt2
ERROR: MethodError: no method matching /<span class="o">(</span>::Date, ::Date<span class="o">)</span>

julia&gt; dt - dt2
<span class="m">4411</span> days

julia&gt; typeof<span class="o">(</span>dt - dt2<span class="o">)</span>
Day

julia&gt; dt2 - dt
-4411 days

julia&gt; <span class="nv">dt</span> <span class="o">=</span> DateTime<span class="o">(</span>2012,2,29<span class="o">)</span>
2012-02-29T00:00:00

julia&gt; <span class="nv">dt2</span> <span class="o">=</span> DateTime<span class="o">(</span>2000,2,1<span class="o">)</span>
2000-02-01T00:00:00

julia&gt; dt - dt2
<span class="m">381110400000</span> milliseconds

julia&gt; typeof<span class="o">(</span>dt - dt2<span class="o">)</span>
Millisecond
</code></pre></div><h1 id="访问器函数">访问器函数</h1>
<p>因为 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Date">Date</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateTime">DateTime</a> 类型被存储为单个 <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Int64">Int64</a> 值，所以日期部分或字段可以通过访问器函数进行检索。小写访问器函数以整数形式返回字段。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">t</span> <span class="o">=</span> Date<span class="o">(</span>2014, 1, 31<span class="o">)</span>
2014-01-31

julia&gt; Dates.year<span class="o">(</span>t<span class="o">)</span>
<span class="m">2014</span>

julia&gt; Dates.month<span class="o">(</span>t<span class="o">)</span>
<span class="m">1</span>

julia&gt; Dates.week<span class="o">(</span>t<span class="o">)</span>
<span class="m">5</span>

julia&gt; Dates.day<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p>而专有形式返回相应 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Period">Period</a> 类型中的相同值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.Year<span class="o">(</span>t<span class="o">)</span>
<span class="m">2014</span> years

julia&gt; Dates.Day<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span> days
</code></pre></div><p>Julia 还提供了复合方法，因为在同时需要多个字段的情况下，这些方法提供了一种效率衡量标准。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.yearmonth<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>2014, 1<span class="o">)</span>

julia&gt; Dates.monthday<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>1, 31<span class="o">)</span>

julia&gt; Dates.yearmonthday<span class="o">(</span>t<span class="o">)</span>
<span class="o">(</span>2014, 1, 31<span class="o">)</span>
</code></pre></div><p>也可以访问底层 <code>UTInstant</code> 或整数值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; dump<span class="o">(</span>t<span class="o">)</span>
Date
  instant: Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span>
    periods: Day
      value: Int64 <span class="m">735264</span>

julia&gt; t.instant
Dates.UTInstant<span class="o">{</span>Day<span class="o">}</span><span class="o">(</span>Day<span class="o">(</span>735264<span class="o">)</span><span class="o">)</span>

julia&gt; Dates.value<span class="o">(</span>t<span class="o">)</span>
<span class="m">735264</span>
</code></pre></div><h1 id="查询函数">查询函数</h1>
<p>查询函数提供关于 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 的历法信息。它们包括关于一周中的某一天的信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">t</span> <span class="o">=</span> Date<span class="o">(</span>2014, 1, 31<span class="o">)</span>
2014-01-31

julia&gt; Dates.dayofweek<span class="o">(</span>t<span class="o">)</span>
<span class="m">5</span>

julia&gt; Dates.dayname<span class="o">(</span>t<span class="o">)</span>
<span class="s2">&#34;Friday&#34;</span>

julia&gt; Dates.dayofweekofmonth<span class="o">(</span>t<span class="o">)</span> <span class="c1"># 5th Friday of January</span>
<span class="m">5</span>

julia&gt; Dates.monthname<span class="o">(</span>t<span class="o">)</span>
<span class="s2">&#34;January&#34;</span>

julia&gt; Dates.daysinmonth<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p>以及 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 的年份和季度信息。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.isleapyear<span class="o">(</span>t<span class="o">)</span>
<span class="nb">false</span>

julia&gt; Dates.dayofyear<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>

julia&gt; Dates.quarterofyear<span class="o">(</span>t<span class="o">)</span>
<span class="m">1</span>

julia&gt; Dates.dayofquarter<span class="o">(</span>t<span class="o">)</span>
<span class="m">31</span>
</code></pre></div><p><a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.dayname">dayname</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.monthname">monthname</a> 方法也可以使用一个可选的 <code>locale</code> 关键字，它可以用来返回其他语言/地区的年份或月份的名称。这些函数也有返回缩写名称的版本，即 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.dayabbr">dayabbr</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.monthabbr">monthabbr</a>。首先将映射加载到 <code>LOCALES</code> 变量中。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">french_months</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;janvier&#34;</span>, <span class="s2">&#34;février&#34;</span>, <span class="s2">&#34;mars&#34;</span>, <span class="s2">&#34;avril&#34;</span>, <span class="s2">&#34;mai&#34;</span>, <span class="s2">&#34;juin&#34;</span>,
                        <span class="s2">&#34;juillet&#34;</span>, <span class="s2">&#34;août&#34;</span>, <span class="s2">&#34;septembre&#34;</span>, <span class="s2">&#34;octobre&#34;</span>, <span class="s2">&#34;novembre&#34;</span>, <span class="s2">&#34;décembre&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; <span class="nv">french_monts_abbrev</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;janv&#34;</span>,<span class="s2">&#34;févr&#34;</span>,<span class="s2">&#34;mars&#34;</span>,<span class="s2">&#34;avril&#34;</span>,<span class="s2">&#34;mai&#34;</span>,<span class="s2">&#34;juin&#34;</span>,
                              <span class="s2">&#34;juil&#34;</span>,<span class="s2">&#34;août&#34;</span>,<span class="s2">&#34;sept&#34;</span>,<span class="s2">&#34;oct&#34;</span>,<span class="s2">&#34;nov&#34;</span>,<span class="s2">&#34;déc&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; <span class="nv">french_days</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&#34;lundi&#34;</span>,<span class="s2">&#34;mardi&#34;</span>,<span class="s2">&#34;mercredi&#34;</span>,<span class="s2">&#34;jeudi&#34;</span>,<span class="s2">&#34;vendredi&#34;</span>,<span class="s2">&#34;samedi&#34;</span>,<span class="s2">&#34;dimanche&#34;</span><span class="o">]</span><span class="p">;</span>

julia&gt; Dates.LOCALES<span class="o">[</span><span class="s2">&#34;french&#34;</span><span class="o">]</span> <span class="o">=</span> Dates.DateLocale<span class="o">(</span>french_months, french_monts_abbrev, french_days, <span class="o">[</span><span class="s2">&#34;&#34;</span><span class="o">]</span><span class="o">)</span><span class="p">;</span>
</code></pre></div><p>然后可以利用上述函数进行查询。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.dayname<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;vendredi&#34;</span>

julia&gt; Dates.monthname<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;janvier&#34;</span>

julia&gt; Dates.monthabbr<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
<span class="s2">&#34;janv&#34;</span>
</code></pre></div><p>由于没有加载日期的缩写版本，试图使用函数 <code>dayabbr</code> 会出错。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.dayabbr<span class="o">(</span>t<span class="p">;</span><span class="nv">locale</span><span class="o">=</span><span class="s2">&#34;french&#34;</span><span class="o">)</span>
ERROR: BoundsError: attempt to access 1-element Array<span class="o">{</span>String,1<span class="o">}</span> at index <span class="o">[</span>5<span class="o">]</span>
Stacktrace:
<span class="o">[</span>...<span class="o">]</span>
</code></pre></div><h1 id="时间类型-周期算术">时间类型-周期算术</h1>
<p>在使用任何语言/日期框架时，熟悉如何处理日期-周期算术是一个很好的做法，因为有一些<a href="https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/">棘手的问题</a>需要处理（尽管对于日-精度类型来说要少得多）。</p>
<p><code>Dates</code> 模块的方法试图遵循简单的原则，即在做 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.Period">Period</a> 算术时尽量少改。这种方法也常被称为历法算术，或者说如果有人在对话中问你同样的计算方法，你可能会猜到。为什么要大惊小怪呢？我们举个经典的例子：把2014年1月31日加1个月。答案是什么？Javascript 会说<a href="https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/">3月3日</a>（假设31天）。PHP 会说<a href="https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month">3月2日</a>（假设30天）。事实上，没有正确的答案。在 <code>Dates</code> 模块中，它给出的结果是2月28日。它是如何计算出来的呢？我喜欢想到赌场里经典的 7-7-7 赌博游戏。</p>
<p>现在只要想象一下，老虎机不是 7-7-7，而是年-月-日，或者在我们的例子中，2014-01-31。当你要求在这个日期的基础上增加1个月的时候，月份槽就会递增，所以现在我们有 2014-02-31。然后检查日号是否大于新月份的最后有效日，如果大于（如上例），则日号向下调整到最后有效日（28）。这种方法的后果是什么呢？继续在我们的日期上再加一个月，<code>2014-02-28 + Month(1) == 2014-03-28</code>。什么？你是在期待3月的最后一天吗？不对，对不起，记得 7-7-7 的档期。尽可能少的槽位要改变，所以我们先把月份槽位递增1，2014-03-28，轰，我们就完成了，因为这是一个有效的日期。另一方面，如果我们要在原来的日期 2014-01-31 的基础上增加2个月，那么我们最终的结果是 2014-03-31，正如预期的那样。这种方法的另一个后果是，当强行进行特定的排序时，关联性会有所损失（即以不同的顺序添加东西会导致不同的结果）。比如说：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="o">(</span>Date<span class="o">(</span>2014,1,29<span class="o">)</span>+Dates.Day<span class="o">(</span>1<span class="o">)</span><span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span>
2014-02-28

julia&gt; <span class="o">(</span>Date<span class="o">(</span>2014,1,29<span class="o">)</span>+Dates.Month<span class="o">(</span>1<span class="o">)</span><span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span>
2014-03-01
</code></pre></div><p>那是怎么回事呢？在第一行中，我们在1月29日的基础上加1天，结果是 2014-01-30；然后再加1个月，于是得到 2014-02-30，再往下调整为 2014-02-28。在第二个例子中，我们先加1个月，我们得到 2014-02-29，再往下调整为 2014-02-28，然后再加1天，结果是 2014-03-01。在这种情况下，有一个设计原则是有帮助的，那就是在存在多个 Periods 的情况下，操作将按照 Periods 的类型来排序，而不是按照它们的值或位置顺序来排序；这意味着总是先加 <code>Year</code>，然后加 <code>Month</code>，再加 <code>Week</code> 等。因此，以下确实会导致关联性并正好有用:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Date<span class="o">(</span>2014,1,29<span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span>
2014-03-01

julia&gt; Date<span class="o">(</span>2014,1,29<span class="o">)</span> + Dates.Month<span class="o">(</span>1<span class="o">)</span> + Dates.Day<span class="o">(</span>1<span class="o">)</span>
2014-03-01
</code></pre></div><p>棘手吗？也许吧。一个无辜的 <code>Dates</code> 用户该怎么做？最重要的是要注意，当处理月份时，明确地强制执行某种关联性，可能会导致一些意想不到的结果，但除此之外，一切都应该按照预期工作。值得庆幸的是，在 UT 中处理时间时，日期-周期算术中的奇特情况几乎就是这样了（避免了处理夏令时、闰秒等的 &ldquo;乐趣&rdquo;）。</p>
<p>作为奖励，所有的周期算术对象都可以直接与范围一起工作。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">dr</span> <span class="o">=</span> Date<span class="o">(</span>2014,1,29<span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span>2014,2,3<span class="o">)</span>
Date<span class="o">(</span><span class="s2">&#34;2014-01-29&#34;</span><span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span><span class="s2">&#34;2014-02-03&#34;</span><span class="o">)</span>

julia&gt; collect<span class="o">(</span>dr<span class="o">)</span>
6-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-01-29
 2014-01-30
 2014-01-31
 2014-02-01
 2014-02-02
 2014-02-03

julia&gt; <span class="nv">dr</span> <span class="o">=</span> Date<span class="o">(</span>2014,1,29<span class="o">)</span>:Dates.Month<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span>2014,07,29<span class="o">)</span>
Date<span class="o">(</span><span class="s2">&#34;2014-01-29&#34;</span><span class="o">)</span>:Month<span class="o">(</span>1<span class="o">)</span>:Date<span class="o">(</span><span class="s2">&#34;2014-07-29&#34;</span><span class="o">)</span>

julia&gt; collect<span class="o">(</span>dr<span class="o">)</span>
7-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-01-29
 2014-02-28
 2014-03-29
 2014-04-29
 2014-05-29
 2014-06-29
 2014-07-29
</code></pre></div><pre><code>for i in Date(&quot;2020-08-01&quot;):Day(1):Date(&quot;2020-08-09&quot;)
           println(i)
end

2020-08-01
2020-08-02
2020-08-03
2020-08-04
2020-08-05
2020-08-06
2020-08-07
2020-08-08
2020-08-09
</code></pre><h1 id="调整器函数">调整器函数</h1>
<p>尽管日期-周期算术很方便，但经常需要在日期上进行的计算具有日历或时间的性质，而不是固定的周期数。节日就是一个很好的例子，大多数都遵循这样的规则：&ldquo;纪念日 = 五月的最后一个星期一&rdquo;，或者 &ldquo;感恩节 = 十一月的第四个星期四&rdquo;。这类时间表达式处理的是相对于日历的规则，比如本月的第一天或最后一天，下周二，或第一个和第三个星期三等。</p>
<p><code>Dates</code> 模块通过几个方便的方法提供了调整器 API，这些方法有助于简单、简洁地表达时间规则。第一组调整器方法处理周、月、季度和年的首尾。它们每个方法都接收一个单一的 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为输入，并返回或调整到相对于输入的所需时期的第一个或最后一个。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.firstdayofweek<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">)</span><span class="o">)</span> <span class="c1"># Adjusts the input to the Monday of the input&#39;s week</span>
2014-07-14

julia&gt; Dates.lastdayofmonth<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">)</span><span class="o">)</span> <span class="c1"># Adjusts to the last day of the input&#39;s month</span>
2014-07-31

julia&gt; Dates.lastdayofquarter<span class="o">(</span>Date<span class="o">(</span>2014,7,16<span class="o">)</span><span class="o">)</span> <span class="c1"># Adjusts to the last day of the input&#39;s quarter</span>
2014-09-30
</code></pre></div><p>接下来的两个高阶方法 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.tonext-Tuple%7BTimeType,Int64%7D">tonext</a> 和 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.toprev-Tuple%7BTimeType,Int64%7D">toprev</a>，通过将一个 <code>DateFunction</code> 和一个起始 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为第一个参数来概括处理时间表达式。<code>DateFunction</code> 只是一个函数，通常是匿名的，它接受一个单一的 <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.TimeType">TimeType</a> 作为输入，并返回一个 <a href="https://docs.julialang.org/en/v1/base/numbers/#Core.Bool">Bool</a>，<code>true</code> 表示满足调整标准。例如:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; <span class="nv">istuesday</span> <span class="o">=</span> x-&gt;Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.Tuesday<span class="p">;</span> <span class="c1"># Returns true if the day of the week of x is Tuesday</span>

julia&gt; Dates.tonext<span class="o">(</span>istuesday, Date<span class="o">(</span>2014,7,13<span class="o">)</span><span class="o">)</span> <span class="c1"># 2014-07-13 is a Sunday</span>
2014-07-15

julia&gt; Dates.tonext<span class="o">(</span>Date<span class="o">(</span>2014,7,13<span class="o">)</span>, Dates.Tuesday<span class="o">)</span> <span class="c1"># Convenience method provided for day of the week adjustments</span>
2014-07-15
</code></pre></div><p>这对于更复杂的时间表达式的 do-block 语法是很有用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">julia&gt; Dates.tonext<span class="o">(</span>Date<span class="o">(</span>2014,7,13<span class="o">)</span><span class="o">)</span> <span class="k">do</span> x
           <span class="c1"># Return true on the 4th Thursday of November (Thanksgiving)</span>
           Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.Thursday <span class="o">&amp;&amp;</span>
           Dates.dayofweekofmonth<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="m">4</span> <span class="o">&amp;&amp;</span>
           Dates.month<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.November
       end
2014-11-27
</code></pre></div><p><a href="https://docs.julialang.org/en/v1/base/collections/#Base.filter">Base.filter</a> 方法可以用来获取指定范围内的所有有效日期/时刻。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 匹兹堡街道清洁; 从 4月到11月的每第二个周二</span>
<span class="c1"># 日期范围从 2014-01-01 到 2015-01-01</span>
julia&gt; <span class="nv">dr</span> <span class="o">=</span> Dates.Date<span class="o">(</span>2014<span class="o">)</span>:Day<span class="o">(</span>1<span class="o">)</span>:Dates.Date<span class="o">(</span>2015<span class="o">)</span><span class="p">;</span>

julia&gt; filter<span class="o">(</span>dr<span class="o">)</span> <span class="k">do</span> x
           Dates.dayofweek<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> Dates.Tue <span class="o">&amp;&amp;</span>
           Dates.April &lt;<span class="o">=</span> Dates.month<span class="o">(</span>x<span class="o">)</span> &lt;<span class="o">=</span> Dates.Nov <span class="o">&amp;&amp;</span>
           Dates.dayofweekofmonth<span class="o">(</span>x<span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="m">2</span>
       end
8-element Array<span class="o">{</span>Date,1<span class="o">}</span>:
 2014-04-08
 2014-05-13
 2014-06-10
 2014-07-08
 2014-08-12
 2014-09-09
 2014-10-14
 2014-11-11
</code></pre></div><p>在 Raku 中上面的代码可以写成:</p>
<pre><code class="language-raku" data-lang="raku">lazy my @dates = Date.new('2014-01-01') ... Date.new('2015-01-01');

.say for @dates.grep: -&gt; $d {
    $d.day-of-week == 2 &amp;&amp;
    4  &lt;= $d.month &lt;= 11 &amp;&amp;
    $d.weekday-of-month == 2
}
</code></pre><p>其他的例子和测试可以在 <a href="https://github.com/JuliaLang/julia/blob/master/stdlib/Dates/test/adjusters.jl">stdlib/Dates/test/adjusters.jl</a> 中找到。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dates" term="dates" label="dates" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Flink 中的 Table API]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-30-table-api-in-flink/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-30-table-api-in-flink/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-26T00:00:00+08:00</published>
            <updated>2020-07-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Real Time Reporting with the Table API</blockquote><p>Apache Flink 提供的 Table API 是一个统一的、关系型的 API，用于批处理和流处理，即在无边界的、实时的流或有边界的、批处理的数据集上以相同的语义执行查询，并产生相同的结果。Flink 中的 Table API 通常用于简化数据分析、数据管道化和 ETL 应用的定义。</p>
<h2 id="你要构建什么">你要构建什么?</h2>
<p>在本教程中，你将学习如何构建一个实时的仪表盘，以按账户跟踪金融交易。该管道将从 Kafka 读取数据，并将结果写入 MySQL，通过 Grafana 可视化。</p>
<h2 id="先决条件">先决条件</h2>
<p>本演练假设你对 Java 或 Scala 有一定的熟悉，但即使你来自不同的编程语言，你也应该能够跟上。它还假设你熟悉基本的关系概念，如 SELECT 和 GROUP BY 子句。</p>
<h2 id="救命-我被卡住了">救命, 我被卡住了!</h2>
<p>如果你遇到困难，请查看<a href="https://flink.apache.org/community.html">社区支持资源</a>。特别是 Apache Flink 的<a href="https://flink.apache.org/community.html#mailing-lists">用户邮件列表</a>，它一直是 Apache 项目中最活跃的一个，也是快速获得帮助的好方法。</p>
<h2 id="如何跟进">如何跟进</h2>
<p>如果你想跟着走，你需要一台电脑与。</p>
<ul>
<li>Java 8 或 11</li>
<li>Maven</li>
<li>Docker</li>
</ul>
<p>所需的配置文件可在 <a href="https://github.com/apache/flink-playgrounds">flink-playgrounds</a> 资源库中获得。下载后，在 IDE 中打开项目 flink-playground/table-walkthrough，并导航到文件 SpendReport。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">EnvironmentSettings</span> <span class="n">settings</span> <span class="k">=</span> <span class="nc">EnvironmentSettings</span><span class="o">.</span><span class="n">newInstance</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="nc">TableEnvironment</span> <span class="n">tEnv</span> <span class="k">=</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span><span class="o">;</span>

<span class="n">tEnv</span><span class="o">.</span><span class="n">executeSql</span><span class="o">(</span><span class="s">&#34;CREATE TABLE transactions (\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    account_id  BIGINT,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    amount      BIGINT,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    transaction_time TIMESTAMP(3),\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    WATERMARK FOR transaction_time AS transaction_time - INTERVAL &#39;5&#39; SECOND\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;) WITH (\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;connector&#39; = &#39;kafka&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;topic&#39;     = &#39;transactions&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;properties.bootstrap.servers&#39; = &#39;kafka:9092&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;format&#39;    = &#39;csv&#39;\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;)&#34;</span><span class="o">)</span><span class="o">;</span>

<span class="n">tEnv</span><span class="o">.</span><span class="n">executeSql</span><span class="o">(</span><span class="s">&#34;CREATE TABLE spend_report (\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    account_id BIGINT,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    log_ts     TIMESTAMP(3),\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    amount     BIGINT\n,&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    PRIMARY KEY (account_id, log_ts) NOT ENFORCED&#34;</span> <span class="o">+</span>
    <span class="s">&#34;) WITH (\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;   &#39;connector&#39;  = &#39;jdbc&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;   &#39;url&#39;        = &#39;jdbc:mysql://mysql:3306/sql-demo&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;   &#39;table-name&#39; = &#39;spend_report&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;   &#39;driver&#39;     = &#39;com.mysql.jdbc.Driver&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;   &#39;username&#39;   = &#39;sql-demo&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;   &#39;password&#39;   = &#39;demo-sql&#39;\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;)&#34;</span><span class="o">)</span><span class="o">;</span>

<span class="nc">Table</span> <span class="n">transactions</span> <span class="k">=</span> <span class="n">tEnv</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="s">&#34;transactions&#34;</span><span class="o">)</span><span class="o">;</span>
<span class="n">report</span><span class="o">(</span><span class="n">transactions</span><span class="o">)</span><span class="o">.</span><span class="n">executeInsert</span><span class="o">(</span><span class="s">&#34;spend_report&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><h2 id="拆解代码">拆解代码</h2>
<h3 id="the-execution-environment">The Execution Environment</h3>
<p>前两行设置了你的 <code>TableEnvironment</code>。表环境是你如何为你的 Job 设置属性，指定你是在写批处理还是流式应用，以及创建你的源。本演练创建了一个使用流式执行的标准表环境。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">EnvironmentSettings</span> <span class="n">settings</span> <span class="k">=</span> <span class="nc">EnvironmentSettings</span><span class="o">.</span><span class="n">newInstance</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="nc">TableEnvironment</span> <span class="n">tEnv</span> <span class="k">=</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><h3 id="注册表">注册表</h3>
<p>接下来，在当前<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/catalogs.html">目录</a>中注册了表，您可以使用这些表连接到外部系统，以便读写批处理和流数据。表源提供对存储在外部系统中的数据的访问，如数据库、键值存储、消息队列或文件系统。table sink 向外部存储系统发出一个表。根据源和 sink 的类型，它们支持不同的格式，如 CSV、JSON、Avro 或 Parquet。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">tEnv</span><span class="o">.</span><span class="n">executeSql</span><span class="o">(</span><span class="s">&#34;CREATE TABLE transactions (\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    account_id  BIGINT,\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    amount      BIGINT,\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    transaction_time TIMESTAMP(3),\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    WATERMARK FOR transaction_time AS transaction_time - INTERVAL &#39;5&#39; SECOND\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;) WITH (\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    &#39;connector&#39; = &#39;kafka&#39;,\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    &#39;topic&#39;     = &#39;transactions&#39;,\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    &#39;properties.bootstrap.servers&#39; = &#39;kafka:9092&#39;,\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;    &#39;format&#39;    = &#39;csv&#39;\n&#34;</span> <span class="o">+</span>
     <span class="s">&#34;)&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>注册了两个表：一个是交易输入表，一个是消费报告输出表。交易(transaction)表让我们可以读取信用卡交易，其中包含账户ID(account_id)、时间戳(transaction_time)和美元金额(amount)。该表是在一个名为 <code>transactions</code> 的 Kafka 主题上的逻辑视图，包含 CSV 数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">tEnv</span><span class="o">.</span><span class="n">executeSql</span><span class="o">(</span><span class="s">&#34;CREATE TABLE spend_report (\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    account_id BIGINT,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    log_ts     TIMESTAMP(3),\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    amount     BIGINT\n,&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    PRIMARY KEY (account_id, log_ts) NOT ENFORCED&#34;</span> <span class="o">+</span>
    <span class="s">&#34;) WITH (\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;connector&#39;  = &#39;jdbc&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;url&#39;        = &#39;jdbc:mysql://mysql:3306/sql-demo&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;table-name&#39; = &#39;spend_report&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;driver&#39;     = &#39;com.mysql.jdbc.Driver&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;username&#39;   = &#39;sql-demo&#39;,\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;    &#39;password&#39;   = &#39;demo-sql&#39;\n&#34;</span> <span class="o">+</span>
    <span class="s">&#34;)&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>第二张表 <code>spend_report</code>，存储了最终的汇总结果。其底层存储是 MySql 数据库中的一张表。</p>
<h3 id="查询">查询</h3>
<p>配置好环境和注册好表之后，你就可以构建你的第一个应用程序了。从 <code>TableEnvironment</code> 中，你可以从一个输入表中读取它的行，然后使用 <code>executeInsert</code> 将这些结果写入到一个输出表中。<code>report</code> 函数是你实现业务逻辑的地方。它目前还没有被实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Table</span> <span class="n">transactions</span> <span class="k">=</span> <span class="n">tEnv</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="s">&#34;transactions&#34;</span><span class="o">)</span><span class="o">;</span>
<span class="n">report</span><span class="o">(</span><span class="n">transactions</span><span class="o">)</span><span class="o">.</span><span class="n">executeInsert</span><span class="o">(</span><span class="s">&#34;spend_report&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><h2 id="测试">测试</h2>
<p>该项目包含一个二次测试类 <code>SpendReportTest</code>，用于验证报表的逻辑。它以批处理模式创建了一个表环境。</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">EnvironmentSettings</span> <span class="n">settings</span> <span class="k">=</span> <span class="nc">EnvironmentSettings</span><span class="o">.</span><span class="n">newInstance</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">inBatchMode</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="n">build</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="nc">TableEnvironment</span> <span class="n">tEnv</span> <span class="k">=</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span><span class="o">;</span>
</code></pre></div><p>Flink 的独特属性之一是它在批处理和流式处理之间提供一致的语义。这意味着你可以在静态数据集上以批处理模式开发和测试应用程序，并以流式应用程序的形式部署到生产中。</p>
<h2 id="尝试一下">尝试一下</h2>
<p>现在有了 Job 设置的骨架，你就可以添加一些业务逻辑了。目标是建立一个报告，显示每个账户在一天中每个小时的总支出。这意味着时间戳列需要从毫秒到小时的颗粒度进行舍入。</p>
<p>Flink 支持用纯 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/sql/">SQL</a> 或使用 <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/tableApi.html">Table API</a> 开发关系型应用。Table API 是一个受 SQL 启发的流畅 DSL，可以用 Python、Java 或 Scala 编写，并支持强大的 IDE 集成。就像 SQL 查询一样，Table 程序可以选择所需的字段，并通过你的键进行分组。这些功能，加上<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/functions/systemFunctions.html">内置的函数</a>，如 <code>floor</code> 和 <code>sum</code>，写这个报告问题不大。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Table</span> <span class="nf">report</span><span class="o">(</span><span class="n">Table</span> <span class="n">transactions</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">transactions</span><span class="o">.</span><span class="na">select</span><span class="o">(</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;transaction_time&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">floor</span><span class="o">(</span><span class="n">TimeIntervalUnit</span><span class="o">.</span><span class="na">HOUR</span><span class="o">)</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span> <span class="n">$</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">select</span><span class="o">(</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h2 id="用户定义的函数">用户定义的函数</h2>
<p>Flink 包含有限的内置函数，有时你需要用<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/functions/udfs.html">用户定义的函数</a>来扩展它。如果 <code>floor</code> 不是预定义的，你可以自己实现它。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.time.LocalDateTime</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.time.temporal.ChronoUnit</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.flink.table.annotation.DataTypeHint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.table.functions.ScalarFunction</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyFloor</span> <span class="kd">extends</span> <span class="n">ScalarFunction</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nd">@DataTypeHint</span><span class="o">(</span><span class="s">&#34;TIMESTAMP(3)&#34;</span><span class="o">)</span> <span class="n">LocalDateTime</span> <span class="nf">eval</span><span class="o">(</span>
        <span class="nd">@DataTypeHint</span><span class="o">(</span><span class="s">&#34;TIMESTAMP(3)&#34;</span><span class="o">)</span> <span class="n">LocalDateTime</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">return</span> <span class="n">timestamp</span><span class="o">.</span><span class="na">truncatedTo</span><span class="o">(</span><span class="n">ChronoUnit</span><span class="o">.</span><span class="na">HOURS</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>然后迅速将其集成到你的应用程序中。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Table</span> <span class="nf">report</span><span class="o">(</span><span class="n">Table</span> <span class="n">transactions</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">transactions</span><span class="o">.</span><span class="na">select</span><span class="o">(</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">call</span><span class="o">(</span><span class="n">MyFloor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">$</span><span class="o">(</span><span class="s">&#34;transaction_time&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span> <span class="n">$</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">select</span><span class="o">(</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>这个查询会消耗 <code>transactions</code> 表的所有记录，计算报表，并以高效、可扩展的方式输出结果。使用该实现运行测试将通过。</p>
<h2 id="添加窗口">添加窗口</h2>
<p>基于时间的数据分组是数据处理中的典型操作，尤其是在处理无限流时。基于时间的分组被称为<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/stream/operators/windows.html">窗口</a>，Flink 提供了灵活的窗口语义。最基本的窗口类型称为 <code>Tumble</code> 窗口，它有一个固定的大小，其桶不重叠。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Table</span> <span class="nf">report</span><span class="o">(</span><span class="n">Table</span> <span class="n">transactions</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">transactions</span>
        <span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="n">Tumble</span><span class="o">.</span><span class="na">over</span><span class="o">(</span><span class="n">lit</span><span class="o">(</span><span class="n">1</span><span class="o">)</span><span class="o">.</span><span class="na">hour</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">$</span><span class="o">(</span><span class="s">&#34;transaction_time&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span> <span class="n">$</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">)</span>
        <span class="o">.</span><span class="na">select</span><span class="o">(</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;account_id&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">&#34;log_ts&#34;</span><span class="o">)</span><span class="o">,</span>
            <span class="n">$</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">&#34;amount&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>这就定义了你的应用程序使用基于时间戳列的一小时翻滚窗口。因此，时间戳为 2019-06-01 01:23:47 的行被放在 2019-06-01 01:00:00 窗口中。</p>
<p>基于时间的聚合是独一无二的，因为在连续流应用中，时间与其他属性不同，一般是向前移动的。与 floor 和你的 UDF 不同，窗口函数是<a href="https://en.wikipedia.org/wiki/Intrinsic_function">内在的</a>，它允许运行时应用额外的优化。在批处理上下文中，窗口提供了一个方便的 API，用于通过时间戳属性对记录进行分组。</p>
<p>用这个实现运行测试也会通过。</p>
<h2 id="再来一次用流">再来一次，用流!</h2>
<p>就这样，一个功能齐全的、有状态的、分布式的流式应用! 查询不断地消耗 Kafka 的事务流，计算每小时的花费，并在结果准备好后立即发出。由于输入是界的，所以查询一直在运行，直到手动停止。而且由于 Job 使用了基于时间窗口的聚合，所以当框架知道某个窗口不会再有记录到达时，Flink 可以进行特定的优化，比如状态清理。</p>
<p>表游乐场是完全 docker 化的，可以作为流式应用在本地运行。该环境包含一个 Kafka 主题、一个连续数据生成器、MySql 和 Grafana。</p>
<p>从 <code>table-walkthrough</code> 文件夹内启动 <code>docker-compose</code> 脚本。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ docker-compose build
$ docker-compose up -d
</code></pre></div><p>你可以通过 <a href="http://localhost:8082/">Flink 控制台</a>查看正在运行的作业信息。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.11/fig/spend-report-console.png" alt="img"></p>
<p>从 MySQL 里面探索结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ docker-compose <span class="nb">exec</span> mysql mysql -Dsql-demo -usql-demo -pdemo-sql

mysql&gt; use sql-demo<span class="p">;</span>
Database changed

mysql&gt; <span class="k">select</span> count<span class="o">(</span>*<span class="o">)</span> from spend_report<span class="p">;</span>
+----------+
<span class="p">|</span> count<span class="o">(</span>*<span class="o">)</span> <span class="p">|</span>
+----------+
<span class="p">|</span>      <span class="m">110</span> <span class="p">|</span>
+----------+
</code></pre></div><p>最后，去 <a href="http://localhost:3000/d/FOe0PbmGk/walkthrough?viewPanel=2&amp;orgId=1&amp;refresh=5s">Grafana</a> 看看完全可视化的结果吧!</p>
<p>原文链接: <a href="https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/table_api.html">https://ci.apache.org/projects/flink/flink-docs-release-1.11/try-flink/table_api.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flink" term="flink" label="flink" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/table" term="table" label="table" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/api" term="api" label="api" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Julia 语言学习笔记]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-27-learning-julialang/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-26T00:00:00+08:00</published>
            <updated>2020-07-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Learning Julia</blockquote><h2 id="语法">语法</h2>
<h3 id="数值字面量系数">数值字面量系数</h3>
<p>在标识符或圆括号前面直接放一个数字, 例如 <code>2x</code> 或 <code>2(x+y)</code>, 会被认为是把标识符和它前面的数字相乘。这样写多项式就很方便了。</p>
<h3 id="向量化的点号运算符">向量化的点号运算符</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">.+</span> <span class="mi">3</span>

<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mi">4</span>
 <span class="mi">5</span>
 <span class="mi">6</span>
</code></pre></div><p><code>.+</code> 类似于 Raku 中的 <code>»+»</code> 超运算符:</p>
<pre><code class="language-raku" data-lang="raku">[1,2,3] »+» 3
[4 5 6]
</code></pre><p>但是 Julia 的 <code>Vectorized &quot;dot&quot;</code> 语法没有 Raku 的超运算符语法清晰。</p>
<p>类似的例子还有:</p>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">sin</span><span class="o"></span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="c"># 0.479425538604203</span>

<span class="n">A</span><span class="o"></span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]</span>
<span class="n">sin</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="o"></span><span class="p">)</span>

<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">0.479425538604203</span>
 <span class="mf">0.8414709848078965</span>
 <span class="mf">0.9974949866040544</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span><span class="n">y</span><span class="o"></span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span><span class="n">x</span><span class="o"></span> <span class="o">+</span> <span class="mi">4</span><span class="n">y</span><span class="o"></span><span class="p">;</span>
<span class="n">A</span><span class="o"></span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span><span class="p">;</span>
<span class="n">B</span><span class="o"></span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">]</span><span class="p">;</span>
<span class="n">f</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="nb">pi</span><span class="p">,</span> <span class="n">A</span><span class="o"></span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">13.42477796076938</span>
 <span class="mf">17.42477796076938</span>
 <span class="mf">21.42477796076938</span>

<span class="n">f</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="o"></span><span class="p">,</span> <span class="nb">pi</span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">15.566370614359172</span>
 <span class="mf">18.566370614359172</span>
 <span class="mf">21.566370614359172</span>

<span class="n">f</span><span class="o"></span><span class="o">.</span><span class="p">(</span><span class="n">A</span><span class="o"></span><span class="p">,</span><span class="n">B</span><span class="o"></span><span class="p">)</span>
<span class="mi">3</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="mf">19.0</span>
 <span class="mf">26.0</span>
 <span class="mf">33.0</span>
</code></pre></div><p>等价的 Raku 写法为:</p>
<pre><code class="language-raku" data-lang="raku">sub f(\x, \y) { 3*x + 4*y};

my \A = [1.0, 2.0, 3.0];
my \B = [4.0, 5.0, 6.0];

A».&amp;f(pi)
[15.566370614359172 18.566370614359172 21.566370614359172]
</code></pre><h3 id="链式比较">链式比较</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&lt;</span><span class="o">=</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">=</span><span class="o">=</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">1</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">5</span>
<span class="kc">true</span>
</code></pre></div><p>Raku 同样支持这种链式比较。</p>
<h3 id="虚数">虚数</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">real</span><span class="o"></span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span>         <span class="c"># 1</span>
<span class="n">imag</span><span class="o"></span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span>         <span class="c"># 2</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="nb">im</span><span class="p">)</span> <span class="c"># 5 + 0im</span>
</code></pre></div><pre><code class="language-raku" data-lang="raku">(1 + 2i).re         # 1
(1 + 2i).im         # 2
(1 + 2i) * (1 - 2i) # 5+0i
</code></pre><h3 id="命名参数">命名参数</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">function</span> <span class="n">plot</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="p">;</span> <span class="n">style</span><span class="o"></span><span class="o">=</span><span class="s">&#34;</span><span class="s">s</span><span class="s">o</span><span class="s">l</span><span class="s">i</span><span class="s">d</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">width</span><span class="o"></span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o"></span><span class="o">=</span><span class="s">&#34;</span><span class="s">b</span><span class="s">l</span><span class="s">a</span><span class="s">c</span><span class="s">k</span><span class="s">&#34;</span><span class="p">)</span>
    <span class="c">###</span>
<span class="k">end</span>

<span class="n">plot</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="p">,</span> <span class="n">width</span><span class="o"></span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plot</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="p">,</span> <span class="o">:</span><span class="n">width</span><span class="o"></span> <span class="o">=</span><span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div><h3 id="函数组合">函数组合</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">(</span><span class="n">sqrt</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="o">+</span><span class="p">)</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="c"># 3.0</span>

<span class="n">map</span><span class="o"></span><span class="p">(</span><span class="n">first</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="n">reverse</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="n">uppercase</span><span class="o"></span><span class="p">,</span> <span class="n">split</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">y</span><span class="s">o</span><span class="s">u</span><span class="s"> </span><span class="s">c</span><span class="s">a</span><span class="s">n</span><span class="s"> </span><span class="s">c</span><span class="s">o</span><span class="s">m</span><span class="s">p</span><span class="s">o</span><span class="s">s</span><span class="s">e</span><span class="s"> </span><span class="s">f</span><span class="s">u</span><span class="s">n</span><span class="s">c</span><span class="s">t</span><span class="s">i</span><span class="s">o</span><span class="s">n</span><span class="s">s</span><span class="s"> </span><span class="s">l</span><span class="s">i</span><span class="s">k</span><span class="s">e</span><span class="s"> </span><span class="s">t</span><span class="s">h</span><span class="s">i</span><span class="s">s</span><span class="s">&#34;</span><span class="p">)</span><span class="p">)</span>
<span class="mi">6</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Char</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
 <span class="sc">&#39;U&#39;</span>
 <span class="sc">&#39;N&#39;</span>
 <span class="sc">&#39;E&#39;</span>
 <span class="sc">&#39;S&#39;</span>
 <span class="sc">&#39;E&#39;</span>
 <span class="sc">&#39;S&#39;</span>
</code></pre></div><h3 id="piping">Piping</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="mi">1</span><span class="o">:</span><span class="mi">10</span> <span class="o">|&gt;</span> <span class="n">sum</span><span class="o"></span> <span class="o">|&gt;</span> <span class="n">sqrt</span><span class="o"></span> <span class="c"># 7.416198487095663</span>

<span class="c"># 等价于</span>
<span class="p">(</span><span class="n">sqrt</span><span class="o"></span> <span class="n">∘</span><span class="o"></span> <span class="n">sum</span><span class="o"></span><span class="p">)</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span>  <span class="c"># 7.416198487095663</span>
</code></pre></div><h3 id="广播和管道一起使用">广播和管道一起使用</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="p">[</span><span class="s">&#34;</span><span class="s">a</span><span class="s">&#34;</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">l</span><span class="s">i</span><span class="s">s</span><span class="s">t</span><span class="s">&#34;</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">o</span><span class="s">f</span><span class="s">&#34;</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">s</span><span class="s">t</span><span class="s">r</span><span class="s">i</span><span class="s">n</span><span class="s">g</span><span class="s">s</span><span class="s">&#34;</span><span class="p">]</span> <span class="o">.</span><span class="o">|&gt;</span> <span class="p">[</span><span class="n">uppercase</span><span class="o"></span><span class="p">,</span> <span class="n">reverse</span><span class="o"></span><span class="p">,</span> <span class="n">titlecase</span><span class="o"></span><span class="p">,</span> <span class="n">length</span><span class="o"></span><span class="p">]</span>
<span class="mi">4</span><span class="o">-</span><span class="n">element</span><span class="o"></span> <span class="kt">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="o">:</span>
  <span class="s">&#34;</span><span class="s">A</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="s">t</span><span class="s">s</span><span class="s">i</span><span class="s">l</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="s">O</span><span class="s">f</span><span class="s">&#34;</span>
 <span class="mi">7</span>
</code></pre></div><h3 id="组合类型">组合类型</h3>
<ul>
<li>不可变组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">struct</span> <span class="n">Foo</span><span class="o"></span>
    <span class="n">bar</span><span class="o"></span>
    <span class="n">baz</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Int</span>
    <span class="n">qux</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span>
<span class="k">end</span>

<span class="n">foo</span><span class="o"></span> <span class="o">=</span> <span class="n">Foo</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">l</span><span class="s">a</span><span class="s">n</span><span class="s">g</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">typeof</span><span class="o"></span><span class="p">(</span><span class="n">foo</span><span class="o"></span><span class="p">)</span> <span class="c"># Foo</span>
<span class="n">typeof</span><span class="o"></span><span class="p">(</span><span class="n">Foo</span><span class="o"></span><span class="p">)</span> <span class="c"># DataType</span>

<span class="n">foo</span><span class="o"></span><span class="o">.</span><span class="n">bar</span><span class="o"></span>     <span class="c"># rakulang</span>
<span class="n">foo</span><span class="o"></span><span class="o">.</span><span class="n">qux</span><span class="o"></span>     <span class="c"># 1.5</span>
<span class="n">foo</span><span class="o"></span><span class="o">.</span><span class="n">qux</span><span class="o"></span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># ERROR: setfield! immutable struct of type Foo cannot be changed</span>
</code></pre></div><ul>
<li>可变组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">mutable</span> <span class="k">struct</span> <span class="n">Bar</span><span class="o"></span>
    <span class="n">baz</span><span class="o"></span>
    <span class="n">qux</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span>
<span class="k">end</span>

<span class="n">bar</span><span class="o"></span> <span class="o">=</span> <span class="n">Bar</span><span class="o"></span><span class="p">(</span><span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">d</span><span class="s">o</span><span class="s">&#34;</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">)</span>
<span class="n">bar</span><span class="o"></span><span class="o">.</span><span class="n">baz</span><span class="o"></span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span>
<span class="n">bar</span><span class="o"></span><span class="o">.</span><span class="n">qux</span><span class="o"></span> <span class="o">=</span> <span class="mf">2.0</span>
</code></pre></div><h3 id="联合类型">联合类型</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">IntOrString</span><span class="o"></span> <span class="o">=</span> <span class="kt">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">AbstractString</span><span class="p">}</span>
<span class="mi">1</span> <span class="o">:</span><span class="o">:</span> <span class="n">IntOrString</span><span class="o"></span>          <span class="c"># 1</span>
<span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">l</span><span class="s">a</span><span class="s">n</span><span class="s">g</span><span class="s">&#34;</span> <span class="o">:</span><span class="o">:</span> <span class="n">IntOrString</span><span class="o"></span> <span class="c"># rakulang</span>
</code></pre></div><h3 id="参数化类型">参数化类型</h3>
<ul>
<li>参数化组合类型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="k">struct</span> <span class="n">Point</span><span class="o"></span><span class="p">{</span><span class="n">T</span><span class="o"></span><span class="p">}</span>
    <span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">T</span><span class="o"></span>
    <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">T</span><span class="o"></span>
<span class="k">end</span>

<span class="n">point</span><span class="o"></span><span class="o">=</span><span class="n">Point</span><span class="o"></span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="n">point</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span> <span class="c"># 1.0</span>
<span class="n">point</span><span class="o"></span><span class="o">.</span><span class="n">y</span><span class="o"></span> <span class="c"># 2.0</span>


<span class="k">struct</span> <span class="n">Circle</span><span class="o"></span><span class="p">{</span><span class="n">T</span><span class="o"></span><span class="p">,</span><span class="n">U</span><span class="o"></span><span class="p">}</span>
    <span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">T</span><span class="o"></span>
    <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="n">U</span><span class="o"></span>
<span class="k">end</span>

<span class="n">c</span><span class="o"></span> <span class="o">=</span> <span class="n">Circle</span><span class="o"></span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">AbstractString</span><span class="p">}</span><span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="s">&#34;</span><span class="s">r</span><span class="s">a</span><span class="s">k</span><span class="s">u</span><span class="s">l</span><span class="s">a</span><span class="s">n</span><span class="s">g</span><span class="s">&#34;</span><span class="p">)</span>
<span class="n">c</span><span class="o"></span><span class="o">.</span><span class="n">x</span><span class="o"></span> <span class="c"># 6.0</span>
<span class="n">c</span><span class="o"></span><span class="o">.</span><span class="n">y</span><span class="o"></span> <span class="c"># rakulang</span>
</code></pre></div><h3 id="多重分派">多重分派</h3>
<div class="highlight"><pre class="chroma"><code class="language-julia" data-lang="julia"><span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span><span class="o"></span> <span class="o">+</span> <span class="n">y</span><span class="o"></span>
<span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span><span class="o"></span> <span class="o">-</span> <span class="n">y</span><span class="o"></span>

<span class="n">methods</span><span class="o"></span><span class="p">(</span><span class="n">f</span><span class="o"></span><span class="p">)</span>
<span class="c"># 2 methods for generic function &#34;f&#34;:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Float64</span><span class="p">)</span> <span class="kp">in</span> <span class="n">Main</span><span class="o"></span> <span class="n">at</span><span class="o"></span> <span class="n">REPL</span><span class="o"></span><span class="p">[</span><span class="mi">33</span><span class="p">]</span><span class="o">:</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">f</span><span class="o"></span><span class="p">(</span><span class="n">x</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">,</span> <span class="n">y</span><span class="o"></span><span class="o">:</span><span class="o">:</span><span class="kt">Number</span><span class="p">)</span> <span class="kp">in</span> <span class="n">Main</span><span class="o"></span> <span class="n">at</span><span class="o"></span> <span class="n">REPL</span><span class="o"></span><span class="p">[</span><span class="mi">34</span><span class="p">]</span><span class="o">:</span><span class="mi">1</span>

<span class="n">f</span><span class="o"></span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="c"># 7</span>
<span class="n">f</span><span class="o"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>   <span class="c"># 1</span>
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julialang" term="julialang" label="julialang" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/julia" term="julia" label="julia" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[通过函数式编程实现更简洁的代码]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-26-cleaner-code-with-functional-programming/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/?utm_source=atom_feed" rel="related" type="text/html" title="Checklist for Raku 6.d" />
            
                <id>https://ohmyweekly.github.io/notes/2020-07-26-cleaner-code-with-functional-programming/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-26T00:00:00+08:00</published>
            <updated>2020-07-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Cleaner code with functional programming</blockquote><p>函数式编程是一种编程风格，现代语言或多或少都支持这种风格。在这篇文章中，我想解释一下函数式编程如何为你提供强大的抽象，使你的代码更加简洁。我将用 Raku 和 Python 中的例子来说明这一点，我们将看到这两种语言都是函数式编程的优秀语言。</p>
<h2 id="raku-简介">Raku: 简介</h2>
<p>本文的代码示例是用 Python 和 Raku 编写的。我想大多数人都熟悉 Python，但 Raku 不太为人所知，所以我先解释一下基础知识。本文中的代码不是很习惯，所以如果你懂得其他编程语言，应该很容易理解。</p>
<p>Raku 与 Perl 最为相似。两种语言在语法上都与 C/C++、Java 和 JavaScript 相似：基于块，语句用分号隔开，块用大括号分界，参数列表放在括号中，用逗号隔开。将 Perl 和 Raku 与其他语言区分开来的主要特征是使用魔符（&ldquo;有趣的字符&rdquo;）来识别变量的类型：<code>$</code> 代表标量，<code>@</code> 代表数组，<code>%</code> 代表哈希（映射），<code>&amp;</code> 代表子程序。变量也有关键字来标识它们的作用域，我只用 <code>my</code> 来标识变量的词法作用域。子程序是用 <code>sub</code> 关键字来声明的，子程序可以是命名的，也可以是匿名的。</p>
<pre><code class="language-perl6" data-lang="perl6">sub square ($x) {
    $x*$x;
}
# anonymous subroutine 
my $anon_square = sub ($x) {
    $x*$x;
}
</code></pre><p>在 Python 中，这将是：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="c1"># anonymous subroutine </span>
<span class="n">anon_square</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
</code></pre></div><p>Raku 支持无符号变量，并使用 <code>\</code> 语法来声明它们。更多关于普通变量和无符号变量之间的区别，请参见 <a href="https://docs.raku.org/language/variables#Sigilless_variables">Raku 文档</a>。例如(<code>say</code> 打印它的参数，后面加一个换行)。</p>
<pre><code class="language-perl6" data-lang="perl6">my \x = 42; # sigilless
my $y = 43; 
say x + $y; 
</code></pre><p>在本文的代码中，我将尽可能地使用无符号变量。</p>
<p>Raku 有几种类型的序列数据结构。在下面的代码中，我将使用<a href="https://docs.raku.org/language/list">列表和数组</a>以及<a href="https://docs.raku.org/type/Range">范围</a>。在 Raku 中，列表和数组的主要区别在于，列表是不可变的，这意味着一旦创建，就不能修改。所以它是一个只读的数据结构。要&quot;更新&quot;一个不可变的数据结构，你需要创建一个更新的副本。另一方面，数组是可变的，所以我们可以更新它们的元素，扩展它们，缩小它们等等。所有的更新都发生在原始数据的位置上。</p>
<p>Raku 的数组类似于 Python 的 list，Raku 的 list 类似于 Python 的 tuple，也是不可变的。除了语法之外，Raku 中的范围与 Python 中的范围相似，都是不可变的。</p>
<pre><code class="language-perl6" data-lang="perl6">my @array1 = 1,2,3; #=&gt; an array because of the '@' sigil
my \array2 = [1,2,3]; #=&gt; an array, because of the '[...]'

my \range1 = 1 .. 10; #=&gt; a range 1 .. 10
my @array3 = 1 .. 10; #=&gt; an array from a range, because of the '@' sigil

my \list1 = 1,2,3; #=&gt; a list
my $list2 = (1,2,3); #=&gt; also a list
my \list3 = |(1 .. 10);  #=&gt; an array from a range because of the '|' flattening operation
</code></pre><p>相应的 Python 代码为:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">list1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="p">)</span> <span class="c1">#=&gt; a list from a tuple</span>
<span class="n">list2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="p">;</span> <span class="c1">#=&gt; a list, because of the &#39;[...]&#39;</span>

<span class="n">range1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span> <span class="c1">#=&gt; a range 1 .. 10</span>
<span class="n">list3</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span><span class="p">)</span><span class="p">;</span> <span class="c1">#=&gt; a list from a range</span>

<span class="n">tuple1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span> <span class="c1">#=&gt; a tuple</span>
<span class="n">tuple2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="p">)</span> <span class="c1">#=&gt; a tuple from a list</span>
<span class="n">tuple3</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span><span class="p">)</span> <span class="c1">#=&gt; creates a tuple from a range</span>
</code></pre></div><p>其他具体的语法或功能将针对具体的例子进行解释。</p>
<h2 id="其他任何名称的函数---作为值的函数"><em>其他任何名称的函数</em> - 作为值的函数</h2>
<p>函数是函数式编程的精髓。正如我在<a href="https://wimvanderbauwhede.github.io/articles/everything-is-a-function">&ldquo;万物皆函数&rdquo;</a>一文中所解释的那样，在适当的函数式语言中，所有的结构都是由函数构建的。</p>
<p>所有现代编程语言都有函数、程序、子程序或方法的概念。它们是代码重用的重要机制。通常，我们认为函数是对一些输入值进行操作以产生一个或多个输出值的东西。输入值可以是全局声明的，也可以是一个类的属性，或者作为参数传递给函数。同样，输出值可以直接返回，到全局变量，作为类的属性或通过修改输入值。</p>
<p>要想从函数式编程中获益最多，最好是函数是纯粹的，这意味着对函数的调用总是对相同的输入产生相同的输出。在实践中，如果函数只接受输入作为参数，并直接返回输出，这一点比较容易实现，但这并不是必不可少的。</p>
<p>函数式编程的关键特征是，函数的输入值和输出值本身可以是函数。所以函数必须是你语言中的值。有时这被称为 &ldquo;函数必须是一等公民&rdquo;，一个接收和/或返回函数的函数有时被称为&quot;高阶函数&rdquo;。</p>
<p>如果函数是值，那么我们就可以将它们赋值给变量。特别是我们会将它们赋值给其他函数的参数。但我们也可以将它们赋值给普通的变量。</p>
<p>让我们考虑以下函数，<code>choose</code>，它需要三个参数 <code>t</code>，<code>f</code> 和 <code>c</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub choose (\t, \f, \d) {
    if (d) {t} else {f}
}
# Python
def choose (t, f, d):
  if d:
    return t 
  else:
    return f
</code></pre><p>首先让我们用字符串作为前两个参数的值来调用 <code>choose</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \tstr = &quot;True!&quot;;
my \fstr = &quot;False!&quot;;

my \res_str = choose(tstr, fstr, True);

say res_str; #=&gt; says &quot;True!&quot;
# Python
tstr = &quot;True!&quot;
fstr = &quot;False!&quot;

res_str = choose(tstr,fstr,True)

print(res_str) #=&gt; says &quot;True!&quot;
</code></pre><p>现在让我们尝试用函数作为参数:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub tt (\s) { say &quot;True {s}!&quot; }
sub ff (\s) { say &quot;False {s}!&quot; }

my &amp;res_f = choose(&amp;tt, &amp;ff, False);

say &amp;res_f; #=&gt; says &amp;ff
res_f(&quot;rumour&quot;); #=&gt; says &quot;False rumour!&quot;
# Python
def tt(s):
  print( &quot;True &quot;+s+&quot;!&quot;)
def ff(s):  
  print( &quot;False&quot;+s+&quot;!&quot;)

res_f = choose(tt,ff,True)

print(res_f) #=&gt; says &lt;function tt at 0x7f829c3aa310&gt;
res_f(&quot;rumour&quot;) #=&gt; says &quot;False rumour!&quot;
</code></pre><p>因此，我们的函数 <code>choose</code>  接收两个函数作为它的前两个参数，并返回一个函数。在 Raku 中，我们需要在函数名上加上 <code>&amp;</code> 符号，因为否则它们会被求值：像 <code>tt</code> 这样的裸函数名就等于调用没有参数的函数 <code>tt()</code>。通过将这个函数赋值给一个变量(<code>res_f</code>)，我们现在可以将 <code>res_f</code> 作为一个函数来调用，它最终会根据选择来调用 <code>tt</code> 或 <code>ff</code>。</p>
<h2 id="函数不需要名字">函数不需要名字</h2>
<p>现在，如果我们可以将函数赋值给变量，它们本身其实并不需要一个名字。所以我们的函数可以是匿名的。大多数语言都支持匿名函数，在函数式语言中，它们通常被称为 &ldquo;lambda 函数&rdquo;。在 Raku 中，我们有两种方法来创建匿名函数。</p>
<p>使用 <code>sub (...)</code> 语法:</p>
<pre><code class="language-perl6" data-lang="perl6">my \tt = sub (\s) { say &quot;True {s}!&quot; };
</code></pre><p>或者使用<a href="https://docs.raku.org/language/functions#index-entry-pointy_blocks">&lsquo;尖号块&rsquo;</a>语法，这样更紧凑一些:</p>
<pre><code class="language-perl6" data-lang="perl6">my \ff = -&gt; \s { say &quot;False {s}!&quot; };
</code></pre><p>Python 使用 <code>lambda</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">tt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="k">print</span><span class="p">(</span> <span class="sa"></span><span class="s2">&#34;</span><span class="s2">True </span><span class="s2">&#34;</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">!</span><span class="s2">&#34;</span> <span class="p">)</span>
<span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span> <span class="p">:</span> <span class="k">print</span><span class="p">(</span> <span class="sa"></span><span class="s2">&#34;</span><span class="s2">False </span><span class="s2">&#34;</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">!</span><span class="s2">&#34;</span> <span class="p">)</span>
</code></pre></div><p>所以现在我们可以说:</p>
<pre><code class="language-perl6" data-lang="perl6">my &amp;res_f = choose(tt, ff, True);

say &amp;res_f; #=&gt; says sub { }
res_f(&quot;story&quot;); #=&gt; says &quot;True story!&quot;
</code></pre><p>当我们打印出函数所绑定的变量时，Raku 返回 <code>sub { }</code> 来表示该变量包含一个函数。</p>
<p>在 Python 中:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">res_f</span> <span class="o">=</span> <span class="n">choose</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span><span class="p">;</span>

<span class="k">print</span><span class="p">(</span> <span class="n">res_f</span><span class="p">)</span> <span class="c1">#=&gt; says &lt;function &lt;lambda&gt; at 0x7f829b298b80&gt;</span>
<span class="n">res_f</span><span class="p">(</span><span class="sa"></span><span class="s2">&#34;</span><span class="s2">story</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1">#=&gt; says &#34;True story!&#34;</span>
</code></pre></div><h2 id="例子-map-grep-和-reduce">例子: <code>map</code>、 <code>grep</code> 和 <code>reduce</code></h2>
<p>函数的功能有很多用途，我只想重点介绍三个在 Raku 中现成的例子：<code>map</code>、<code>reduce</code> 和 <code>grep</code>。Python 有 <code>map</code> 和 <code>filter</code>，并通过 <code>functools</code> 模块提供 <code>reduce</code>。这些函数的共同点是，它们提供了一种对列表进行 <code>for</code> 循环的替代方法。</p>
<h3 id="map--对列表中的所有元素进行函数应用"><code>map</code> : 对列表中的所有元素进行函数应用</h3>
<p><code>map</code> 有两个参数：一个函数和一个列表。它将函数按顺序应用于列表中的所有值，并返回结果，例如将列表中的所有值平方。</p>
<pre><code class="language-perl6" data-lang="perl6">my \res = map -&gt; \x {x*x} , 1 .. 10;
</code></pre><p>在 Python 中，我们需要显式地创建元组，但除了语法上的差异，结构是完全一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span> <span class="nb">map</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span><span class="p">)</span><span class="p">)</span>
</code></pre></div><p>这是对传统 <code>for</code> 循环的功能替代。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = [];
for 1 .. 10 -&gt; \x {
    res.push(x*x);
}
# Python
res = []
for x in range(1,11):
    res.append(x*x)
</code></pre><p>请注意，在 Raku 和 Python 中，我们需要为 <code>for</code> 循环版本使用一个可变的数据结构，而 <code>map</code> 版本则使用不可变的数据结构。</p>
<h3 id="grep--过滤列表"><code>grep</code> : 过滤列表</h3>
<p><code>grep</code> (在 Python 中称为 <code>filter</code>)也接受参数，一个函数和一个列表，但它只返回函数返回真的列表中的值。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = grep -&gt; \x { x % 5 == 0 }, 1 .. 30;
# Python
res = tuple(filter( lambda x : x % 5 == 0 ,range(1,31)))
</code></pre><p>当然我们也可以用 <code>for</code> 循环和 <code>if</code> 语句来写，但这又需要一个可变的数据结构。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \res = [];
for 1 .. 30 -&gt; \x {
    if (x % 5 == 0) {
    res.push(x);
    }
}
# Python
res = []
for x in range(1,31): 
  if (x % 5 == 0):
    res.append(x)
</code></pre><p><code>map</code> 和 <code>grep</code> 的好处是，你可以很容易地把它们链在一起。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
grep -&gt; \x { x % 5 == 0 }, map -&gt; \x {x*x}, 1..30
# Python
res = tuple(filter( lambda x : x % 5 == 0 ,map( lambda x : x*x ,range(1,31))))
</code></pre><p>这是因为 <code>map</code> 和 <code>grep</code> 接受一个列表并返回一个列表，所以只要你需要对一个列表进行操作，就可以通过链式调用来实现。</p>
<h3 id="reduce--化整为零"><code>reduce</code> : 化整为零</h3>
<p><code>reduce</code> 也接受一个函数和一个 list，但它使用函数将 list 的所有元素合并成一个结果。所以函数必须接受两个参数。第二个参数是从列表中取出的元素，第一个参数作为状态变量来组合所有元素。例如，计算一个数字列表的和:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \sum = reduce sub (\acc,\elt) {acc+elt}, 1 .. 10;

say sum; #=&gt; says 55
# Python
from functools import reduce

sum = reduce(lambda acc,elt: acc+elt, range(1,11))

print( sum); #=&gt; says 55
</code></pre><p>这里发生的情况是，首先将 <code>acc</code> 设置为列表中的第一个元素(1)，然后加上第二个元素，所以 <code>acc</code> 变成 1+2=3；然后加上第三个元素(3)，以此类推。其效果是将列表中的所有数字连续相加。</p>
<p>为了更清楚地说明这一点，我们来写一个我们自己的 <code>reduce</code> 版本。</p>
<h3 id="编写你自己的">编写你自己的</h3>
<p>在许多函数式语言中，从左到右（从最低索引开始）和从右到左（从最高索引开始）的还原是有区别的。这一点很重要，因为根据做还原的函数，如果从左边或右边消耗列表，结果可能会不同。例如，假设我们的化简函数是</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
-&gt; \x,\y {x+y}
# Python
lambda x,y: x+y
</code></pre><p>那么我们从哪个方向遍历列表并不重要。但考虑以下函数:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
-&gt; \x,\y { x &lt; y ?? x+y !! x }

# Python
lambda x,y: x+y if x&lt;y else x
</code></pre><p>( <code>... ?? ... !! ...</code> 是条件操作符的 Raku 句法，在大多数其他语言中是 <code>... ? ... : ...</code> 在 Python 中是 <code>... if ... else ...</code>)。</p>
<p>在这种情况下，如果列表从左或从右还原，结果会有所不同。在 Raku 和 Python 中，<code>reduce</code> 是一种从左到右的还原。</p>
<p>另外，<code>reduce</code> 函数可以不使用列表的第一个元素，而是取一个额外的参数，通常称为累加器。在函数式语言中，<code>reduce</code> 通常被称为 <code>fold</code>，所以我们可以有一个左折和一个右折。让我们来看看如何实现这些。</p>
<h4 id="left-fold">Left fold</h4>
<p>实现左折的直接方法（所以和 <code>reduce</code> 一样）是在函数内部使用 <code>for</code> 循环。这意味着我们必须在循环的每次迭代上更新累加器的值。在 Raku 中，无符号变量是不可变的（我在这里简化了，完整的故事请看 <a href="https://docs.raku.org/language/containers#Binding">Raku 文档</a>），所以我们需要使用一个有符号的变量，<code>$acc</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub foldll (&amp;f, \iacc, \lst) { 
  my $acc = iacc; 
  for lst -&gt; \elt {
    $acc = f($acc,elt);
  }
  $acc;
}

# Python
def foldll (f, iacc, lst):
  acc = iacc
  for elt in lst:
    acc = f(acc,elt)  
  return acc
</code></pre><p>如果我们只想使用不可变的变量，我们可以使用递归。Raku 使这一点变得简单，因为它允许一个子程序有多个签名(<code>multi sub</code>)，并且它会调用与签名相匹配的变量。</p>
<p>我们的 <code>foldl</code> 将消耗输入列表 <code>lst</code>，并使用 <code>f</code> 将其元素组合到累加器 <code>acc</code> 中，当列表被消耗后，计算结束，我们可以返回 <code>acc</code> 作为结果。所以我们的第一个变体说，如果输入列表是空的，我们应该返回 <code>acc</code>。 第二个变体从列表中取出一个元素 <code>elt</code> (关于 <code>*</code> 的细节请参见 <a href="https://docs.raku.org/type/Range">Raku 文档</a>)，并将其与 <code>acc</code> 结合到 <code>f(acc,elt)</code> 中。然后用这个新的累加器和 list 的剩余部分 <code>rest</code> 再次调用 <code>foldl</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># When the list is empty, return the accumulator
multi sub foldl (&amp;f, \acc, ()) { acc }
multi sub foldl (&amp;f, \acc, \lst) {
  # Raku's way of splitting a list in the first elt and the rest
  # The '*' is a shorthand for the end of the list
   my (\elt,\rest) = lst[0, 1 .. * ]; 
   # The actual recursion
   foldl( &amp;f, f(acc, elt), rest);
}
</code></pre><p>Python 不允许这种模式匹配，所以我们需要使用条件来编写递归。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">foldl</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">lst</span> <span class="o">==</span> <span class="p">(</span><span class="p">)</span><span class="p">:</span> 
    <span class="k">return</span> <span class="n">acc</span> 
  <span class="k">else</span><span class="p">:</span>
  <span class="c1"># Python&#39;s way of splitting a tuple in the first elt and the rest</span>
  <span class="c1"># rest will be a list, not a tuple, but we&#39;ll let that pass</span>
   <span class="p">(</span><span class="n">elt</span><span class="p">,</span><span class="o">*</span><span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="n">lst</span> 
   <span class="c1"># The actual recursion</span>
   <span class="k">return</span> <span class="n">foldl</span><span class="p">(</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">elt</span><span class="p">)</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</code></pre></div><p>在这个实现中，所有的变量都不会被更新。所以所有的变量都可以是不可变的。</p>
<h4 id="right-fold">Right fold</h4>
<p>右折与左折颇为相似。对于基于循环的版本，我们所做的只是将列表反转(<code>reverse</code>)。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub foldrl (&amp;f, \acc, \lst) { 
  my $res = acc;
  for  lst.reverse -&gt; \elt {
    $res = f($res,elt);
  }
  $res;
}

# Python
def foldlr (f, iacc, lst):
  acc = iacc
  for elt in lst.reverse():
    acc = f(acc,elt)  
  return acc
</code></pre><p>在递归版本中，我们从列表中取最后一个元素而不是第一个元素。关于 <code>..^ * - 1</code> 语法的细节，请参见 <a href="https://docs.raku.org/language/operators#infix_..%5E">Raku 文档</a>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
multi sub foldr ( &amp;f, \acc, ()) { acc }
multi sub foldr (&amp;f, \acc, \lst) {
    my (\rest,\elt) = lst[0..^*-1, *  ];
    foldr( &amp;f, f(acc, elt), rest);
}

# Python
def foldr (f, acc, lst):
  if lst == (): 
    return acc 
  else:
   (*rest,elt) = lst 
   return foldr( f, f(acc, elt), rest)
</code></pre><h4 id="map-and-grep-are-folds"><code>map</code> and <code>grep</code> are folds</h4>
<p>现在，<code>map</code> 和 <code>grep</code> 呢？我们当然可以用 <code>for</code> 循环来实现，但我们也可以用我们的 <code>foldl</code> 来实现它们。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub map (&amp;f,\lst) {
    foldl( sub (\acc,\elt) {
            (|acc,f(elt))
            }, (), lst);
}

# Python
def map (f,lst):
    return foldl( 
      lambda acc,elt:(*acc, f(elt))
      ,()
      ,lst
    )
</code></pre><p>因为函数 <code>f</code> 是可映射的，所以它只有一个参数。但是 <code>foldl</code> 需要一个有两个参数的函数，第一个参数为累加器。所以我们用两个参数的匿名函数调用 <code>foldl</code>。累积器本身是一个空列表。虽然我们前面说过，还原将原来列表的所有元素合并成一个返回值，当然这个返回值可以是任何数据类型，所以也是一个列表。所以我们对原始列表中的每一个元素都调用 <code>f</code>，并将其添加到累加器列表的末尾。(<code>|</code> 将列表扁平化，所以 <code>(|acc,f(elt))</code> 是一个由 <code>acc</code> 的元素和 <code>f(elt)</code> 的结果建立的新列表。)</p>
<p>类似地，我们也可以定义 <code>grep</code>:</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub grep (&amp;f,\lst) {
    foldl( sub (\acc,\elt) {
      if (f(elt)) {
          (|acc,elt)
      } else {
          acc
      }
    }, (), lst);
}

# Python
def filter (f,lst):
    return foldl( 
      lambda acc,elt:
        (*acc,elt) if f(elt) else acc
      , (), lst)
</code></pre><p>就像在 <code>map</code> 实现中一样，我们用一个匿名函数调用 <code>foldl</code>。在这个函数中，我们测试 <code>lst</code> 中的每个 <code>elt</code> 是否为 <code>f(elt)</code> 为真。如果是真，我们就从 <code>acc</code> 和 <code>elt</code> 创建一个新的列表，否则我们就只返回 <code>acc</code>。 因为 <code>map</code> 和 <code>grep</code> 分别对列表中的每个元素进行操作，所以我们也可以使用右折来实现它们。</p>
<p>通过这些例子，我希望无论是对函数工作的概念，还是对函数可能的实现方式，都变得更加清晰。递归实现的优点是它允许我们使用不可变的数据结构。</p>
<h3 id="为什么是不可变的数据结构">为什么是不可变的数据结构？</h3>
<p>你可能会好奇为什么我关注这些不可变的数据结构。正如我们将看到的那样，函数式编程与不可改变的数据结构配合得非常好。而且它们有一个很大的优势：你永远不用担心是否不小心修改了你的数据，也不用担心是否应该做一个副本来确定。所以使用不可变数据结构可以使代码不易出错，更容易调试。它们还具有潜在的性能优势。而我们接下来会看到，在 Raku 中还有另一个优势。</p>
<h2 id="返回函数的函数">返回函数的函数</h2>
<p>函数也可以返回函数。如果我们想拥有一个可参数化的函数，这一点尤其有用。举个简单的例子，假设我们想要一系列以固定值递增一个数字的函数：<code>add1</code>、<code>add2</code> 等。当然，我们可以分别写出每一个函数。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub add_1 (\x) {x+1}
sub add_2 (\x) {x+2}
sub add_3 (\x) {x+3}
sub add_4 (\x) {x+4}
sub add_5 (\x) {x+5}

say add_1(4); #=&gt; says 5
# Python
def add_1 (x) : return x+1
def add_2 (x) : return x+2
def add_3 (x) : return x+3
def add_4 (x) : return x+4
def add_5 (x) : return x+5

print( add_1(4)) #=&gt; says 5
</code></pre><p>或者我们可以使用一个充满匿名函数的列表。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add =
sub (\x) {x},
sub (\x) {x+1},
sub (\x) {x+2},
sub (\x) {x+3},
sub (\x) {x+4},
sub (\x) {x+5};

say add[0].(4); #=&gt; says 5


# Python
add = (
lambda x : x+1,
lambda x : x+2,
lambda x : x+3,
lambda x : x+4,
lambda x : x+5
)

print( add[0](4)) #=&gt; says 5
</code></pre><p>我们可以做得更好，用一个循环来填充一个匿名函数的数组。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add = [];
for 0 .. 5 -&gt; \n {
  add.push(sub (\x) {x+n});
}

say add[1].(4); #=&gt; says 5

# Python
add = []
for n in range(0,6):
  add.append(lambda x: x+n)
</code></pre><p>我们每次循环迭代都会创建一个新的匿名函数，并将其添加到数组中。但是，我们可以使用一个函数来创建这些匿名函数，然后我们可以使用 <code>map</code> 来代替循环，并使用一个不可改变的数据结构。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub gen_add(\n) {  
  sub (\x) {x+n}
}

my \add = map &amp;gen_add, 0..5;

say add[1].(4); #=&gt; says 5

# Python
def gen_add(n):  
  return lambda x : x+n

add = tuple(map( gen_add, range(0,6)))

print( add[1](4)) #=&gt; says 5
</code></pre><h3 id="laziness">Laziness</h3>
<p>在 Raku 中，使用(不可改变的)范围有一个额外的好处：我们可以将范围的末端设置为无穷大，在 Raku 中可以写成 <code>∞</code>(unicode 221E)、<code>*</code> 或 <code>Inf</code>。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
my \add = map &amp;gen_add, 0 .. ∞;  

say add[244].(7124); #=&gt; says 7368
</code></pre><p>这是一个所谓的&quot;懒惰求值&quot;的例子，简称 laziness：Raku 不会尝试（和失败）处理这个无限的列表。相反，它将在我们实际使用该列表中的一个元素时进行处理。表达式的评估会延迟到需要结果的时候，所以当我们调用 <code>add[244]</code> 时，发生的情况是 <code>gen_add(244)</code> 被调用来生成该函数。请注意，这在 <code>for</code> 循环中是行不通的，因为要使用 <code>for</code> 循环，我们需要一个可变的数据结构，而惰性列表必须是不可变的。所以这是一个很好的例子，说明函数式编程风格如何让你从懒惰中获益。</p>
<p>这也是为什么我们递归地实现了 <code>foldl</code>，然后用它来实现我们自己的 <code>map</code> 和 <code>grep</code>：基于递归的版本不需要更新任何变量，所以它们可以与不可变的惰性数据结构一起工作。</p>
<h2 id="函数组合">函数组合</h2>
<p>我们在上面看到，你可以把 <code>map</code> 和 <code>grep</code> 的调用链在一起。通常情况下，你只需要将 <code>map</code> 调用链在一起，例如</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
map -&gt; \x { x + 5 }, map -&gt; \x {x*x}, 1..30;

# Python
map( lambda x : x + 5, map( lambda x : x*x, range(1,31)))
</code></pre><p>在这种情况下，我们可以做得更有效率一些：比起创建一个列表，然后在这个列表上调用 <code>map</code>，我们可以通过组合函数一次完成两个计算。Raku 为此提供了一个特殊的操作符。</p>
<pre><code class="language-perl6" data-lang="perl6">map -&gt; \x { x + 5 } ∘ -&gt; \x { x * x }, 1..30;
</code></pre><p>操作符 <code>∘</code>（&ldquo;环形操作符&rdquo;，unicode 2218，但你也可以用普通的 <code>o</code>）是函数组成操作符，它的发音是 &ldquo;after&rdquo;，所以 <code>f ∘ g</code> 是 &ldquo;f after g&rdquo;。它的作用是将两个现有的函数组合起来，创建一个新的函数。</p>
<pre><code class="language-perl6" data-lang="perl6">my &amp;h = &amp;f ∘ &amp;g;
</code></pre><p>是下面的代码是一样的:</p>
<pre><code class="language-perl6" data-lang="perl6">sub h (\x) {
    f(g(x))
}
</code></pre><p>组成运算符的优点是，它可以适用于任何函数，包括匿名函数。但实际上，它只是另一个高阶函数。它只是下面函数的运算符形式。</p>
<pre><code class="language-perl6" data-lang="perl6"># Raku
sub compose(&amp;f,&amp;g) {
    sub (\x) { f(g(x)) }
}
</code></pre><p>Python 没有函数组成操作符，但你也可以很容易地在 Python 中拥有 <code>compose</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># Python</span>
<span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">)</span><span class="p">:</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span>
</code></pre></div><h2 id="结论">结论</h2>
<p>在这篇文章中，我用 Raku 和 Python 的例子介绍了三种关键的函数式编程技术：对函数进行操作的函数、返回函数的函数和函数组成。我已经展示了你如何使用函数 <code>map</code>、<code>reduce</code>(折叠)和 <code>grep</code>(过滤)来操作不可变的列表。我已经解释了哟(如何用递归和不递归实现这样的函数，以及递归实现的优势是什么。下面是《 <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.raku">Raku</a> 与 <a href="https://github.com/wimvanderbauwhede/raku-examples/blob/master/decluttering-with-functional-programming.py">Python</a>》一文中的代码。</p>
<p>当然，函数式编程的内容还有很多，我也写了<a href="https://wimvanderbauwhede.github.io/articles/">几篇更高级的文章</a>。本文介绍的概念应该为理解那些更高级的主题打下良好的基础。如果你想了解更多关于函数式编程的知识，你可以考虑我的<a href="https://www.futurelearn.com/courses/functional-programming-haskell">免费在线课程</a>。</p>
<p>原文: <a href="https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/">https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/functional-programming" term="functional-programming" label="functional programming" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Checklist for Raku 6.d]]></title>
            <link href="https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/2020-07-21-checklist-for-6-dot-d/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-21T00:00:00+08:00</published>
            <updated>2020-07-21T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Checklist for 6.d</blockquote><h2 id="问题">问题</h2>
<p>在 6.d 版本中, 很多东西都发生了变化, 我们至少需要发布一个版本。<a href="https://github.com/perl6/roast/blob/master/docs/announce/6.d.md">这里有个列表</a>。然而, 覆盖面是不完整的。弃用通知采取了不同的形式, 一些新的类型和方法在那里, 一些则没有&hellip;&hellip;</p>
<p>用 <code>#2632</code> 引用这个问题, 并检查项目, 当你的工作, 无论是通过改变后的文档, 看到没有变化, 需要做它。在这种情况下, 请通过评论或如何解释为什么是这种情况。</p>
<h2 id="版本控制的变更">版本控制的变更</h2>
<ul>
<li><strong>[6.d]</strong> <code>&amp;await</code> 在等待的时候不再阻塞线程</li>
<li><strong>[6.d]</strong> <code>whenever</code> 不在 <code>react</code> 抛出的词法作用域内</li>
<li><strong>[6.d]</strong> 在 <code>sub MAIN</code> 里面的 <code>$*ARGFILES</code> 总是由 <code>$*IN</code> 馈入</li>
<li><strong>[6.d]</strong> 结构(字面上的) <code>$()</code>、<code>@()</code> 和 <code>%()</code> 不复存在</li>
<li><strong>[6.d]</strong> 带有 <code>:D</code>/<code>:U</code> 类型约束的变量默认为约束类型的类型对象(例如, 你可以在它们身上使用 <code>.new</code>)</li>
<li><strong>[6.d]</strong> <code>start</code> 块在 sink 上下文中附加异常处理程序</li>
<li>~~**[6.d]** 例程必须使用 <code>return-rw</code> 来返回一个 <code>Proxy</code>, 即使例程被标记为 <code>is raw</code> 或 <code>is rw</code>~~</li>
<li><strong>[6.d]</strong> 原生的 <code>num</code> 类型默认为 <code>0e0</code> 而不是 <code>NaN</code></li>
<li><strong>[6.d]</strong> 在子程序名中, 保留了键名为 <code>sym</code> 的冒号对（如<code>:sym&lt;foo&gt;</code>）, 以备将来使用</li>
</ul>
<h2 id="废弃">废弃</h2>
<p>这些方法在 6.d 语言中已被废弃, 并将在 6.e 中被删除。实现者可以选择发出弃用警告, 或者在 6.e 版本发布后更长的时间内提供这些方法。</p>
<ul>
<li>使用 <code>'-'</code> (单连字符)作为 <code>&amp;open</code> 的特殊路径, 表示特殊的句柄(使用 <code>IO::Special</code> 对象代替)</li>
<li><code>IO::Handle.slurp-rest</code> (使用 <code>.slurp</code> 代替)</li>
<li><code>Any.flatmap</code> (使用<code>.flat</code> 和 <code>.map</code> 方法的组合来代替)</li>
<li><code>Cool.path</code> (使用 <code>.IO</code> 代替)</li>
<li><code>Pair.freeze</code> (使用去容器化的参数的 <code>Pair.new</code> 来代替)</li>
<li><code>Str.subst-mutate</code> (使用带有 <code>.=</code> 方法调用赋值元运算符的 <code>Str.subst</code> 代替)</li>
<li><code>Rational.norm</code> (现在 <code>Rational</code> 类型必须在创建时标准化)</li>
<li><code>IO::Path.child</code> (使用 <code>.add</code> 代替)</li>
<li><code>&amp;undefine</code> (直接分配 <code>Empty</code>/<code>Nil</code> 代替)</li>
<li><code>:count</code> <code>&amp;lines</code>/<code>Str.lines</code> 例程上的参数(使用所返回的 <code>Seq</code> 上的 <code>.elems</code> 代替)</li>
<li><code>&amp;is_approx</code> in Test.pm6 (使用与 <code>&amp;is-approx</code> 非常相似的行为来代替)</li>
</ul>
<h2 id="新的行为">新的行为</h2>
<ul>
<li>通过新的可定义的 <code>&amp;RUN-MAIN</code>、<code>&amp;ARGS-TO-CAPTURE</code> 和 <code>&amp;GENERATE-USAGE</code> 子例程改善 <code>sub MAIN</code> 的自定义处理</li>
<li><code>%</code> 变量中的 <code>QuantHash</code>/<code>Map</code> 和 <code>@</code> 变量中的 <code>List</code> 可以用 <code>is</code> 特性来声明（例如，<code>my %h is Set</code>）</li>
<li>新的 <code>&lt;ww&gt;</code> regex 规则: 只在单词内匹配</li>
<li>循环可以从上一条语句的值中产生一个值的列表</li>
<li>循环中的 <code>next</code>/<code>last</code> 收集其最后的语句值, 对它们运行的迭代返回 <code>Empty</code></li>
<li><code>.perl</code> 可以在消耗过的 <code>Seq</code>、多维数组、<code>Date</code> 和 <code>CallFrame</code> 上调用</li>
<li><code>.gist</code> 可以在 <code>Attribute</code> 上调用</li>
<li>对自动生成的 <code>USAGE</code> 信息进行了大量改进</li>
<li><code>is hidden-from-USAGE</code> 特性，从自动生成的 <code>USAGE</code> 消息中隐藏 <code>sub MAIN</code> 候选者</li>
<li><code>Parameter.perl</code> 包括可内省的默认值</li>
<li><code>%*ENV</code> 值是同素异形的</li>
<li>尝试使用变量 <code>$;</code>、<code>$,</code>、<code>$.</code>、<code>$\</code>、<code>$(</code>、<code>$)</code>、<code>$&lt;</code>、<code>$&gt;</code>、<code>$/</code>、<code>$\</code>、<code>$[</code>、<code>$-</code>、<code>$+</code> 和 <code>$@</code> 会抛出 <code>X::Syntax::Perl5Var</code></li>
<li>默认的 <code>Hash.keyof</code> 返回一个 <code>Str(Any)</code> 强转类型对象</li>
<li>非 ASCII 数字可以在 <code>:42foo</code> 冒号对快捷方式中使用</li>
<li><code>StrDistance</code> 字符串化为 <code>.after</code> 字符串</li>
<li>更明确的 Pod 表格格式</li>
<li><code>Enumeration.enums</code> 返回一个 <code>Map</code></li>
<li>各种整数类型的 <code>.Range</code> 返回它们支持的值的范围</li>
<li><code>min</code>/<code>max</code>  例程也适用于 <code>Hash</code></li>
<li><code>Signature</code> 字面值可以包含字符串/数字字面值以及调用者标记</li>
<li><code>List.invert</code> 通过所需的 <code>Pair</code> 绑定映射, 导致潜在的类型检查失败</li>
<li><code>:exists</code> 可以与多维关联下标一起使用</li>
<li>动态创建的列表可以用来定义一个枚举</li>
<li>在 <code>.first</code> 中, Junction 可以作为匹配器使用</li>
<li>原生属性可以作为参数中的绑定目标</li>
<li><code>Proc</code> 可以与其他 <code>Proc</code> 中的 <code>IO::Pipe</code> 一起工作</li>
<li>类型数组可以用 <code>my SomeType @array</code> 和 <code>my @array of SomeType</code> 创建</li>
<li>当把 <code>Mixy</code> 强转为 <code>Setty</code>/<code>Baggy </code> 时, 负数权重的项将被删除</li>
<li><code>:nth</code> 副词在 <code>m//</code> 上接受一个 <code>Junction</code> 作为参数</li>
<li><code>CX::Warn' 和 </code>CX::Done<code>可以在</code>CONTROL` phaser 中捕获</li>
<li><code>next</code> 可用于 <code>whenever</code> 中</li>
<li><code>require</code> 符号不再过境性地暴露出来</li>
<li>通过 <code>{...}</code> 进行多维访问, 类似于 <code>[...]</code> 的工作方式</li>
<li>在 <code>END</code> 时间打开的任何手柄都会自动关闭</li>
<li>在缓存的 <code>Seq</code> 上, 当 <code>&amp;infix:&lt;eqv&gt;</code>、<code>.Slip</code>、<code>.join</code>、<code>.List</code>、<code>.list</code>、<code>.eager</code>、<code>.Array</code> 和 <code>.is-lazy</code> 被调用时, 就会使用缓存列表</li>
<li><code>IO::Handle.encoding</code> 以 <code>Nil</code> 表示切换到二进制模式</li>
<li><code>is default</code> 特质与属性一起工作</li>
<li>在多重分派中, 带有 <code>is rw</code> 特性的参数被认为比没有特性的参数窄</li>
<li><code>Array</code>、<code>Blob</code> 和 <code>Map</code> 的 <code>.gist</code> 被裁剪成100个元素</li>
<li>新的 <code>for</code> 语句修饰符 <code>hyper for</code>、<code>race for</code> 和 <code>lazy for</code></li>
<li><code>for</code> 循环自动序列化 <code>RaceSeq</code>/<code>HyperSeq</code>；使用新的 <code>for</code> 语句修饰符<code>hyper for</code>/<code>race for</code>避免</li>
<li><code>&amp;infix:&lt;does&gt;</code> 可用于 RHS 上的非组合实例</li>
<li>数值比较器可以与 <code>DateTime </code> 对象一起使用</li>
<li><code>Pod</code> 保留空白类型</li>
<li>定义了带 <code>@</code>、<code>%</code> 和 <code>&amp;</code> 魔符常数的语义</li>
</ul>
<h2 id="math">Math</h2>
<ul>
<li><code>Rational</code> 总是在创建时被化简, 并在其一生中保持不变</li>
<li><code>Inf</code>、<code>Inf</code> 和 <code>NaN</code> 可以分别用 <code>&lt;-1/0&gt;</code>、<code>&lt;1/0&gt;</code> 和 <code>&lt;0/0</code>&gt; 表示, 通过<code>Rational</code> 类型进行舍去。零分母 <code>Rational</code> 被标准化为这三个值之一</li>
<li>在 ±<code>Inf</code> 和 <code>NaN</code> 上调用 <code>.Int</code>, 会抛出异常</li>
<li>改进了 <code>Num</code> 运算符和数学函数的 IEEE 754-2008 合规性</li>
<li>负零 <code>Num</code>(<code>-0e0</code>)被所有例程和语法结构正确处理</li>
<li><code>Num</code> 类型的字符串化必须是可舍弃到原始 <code>Num</code> 的</li>
<li>定义了涉及零的 <code>Complex </code> 指数</li>
<li><code>.expmod</code> 中的负数幂有效</li>
</ul>
<h2 id="setsbagsmixesaka-quanthashes和集合运算符">Sets、Bags、Mixes(aka QuantHashes)和集合运算符</h2>
<ul>
<li>Set 运算符可以用在任何对象上, 在需要的时候会被强转
<ul>
<li>所以, 不需要也不希望有任何预先的强转</li>
<li>如果没有 QuantHash 就能实现所需的功能, 那么 Set 运算符可以自由地不创建任何 QuantHash</li>
</ul>
</li>
<li>对不同类型的 QuantHashes 的 Set 操作将强转到最自由的形式（Set -&gt; Bag -&gt; Mix）</li>
<li>集合运算符的 set_precedes 家族( <code>(&lt;+)</code>、<code>≼</code>、<code>(&gt;+)</code>、<code>≽</code>) 已被移除
<ul>
<li>曾经是子集运算符的 Baggy 形式</li>
<li>QuantHash 升级为最自由的形式, 所以 <code>(&lt;=)</code>、<code>⊆</code>、<code>(&gt;=)</code>、<code>⊇</code> 做正确的事情</li>
</ul>
</li>
<li><code>.classify-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Baggy</code> 类型</li>
<li><code>.invert</code> 方法可用于核心 <code>QuantHash</code> 类型</li>
<li><code>.antipairs</code> 方法可用于 <code>QuantHash</code> 类型</li>
<li><code>QuantHash</code> 类型有 <code>.new-from-pairs</code> 和将一个 <code>QuantHash</code> 类型转换为另一个 <code>QuantHash</code> 类型的方法(例如 <code>Set</code> 类型的 <code>.Bag</code> 方法)</li>
<li><code>QuantHash</code> 类型上的 <code>.hash</code> 对键值进行了字符串化</li>
</ul>
<h2 id="新的形参和实参">新的形参和实参</h2>
<ul>
<li><code>Date.new</code> 接受一个 <code>:&amp;formatter</code></li>
<li><code>.first</code> 可以接受 <code>:kv</code></li>
<li><code>unique</code> 和 <code>.repeated</code> 可以接受 <code>:&amp;as</code> 和 <code>:&amp;with</code></li>
<li>Test.pm6 中的 <code>&amp;plan</code> 可以接受 <code>:skip-all</code></li>
<li><code>&amp;run</code>/<code>&amp;shell</code> 可以接受 <code>:merge</code></li>
<li><code>&amp;note</code> 可以在没有参数的情况下调用</li>
<li><code>open</code> 接受 <code>:$out-buffer</code></li>
<li><code>IO::Path.resolve</code> 可以接受 <code>:completely</code></li>
<li><code>IO::Path.parent</code> 可以接受一个 <code>Int</code> 表示父级</li>
<li><code>Proc::Async.new</code> 吞噬位置参数</li>
<li><code>Signature.ACCEPTS</code> 接受非 <code>Signature</code>/<code>Capture</code> 参数</li>
<li><code>&amp;EVAL</code> 可以接受一个 <code>Blob</code></li>
<li><code>Promise.keep</code>/<code>.break</code> 可以在没有参数的情况下调用</li>
<li>原生数组上的 <code>.sum</code> 可以接受 <code>:wrap</code></li>
<li><code>is required</code> 现在可以接受一个表示理由的参数</li>
<li><code>IO::Socket::Async.listen</code> 可以绑定到端口 <code>0</code> 以向操作系统申请免费端口</li>
<li><code>.encode</code> 可以接受 <code>:translate-nl</code></li>
</ul>
<h2 id="新的例程和运算符">新的例程和运算符</h2>
<ul>
<li>新的 <code>atomicint</code> Unicode 运算符和 ASCII 等价物, 保证线程安全, 原子操作:
<code>&amp;infix:&lt;⚛=&gt;</code>/<code>&amp;atomic-assign</code>、<code>&amp;prefix:&lt;⚛&gt;</code>/<code>&amp;atomic-fetch</code>、
<code>&amp;prefix:&lt;++⚛&gt;</code>/<code>&amp;atomic-inc-fetch</code>、<code>&amp;postfix:&lt;⚛++&gt;</code>/<code>&amp;atomic-fetch-inc</code>、
<code>&amp;prefix:&lt;--⚛&gt;</code>/<code>&amp;atomic-dec-fetch</code>、<code>&amp;postfix:&lt;⚛--&gt;</code>/<code>&amp;atomic-fetch-dec</code>、
<code>&amp;infix:&lt;⚛-=&gt;</code>/<code>&amp;infix:&lt;⚛−=&gt;</code>/<code>&amp;atomic-fetch-sub</code> 和 <code>&amp;infix:&lt;⚛+=&gt;</code>/<code>&amp;atomic-fetch-add</code></li>
<li><code>&amp;cas</code>: 原子比较与交换</li>
<li><code>≤</code>、<code>≥</code> 和 <code>≠</code> 运算符是 Unicode 运算符, 分别等价于 <code>&lt;=</code>、<code>&gt;=</code> 和 <code>!=</code></li>
<li><code>&amp;infix:&lt;unicmp&gt;</code>/<code>&amp;infix:&lt;coll&gt;</code>: <code>&amp;infix:&lt;cmp&gt;</code> 的替代行为</li>
<li><code>TR///</code>: <code>tr///</code> 的非变异版本</li>
<li><code>submethod TWEAK</code>: 与 <code>BUILD</code> 类似, 除了它与属性默认值兼容之外</li>
<li><code>&amp;duckmap</code>: 应用 <code>&amp;callable</code> 到每个元素上</li>
<li><code>&amp;deepmap</code>: 应用 <code>&amp;callable</code> 到每个元素上, 下降到 <code>Iterable</code> 中</li>
<li><code>&amp;take-rw</code>: 像 <code>&amp;take</code> 一样, 但有一个可写的容器</li>
<li><code>&amp;indir</code>: 在给定的 <code>$*CWD</code> 中执行代码</li>
<li><code>&amp;spurt</code>: 参见 <code>IO::Path.spurt</code></li>
<li><code>&amp;prompt</code>: 提示用户输入</li>
<li><code>uniprops</code>: <code>uniprop</code> 的多字符版本</li>
<li><code>symlink</code>: 建立文件符号链接</li>
<li><code>link</code>: 创建文件硬连接</li>
<li><code>.hyper</code>/<code>.race</code>: 并行处理值的列表</li>
<li><code>Seq.from-loop</code>: 从 <code>Callable</code> 生产一个 <code>Seq</code></li>
<li><code>Str.uniparse</code>: 将一个或多个 Unicode 字符名解析为实际字符</li>
<li><code>Str.parse-base</code>: <code>Int.base</code> 操作的反转</li>
<li><code>IO::Path</code> 提供了 <code>.ACCEPTS</code>、<code>.SPEC</code>、<code>.CWD</code>、<code>.Numeric</code>、<code>.add</code>、<code>.extension</code>、<code>.mode</code> 和各种文件测试、<code>.parts</code>、<code>.sibling</code> 和 <code>.spurt</code></li>
<li><code>IO::Handle</code> 提供了 <code>.READ</code>、<code>.WRITE</code>、<code>.EOF</code>、<code>.DESTROY</code>,
<code>.readchars</code>、<code>.flush</code>、<code>.lock</code>、<code>.unlock</code>、<code>.out-buffer</code>、<code>.tell</code>,
<code>.say</code>、<code>.slurp</code>、<code>.seek</code>、<code>.printf</code>、<code>.print-nl</code> 和 <code>.watch</code></li>
<li><code>IO::Pipe</code> 提供了 <code>.proc</code></li>
<li><code>Iterator</code> 提供了 <code>.skip-one</code>、<code>.skip-at-least</code> 和 <code>.skip-at-least-pull-one</code></li>
<li><code>Mu.emit</code>: <code>&amp;emit</code> 的方法形式</li>
<li>Test.pm6 模块中的 <code>&amp;fails-like</code>: 允许测试失败</li>
<li>Test.pm6 模块中的 <code>&amp;bail-out</code>: 退出失败的测试套件</li>
<li>Test.pm6 模块中的 <code>&amp;is-approx</code>: 测试一个数字近似于另一个</li>
<li><code>Buf</code> 拥有 <code>.allocate</code>、<code>.reallocate</code>、<code>.append</code>、<code>.push</code>、<code>.pop</code>、<code>.splice</code>、<code>.subbuf-rw</code>、<code>.prepend</code> 和 <code>.unshift</code> 方法</li>
<li><code>Range</code> 支持了 <code>.rand</code></li>
<li><code>Backtrace</code> 拥有方法 <code>.map</code>、<code>.flat</code>、<code>.concise</code> 和 <code>.summary</code></li>
<li><code>.classify-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>.categorize-list</code> 方法可用于 <code>Hash</code> 类型</li>
<li><code>Code.of</code>: 返回返回类型约束</li>
<li><code>Code.line</code>/<code>.file</code>: 返回定义的行/文件</li>
<li><code>Proc::Async</code> 提供了 <code>.Supply</code>、<code>.ready</code>、<code>.pid</code>、<code>.bind-stdin</code>、<code>.bind-stdout</code> 和 <code>.bind-stderr</code></li>
<li><code>Proc.command</code>/<code>Proc::Async.command</code>: 我们要执行的命令</li>
<li><code>Proc</code> 提供了 <code>.signal</code>、<code>.pid</code> 和 <del><code>.encoding</code></del></li>
<li><code>Complex</code> 提供了 <code>.cis</code>、<code>.reals</code>、<code>.ceiling</code>、<code>.floor</code>、<code>.round</code>、<code>.truncate</code> 和 <code>.abs</code> 方法, 并可以使用 <code>&lt;=&gt;</code> 进行比较(只要虚部可以忽略不计)</li>
<li><code>DateTime</code> 提供了 <code>.offset-in-hours</code>、<code>.hh-mm-ss</code> 和 <code>.Date</code></li>
<li><code>DateTime</code> 可以使用 <code>&lt;=&gt;</code> 运算符和其它 <code>DateTime</code> 对象进行比较</li>
<li><code>Date</code> 提供了 <code>.DateTime</code> 方法</li>
<li><code>&amp;infix:&lt;+&gt;</code>/<code>&amp;infix:&lt;-&gt;</code> 可以被 <code>Duration</code>、<code>DateTime</code> 和 <code>Real</code> 类型调用</li>
<li><code>Enumeration</code> 提供了 <code>.Int</code>、<code>.pred</code>、<code>.succ</code>、<code>.kv</code> 和 <code>.pair</code></li>
<li><code>.Date</code> 可以在 <code>Instant</code> 上调用</li>
<li>Junction 能使用 <code>Junction.new</code> 调用来创建</li>
<li><code>List</code> 类型拥有 <code>.to</code> 和 <code>.from</code> 方法</li>
<li><code>Map</code> type 提供了 <code>Int</code> 方法, 返回 pair 的数量</li>
<li><code>Any.skip</code>: 跳过列表中的值</li>
<li><code>Any.batch</code>: <code>.rotor</code> 的更基本的表兄弟</li>
<li><code>Mu.iterator</code>: 为一个列表中的值生成一个 <code>Iterator</code></li>
<li><code>IO::Spec::*</code> 类型提供了 <code>.tmpdir</code>、<code>.extension</code> 和 <code>.path</code></li>
<li><code>Pair</code> 提供了 <code>.ACCEPTS</code>、<code>.Pair</code> 和 <code>.invert</code></li>
<li><code>.Capture</code> 方法对所有核心类型都有明确定义</li>
<li>定义了 <code>.ACCEPTS</code> 在同素异形体上的语义</li>
<li><code>Failure.self</code> 使未处理的 <code>Failure</code> 爆发</li>
<li><code>Thread.is-initial-thread</code>: 我们是在初始线程中运行吗</li>
<li><code>Match</code> 提供了 <code>.Int</code> 和 <code>.actions</code></li>
<li><code>IO::Socket::Async</code> 提供了 <code>.socket-port</code> 和 <code>.peer-port</code></li>
<li><code>Promise</code> 提供了另一种构造函器 <code>.kept</code> 和 <code>.broken</code></li>
<li><code>WhateverCode</code> 提供了 <code>.assuming</code></li>
<li><code>WhateverCode</code> 和 <code>Block</code> 提供了 <code>.cando</code></li>
<li><code>.:&lt;…&gt;</code> 语法用于调用前缀运算符作为后缀</li>
<li><code>$*KERNEL</code> 提供了 <code>.hostname</code></li>
<li><code>Nil</code> 拥有定义的 <code>.FALLBACK</code> 特殊方法来返回 <code>Nil</code></li>
</ul>
<h2 id="新类型">新类型</h2>
<ul>
<li><code>atomicint</code>: 原生的 <code>int</code>, 大小可用于新的原子运算符</li>
<li><code>Lock::Async</code>: 互斥的非阻塞机制</li>
<li><code>Encoding::Registry</code>: 管理可用的编码</li>
<li><code>Encoding::Encoder</code>: 编码器, 用于特定的编码</li>
<li><code>Encoding::Decoder</code>: 解码器, 用于特定的编码</li>
<li><code>IO::CatHandle</code>: 将多个只读的 <code>IO::Handle</code> 视同一个</li>
<li>原生的 <code>str</code> 数组</li>
<li><code>Supplier::Preserving</code>: 缓存的实时 <code>Supply</code> 工厂</li>
<li><code>Semaphore</code>: 控制多线程对共享资源的访问</li>
<li><code>IO::Special</code>: 特殊I/O设备的路径 (例如 <code>STDOUT</code>)</li>
<li><code>Exceptions::JSON</code> 自定义异常处理程序的实现(可与<code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量一起使用)</li>
<li><code>SeekType</code> 枚举: <code>IO::Handle.seek</code> 中使用的值</li>
</ul>
<h2 id="新的变量">新的变量</h2>
<ul>
<li>
<p><code>$*USAGE</code>: 可在 <code>MAIN</code> 子例程中使用, 包含自动生成的 <code>USAGE</code> 信息</p>
</li>
<li>
<p>%*SUB-MAIN-OPTS: 设置 <code>sub MAIN</code> 的行为</p>
<ul>
<li><code>%*SUB-MAIN-OPTS&lt;named-anywhere&gt;</code> 允许将命名参数放在命令行的任何位置</li>
</ul>
</li>
<li>
<p><code>$*COLLATION</code>: 配置四个 Unicode 校对级别</p>
</li>
<li>
<p><code>$*INIT-INSTANT</code>: 代表程序启动时间的 <code>Instant</code></p>
</li>
<li>
<p><code>$*HOME</code>: 用户的主目录, 如果存在的话</p>
</li>
<li>
<p><code>&amp;*chdir</code>: <code>Callable</code> 包含 <code>IO::Path.chdir</code> 的变体, 也设置进程的当前目录</p>
</li>
<li>
<p><code>PERL6_TEST_DIE_ON_FAIL</code> 环境变量: 在第一次失败时停止测试套件</p>
</li>
<li>
<p><code>PERL6_EXCEPTIONS_HANDLER</code> 环境变量: 指定自定义异常处理类</p>
</li>
</ul>
<h2 id="对边缘情况强转行为的澄清">对边缘情况/强转行为的澄清</h2>
<ul>
<li><code>UInt</code> 与 <code>Int</code> 类型对象智能匹配为 <code>True</code></li>
<li><code>sink</code> 语句前缀爆炸 <code>Failure</code></li>
<li>定义了1项和0项列表以及负参数和非整数参数的 <code>permutations</code>/<code>combinations</code> 的行为</li>
<li><code>&amp;val</code>、<code>Str.Numeric</code> 和其他 <code>Str</code> 数字转换方法在试图转换 Unicode <code>No</code> 字符组或合成数字时会 <code>fail</code></li>
<li><code>:42foo</code> 冒号对快捷方式中不能使用合成数字</li>
<li>现在、<code>Enumeration</code> 可以作为一个数组形状指定器使用</li>
<li>含有空格的 <code>Str</code> 的数值转换现在返回 <code>0</code></li>
<li>带空的模式参数的 <code>samark</code>, 简单地返回调用者</li>
<li><code>.polymod</code> 可用于 <code>lazy</code> 但有限的除数列表</li>
<li>定义了 <code>.[*-0]</code> 索引</li>
<li><code>.rotor</code> 中大于子列表的负数空隙抛出异常</li>
<li><code>.rotor</code> 的非 <code>Int</code> 参数被强转为 <code>Int</code> 参数</li>
<li>读取 <code>/proc</code> 文件时定义了 <code>.lines</code></li>
<li>定义了字符串上后缀/前缀  <code>++</code>/<code>--</code> 中泰语数字的行为</li>
<li>sunk <code>for</code> 里面的 <code>map</code> 被视为 sunk</li>
<li>Sunk <code>for</code> 循环将上一条语句的方法调用值下沉</li>
<li><code>Bool</code> 对象上的 <code>.Int</code> 返回一个 <code>Int</code> 对象</li>
<li><code>splice</code> 可用于扩展数组</li>
<li><code>classify</code> 可以与 <code>Junction</code> 配合使用</li>
<li><code>.pairup</code> on a type object returns an empty <code>Seq</code></li>
<li><code>.pairup</code> 总是返回一个 <code>Seq</code></li>
<li>拒绝接受  <code>Date</code>/<code>DateTime</code> 构造函数中的合成代码点</li>
<li><code>⸨</code>/<code>⸩</code> 对儿现在可以作为引号结构中的匹配字符使用</li>
<li><code>Array</code> 类型对象上的 <code>.flat</code> 简单地返回该类型对象</li>
<li>混合级 <code>classify</code> 在 <code>Hash</code> 上抛出异常</li>
<li><code>Junction</code> 可以用于给 <code>Hash</code> 指定多个键</li>
<li>给 <code>.classify-list</code> 的 <code>Callable</code> 现在保证每项只执行一次</li>
<li><code>:delete</code> 对 <code>Hash</code> 类型对象进行关联查找时返回 <code>Nil</code></li>
<li>Test.pm6 中的 <code>&amp;is-deeply</code> 会自动 <code>.cache</code> 作为参数的 <code>Seq</code>, 并使用返回的 <code>List</code> 进行测试</li>
<li><code>Complex.new()</code> 给出 <code>&lt;0+0i&gt;</code></li>
<li><code>Int.new</code> 现在可以保证构建一个新的 <code>Int</code> (而不是, 比如说, 从常量缓存中重用一个)</li>
<li>定义了一个参数(1-arg)版本的 <code>&amp;infix:&lt;=:=&gt;</code> 和 <code>&amp;infix:&lt;eqv&gt;</code></li>
<li>如果直接或间接地调用 <code>.BIND-POS</code>、<code>.BIND-KEY</code>、<code>.ASSIGN-POS</code>、<code>.ASSIGN-KEY</code>、<code>.STORE</code>、<code>.push</code>、<code>.append</code>、<code>.unshift</code>、<code>.prepend</code>、<code>Nil</code> 类型现在抛出异常</li>
<li><code>Nil.ord</code> 返回一个空的 <code>Seq</code></li>
<li><code>Nil.chrs</code> 返回一个 <code>&quot;\0&quot;</code></li>
<li><code>Num.new</code> 强转参数为 <code>Num</code></li>
<li><code>infix:&lt;Z&gt;()</code> 返回一个空的 <code>Seq</code></li>
<li><code>.comb</code> 总是返回一个 <code>Seq</code></li>
<li>用 <code>&amp;infix:&lt;+&gt;</code> 化简一个项, 简单地返回该项</li>
<li><code>()[0]</code> 返回 <code>Nil</code></li>
<li>允许在(可能是无限的) <code>Seq</code> 上使用 Regex 智能匹配</li>
<li>定义了 <code>Range</code> 对象的智能匹配</li>
<li><code>Set</code> 转换为<code>Mix</code>/<code>Bag</code> 不再有 <code>Bool</code> 权重</li>
<li>当一个或多个操作数为 <code>0</code> 时、<code>gcd</code> 是有定义的</li>
<li><code>defined</code> 例程中的 <code>Junction</code> 自动线程化</li>
<li><code>sum</code> 可以处理含有 <code>Junction</code> 的列表</li>
<li><code>Grammar.parse</code> 让顶级 <code>regex</code> 回溯</li>
<li><code>U+2212 MINUS SIGN [Sm] (-)</code> 现在得到更多结构的支持, 如 <code>Str.Numeric</code> 和 <code>&amp;val</code></li>
<li>Arity-1 <code>&amp;infix:&lt;~&gt;</code> 与 <code>Blob</code> 可以一起工作</li>
<li>在签名中, 所有的 <code>Numeric</code> 字面值都支持作为值字面值</li>
<li>正则表达式中的 <code>\b</code> 和 <code>\B</code> 抛出 <code>X::Obsolete</code></li>
<li><code>True</code> 和 <code>False</code> 作为签名中的值字面量发出警告</li>
<li><code>.sort</code> 和 <code>IO::Spec::Unix.path</code> 的返回值总是 <code>Seq</code></li>
<li><code>Range</code> 对象上的 Out-of-range <code>.AT-POS</code> 返回 <code>Nil</code></li>
<li>对于不存在的键、<code>Pair.AT-KEY</code> 返回 <code>Nil</code></li>
<li>所有的 <code>Cool</code> 类型都提供了 <code>.Rat</code>/<code>.FatRat</code> 强转器</li>
<li><code>IO::Path</code> 文件测试不缓存先前测试执行的结果</li>
<li><code>Seq</code> eqv <code>List</code> 仅根据类型不匹配就定为 <code>False</code></li>
<li><del><input disabled="" type="checkbox">在 <code>Hash </code>、<code>Hash </code> 和 <code>QuantHash</code> 上, 来自 <code>.kv</code>、<code>.values</code> 和 <code>.pair</code> 序列的值是可写的</del> 参见 <a href="https://github.com/Raku/roast/issues/614">Raku/roast#614</a> 和 <a href="https://github.com/Raku/doc/issues/3519">#3519</a></li>
<li><code>&amp;infix:&lt;∘&gt;</code>/<code>&amp;infix:&lt;o&gt;</code> 保留 LHF 的 <code>.of</code> 和 RHS 的 <code>.arity</code> 和 <code>.count</code></li>
<li>完善了 regex 运算符副词中的可接受参数(例如:<code>:in(…)</code>)</li>
<li>完善了 <code>IO::Handle.open</code> 中可接受的参数组合</li>
<li><code>IO::Path.Str</code> 不包含 <code>.CWD</code> 属性的值</li>
<li><code>IO::Path</code> 类型拒绝带有  <code>nul</code> 字节 (<code>&quot;\0&quot;</code>) 的路径</li>
<li><code>IO::Pipe</code> 的 <code>.path</code>/<code>.IO</code> 返回一个 <code>IO::Path</code> 类型对象</li>
<li>如果目的路径和源路径是一样的 <code>IO::Path</code> 的 <code>.copy</code>/<code>.move</code> 会 <code>fail</code></li>
<li><code>dir</code> 创建的 <code>IO::Path</code> 绝对性由调用者控制</li>
<li>更多定义的边缘行为、<code>Callable </code> 处理、<code>. defined</code> 调用, 以及 <code>&amp;infix:&lt;andthen&gt;</code>、<code>&amp;infix:&lt;orelse&gt;</code> 和 <code>&amp;infix:&lt;notandthen&gt;</code> 操作符的链接</li>
<li><code>Seq</code> 的禅切不缓存它们</li>
<li><code>List.Capture</code> 将任何包含的 <code>Pair</code> 对象的键字符串化</li>
<li>带处理的 <code>Failure</code> 参数的 <code>&amp;fail</code> 把它标记为是未处理的</li>
<li><code>use lib</code> 接受 <code>IO::Path</code> 对象</li>
<li>锚点 <code>^</code>、<code>^^</code>、<code>$</code> 和 <code>$$</code> 在环视中有效</li>
<li><code>Grammar.made</code> 支持类型对象</li>
<li><code>.isa</code> 支持 <code>subset </code> 类型对象</li>
<li><code>:delete</code> 可用于惰性数组</li>
<li><code>&amp;infix:&lt;eqv&gt;</code> 可以在某些情况下对惰性参数起作用</li>
<li>动态查询(<code>::(...)</code>) 是限制性的 regex 语法, 并且需要 <code>use MONKEY-SEE-NO-EVAL</code> 的许可</li>
<li>定义了带孔数组的 <code>.Slip</code> 和 <code>.List</code></li>
<li><code>Promise.in</code>/<code>.at</code> 和 <code>Supply.interval</code> 可以用零值和负值工作</li>
<li><code>Supply.interval</code> 最小值为 <code>0.001</code>；较低值被处理为 <code>0.001</code>, 并发出警告#, 参见 <a href="https://github.com/Raku/doc/pull/2649">https://docs.perl6.org/type/Supply#method_interval PR [#2649]</a></li>
<li><code>Supply</code> 提供了 <code>.Seq</code>、<code>.list</code> 和 <code>.zip</code></li>
<li>可以在构建方法中绑定到原生类型属性</li>
<li><code>WhateverCode</code> 传播 <code>use fatal</code></li>
<li><code>say</code>、<code>note</code>、<code>put</code>、<code>print</code> 和 <code>printf</code> 例程自动线程化 <code>Junction</code></li>
<li><code>IO::Handle.eof</code> 值在 <code>.seek</code> 过终点后再返回时也会相应改变</li>
<li>定义了 <code>.succ'、</code>.pred<code>和</code>.Bool` 的同质异形体</li>
<li>在核心 <code>Numeric</code> 上定义了 <code>.Bridge</code></li>
<li><del><input disabled="" type="checkbox">在核心 <code>Numeric</code> 的类型对象上定义了 <code>.Numeric</code>/<code>.Real</code></del></li>
<li>定义了关于零分母有理数的 <code>Rational.Bool</code></li>
<li><code>say</code>/<code>note</code> 保证在 <code>Str</code> 的子类上调用 <code>.gist</code></li>
<li>定义了 <code>Junction.Str</code> 返回 <code>Junction</code></li>
<li>定义了 <code>Junction.gist</code>/<code>.perl</code> 返回一个 <code>Str</code></li>
<li><code>Map</code>/<code>Hash</code> 的 <code>.list</code>/<code>.cache</code> 返回一个 <code>List</code></li>
<li>定义了 <code>.round</code> 的返回类型</li>
<li>定义了 <code>Enumeration:D</code>  不  <code>.ACCEPT</code> 一个 <code>Enumeration:U</code> , 参见 <a href="https://github.com/rakudo/rakudo/issues/2073">rakudo/rakudo#2073</a></li>
</ul>
<h2 id="杂项">杂项</h2>
<ul>
<li><code>IO::ArgFiles</code> 类型只是 <code>IO::CatHandle</code> 的一个空的子类</li>
<li>对常量的约束
<ul>
<li>约束是完全强制的</li>
<li>试图在常量上使用参数化类型约束(例如使用 <code>my Foo constant @int</code>) 会引发 <code>X::ParametricConstant</code> 异常</li>
</ul>
</li>
<li><code>Pod</code> <code>=defn</code>(定义列表)指令可用</li>
<li><code>Pod</code> 提供了 <code>:numbered</code> 配置键</li>
<li><code>.^ver</code>、<code>.^auth</code> 和 <code>.^name</code> 元方法在 <code>module</code> 中可用, 而在 <code>package</code> 中则没有, 这是设计上的原因</li>
<li><code>qww&lt;…&gt;</code> 中支持花哨的引号(<code>’…’</code>、<code>“…”</code>、<code>｢…｣</code> 和变体)</li>
<li><code>&amp;infix:&lt; &gt;</code> 支持查找自动生成的 <code>Callables</code> (例如: <code>&amp;infix:&lt;XX&gt;</code>)</li>
<li>使用命名的 <code>anon</code> 子例程不再产生重声明警告</li>
<li><code>::?MODULE</code>/<code>$?MODULE</code> 变量的扩展规范</li>
<li><code>sub MAIN</code> 可以接受一个参数上的 <code>Enumeration</code> 类型约束和 <code>where</code> 子句</li>
<li>笑脸型约束可以用在子集上</li>
<li><code>start</code> 块和 thunks 得到新的 <code>$/</code> 和 <code>$!</code></li>
<li>定义了与列表关联运算符一起使用的 <code>R</code> 元运算符</li>
<li>类型强转可以用在签名返回类型约束中</li>
<li><code>&amp;infix:&lt;x&gt;</code>/<code>&amp;infix:&lt;x&gt;</code> 抛出了 <code>-Inf</code>/<code>NaN</code> 重复参数</li>
<li>字面结构 <code>put</code> 和 <code>put for</code> 抛出, 需要使用括号</li>
<li>扩大了 Unicode 例程和功能的规范覆盖面-将覆盖面升级到 Unicode 第11版</li>
<li><code>$.</code> 方法调用语法能用在元方法中了</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/raku" term="raku" label="raku" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/6.d" term="6.d" label="6.d" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[ImageMagick - Drawing]]></title>
            <link href="https://ohmyweekly.github.io/notes/imagemagick-drawing/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/imagemagick-notes/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick 笔记" />
                <link href="https://ohmyweekly.github.io/notes/imagemagick-transform/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick - Transform" />
            
                <id>https://ohmyweekly.github.io/notes/imagemagick-drawing/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-05T00:00:00+08:00</published>
            <updated>2020-07-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>ImageMagick Drawing</blockquote><p><a href="https://imagemagick.org/Usage/draw/">https://imagemagick.org/Usage/draw/</a></p>
<p>在 IM 中绘图是在现有图像中添加新元素的方法。虽然在<a href="https://imagemagick.org/Usage/fonts/">复合字体效果</a>的示例页和<a href="https://imagemagick.org/Usage/annotating/">图像注释</a>中涵盖了很多文本绘制的内容，但本页涉及 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 操作符的其他更普遍的方面。</p>
<p>绘制命令最初是作为一种创建简单图像的手段。但随着时间的推移，它已经扩展成为矢量图形到光栅图像转换的界面。</p>
<h2 id="imagemagick-绘制命令">ImageMagick 绘制命令</h2>
<p>计算机中的图像通常以两种不同的方式保存。第一种也是你在这些示例页面中看到的最常见的方式被称为光栅图形。在这种方式中，图像是以像素的矩形阵列来存储的。</p>
<p>另一种方式不太常见，也不太容易修改，但从另一个意义上讲，它的通用性更强，即对象矢量图形。在这种形式下，图像是用线条、弧线、颜色填充，有时还有深度来描述的。这是非常有用的，因为你可以将这些图像放大到你想要的任何尺寸，而且它们仍然可以完美地显示。与光栅格式的图像相比，您还可以在很小的空间内描述非常大和复杂的图像。</p>
<p>矢量图形图像的例子包括 postscript 和新的 <a href="http://www.w3.org/TR/SVG/">SVG-可缩放矢量图形</a>。</p>
<p>True-Type 字体也是矢量图形的例子，因为它允许在任何比例下使用单个字符描述。</p>
<p>&ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 图像操作符，是进入 ImageMagick 矢量绘图功能的一个窗口，并形成了一套与 IM 的普通命令行图像操作符相当独立的命令。</p>
<blockquote>
<p>一般使用的矢量图形文件格式只有几种，因为每一种这样的格式通常与其他这样的格式有很大的不同。其结果是，很少有代码共享的可能。
基于这个原因，ImageMagick 更关注使用矢量图形来绘制 SVG 格式的图像。Postscript 和 true-type 字体图形被传递给其他外部的&rdquo;<a href="https://imagemagick.org/Usage/files/#delegate">代理</a>&ldquo;库和应用程序，它们更适合绘制这些类型的矢量图形格式。
这并不是说 SVG 没有代理库。一个例子是 RSVG 库或 GTK SVG 库，这些库在编译时是可用的。IM 会链接到这些库来转换 SVG，而不是自己尝试去做。</p>
</blockquote>
<h3 id="原始绘图命令">原始绘图命令</h3>
<p>让我们从 MVG 命令的 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 图像操作符中最古老、最简单、最常见的绘图原语开始。</p>
<p>请注意，所有的参数都被视为浮点数，不一定是整数，比如我在这些例子中通常使用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Single Pixel Draw  (两种方式 -- 这些像素点都被放大了)</span>

  <span class="c1"># Point &#39;paints&#39; the color pixel</span>
  convert -size 10x6 xc:skyblue  -fill black <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;point 3,2&#39;</span>         -scale 100x60   draw_point.gif

  <span class="c1"># Color Point &#39;replaces&#39; the color pixel</span>
  convert -size 10x6 xc:skyblue  -fill black <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 6,3 point&#39;</span>   -scale 100x60   draw_color_point.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_point.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_color_point.gif" alt="img"></p>
<p>根据给出的注释，当涉及半透明颜色时，这两种点方法会产生不同的结果。详情请参见下面的<a href="https://imagemagick.org/Usage/draw/#color">颜色填充原语</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># 矩形  /  圆角矩形  /  矩形圆弧</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;rectangle 20,10 80,50&#34;</span>       draw_rect.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;roundrectangle 20,10 80,50 20,15&#34;</span>  draw_rrect.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;arc  20,10 80,50  0,360&#34;</span>     draw_arc.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;arc  20,10 80,50 45,270&#34;</span>     draw_arc_partial.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_rect.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_rrect.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_arc.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_arc_partial.gif" alt="img"></p>
<p><code>arc</code> 绘制原语与矩形一起列出，因为它实际上只是一个&quot;椭圆&rdquo;，装在两个坐标定义的&quot;矩形&rdquo;(<code>rectangle</code>)内。部分弧线很少使用，因为很难确定端点，除非角度限制在九十度的倍数。</p>
<p><code>circle</code> 和 <code>ellipse</code> 原语涉及&quot;中心&quot;坐标与&quot;边缘&quot;坐标，或&quot;大小&quot;和&quot;角度&quot;值。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># 圆  /  椭圆    (以某一点为中心)</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;circle 50,30 40,10&#34;</span>          draw_circle.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;ellipse 50,30 40,20 0,360&#34;</span>   draw_ellipse.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;ellipse 50,30 40,20 45,270&#34;</span>   draw_ellipse_partial.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_ellipse.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/draw_ellipse_partial.gif" alt="img"></p>
<p>你也可以看看 <a href="https://imagemagick.org/Usage/draw/#push_context">Push/Pop 上下文</a>，了解如何创建一个旋转的椭圆的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># 直线 / 折线 / 多边形 / 贝塞尔曲线</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;line   20,50 90,10&#34;</span>                 draw_line.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;polyline 40,10 20,50 90,10 70,40&#34;</span>   draw_polyline.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;polygon  40,10 20,50 90,10 70,40&#34;</span>   draw_polygon.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;bezier   40,10 20,50 90,10 70,40&#34;</span>   draw_bezier.gif
</code></pre></div><p>比较好的画直线和曲线的方法是使用 <a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径画法</a>，它的用途更广，甚至可以实现&quot;比例画线&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># text drawing  / image</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -font Candice -pointsize <span class="m">40</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;text 0,0 &#39;Hello&#39;&#34;</span>   draw_text.gif

  convert -size 100x60 xc:skyblue -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;image over 0,0 0,0 &#39;terminal.gif&#39;&#34;</span>   draw_image.gif
</code></pre></div><p>最后这两个填充类型的操作是目前唯一受 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?gravity">-gravity</a>&rdquo; 影响的绘制操作。这些操作的其他修饰符，包括 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fill">-fill</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?origin">-origin</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?stroke">-stroke</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?strokewidth">-strokeidth</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?font">-font</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?pointsize">-pointsize</a>&quot;、&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?box">-box</a>&quot;。他们还有其他的修饰符，但这些修饰符与更高级的 <a href="https://imagemagick.org/Usage/draw/#mvg">Magick Vector Graphics</a> 语言有关。</p>
<h2 id="贝赛尔原语">贝赛尔原语</h2>
<p>&ldquo;bezier&rdquo; 原语用于绘制曲线。每条命令只画一条曲线段。通常会给出 4 个点（8 个数字）：一个起点'结&rsquo;、两个控制点和一个终点'结&rsquo;。两个控制点定义了曲线的方向以及曲线偏离附加的终点'结'点的速度。</p>
<p>为了顺利地将两条曲线连接起来，应该将端点的控制点通过'结'镜像，形成下一条贝塞尔曲线的控制点。例如这里我画了两条平稳连接在一起的贝赛尔曲线。请注意控制线和点（也是画出来的）是如何通过连接坐标直线镜像的，无论是角度还是长度。这一点很重要，否则曲线将不平滑。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10 50,50   50,50 75,90   70,10 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2</span><span class="s2">&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 30,90   25,10 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 75,90   70,10 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_joined.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_joined.gif" alt="img"></p>
<p>如果我移动其中一个控制点，使它不从同一&quot;结&quot;的另一个控制点通过附加的&quot;结&quot;进行&quot;反射&rdquo;，那么曲线将不连续。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10 50,50   50,50 80,50   70,10 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2</span><span class="s2">&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 30,90   25,10 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 80,50   70,10 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_disjoint.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_disjoint.gif" alt="img"></p>
<p>如果再次移动控制点，使其与相关的&quot;结&quot;点相匹配，线条将直接从该点出发，完全没有任何&quot;曲线&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10 50,50   50,50 50,50   70,10 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2</span><span class="s2">&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 30,90   25,10 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 50,50   70,10 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_no_curve.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_no_curve.gif" alt="img"></p>
<p>如果两个控制点都设置为各自的&quot;结点&rdquo;，那么就会生成一条直线。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 10,10   50,50 50,50   50,50 50,50   90,40 90,40&#34;</span>
  <span class="nv">clines</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$points</span><span class="s2">&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/   /\n/g&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>             <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">line </span><span class="nv">$line</span><span class="s2">&#34;</span><span class="p">;</span> <span class="k">done</span><span class="sb">`</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> path <span class="s2">&#34;&#39;&#34;</span><span class="p">;</span> <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2</span><span class="s2">&#34;</span>
           <span class="k">done</span><span class="p">;</span>  <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span><span class="sb">`</span>

  convert -size 100x100 xc:skyblue -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke gray </span><span class="nv">$clines</span><span class="s2">    stroke blue </span><span class="nv">$symbols</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 10,10 10,10   50,50 50,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke red  bezier 50,50 50,50   90,40 90,40 &#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_lines.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_lines.gif" alt="img"></p>
<p>如果不指定所有 4 个点，&lsquo;bezier&rsquo; 原语并不真正有用。只有第一个点和最后一个点被归类为'结&rsquo;，曲线将通过（或结束）这两个点。所有其他的点纯粹被视为控制点，按照给定的顺序对曲线产生影响，控制点越远，对该段曲线的影响越大。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;10,10 30,90   25,10    75,90   70,10 90,40&#34;</span>
  <span class="nv">symbols</span><span class="o">=</span><span class="sb">`</span><span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">M </span><span class="nv">$point</span><span class="s2">   l -2,-2 +4,+4 -2,-2   l -2,+2 +4,-4 -2,+2</span><span class="s2">&#34;</span>
           <span class="k">done</span><span class="sb">`</span>

  convert -size 100x100  xc:skyblue  -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke gray  polyline </span><span class="nv">$points</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke red   bezier </span><span class="nv">$points</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke blue  path &#39;</span><span class="nv">$symbols</span><span class="s2">&#39; </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          draw_bezier_multi.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_bezier_multi.gif" alt="img"></p>
<p>为了保持简单，不建议你每条 &lsquo;bezier&rsquo; 曲线段使用超过或少于4个点。</p>
<p>其实我建议你完全不要使用 &lsquo;bezier&rsquo; 原语，而是使用 <a href="https://imagemagick.org/Usage/draw/#cubic">SVG Path Cubic Bezier</a> 来生成曲线。它有一个特殊的 &ldquo;s&rdquo; 曲线延续功能，可以自动做相应的控制点&quot;反射&rdquo;，生成平滑连接的曲线段，减少你需要使用的控制点数量。您还可以定义相对于路径中最后一个端点的点。</p>
<h2 id="颜色填充原语">颜色填充原语</h2>
<p>除了上述 &ldquo;简单&quot;原语之外，&quot;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&ldquo;还提供了一组颜色填充或修改原语。这些原语根据所选方法，从指定的点开始修改图像中的颜色。</p>
<p>这些填充方法实际上不是真正的 &lsquo;draw&rsquo; 命令，而是颜色替换函数。它们被添加到绘图中，因为在程序的早期版本中，将它们的操作插入到 ImageMagick 中是最简单的。</p>
<p>就像上面一样，使用的颜色是用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fill">-fill</a>&ldquo;颜色设置的，但如果设置了，就会使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 图像来代替。</p>
<p>上面的其他设置选项没有使用，对这些操作没有影响。</p>
<p>两个额外的设置也将应用于这些原语，即 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?bordercolor">-bordercolor</a>&rdquo; 和 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fuzz">-fuzz</a>&ldquo;系数设置。但是，这些设置不能在 &ldquo;MVG&rdquo; 语言中定义，因此只能在使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?draw">-draw</a>&rdquo; 操作符之前进行设置。</p>
<p>第一个 &lsquo;color point&rsquo; 你已经看到了，它是上述例子中 &lsquo;point&rsquo; 绘制原语的替代。如果你仔细观察，你会看到我们在测试图像中设置的单个白色像素。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 point&#39;</span>      color_point.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_point.png" alt="img"></p>
<p>然而在绘制透明色和半透明色时，这些功能是不一样的。</p>
<p>这里我们有一个三个像素的红色图像（放大了），第二个或中间的像素我们用 <code>point</code> 函数在红色像素上画上半透明的蓝色，得到紫色的结果。然而如果使用 <code>color point</code> 函数（最后一个或右边的像素），红色完全被半透明的蓝色像素所取代。它不会被叠加。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 3x1 xc:red -matte -fill <span class="s1">&#39;#00F8&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;point 1,0&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 2,0 point&#39;</span>   -scale 33x33  draw_points.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_points.png" alt="img"></p>
<p>所有的 <code>color</code> 函数都会进行全色替换，而其他所有的颜色原语都会在图像上面'画'出颜色。因此，你可以使用 <code>color</code> 来绘制透明色。</p>
<p><code>color replace</code> 绘制函数将在指定的位置替换所有精确给定颜色的实例。而且正如您所看到的，这些区域不一定要连接在一起。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 replace&#39;</span>      color_replace.png

  convert color_test.png   -fill white   -fuzz 13%<span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 replace&#39;</span>      color_replace_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_replace.png" alt="img"></p>
<p>然而，正如你在第一个结果中所看到的，一些沿边缘的像素没有被替换。这些像素与所选像素的颜色不完全相同，所以它们被忽略了。添加一个小的<a href="https://imagemagick.org/Usage/color_basics/#fuzz">模糊因子</a>也会包含与原色相似的颜色。如上面第二个例子所示。</p>
<p>当然，<code>fuzz factor</code> 并不是一个很好的解决方案，因为它不会捕捉所有这样的边缘像素。这是所有这些 <code>color fill</code> 方法经常出现的问题，也是一个没有通用解决方案的问题。</p>
<p>如果你想替换一个特定的已知颜色，而不是从图像本身选择一种颜色，那么可以使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?opaque">-opaque</a>&rdquo; 图像操作符来代替。该函数还使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fuzz">-fuzz</a>&rdquo; 因子设置来增加与给定颜色相匹配的颜色范围。</p>
<p><code>floodfill</code> 的方法也很简单，因为它只会填充所选点周围的整个区域，而不会选择任何其他没有以某种方式连接的类似颜色的区域。</p>
<p>你也可以通过使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?fuzz">-fuzz</a>&rdquo; 来扩大被填充的区域，以包括相似的颜色。在这种情况下，我们选择了一个足够高的值，也包括了交叉边界，允许洪水填充&quot;泄漏&quot;到图像的另一侧。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 floodfill&#39;</span>      color_floodfill.png

  convert color_test.png   -fill white   -fuzz 15%   <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 floodfill&#39;</span>      color_floodfill_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_floodfill.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/color_floodfill_fuzz.png" alt="img"></p>
<p>用颜色填充区域并非没有问题。颜色可能会越过薄薄的边界，渗入到不想要的区域，(<a href="https://imagemagick.org/Usage/formats/#bg_pattern">请看背景图案上的 GIF</a>，以证明这一点)。或者，它可能无法填满所选区域的边缘，（见<a href="https://imagemagick.org/Usage/antialiasing/#floodfill">反锯齿和泛滥填充问题</a>）。但它确实有效。</p>
<p><code>filltoborder</code> 就像 <code>floodfill</code> 一样，只是你指定了一个颜色，这个颜色的边界是要填充的区域，而不是填充过程中要替换的颜色。</p>
<p>当然也建议在该边框颜色选择中加入 <code>similar colors</code> 的<a href="https://imagemagick.org/Usage/color_basics/#fuzz">模糊因子</a>，以进一步限制洪水填充。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white  -bordercolor royalblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 filltoborder&#39;</span>   color_filltoborder.png

  convert color_test.png   -fill white  -bordercolor blue <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 filltoborder&#39;</span>   color_filltoborder2.png

  convert color_test.png   -fill white  -bordercolor blue  -fuzz 30% <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 filltoborder&#39;</span>   color_filltoborder_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_filltoborder.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/color_filltoborder2.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/color_filltoborder_fuzz.png" alt="img"></p>
<p>最后的绘制颜色方法是 <code>reset</code>，它只是将整个图像替换或重置为填充颜色。在这种情况下，实际选择的像素对结果没有任何影响。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;color 30,20 reset&#39;</span>      color_reset.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/color_reset.png" alt="img"></p>
<p>这实际上是非常有用的，因为它提供了一种简单的方法从现有图像生成纯色（或平铺图像）画布。(请参见 <a href="https://imagemagick.org/Usage/canvas/#sized">Canvases Sized to an Existing Image</a>)以了解此方法和其他做同样事情的方法。</p>
<p>未来：使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 图案来填充该区域。</p>
<h2 id="matt-填充原语">Matt 填充原语</h2>
<p><code>matte</code> 绘制原语的工作方式与上述 <code>color</code> 原语完全相同，只是它不会替换所选区域的颜色，只会替换所选区域的 <code>matte</code> 通道。（也就是只有 <code>alpha</code> 或 <code>matte</code> 通道被这些填充函数调整）。</p>
<p>就像 <code>color</code> 填充函数一样，<code>matte</code> 值使用的是填充色（除非用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 作为 <code>alpha value</code> 的来源）。</p>
<p>这里我们使用上面同样的 <code>color floodfill</code> 例子，但这里只调整 matte 通道，使填充部分完全透明。也就是说，原来的颜色仍然存在，只是透明而已!</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill none <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;matte 30,20 floodfill&#39;</span>      matte_floodfill.png

  convert color_test.png   -fill none   -fuzz 15%   <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;matte 30,20 floodfill&#39;</span>      matte_floodfill_fuzz.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/matte_floodfill.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/matte_floodfill_fuzz.png" alt="img"></p>
<p>也可以使用 <code>matte reset</code> 函数使整个图像变成半透明的。当然在这种情况下，我们必须输出到 PNG，它可以接受半透明颜色的图像。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert color_test.png   -fill <span class="s1">&#39;#00000080&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;matte 30,20 reset&#39;</span>      matte_reset.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/matte_reset.png" alt="img"></p>
<p>注意，在操作中没有使用 <code>black</code> 颜色分量，只使用了颜色的 <code>matte</code> 分量。图像的原色保持原样。</p>
<p>未来：使用 &ldquo;<a href="https://imagemagick.org/Usage/option_link.cgi?tile">-tile</a>&rdquo; 模式来制作有趣的哑光效果。</p>
<p><code>color</code> 和 <code>matte</code> 都是完全替换颜色的函数，它总是会产生一个布尔（all or nothing）类型的颜色替换。因此，这些区域的边缘总是会显示出 <a href="https://imagemagick.org/Usage/antialiasing/">Aliasing 效果</a>。</p>
<p>正因为如此，除了设置 GIF 图像的透明区域（也是布尔型）外，一般来说，这些都不是一般图像显影的好图像运算符。不过也不是全无用处，<a href="https://imagemagick.org/Usage/masking/#bg_remove">从背景去除</a>的例子中可以看出。</p>
<h2 id="关于绘图命令的具体内容">关于绘图命令的具体内容</h2>
<h3 id="像素坐标">像素坐标</h3>
<p><code>[-draw](https://imagemagick.org/Usage/option_link.cgi?draw)</code> 命令（以及IM中的许多其他命令）使用的是所谓的&quot;像素坐标&rdquo;。也就是 &ldquo;10,10&rdquo; 的坐标是左上角往下10个像素的中心。</p>
<p>在这个坐标系中，0,0 是左上角像素的中心，w-1,h-1 是右下角的中心。实际的边缘位于 -0.5,-0.5 和 w-0.5,h-0.5，中心像素（如果图像是奇数大小）位于 &lsquo;(w-1)/2,(h-1)/2&rsquo;。</p>
<p>然而，当您对图像进行数学处理时（如使用扭曲时），实际的像素没有实际意义，因此它使用&quot;图像坐标&rdquo;。在这个系统中，图像的实际边缘在 &lsquo;0,0&rsquo; 和 &lsquo;w,h&rsquo; 处。而图像的中心（可能是，也可能不是像素的中心）在 &lsquo;w/2,h/2&rsquo;。</p>
<p>要将 &lsquo;像素坐标&rsquo; 转换为图像坐标，请加上 ½ 如左上角像素的中心是 &lsquo;0.5,0.5&rsquo;，右下角像素的中心是 &lsquo;w-0.5,h-0.5&rsquo;。
<em>例如：小图像中的圆心</em></p>
<h3 id="绘制伽马和色域校正">绘制伽马和色域校正</h3>
<p>和几乎所有的 ImageMagick 操作一样， <code>[-draw](https://imagemagick.org/Usage/option_link.cgi?draw)</code> 是一个线性运算符，因此在线性 RGB 色彩空间中工作。这意味着，为了得到平滑的边缘，你可能需要对图像进行一些伽玛校正，然后再保存，这样就可以使用非线性（伽玛校正）的sRGB色彩空间来存储。</p>
<p>例如，如果你画了一个大圆，然后保存它&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 81x81 xc:black -fill white -draw <span class="s1">&#39;circle 40,40 40,3&#39;</span> <span class="se">\
</span><span class="se"></span>          circle_raw.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_raw.png" alt="img"></p>
<p>看看圆圈的边缘，其实看起来并不是真的很光滑。你可以看到明显的阶梯效果。</p>
<p>那是因为你是在线性 RGB 色彩空间中画的圆。但是你却把图像保存成了真正的 sRGB 色域！这就导致了你的图像在保存的过程中出现了明显的阶梯效果。</p>
<p>为了解决这个问题，我们需要在保存图像之前给图像添加一个伽玛校正。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 81x81 xc:black -fill white -draw <span class="s1">&#39;circle 40,40 40,3&#39;</span> <span class="se">\
</span><span class="se"></span>          -gamma 2.2 circle_gamma.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_gamma.png" alt="img"></p>
<p>现在，圆圈边缘实际上看起来光滑圆润，就像它们应该的那样。</p>
<p>如果你想正确地做这件事，我们真的应该使用色彩空间进行修正。然而，由于IM假设RGB是保存的默认色彩空间，你需要做一些棘手的处理来让它正确地做事情。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 81x81 xc:black -set colorspace RGB <span class="se">\
</span><span class="se"></span>          -fill white -draw <span class="s1">&#39;circle 40,40 40,3&#39;</span> <span class="se">\
</span><span class="se"></span>          -colorspace sRGB circle_sRGB.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_sRGB.png" alt="img"></p>
<blockquote>
<p>请注意，sRGB色彩空间（这是保存图像的正确方法）与简单地应用2.2伽玛校正并不完全相同。然而，两者之间的结果差异很小，只有在非常非常粗糙的图像中才能看到。
在IM v6.7.5-1之前，色彩空间名称 &ldquo;sRGB&rdquo; 和 &ldquo;RGB&rdquo;（线性-RGB）实际上是颠倒的。因此，在旧版本的IM中，上面的两个标签应该被调换。</p>
</blockquote>
<p>要使用真实的图像（在IMv6中）正确地绘制（或进行任何&quot;线性&quot;图像处理），你需要首先删除任何现有的伽玛，处理图像，然后恢复该伽玛校正。更多细节请参见<a href="https://imagemagick.org/Usage/resize/#resize_colorspace">使用色域校正调整大小</a>。</p>
<p>下面是一个在真实图像上绘图的例子&hellip;。首先是没有任何颜色校正（原始），然后是伽玛和色域校正。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert rose:  -fill none -stroke white -draw <span class="s1">&#39;line 5,40 65,5&#39;</span>  rose_raw.png

  convert rose: -gamma .454545 <span class="se">\
</span><span class="se"></span>          -fill none -stroke white -draw <span class="s1">&#39;line 5,40 65,5&#39;</span> <span class="se">\
</span><span class="se"></span>          -gamma 2.2 rose_gamma.png

  convert rose: -colorspace RGB <span class="se">\
</span><span class="se"></span>          -fill none -stroke white -draw <span class="s1">&#39;line 5,40 65,5&#39;</span> <span class="se">\
</span><span class="se"></span>          -colorspace sRGB rose_sRGB.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/rose_raw.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/rose_gamma.png" alt="img">
<img src="https://imagemagick.org/Usage/draw/rose_sRGB.png" alt="img"></p>
<p>正如你所看到的，通过使用伽玛或色彩空间校正，线条变得非常平滑，没有锯齿状的&quot;楼梯&quot;别离效果，比直接绘制时可以看到。(你需要一个很好的显示器才能看到它)</p>
<blockquote>
<p>上面的线条是用 <code>[-stroke](https://imagemagick.org/Usage/option_link.cgi?stroke)</code> 颜色绘制的。您可以使用 <code>[-fill](https://imagemagick.org/Usage/option_link.cgi?fill)</code> 来绘制线条，并得到同样的结果，但这样您就不能使用 <code>[-strokewidth](https://imagemagick.org/Usage/option_link.cgi?strokewidth)</code> 来控制线条粗细。更多信息请参见下面的&rdquo;<a href="https://imagemagick.org/Usage/draw/#stroke">描边颜色设置</a>&quot;。
色域名称实际上是使用&rsquo;sRGB'色彩空间的值来定义的，但通过绘制应用，就好像图像是在线性RGB色彩空间中一样。因此，对命名的颜色（不是&quot;白&quot;或&quot;黑&rdquo;）使用上述伽玛校正将导致这些颜色变得失真。在这种情况下，最好不要使用伽玛或色域校正，这样命名的颜色就会正确映射。
命名的&rsquo;sRGB'颜色与图像的色彩空间的正确映射，将作为IMv7开发的一部分被修正。</p>
</blockquote>
<h3 id="描边描边宽度和填充的相互作用">描边、描边宽度和填充的相互作用</h3>
<p><code>[-stroke](https://imagemagick.org/Usage/option_link.cgi?stroke)</code> 和 <code>[-strokewidth](https://imagemagick.org/Usage/option_link.cgi?strokewidth)</code> 选项用于在字体边缘绘制轮廓。</p>
<p>这些选项通常与 <code>[-fill](https://imagemagick.org/Usage/option_link.cgi?fill)</code> 一起使用，以使文字更有趣，而不费力。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 380x70 xc:lightblue -pointsize <span class="m">50</span> -font Chisel <span class="se">\
</span><span class="se"></span>            -fill green  -stroke black  -draw <span class="s1">&#39;text 10,55 &#34;Black Border&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>            stroke_font.jpg
</code></pre></div><p>默认设置是 <code>-strokewidth 1</code> 和 <code>-stroke None</code>。</p>
<p>但这样做会使轮廓笔画不可见，只留下 <code>[-fill](https://imagemagick.org/Usage/option_link.cgi?fill)</code> 的颜色，你不会看到它。</p>
<p>当 <code>-strokewidth</code> 为 &ldquo;不可见 &ldquo;时， <code>-strokewidth</code> 唯一的效果是对字体大小属性的影响，也就是说它仍然可以影响字体定位和 <a href="https://imagemagick.org/Usage/text/#label">Label 和 Caption</a> 图片生成的大小。否则，宽度在你使笔画可见之前是没有可见效果的。</p>
<p>为了了解 <code>[-strokewidth](https://imagemagick.org/Usage/option_link.cgi?strokewidth)</code> 对字体外观的实际影响（当使其可见时），我在这里绘制了一些不同宽度的文字，从 &ldquo;turned off&rdquo; 到越来越大。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 320x420 xc:lightblue -pointsize <span class="m">70</span> -font Vademecum <span class="se">\
</span><span class="se"></span>      -fill red -stroke none                 -draw <span class="s1">&#39;text 30,80  &#34;Stroke -&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">0</span> -draw <span class="s1">&#39;text 30,160 &#34;Stroke 0&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">1</span> -draw <span class="s1">&#39;text 30,240 &#34;Stroke 1&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">2</span> -draw <span class="s1">&#39;text 30,320 &#34;Stroke 2&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      -fill red -stroke black -strokewidth <span class="m">3</span> -draw <span class="s1">&#39;text 30,400 &#34;Stroke 3&#34;&#39;</span> <span class="se">\
</span><span class="se"></span>      stroke_table.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/stroke_table.jpg" alt="img"></p>
<p>请注意，从上面的例子中，设置 <code>-strokewidth</code> 为 &ldquo;0&rdquo; 与设置 <code>-stroke</code> 颜色为 &ldquo;none&rdquo;（默认值）是不同的。前者会画出一个非常非常细的笔触轮廓，而后者则会有效地关闭它。在这两种情况下，笔触仍然会被绘制。</p>
<p>然而你也应该注意到，即使 <code>-strokewidth</code> 为 &ldquo;0&rdquo;，图像的轮廓也会比普通的 <code>filled</code> 图像（使用 <code>-stroke</code> 颜色为 &ldquo;none&rdquo;）扩大非常小。</p>
<p>最后，使用任何小于 &ldquo;1.0&rdquo; 的宽度都不能正常工作。在这种情况下，你应该谨慎行事。</p>
<p>但是请记住， <code>-strokewidth</code> 也是一个浮点设置。也就是说，&ldquo;0.5&rdquo; 的笔画宽度也是有效的。然而，通常只有当您试图在关闭防锐化功能的情况下绘制薄的位图圆时，这才是重要的。</p>
<p>下面是一个使用超大笔触宽度的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">   convert -size 320x100 xc:lightblue -font Candice -pointsize <span class="m">72</span> -fill white <span class="se">\
</span><span class="se"></span>           -stroke black -strokewidth <span class="m">15</span> -draw <span class="s2">&#34;text 25,65 &#39;Anthony&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           stroke_thick.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/stroke_thick.jpg" alt="img"></p>
<p>请注意， <code>-strokewidth</code> 可以向内和向外扩展线条。下面是同样的例子，但是重新绘制了字体，没有笔画轮廓，去掉了很粗的笔画的内侧部分。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">   convert -size 320x100 xc:lightblue -font Candice -pointsize <span class="m">72</span> -fill white <span class="se">\
</span><span class="se"></span>           -stroke black -strokewidth <span class="m">15</span> -draw <span class="s2">&#34;text 25,65 &#39;Anthony&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           -stroke none                  -draw <span class="s2">&#34;text 25,65 &#39;Anthony&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>           stroke_outline.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/stroke_outline.jpg" alt="img"></p>
<p>更多使用描边的例子请看<a href="https://imagemagick.org/Usage/fonts/">复合字体效果</a>。请特别看一下&rdquo;<a href="https://imagemagick.org/Usage/fonts/#balloon">气球效果</a>&quot;。</p>
<h3 id="绘制描边线条">绘制（描边）线条</h3>
<p>IM中的默认画线有一些奇怪的行为，值得了解。下面就为大家介绍一下默认画线&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_default.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_default.jpg" alt="img"></p>
<p>你可以用 <a href="https://imagemagick.org/Usage/option_link.cgi?fill"><code>-fill</code></a> 选项设置线条的颜色。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line.jpg" alt="img"></p>
<p>此外，你还可以通过设置 <code>[-stroke](https://imagemagick.org/Usage/option_link.cgi?stroke)</code> 颜色，使线条稍微粗一些。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke.jpg" alt="img"></p>
<p>但是我们用 <code>-fill</code> 选项指定的白色是怎么回事呢？</p>
<p>这就是在 ImageMagick 中绘制线条的棘手之处。该程序所做的实际上是将线条视为一个约1像素宽的填充对象。这是自然的，因为通常情况下，多条线通常用于扫出一个要填充的区域。</p>
<p>所以，就像我们在上一节中使用字体的描边一样，IM 用填充色绘制线条（或对象），然后用描边色在其周围绘制。结果就是，现在上面的描边色线条稍微粗了一点，填充色完全隐藏在下面。如果你把描边色做成半透明的，就可以让这个填充色再次显现出来。</p>
<p>综上所述，线条会出现在 <code>-fill</code> 颜色下绘制，但一旦 <code>-stroke</code> 颜色被定义为默认的&quot;无&quot;或&quot;透明&quot;颜色以外的颜色，该选项就没有任何意义了。</p>
<blockquote>
<p>选项 <code>-linewidth</code> 实际上只是 <code>-strokewidth</code> 的别名，不应该被使用。</p>
</blockquote>
<p>例如，你可能会认为这个命令会产生很粗的线条。确实如此，但由于 <code>-stroke</code> 的颜色是不可见的，所以你看不到它。你只能看到线条的一个像素宽的区域的内部&quot;填充&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -strokewidth <span class="m">3</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_fill_3.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_fill_3.jpg" alt="img"></p>
<blockquote>
<p>以上的结果其实我认为是一个 BUG，什么都没画，因为没有'区域'填充，也没有设置线的'描边颜色&rsquo;。什么都没有画，因为没有&quot;区域 &ldquo;需要填充，也没有设置线的&quot;笔触颜色&rdquo;。IM 目前这样做的原因是为了避免新用户的混淆，但实际上这只会给高级用户带来问题。详见<a href="https://imagemagick.org/Usage/draw/#bounds">《绘制填充边界》</a>。</p>
</blockquote>
<p>但如果同时定义了描边颜色，就会得到要求的粗线&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -stroke black -strokewidth <span class="m">3</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_3.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_3.jpg" alt="img"></p>
<p>如果将 <code>-strokewidth</code> 设置为1，则上面的一行将被完全覆盖。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -stroke black -strokewidth <span class="m">1</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_1.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_1.jpg" alt="img"></p>
<p>当然当你掌握了这些知识后，你就可以利用这些知识进行创作，就像画字体一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -stroke black -strokewidth <span class="m">5</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          -stroke white -strokewidth <span class="m">2</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_multi.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_multi.jpg" alt="img"></p>
<p>在这里，我使用了最薄的 <code>-strokewidth</code> 设置为 &ldquo;0&rdquo;，就像我对上述字体所做的一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 5,35 95,5&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_0.jpg
</code></pre></div><p>这就产生了一个非常奇怪的结果，即由黑点和灰段组成的点线。这是笔触、填充和背景色之间奇怪的&quot;色拍频率&quot;的结果。</p>
<p>下面是线条的放大图&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_0_white.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_0_white.jpg" alt="img"></p>
<blockquote>
<p>颜色节拍频率 &ldquo;的效果与&quot;声音节拍&quot;的效果并无二致，当你有两把非常轻微的不调的吉他时，你会得到这样的效果。在这种情况下，你会得到一个黑点，其中笔触颜色完全覆盖了基本的填充颜色，你会得到一个灰色的点，其中笔触颜色与填充和背景颜色混合。
颜色混合是反锯齿过程的自然结果，IM使用反锯齿过程来尝试改善线条和其他绘制对象的外观。更多信息请参见<a href="https://imagemagick.org/Usage/antialiasing/"> IM 中的抗锯齿</a>讨论和示例页面。</p>
</blockquote>
<p>需要注意的是，这种效果只出现在倾斜的线条上，而不是纯水平或垂直的线条，因为在这些线条上，别名没有影响，因此也就没有&quot;色拍频率&quot;的效果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x40 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill white -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 5,20 95,20&#34;</span> <span class="se">\
</span><span class="se"></span>          line_stroke_horz.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_horz.jpg" alt="img"></p>
<p>在这里，我在放大的视图上使用了不同的底层填充颜色，所以你可以看到颜色如何改变结果的节拍。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill none -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%     line_stroke_0_none.jpg

  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill red -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_0_red.jpg

  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill black -stroke black -strokewidth <span class="m">0</span> -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_0_black.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_0_none.jpg" alt="img">
<img src="https://imagemagick.org/Usage/draw/line_stroke_0_red.jpg" alt="img">
<img src="https://imagemagick.org/Usage/draw/line_stroke_0_black.jpg" alt="img"></p>
<p>让我们把它和无 stroke 相比&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 25x10 xc:lightblue <span class="se">\
</span><span class="se"></span>          -fill black -stroke none -draw <span class="s2">&#34;line 2,8 22,1&#34;</span> <span class="se">\
</span><span class="se"></span>          -scale 400%    line_stroke_-_black.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/line_stroke_-_black.jpg" alt="img"></p>
<p>正如你所看到的，当绘制非常细的线条时，你可以通过使用相同的填充和描边颜色，或者将其中一种颜色设置为无来减少&quot;节拍&rdquo;。虽然后者是最好的主意，但前者可能对你的特定编程需求更实用。</p>
<p>注意，填充线的粗细是 &ldquo;0&rdquo;。但描边线可以有更大的厚度。它也是一个浮点值! 2.5像素宽的线条是完全有效的。</p>
<blockquote>
<p>这些结果不仅是由于笔画宽度为0的bug，导致颜色跳动，而且在没有实际需要填充的区域时，&ldquo;填充色&quot;被画出了额外的1.0直径厚度。这我也认为是一个bug。请看<a href="https://imagemagick.org/Usage/draw/#bounds">绘制填充边界</a>。</p>
</blockquote>
<h3 id="绘制填充边界">绘制填充边界</h3>
<p>关于各种绘制原语，还有一些其他要点需要您注意。</p>
<p>笔画宽度对于大于 1.0 的浮点值工作得很好，但对于小于 1.0 的值似乎会崩溃。这是由于使用的实现算法造成的，而不仅仅是因为它是错误的，因为它在较大厚度的线条上工作得很好。</p>
<p>基本上，如果你使用的笔画宽度为零，你可以期待没有笔画颜色会被添加。相反，你会得到一种节拍模式，当线条穿过像素的实际&quot;中心&quot;时，笔触颜色就会达到全部强度。</p>
<p>真正应该发生的是，添加到像素上的颜色数量应该反映出被绘制的线条的面积，而不是像素与该线条的距离。因此，零宽度的线条不应该给图像添加任何颜色，而厚度小于1.0的线条应该只添加较少的颜色。</p>
<p>请看上面的例子 <a href="https://imagemagick.org/Usage/draw/#strokewidth">Draw Lines, with StrokeWidth and Stroke</a>。</p>
<p>另一个问题是，填充颜色没有应用到正在绘制的形状（多边形）的边缘，而是应用到更远的半像素处。这包括没有应用&quot;描边&quot;的情况，而边缘应该是精确的。它也包括画一条&quot;线&rdquo;，它的填充厚度实际上是&quot;零&rdquo;。</p>
<p>基本上，如果你画了一条线，没有启用描边，从技术上讲，你应该看到，没有线，因为它没有&quot;填充&quot;厚度。相反，线条的绘制至少包括1个像素宽的&quot;填充&quot;颜色。这是出于历史原因，一般来说可以避免新用户对IM的混淆。不幸的是，这对高级用户来说是不正确的。</p>
<p>这意味着，如果您只使用填充色绘制两个多边形，并共享一个边缘，该边缘将重叠1个像素，因为每个多边形的所有边缘都比它大半像素。换句话说，多边形和其他形状并不适合在一起，而是重叠的。</p>
<p>例如，在这里我试着使用 <code>draw</code> 把一张图片分成两半（在白色上绘制黑色）。要做到这一点，我画了两个多边形，共享一个边缘，完全没有重叠。由此产生的&quot;微小&quot;图像，已被放大显示。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 10x10 xc: -draw <span class="s1">&#39;polygon 2,-1 7,10 10,10 10,-1&#39;</span> bound_left.gif
  convert -size 10x10 xc: -draw <span class="s1">&#39;polygon 2,-1 7,10 -1,10 -1,-1&#39;</span> bound_right.gif
  convert bound_left.gif bound_right.gif -compose Plus -composite bound_add.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/bound_left_mag.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/plus.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/bound_right_mag.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/bound_add_mag.gif" alt="img"></p>
<p>两个黑色的部分(这是实际绘制的)实际上是相互重叠的! 换句话说，尽管我们试图使用绘制的多边形分别绘制这两个区域，但填充的区域比要求的略大。</p>
<p>我还将两张图片加（<a href="https://imagemagick.org/Usage/compose/#plus">加合成</a>）在一起，这样你就可以实际看到绘制的黑色区域的重叠。如果两个多边形是完美契合的，那么 &ldquo;添加 &ldquo;的图画将是纯白色的。</p>
<p>实际的重叠量相当于默认的 <code>-strokewidth 1.0</code> 设置。因此，通常情况下，这个额外的区域会被一个正常的笔画宽度所覆盖。然而它可能会造成一些实际问题。</p>
<p>旁白: 对于一个完整的连接测试，你会在黑色背景上生成50%的灰色区域，然后把它们加在一起。这样你就可以看到这些区域是否不仅 &ldquo;重叠&rdquo;（如上图所示），而且还可以测试当你把这些区域加在一起时，它们是否 &ldquo;重叠不足&rdquo;（在填充的区域之间留下一个间隙）。所得到的图像应该是一个完美平滑的50%灰色，沿连接处没有颜色变化。透明度检查会涉及到，在一个完全透明的背景上应该使用50%透明，50%灰色的颜色。</p>
<p>要查看一个完美的剪切和重新添加的例子，基于一个单一的蒙版图像，请参阅组成方法的例子，<a href="https://imagemagick.org/Usage/compose/#dstout">组成 DstOut</a>。</p>
<p>未来BUG修复：填充的区域应该是精确的，但为了在绘制形状时进行补偿，默认的 &ldquo;描边颜色 &ldquo;应该设置为填充颜色（除非它本身被特别设置）。</p>
<h2 id="mvg---魔法矢量图形">MVG - 魔法矢量图形</h2>
<p>上面显示的原语构成了所有 <code>-draw</code> 操作的基础。它们共同构成了 ImageMagick 中特殊内部语言的起点，称为 Magick Vector Graphics 语言。关于这种语言的更多细节，请参见IM网站上的 <a href="http://www.imagemagick.org/script/magick-vector-graphics.php">MVG 原语和语法摘要</a>。</p>
<p>这种 &ldquo;MVG&rdquo; 语言的设计目标是让 ImageMagick 处理更复杂的 SVG（可缩放矢量图形）语言。它通过尝试将给定 SVG 格式的图像转换为更简单的内部 MVG 格式来实现。更多细节请看下面的 <a href="https://imagemagick.org/Usage/draw/#svg">SVG 处理</a>。</p>
<p>因此，你上面看到的只是 <code>-draw</code> 操作符的一小部分功能。如果你想绘制复杂的对象，我建议你使用SVG编辑器（如 &ldquo;Sodipodi&rdquo;）为对象创建一个单独的SVG格式图像。参见下面的非IM矢量图形程序）。</p>
<p>与 SVG 不同，MVG 没有任何形式的&quot;容器&quot;或图像命令集。在转换过程中，这些命令都被删除，以产生一个简化的 MVG 绘图命令序列。相反，它使用<a href="https://imagemagick.org/Usage/draw/#push_context">图形上下文</a>的概念来保存和恢复各种绘图设置，这就是我们现在要看的。</p>
<h3 id="命令行设置与-mvg-设置">命令行设置与 MVG 设置</h3>
<p>首先，您通过命令行选项设置的几乎所有设置，绘制原语使用的设置在 MVG 绘制命令中都有直接对应的内容。</p>
<p>通过命令行选项（如 <code>-strokewidth</code>）或使用 MVG 绘图字符串（如 <code>strok-width</code>）中的设置，两者之间的主要区别在于 MVG 设置只在 MVG 命令字符串的持续时间内有效。</p>
<p>一般绘图设置的总结:</p>
<pre><code>  __cmd_option__   __draw_MVG__        __Argument__
    -fill            fill                color/tile for inside shapes
    -tile            fill                image tile, replaces fill color

    -stroke          stroke              line color/tile around the shapes
    -strokewidth     stroke-width        pixel width
    +antialias       stroke-antialias    0/1 aliasing line edges

    -font            font                font_name / font_file
    -family          font-family            ?
    -weight            ?                    ?
    -stretch           ?                    ?
    -pointsize       font-size           height in points
    -kerning           -                 extra inter-character spacing

    +antialias       text-antialias      0/1 aliasing drawing text
    -box             text-undercolor     fill color for font bounding box
      -              decorate        (None, Underline, LineThrough or Overline)

    -gravity         gravity             (None, North, South-East,...)
    -fuzz              -                 color delta / percentage
    -bordercolor       -                 color
</code></pre><p>Notes:</p>
<pre><code>  - no such option      ? unknown
</code></pre><p>这些设置通常很好理解，因为它们经常使用，上面也有演示。</p>
<blockquote>
<p>字体、拉伸、样式和重量用于从 ImageMagick 字体列表中识别字体。然而，大多数人只是选择一个特定的字体和大小点来代替使用。因此，它们在IM中很少使用。
正如您所看到的，&ldquo;color fill&rdquo; 原语的特殊设置在 MVG 中并没有直接对应的设置。这就是 <code>-bordercolor</code> 和 <code>-fuzz</code> 因子设置。在使用 <code>-draw</code> 操作符之前，必须从命令行指定这些设置。</p>
</blockquote>
<p>有些 MVG 设置作为全局命令行设置可能更有用，比如字体绘制的 <code>decorate</code> 设置。</p>
<p>警告： <code>[-gravity](https://imagemagick.org/Usage/option_link.cgi?gravity)</code> 不是 SVG 规范的一部分。在 MVG 中，它只用于文本和图像的放置以及对齐。目前没有与默认的&quot;引力&quot;效果分开的调整设置。然而，由于调整是 SVG 文本处理的一部分，这可能会在未来的某个时候改变。</p>
<p>现在，全局命令行设置（在 MVG 绘制字符串之外）用于初始化你所应用的每个 <code>-draw</code> 操作的设置，这就是为什么你可以设置一个 <code>-fill</code> 颜色，然后你可以用它来绘制该颜色的圆。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue   -fill red <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;circle 50,30 40,10&#34;</span>          draw_circle_global.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_global.gif" alt="img"></p>
<p>你可以在 MVG 参数 <code>-draw</code> 中本地覆盖全局设置&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue   -fill red <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill green   circle 50,30 40,10&#34;</span>  draw_circle_override.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_override.gif" alt="img"></p>
<p>然而，在单个 <code>-draw</code> MVG 参数中设置的设置只在 <code>-draw</code> 操作期间存在。也就是说， <code>-draw</code> 中的设置只限于该次绘制，而不会带入以后单独的 <code>-draw</code> 参数中。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue   -fill red   -draw <span class="s1">&#39;fill green&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;circle 50,30 40,10&#34;</span>          draw_circle_local.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_local.gif" alt="img"></p>
<p>如果你打算进行大量的操作，那么在单个 MVG 字符串中进行这些操作可能会比多个 <code>-draw</code> 操作更好。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue  <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill green  circle 41,39 44,57
</span><span class="s2">                 fill blue   circle 59,39 56,57
</span><span class="s2">                 fill red    circle 50,21 50,3  &#34;</span>  draw_circle_multi.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/draw_circle_multi.gif" alt="img"></p>
<h3 id="mvg-特定设置">MVG 特定设置</h3>
<p>其他控制线条和对象绘制方式的 MVG 设置，即使在使用原语操作时也需要了解。这些设置包括&hellip;</p>
<pre><code>   __draw_MVG__       __Description/Argument__
  fill-opacity        fill transparency, from 0.0 to 1.0
  clip-rule           fill style for crossed lines (evenodd, nonzero)

  stroke-opacity      line transparency, number from 0.0 to 1.0
  stroke-dasharray    list of 'on' and 'off' lengths for lines
  stroke-dash
  stroke-linecap      End of line look: butt round square
  stroke-linejoin     Lines joins:  butt  miter round square
  stroke-miterlimit   Angle when 'miter' joins become 'bevel' (or 'butt')
</code></pre><p>记住，所有 MVG 设置和绘图操作符的完整列表可以在 IM 网站的 <a href="http://www.imagemagick.org/script/magick-vector-graphics.php">MVG 原语和语法摘要</a>中看到。</p>
<p>让我们看看一些简单设置的效果&hellip;&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Stroke Opacity</span>
  convert -size 100x60 xc:skyblue -fill none -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 10,10 L 90,10&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.8         path &#39;M 10,20 L 90,20&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.6         path &#39;M 10,30 L 90,30&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.4         path &#39;M 10,40 L 90,40&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-opacity 0.2         path &#39;M 10,50 L 90,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_stroke_opacity.gif

  <span class="c1"># Fill Opacity</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                    rectangle  5,10 15,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.8    rectangle 20,10 30,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.6    rectangle 35,10 45,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.4    rectangle 50,10 60,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity 0.2    rectangle 65,10 75,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-opacity  0     rectangle 80,10 90,50 &#34;</span> <span class="se">\
</span><span class="se"></span>          set_fill_opacity.gif

  <span class="c1"># Plain and Dashed Lines</span>
  convert -size 100x60 xc:skyblue -fill none -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 10,10 L 90,10&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 3       path &#39;M 10,20 L 90,20&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 5       path &#39;M 10,30 L 90,30&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 10 3 3 3  path &#39;M 10,40 L 90,40&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 1 6       path &#39;M 10,50 L 90,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_lines.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 10,10 L 90,10&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 3       path &#39;M 10,20 L 90,20&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 5 5       path &#39;M 10,30 L 90,30&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 10 3 3 3  path &#39;M 10,40 L 90,40&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-dasharray 1 6       path &#39;M 10,50 L 90,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_lines_fill.gif

  <span class="c1"># Note: Technically the second image should be the same as the first</span>
  <span class="c1"># as the &#39;filled&#39; lines contain no area.  This I regard as a BUG.</span>
  <span class="c1"># Stroke Ends and Joins</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black -strokewidth <span class="m">8</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                           path &#39;M 20,20 L 20,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linecap butt        path &#39;M 40,20 L 40,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linecap round       path &#39;M 60,20 L 60,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linecap square      path &#39;M 80,20 L 80,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_endcaps.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black -strokewidth <span class="m">5</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                        path &#39;M  5,70 L 20,20  35,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linejoin miter   path &#39;M 35,70 L 50,20  65,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linejoin bevel   path &#39;M 55,70 L 70,20  85,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-linejoin round   path &#39;M 75,70 L 90,20 105,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_linejoin.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black -strokewidth <span class="m">5</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;                        path &#39;M  5,70 L 20,20  35,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-miterlimit 7     path &#39;M 35,70 L 50,20  65,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;stroke-miterlimit 6     path &#39;M 65,70 L 80,20  95,70&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          set_miterlimit.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/set_stroke_opacity.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_fill_opacity.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_lines.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_lines_fill.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_endcaps.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_linejoin.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/set_miterlimit.gif" alt="img"></p>
<p><code>stroke-miterlimit</code> 的设置是相当难以演示的。这个属性定义了将 <code>miter</code> 连接变为 <code>bevel</code> 连接的角度。基本上对于非常尖锐的角度，一个斜面可以从两条线的实际接合处延伸很长的距离。这就为这个锐角设置了一个最大限度，当它变得太长时，就会使角点变钝。但请注意，它代表的是某种角度的三角值，而不是长度或距离。该值必须大于1.0。</p>
<p>上面显示了对于我所显示的连接角度，斜角会突然转换成一个介于6到7之间的斜角。</p>
<p>例如，1.414 的 <code>troke-miterlimit</code> 会将小于90度的任何角度的 &ldquo;miter&rdquo; 转换为 <code>bevel</code> 。4.0的 值（默认值）将小于约29度的角度转换为连接。而10.0的值可以将小于约11.5度的角度转换为斜面。</p>
<h3 id="svg-s路径绘制">SVG s路径绘制</h3>
<p>SVG 路径是 SVG 的基本绘图原语。它用于绘制线型、圆、曲线、弧线等。SVG 路径的完整规范可以在 <a href="http://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation">SVG 路径规范</a>文档中找到。</p>
<p>然而这并不是一个容易阅读的文档，因为它确实是为程序员而不是用户准备的，所以我将简化和总结路径规范&hellip;</p>
<ul>
<li>字母是命令，而所有的数字（浮点）都是参数</li>
<li>逗号或空格可以作为参数分隔符，否则完全忽略</li>
<li>每个路径组件的最后两个参数 <code>(x,y)</code> 将成为该路径组件的终点(或&quot;结&rdquo;)</li>
<li>大写字母是指最终点的绝对坐标</li>
<li>小写字母是相对于前一个组件的终点而言的</li>
<li>例如 &ldquo;M 1,2 L 3,4 L 2,4&rdquo; 和 &ldquo;M 1,2 L 4,6 L 6,2&rdquo; 是一样的。</li>
<li>即在1,2上加了3,4，画线到4,6。</li>
<li>然后在1,2上加2,4，画出一条线到最后的坐标6,2。</li>
<li>每个元素的参数可以重复，不需要重新发布相同的路径字母，可以多加数字参数组。不过对于曲线，为了方便阅读，我建议你还是加上函数字母。</li>
<li>重复的参数 &ldquo;M&rdquo; 或 &ldquo;m&rdquo; 分别作为 &ldquo;L&rdquo; 或 &ldquo;l&rdquo; 处理。</li>
<li>例如：&rdquo; M 1,2 3,4 5,6 &quot; 和 &quot; M 1,2 L 3,4 L 5,6 &quot; 是一样的。</li>
<li>而：&ldquo;m 1,2 3,4 2,4 &quot; 与 &quot; m 1,2 l 3,4 l 2,4 &quot; 相同。</li>
<li>对于立方贝塞尔，所有的点（控制点和结点）都是相对于前一个路径组件的端点而言的。</li>
</ul>
<p>请注意，您可以用绝对坐标或相对坐标来指定对象。因此，你可以用相对坐标来定义一个对象，只需提供一个初始的绝对&quot;移动&quot;坐标来定位整个路径。</p>
<p>另一方面，你也可以使用其他的&quot;图形内容&quot;命令来移动整个图形在&quot;视图框&quot;或&quot;转换&quot;中的位置（见下文）。因此，在 SVG 路径中使用绝对或相对坐标并不重要。
移动、线条和路径闭合是学习 SVG 对象路径的最初起点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Open, Completed and Closed Paths (same points)</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 L 20,50 90,10 70,40&#39;&#34;</span> path_open.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 L 20,50 90,10 70,40 40,10&#39;&#34;</span> path_complete.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 20,50 90,10 70,40 Z&#39;&#34;</span> path_closed.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_open.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_complete.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_closed.gif" alt="img"></p>
<p>但是请注意，&lsquo;z&rsquo; 只是关闭循环。它并没有创建一个单独的对象。因此，两个&quot;关闭&quot;的路径仍然被归类为一个单一的绘制对象，无论它们是重叠的还是完全断开的。</p>
<p>这里我们展示了两个闭合但重叠的循环，在同一方向上绘制。由于只使用了一条路径，所以对象是一个单一的对象，<code>fill-rule</code> 设置控制了重叠区域的填充方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Overlapping Paths and Fill Rule</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule evenodd \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 70,40 90,10 Z&#39; &#34;</span> path_evenodd.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule nonzero \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 70,40 90,10 Z&#39; &#34;</span> path_nonzero.gif

</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_evenodd.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_nonzero.gif" alt="img"></p>
<p>由于对象围绕中心以相同的角度方向绘制，两个闭合的循环将包含一个周期值为2的区域，因此 <code>evenodd</code> 规则使得该区域未被填充，而非零的 <code>nonzero</code> 规则则将其填充。但是请注意，所有的路径都是可见的，因为它们实际上是同一个对象。</p>
<p>绘制路径的方向是非常重要的，一般情况下，所有的路径相对于对象的'内部'应该绘制在完全相同的方向上。</p>
<p>例如这里我将第二个对象画成与第一个对象相反的方向。因此，当两个对象重叠时，该区域被圈出 &lsquo;0&rsquo; 次。也就是说，无论使用什么 <code>fill-rule</code>，它都将是未被填充的，形成一个'洞&rsquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Overlapping Closed Objects, Second object drawn in reverse</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule evenodd \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 90,10 70,40 Z&#39; &#34;</span> path_rvs_evenodd.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;fill-rule nonzero \
</span><span class="s2">                 path &#39;M 40,10 20,20 70,50 Z
</span><span class="s2">                       M 20,40 90,10 70,40 Z&#39; &#34;</span> path_rvs_nonzero.gif

</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_rvs_nonzero.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_rvs_evenodd.gif" alt="img"></p>
<p>这意味着你可以在物体上产生一个&quot;洞&rdquo;，通过反转方向，使物体的&quot;内部&quot;保持在行进方向的同一侧。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># An object with a reversed drawn hole!</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,10 20,55 70,50 80,5 Z
</span><span class="s2">                       M 50,20 60,40 40,30 Z&#39; &#34;</span> path_with_hole.gif

</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_with_hole.gif" alt="img"></p>
<p>无论 <code>fill-rule</code> 的设置如何，结果都是一样的，因为这个洞是'偶数'和'零&rsquo;，所以是未填充的。</p>
<p>当然，如果您使用一个完全独立的 <code>path</code> 元素，您将生成一个完全独立的对象。在这种情况下，<code>fill-rule</code> 不适用，而只是按照给定的顺序，将对象画在彼此的上方。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Separate paths are separate objects</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 40,10 20,20 70,50 Z&#39;
</span><span class="s2">                 path &#39;M 20,40 70,40 90,10 Z&#39; &#34;</span> path_separate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_separate.gif" alt="img"></p>
<p>未来：坐标对准路径 &ldquo;H&rdquo; 和 &ldquo;V&rdquo;。</p>
<p>椭圆弧是 SVG 路径的圆圈绘制功能&hellip;</p>
<p><code>large</code> 和 <code>sweep</code> 参数特别重要，因为它们用于决定从起点到终点的四种弧线中的哪一种。</p>
<p><code>large</code> 和 <code>sweep</code> 这两个标志定义了四条弧线中哪一条弧线将连接这两个点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1">#  Elliptical Arcs :   A  radius_x,y  angle   large,sweep  x,y</span>
  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 0,0 70,20&#39;&#34;</span>    path_arc.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 0,1 70,20&#39;&#34;</span>    path_arc2.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 1,0 70,20&#39;&#34;</span>    path_arc3.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,15 0 1,1 70,20&#39;&#34;</span>    path_arc4.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc2.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc3.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc4.gif" alt="img"></p>
<p>第二个标志 <code>sweep</code> 简单地决定了弧线路径的方向的哪一边应该被绘制。</p>
<p><code>large</code> 标志是用来选择较长的路径，绕着椭圆的中心走。这是设置的角度的弧线将大于180度。如果关闭，你会得到较小的'弧&rsquo;，不包含椭圆的中心，并且弧线的角度小于180度。</p>
<p>用 &ldquo;Z&rdquo; 来关闭弧线，只是画出最后的直线段。</p>
<p>要创建一个完整的椭圆或圆，你至少需要两个'弧线'段，从第一点到第二点，然后回到第一点。两条弧线都应该有相同的 <code>sweep</code> 设置，所以弧线将在不同的边上，有不同的移动方向。其中一条弧线应该有 <code>large</code> 的设置。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Closed and angled elliptical arcs  (defined by two edge points)</span>

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,20  20  0,0 70,20 Z &#39;&#34;</span> path_arc5.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,20  20  1,1 70,20 Z &#39;&#34;</span> path_arc6.gif

  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40  A 30,20  20  0,0 70,20 \
</span><span class="s2">                                A 30,20  20  1,0 30,40 Z &#39;&#34;</span> path_arc7.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc5.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc6.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/path_arc7.gif" alt="img"></p>
<p>请注意，如果直线太长，在给定的角度下无法适应给定的椭圆大小，椭圆的大小将被放大，以适应以椭圆为中心的直线，这意味着通过使用小数字作为轴半径，你可以只指定轴长的比例，并保证直线路径通过椭圆的中心点。</p>
<p>这意味着，通过使用小数字的轴半径，你可以只指定一个轴长的比例，并保证直线路径穿过椭圆的中心点。也就是说，路径从椭圆的一侧到另一侧形成一个椭圆直径。这并不是椭圆的主轴或次轴，只是一个椭圆的直径。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 3,2  45  0,0 70,20&#39;&#34;</span> path_arc_x.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc_x.gif" alt="img"></p>
<p>当然，使用长度为 &ldquo;1,1&rdquo; 的结果是一个完美的半圆，从一个点，到下一个点。在这种情况下，椭圆角不会有任何区别。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 1,1  0  0,0 70,20&#39;&#34;</span> path_hcircle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_hcircle.gif" alt="img"></p>
<p>对于以两点为中心的全圆，用&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 1,1  0  0,0 70,20
</span><span class="s2">                                 A 1,1  0  1,0 30,40  Z&#39;&#34;</span> path_circle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_circle.gif" alt="img"></p>
<p>SVG 对 &ldquo;弧线&quot;的定义也声明，如果两个半径中的任何一个是0，那么就应该画一条直线。因此，任何半径为 &ldquo;0,0&rdquo; 的圆弧，都只是一条简单的直线圆弧&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 0,0  0  0,0 70,20&#39;&#34;</span> path_arc_line.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_arc_line.gif" alt="img"></p>
<p>如果你为弧线指定了一个非常大的半径，而没有为回程路径指定 <code>large sweep</code>，你可以在两点之间创建该半径的透镜形状。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 30,40   A 50,50  0  0,0 70,20
</span><span class="s2">                                 A 50,50  0  0,0 30,40  Z&#39;&#34;</span> path_lens.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_lens.gif" alt="img"></p>
<p>这种类型的弧线是一个关键特征。它可以让你很容易地把原本是直线的东西变成一条小而明显的曲线。</p>
<p>例如，与其说是一个简单的三角形，不如说是一个&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  L 25,10  L 70,5 L 20,55 Z&#39; &#34;</span>   triangle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle.gif" alt="img"></p>
<p>你可以用一个大半径的弧线代替每条线，让它们只是有轻微的曲线。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  A 100,100 0 0,0 25,10
</span><span class="s2">                                A 100,100 0 0,0 70,5
</span><span class="s2">                                A 100,100 0 0,0 20,55 Z&#39; &#34;</span> triangle_curved.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle_curved.gif" alt="img"></p>
<p>线条的端点没有变化，所发生的只是每个 &ldquo;L&rdquo; 被一个弧线段代替。然而弧线的大小应该与线的长度成正比。由于我没有这样做，较长的对角线比其他两条线有更深的曲线。</p>
<p>请记住，当调整对象的大小或比例时，你也应该将半径的比例与线的长度相同，这样曲线的大小就会相应地调整，所以弧线的比例也会正确。</p>
<p>请注意，<code>sweep</code> 标志可以控制曲线是向外凸起还是向内凸起，这取决于每个路径段的绘制方向(见上文)。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  A 100,100 0 0,0 25,10
</span><span class="s2">                                A 100,100 0 0,1 70,5
</span><span class="s2">                                A 100,100 0 0,1 20,55 Z&#39; &#34;</span> triangle_bulge.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle_bulge.gif" alt="img"></p>
<p>看起来 &ldquo;静态&quot;的直边三角形，现在看起来有点像充满风的帆。</p>
<p>如果你真的想让线条完美的直，而不把它们转换回真正的线段，你可以通过使用弧线半径为零来关闭曲线。</p>
<p>因此，弧线不仅适合生成椭圆和圆，而且对于绘制直线和微曲线段也很有用。它是一种非常通用的通用点到点的绘制路径。</p>
<p>使用椭圆弧来生成分离的曲线段的一个简单的替代方法是使用<a href="https://imagemagick.org/Usage/draw/#quad">四元贝塞尔段</a>来代替，主要的区别是使用一个单一的控制点，而不是一个圆形半径来定义弧线。这也允许您将弧线偏向线段的一端，但代价是难以生成对称的弧线。</p>
<p>当然，您也可以通过使用这两种方法来进行 <code>mix-n-match</code>。</p>
<h3 id="饼图示例">饼图示例</h3>
<p>为了完成对弧线的使用，让我们举个例子，使用为它们生成圆楔。当然，你可能需要使用一些外部的三角数学（你的高中数学有多好？）来确定所需的最终路径点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 140x130 xc:white -stroke black <span class="se">\
</span><span class="se"></span>    -fill red   -draw <span class="s2">&#34;path &#39;M 60,70 L   60,20   A 50,50 0 0,1 68.7,20.8 Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill green -draw <span class="s2">&#34;path &#39;M 60,70 L 68.7,20.8 A 50,50 0 0,1 77.1,23.0 Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill blue  -draw <span class="s2">&#34;path &#39;M 68,65 L 85.1,18.0 A 50,50 0 0,1  118,65   Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill gold  -draw <span class="s2">&#34;path &#39;M 60,70 L  110,70   A 50,50 0 1,1   60,20   Z&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    -fill black -stroke none  -pointsize <span class="m">10</span> <span class="se">\
</span><span class="se"></span>    -draw <span class="s2">&#34;text 57,19 &#39;10&#39; text 70,20 &#39;10&#39; text 90,19 &#39;70&#39; text 113,78 &#39;270&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>    piechart.jpg
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/piechart.jpg" alt="img"></p>
<p>请注意，所有的弧线都是画在 <code>line path</code> 的左边，并有相应的标志（使用 <code>sweep</code> 标志）。但如果弧线覆盖的角度大于180度，则需要设置 <code>large</code> 标志。见上面例子中最后一个 <code>gold</code> 组件。</p>
<p>还要注意的是，你应该完整地画出每个部分，尽管这意味着你可能要画两次边界线。如果你不这样做，你很可能要么不会完全用颜色填充该部分，要么填充颜色会覆盖之前绘制的部分轮廓。</p>
<p>避免重复绘制多条线的唯一方法是绘制所有填充区域，然后重复这样绘制轮廓。就是说你需要把所有的东西都画两遍，确保东西正确匹配。因此，将轮廓加倍可能是最简单的解决方案。</p>
<p>立方贝塞尔曲线可以使用 <code>c</code> 函数定义两个控制点，以及最终的终点。对于使用最后一个控制点的镜像的持续立方贝塞尔曲线（对于连续曲线），你可以使用 <code>s</code> 函数。</p>
<p>下面是一个例子。由于这个函数的复杂性，我预先准备了一个画布，显示控制点的位置，以及最后一个控制点的 <code>assumed mirror</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Cubic Bezier:    C  control_1_x,y control_2_x,y  x,y</span>
  <span class="c1"># Smooth &#34; :       S  control_2_x,y  x,y</span>

  convert path_cubic_canvas.gif  -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 10,30  C 10,4 50,4 50,30  S 90,55 90,30&#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          path_cubic.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_cubic.gif" alt="img"></p>
<p>连接控制点和该路径段路径上的最终点的线（控制线）基本上定义了通过路径上该点的曲线方向。长的控制线会在该点产生一条更平滑的曲线，而短的控制线则会在该点产生一条更清晰的曲线。如果控制点与曲线的点相吻合（控制线长度为零），则曲线在该点有一个尖锐的不连续性，就像只用直线段一样。</p>
<p>作为一个更实际的例子，下面的代码是从 <a href="https://imagemagick.org/Usage/scripts/generate_logo">IM 实例 Logo 生成器脚本</a>中提取出来的，该脚本创建了 <a href="https://imagemagick.org/Usage/images/logo.gif">IM 实例 Logo</a> 的曲线溅射区域。</p>
<p>这个例子的棘手之处在于，我将我使用的立方贝塞尔路径字符串，转换为另一个路径，显示用于生成贝塞尔曲线的控制线。这让我可以看到曲线的控制线角度和长度，使得调整结果变得更加容易。只需要调整一组点就可以同时显示曲线和控制线，将错误控制在最小范围内。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">   <span class="nv">curve</span><span class="o">=</span><span class="s2">&#34;M 12,27  C 7,37  18,50 18,60  S  0,80 10,94
</span><span class="s2">          S 40,74 50,78  S 60,99 76,95  S 72,70 75,65
</span><span class="s2">          S 95,55 95,42  S 69,37 66,32  S 67,2  53,7
</span><span class="s2">          S 43,17 35,22  S 17,17 12,27  Z&#34;</span>
   <span class="nv">c_ctrls</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="nv">$curve</span> <span class="p">|</span> <span class="se">\
</span><span class="se"></span>              sed <span class="s1">&#39;1s/\([0-9]\)  *\([0-9]\)/\1 M \2/;
</span><span class="s1">                   s/S/M/g; s/C/ /;&#39;</span> -<span class="sb">`</span>
   convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>           -draw <span class="s2">&#34;</span><span class="s2">stroke None  fill Green  path &#39;</span><span class="nv">$curve</span><span class="s2">&#39;</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>           -draw <span class="s2">&#34;</span><span class="s2">stroke Red   fill None   path &#39;</span><span class="nv">$c_ctrls</span><span class="s2">&#39;</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>           curvy_splash.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/curvy_splash.gif" alt="img"></p>
<p>如果你仔细观察图像，你会发现曲线的起点和终点有两条方向相反的控制线。对于一个封闭的连续路径来说，开始和结束的控制线应该在相同的角度（只是在镜面方向），当然也应该是相同的长度。这一点很重要，因为很容易弄错。</p>
<p>沿着曲线的所有其他点只有一个控制点/线，它与曲线的绘制方向相反。该线段越长，曲线在该控制点处的 <code>sharp</code> 越低，长度为零则产生一个 <code>point</code>。</p>
<p><code>s</code> 函数在内部根据前一段的数据生成下一段的镜像控制点/线，从而产生曲线的平滑延续。</p>
<p>关于这个路径函数的更多例子，请看<a href="http://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands">《SVG：立方贝塞尔曲线命令》</a>。</p>
<p>手动生成贝塞尔曲线是比较直接的，不需要任何花哨的 GUI 工具。</p>
<ul>
<li>首先定义所有你想让曲线经过的坐标点，在列表的最后重复起始坐标。</li>
<li>现在将这个列表扩大，将所有的 <code>x,y</code> 坐标点加倍成对，并在每对坐标点前添加一个 <code>s</code>（Smooth Cubic）函数。每对中的第一个数字是控制点，连接到第二个数字代表曲线上的点。然而第一个点对却把这一点反过来了，第一个点是曲线的起点，第二个点代表第一个也是唯一一个反转的控制点。</li>
<li>将第一对坐标的函数字母由 &lsquo;S&rsquo; 改为 &lsquo;M&rsquo;，然后在这对坐标之间加一个 &lsquo;C&rsquo;。最后将第二对坐标的 &lsquo;S&rsquo; 去掉，完成初始的立方体（&lsquo;C&rsquo;）函数。</li>
<li>通过添加最后的 &lsquo;Z&rsquo; 来完成路径，关闭曲线。</li>
<li>请看上面的示例序列，它应该是怎样的。</li>
<li>此时您可以测试绘制您的路径。由于所有的控制线长度为零，所以路径将只由直线段组成。</li>
<li>现在您需要做的就是慢慢地、小心地调整控制线段的位置（每个 &ldquo;S&rdquo; 对的第一个坐标），以得到您想要的最终曲线。不要把控制线做得太长，或者方向不对，否则你会得到一条看起来非常滑稽的曲线。</li>
<li>为了帮助查看你的变化和发现错误，请使用上面的转换 &ldquo;sed&rdquo; 命令来绘制路径控制点和曲线控制点之间的控制线。但是请注意，零长度的控制线是不可见的，但是由于lin会产生一个尖锐的点，所以位置应该很明显。</li>
<li>最后，确保 &ldquo;C&rdquo; 之后的第一条控制点/线与终点控制点/线的位置完全相反。</li>
</ul>
<p>交互式曲线的生成也可以通过使用一些矢量图形编辑器来实现。</p>
<p>例如 Luis Guerra 报告说，&ldquo;Inkscape&rdquo; 生成的贝塞尔曲线可以使用 &ldquo;Edit -&gt; XML Editor&rdquo; 功能，然后选择你想要控制点的路径或形状。</p>
<blockquote>
<p>你知道有什么其他的方法可以用GUI工具来提取贝塞尔曲线（在曲线上每个点给出两个或一个控制点）。或者是一些其他的技术来生成这样的曲线？请发邮件给我! 我很乐意听到它。你将会像其他人一样，被记入该技术的名下。</p>
</blockquote>
<p>二次方贝塞尔函数是立方贝塞尔函数的简化，当两个控制点合并成一个控制点时。同样，你可以用 &lsquo;Q&rsquo; 函数开始曲线，然后用 &lsquo;T&rsquo; 函数继续曲线，镜像最后一个控制点。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1">#  Quadratic Bezier:  Q  control_x,y  x,y</span>
  <span class="c1">#  Smooth &#34; :         T  x,y</span>

  convert path_quad_canvas.gif  -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 10,30   Q 20,4 50,30   T 90,30&#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          path_quad.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/path_quad.gif" alt="img"></p>
<p>但我要提醒您，&ldquo;T&rdquo; 继续函数只适用于连接间距相等的点的路径。我不推荐使用它。</p>
<p>二次方曲线的优点是可以替代<a href="https://imagemagick.org/Usage/draw/#arcs">椭圆弧</a>，因为它使用的是实际的位置，而不是弧线的半径。它也可以使弧线偏向于一端而不是另一端，这在使用<a href="https://imagemagick.org/Usage/draw/#arcs">椭圆弧</a>时并不实用。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 20,55  Q 30,32 25,10
</span><span class="s2">                                Q 50,1 70,5
</span><span class="s2">                                Q 50,45 20,55 Z&#39; &#34;</span> triangle_bulge_2.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/triangle_bulge_2.gif" alt="img"></p>
<p>在这种情况下，弧线不是那么均匀，你得到的东西就像一个倒立的鲨鱼鳍，而不是一个帆。</p>
<p>请记住四边形弧线是抛物线，而椭圆弧线基本上是生成圆弧线段。这可能是决定你应该使用哪种类型的弧线段的关键。</p>
<p>有关此路径功能的更多例子，请参见：<a href="http://www.w3.org/TR/SVG/paths.html#PathDataQuadraticBezierCommands">SVG: Quadratic Bezier Curve Commands</a>。</p>
<h3 id="绘图表面的变形">绘图表面的变形</h3>
<p>在这些能力之上，绘制对象的绘图表面可以以各种方式变形，让你做一些令人惊奇的事情。</p>
<p>首先，你可以应用一些通用的绘图表面修改，比如&hellip; &ldquo;translate&rdquo;、&ldquo;rotate&rdquo;、&ldquo;scale&rdquo;、&ldquo;skewX&rdquo;、&ldquo;skewY&rdquo; 和 &ldquo;affine&rdquo;。</p>
<p>例如，给定一个线条的 <code>path</code>，我们可以 <code>translate</code> 绘图表面的原点或0,0点到另一个位置。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30
</span><span class="s2">                 image over 3,3 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  transform_translate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_translate.gif" alt="img"></p>
<p>请注意，&ldquo;0,0&rdquo; 或绘图区域的原点现在以图像为中心，尽管Y轴在图像的顶部仍然是负数，在底部仍然是正数。</p>
<p><code>rotate</code> 操作将旋转绘图表面，所以以后在该表面上绘制的任何东西都将被旋转绘制。当然，它会围绕转换后的原点进行旋转，所以最好同时使用这两个变换运算符。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30    rotate -30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  transform_rotate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_rotate.gif" alt="img"></p>
<p><code>scale</code> 将放大和缩小原点周围的绘图面。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30    scale 1.5,1.5
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  transform_scale.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_scale.gif" alt="img"></p>
<p>一个常见的 <code>scale</code> 用法是将Y轴翻转，使Y的正值向上。当然原点也应该移到中心，或者左下角，以保持秩序。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30    scale 1,-1
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>    transform_flip.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_flip.gif" alt="img"></p>
<p>最后，&ldquo;skewX&rdquo; 和 &ldquo;skewY&rdquo; 在X和Y方向上对图像进行剪切。例如，这里我们使用 &ldquo;skewX&rdquo; 给图像的垂直Y轴一个倾斜。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;translate 50,30   skewX 20
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>    transform_skewY.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/transform_skewY.gif" alt="img"></p>
<p>这些操作符在 MVG <code>-draw</code> 字符串之外有对应的操作符，供一般使用。但是这些命令行版本是运算符，并且立即应用于内存中已经存在的图像，而不是应用于尚未绘制的矢量对象的绘制表面。更多细节请看扭曲图像。</p>
<h3 id="绘制表面的平移变形">绘制表面的平移变形</h3>
<p>上述所有五种画布变换都可以组合成一个通用的 Affine Matrix Operator，可以使用 MVG 原语 &ldquo;affine&rdquo;，也可以在调用 <code>-draw</code> 之前使用 <code>-affine</code> 设置 Affine 变换。</p>
<p>Affine 变换使用一组 &ldquo;Matrix Coefficients&rdquo;，它定义了如何将你给出的坐标修改为实际的绘图坐标。</p>
<p>关于这些 &ldquo;coefficients&rdquo; 如何工作的更多细节，请参阅 <a href="https://imagemagick.org/Usage/distorts/affine/">Affine Matrix Transforms</a>。</p>
<p>例如&hellip; 要设置一个相对于对象绘制时的中心原点&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;affine 1,0,0,1,50,30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>  affine_null.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/affine_null.gif" alt="img"></p>
<p>翻转图像&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;affine 1,0,0,-1,50,30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span> affine_flip.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/affine_flip.gif" alt="img"></p>
<p>绕原点旋转30度&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;affine .866,-.5,.5,.866,50,30
</span><span class="s2">                 image over 4,4 0,0 &#39;terminal.gif&#39;
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 path &#39;M 0,20 -45,20 20,-25 -25,-25&#39;
</span><span class="s2">                 fill none  stroke red
</span><span class="s2">                 path &#39;M 0,10 0,-10  M 10,0 -10,0&#39; &#34;</span>    affine_rot.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/affine_rot.gif" alt="img"></p>
<p>对于更复杂的仿射变换，您可以使用为此目的创建的<a href="https://imagemagick.org/Usage/distorts/affine/#affine_scripts">仿射辅助脚本</a>。这些脚本将诸如旋转角度和中心点之类的东西转换为 Affine 坐标，你可以直接在 <code>-draw affine</code> 或 <code>-affine</code> 设置中使用。</p>
<h3 id="推弹上下文">推/弹上下文</h3>
<p>一些 MVG 原语实际上依赖于这些变换的使用才能正确使用。例如，<a href="https://imagemagick.org/Usage/draw/#primitive_circle">椭圆原语</a>只能用正交对齐的轴直接指定。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;ellipse 50,30 30,15 0,360&#34;</span>   ellipse_orthogonal.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/ellipse_orthogonal.gif" alt="img"></p>
<p>然而，通过使用<a href="https://imagemagick.org/Usage/draw/#transform">绘图变换</a>，我们可以很容易地给椭圆添加一个&quot;旋转角&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue -fill white -stroke black <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;push graphic-context
</span><span class="s2">                 translate 50,30   rotate 30
</span><span class="s2">                 fill white  stroke black
</span><span class="s2">                 ellipse 0,0 30,15 0,360
</span><span class="s2">                 pop graphic-context&#34;</span>       ellipse_rotated.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/ellipse_rotated.gif" alt="img"></p>
<p>请注意，椭圆的 <code>center</code>(旋转点)在应用旋转之前首先被转换。然后，<code>ellipse</code> 在 &ldquo;0,0&rdquo; 处的转换位置被绘制。</p>
<p>上面还显示了两个新的 MVG 绘图原语。&lsquo;push graphic-context&rsquo; 和 &lsquo;pop graphic-context&rsquo;。在上面的例子中，并不是严格意义上的需要，但在进行主要的绘图转换时，建议使用这两个原语。</p>
<p><code>push</code> 和 <code>pop</code> 原语的作用是保存当前的绘图状态或 &ldquo;graphic-context&rdquo;，然后再次恢复。在这两个原语之间更改的任何绘图设置都会被遗忘。这包括曲面变形（如 &ldquo;平移 &ldquo;和 &ldquo;旋转&rdquo;）、颜色设置 <code>fill</code> 和 <code>stroke</code> 或任何其他修改了绘图 <code>state</code> 的设置。</p>
<p>这些原语使您可以轻松地绘制具有许多变换的非常复杂的对象，然后将事物恢复到更 &ldquo;正常&quot;的状态，以便以后进行绘制操作。您可以在下面的<a href="https://imagemagick.org/Usage/draw/#arrows">绘制箭头</a>中看到更实用的演示。</p>
<h3 id="推弹特殊对象">推/弹特殊对象</h3>
<p><img src="https://imagemagick.org/Usage/img_www/const_barrier.gif" alt="img">  建设中 <img src="https://imagemagick.org/Usage/img_www/const_hole.gif" alt="img"></p>
<p>更多专门用于 MVG 处理 SVG 格式的设置。</p>
<pre><code>    font-family   font-stretch   font-style   font-weight
    encoding 'UTF-8'

    push defs

      push gradient 'def_name' linear X1,Y1 X2,Y2
        stop-color 'color' where
        stop-color 'color' where
          # where is a point between the two pixels given (0 = X1,Y1  1= X2,Y2)
        gradient-units 'objectBoundingBox|userSpaceOnUse'
        affine ....
      pop gradient

      push gradient 'def_name' radial CX,CY FX,FY R
        # Here CX,CY is the center of the radial gradient of radius R
        # the FX,FY is the focal, and is usually the same a CX,CY
        # unless you are trying to warp the gradient in a specific direction
        stop-color 'color' where
        ...
      pop gradient

    pop defs

    push graphic-context
      fill 'url(#def_name)'
      ... draw things here ...
    pop graphic-context
</code></pre><p>例子见 Florent Monnier 的开发网站&hellip;  <a href="http://www.linux-nantes.fr.eu.org/~fmonnier/OCaml/MVG/">http://www.linux-nantes.fr.eu.org/~fmonnier/OCaml/MVG/</a>。</p>
<h3 id="阅读-mvg-文件">阅读 MVG 文件</h3>
<p>正如你在上面的例子中所看到的，MVG 的 <code>-draw</code> 参数可以变得很长。事实上，SVG 到 MVG 的转换可以产生一些非常长的 MVG 绘图参数（见下文）。</p>
<p>然而，IM 的一般命令行界面允许您通过使用 <code>&quot;@filename&quot;</code> 参数从文件中读取任何字符串参数。这很方便，因为这意味着你可以从一个单独的文件中读取非常长和复杂的MVG绘图命令。</p>
<p>例如，如果我将 MVG 操作放入一个名为 &ldquo;draw_circles.mvg&rdquo; 的文件中，那么我就可以像这样绘制&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:skyblue  -draw @mvg_circles.mvg  mvg_draw.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/mvg_circles.mvg.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/mvg_draw.gif" alt="img"></p>
<p>不仅如此，ImageMagick 还懂得直接读取 &ldquo;MVG:&rdquo; 图像文件格式，让你可以更直接地绘制此类命令。然而，除非 MVG文 件定义了一个画布，否则你可能需要指定初始画布（ <code>-size</code> 和&rdquo;-background&rdquo;）来绘制。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60  -background limegreen  mvg_circles.mvg  mvg_file.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/mvg_circles.mvg.gif" alt="img"> <img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/mvg_file.gif" alt="img"></p>
<p>你可以通过在 MVG 文件中添加一个 &ldquo;viewbox&rdquo;，并添加适当的背景色填充绘制，将初始画布设置移动到 MVG 图像中。这样就完成了 MVG 图像文件作为一个完整的图像定义。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert    mvg_circles2.mvg    mvg_image.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/mvg_circles2.mvg.gif" alt="img"> <img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img"> <img src="https://imagemagick.org/Usage/draw/mvg_image.gif" alt="img"></p>
<blockquote>
<p>目前只有一种方法可以从 MVG 参数字符串中读取外部 MVG 文件，那就是使用 &ldquo;图像 &ldquo;绘图原语。遗憾的是，这将 MVG 的 include 转换为光栅图像，然后再将该图像覆盖到绘图表面。
换句话说，目前还没有MVG的 &ldquo;include&quot;功能。 :-(</p>
</blockquote>
<p><img src="https://imagemagick.org/Usage/img_www/const_barrier.gif" alt="img">  建设中 <img src="https://imagemagick.org/Usage/img_www/const_hole.gif" alt="img"></p>
<p>您可以生成IM的低级绘制操作，使用 `<a href="https://imagemagick.org/Usage/option_link.cgi?render">+render</a> 来记录它们。</p>
<p>当你再给 <code>-render</code> 设置/操作时，IM将立即绘制这些保存的操作。</p>
<p>奇怪的是，仅仅输出到 &ldquo;MVG&rdquo; 文件似乎也能做到这一点&hellip;&hellip;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">     convert  ...   -draw <span class="s1">&#39;....&#39;</span>  draw_commands.mvg
</code></pre></div><p>注意：如果你在输出 MVG 格式文件时画了一条曲线，文件中会列出以下内容。曲线是一系列的短线段，而不是原始曲线。</p>
<p>当然您也可以完全使用更通用的 SVG 格式。参见下面的 &ldquo;<a href="https://imagemagick.org/Usage/draw/#svg">SVG 格式处理</a>&quot;。</p>
<h3 id="mvg-阿尔法构成">MVG 阿尔法构成</h3>
<p><img src="https://imagemagick.org/Usage/img_www/const_barrier.gif" alt="img">  建设中 <img src="https://imagemagick.org/Usage/img_www/const_hole.gif" alt="img"></p>
<p>我没有看到任何使用 Alpha 构图的情况（除了 <code>painters</code> 的算法之外）。基本上是一种 &ldquo;over&rdquo; alpha 合成）来绘制对象。</p>
<p>然而，这并不是说不能这样做。</p>
<p>如果你喜欢将你的矩形、椭圆、圆形或其他物体用不同的阿尔法成分（如 &ldquo;DstOver&rdquo;，这是一个类似于 Under 的成分），然后在空白的透明画布上画出你的人物，同样的构图，并将其合成到您的图像上。</p>
<p>然而，由于 SVG 允许您使用 alpha 合成来绘制文本和其他的图像，因此，您可以使用 SVG 来绘制图像项目到图像上，我想这将是一个未来的补充。</p>
<p>敬请期待</p>
<h3 id="绘制符号">绘制符号</h3>
<p>有时你在图像上有一组点，你想在那里绘制参考符号，如十字、圆圈等。遗憾的是，目前IM还没有可以轻松绘制这类符号的命令，但只要稍加努力，你就可以绘制这类符号。</p>
<h4 id="符号绘制技巧">符号绘制技巧</h4>
<p>在给定的位置列表中绘制多个符号的诀窍是使用 shell 脚本或任何你正在使用的 API 生成 MVG 绘图命令，以便将给定的点集转化为适当的绘图命令集。
例如，我在这里将一条线上的点转换为每一个点的&quot;加号&rdquo;&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># convert each point into a draw command for a cross (using &#39;awk&#39;)</span>
  <span class="c1"># the &#39;tr&#39; converts spaces into &#39;newlines&#39; (one point per line).</span>
  <span class="nv">crosses</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="nv">$points</span> <span class="p">|</span> tr -s <span class="s1">&#39; &#39;</span> <span class="s1">&#39;\012&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>     awk -F, <span class="s1">&#39;{ print &#34;line &#34; $1-3 &#34;,&#34; $2 &#34; &#34; $1+3 &#34;,&#34; $2 ;
</span><span class="s1">                print &#34;line &#34; $1 &#34;,&#34; $2-3 &#34; &#34; $1 &#34;,&#34; $2+3 ; }&#39;</span> -<span class="sb">`</span>

  <span class="c1"># draw a red line between the points, and blue crosses on the points.</span>
  convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">fill none stroke red   polyline </span><span class="nv">$points</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">fill none stroke blue  </span><span class="nv">$crosses</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          points_plus.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_plus.gif" alt="img"></p>
<p>上面使用 &ldquo;tr&rdquo; 将每个点（两个数字）分成每条线上的一个点，然后使用 &ldquo;awk&rdquo; 进行所有数学计算，在给定的点上绘制&quot;加号&rdquo;。你可以使用任何你喜欢的东西，因为我只是在输入点列表上应用了一种文本宏扩展的形式。几乎所有的编程语言都可以做到这一点。对于上面的shell脚本案例，我只是发现 &ldquo;awk&rdquo; 是最简单、最快的手段。</p>
<p>其实你甚至可以使用 Imagemagick 本身的 &ldquo;convert&rdquo; 格式选项来进行这种 &ldquo;macro&rdquo; 的扩展&hellip;比如这里我用它来计算圆周上的一个点，对于这个&quot;点符号&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># circle radius (or symbol size) to draw around each point.</span>
  <span class="nv">radius</span><span class="o">=</span>3.5

  <span class="c1"># convert each point into a draw command for a cross</span>
  <span class="c1"># In this case, points are space separated by the shell</span>
  <span class="nv">circles</span><span class="o">=</span><span class="k">$(</span><span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
             <span class="nv">x</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$point</span><span class="s2">&#34;</span> <span class="p">|</span> cut -d, -f1<span class="k">)</span>
             <span class="nv">y</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$point</span><span class="s2">&#34;</span> <span class="p">|</span> cut -d, -f2<span class="k">)</span>
             <span class="c1"># use IM to do some floating point math, EG:  y2=$y+$radius</span>
             <span class="nv">y2</span><span class="o">=</span><span class="k">$(</span>convert xc: -format <span class="s1">&#39;%[fx:&#39;</span><span class="s2">&#34;</span><span class="nv">$y</span><span class="s2">&#34;</span><span class="s1">&#39;+&#39;</span><span class="s2">&#34;</span><span class="nv">$radius</span><span class="s2">&#34;</span><span class="s1">&#39;]&#39;</span> info:<span class="k">)</span>
             <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">circle </span><span class="nv">$x</span><span class="s2">,</span><span class="nv">$y</span><span class="s2"> </span><span class="nv">$x</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2">&#34;</span>
           <span class="k">done</span><span class="k">)</span>

  <span class="c1"># Draw a red line between the points, and blue circles on the points.</span>
  convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">fill none stroke red   polyline </span><span class="nv">$points</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">fill none stroke blue  </span><span class="nv">$circles</span><span class="s2"> </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          points_circle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_circle.gif" alt="img"></p>
<p>现在，您生成的绘制字符串可能会变得相当长，并且可能会开始导致您的最终命令的长度问题。所以，与其将点转换成长字符串，然后我们在命令行上传递给 IM，不如将绘制命令以文件的形式管道化给 IM。</p>
<p>我这次也使用了 <a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径</a>的绘制方法来代替 <a href="https://imagemagick.org/Usage/draw/#primitives">Draw Primitive</a> 的绘制方法。另外我生成的符号是每个点周围的三角形。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># convert each point into a draw commands to draw a triangle</span>
  <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
     <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">path &#39;M </span><span class="nv">$point</span><span class="s2">  m 0,-5 -4,+8 +8,0 -4,-8&#39;</span><span class="s2">&#34;</span>
  <span class="k">done</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>    convert -size 100x100 xc:white <span class="se">\
</span><span class="se"></span>          -fill none -stroke red  -draw <span class="s2">&#34;</span><span class="s2">path &#39;M </span><span class="nv">$points</span><span class="s2">&#39; </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -fill none -stroke blue -draw <span class="s1">&#39;@-&#39;</span> <span class="se">\
</span><span class="se"></span>          points_tri.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_tri.gif" alt="img"></p>
<p><a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径</a>实际上使这一点变得更容易，通过允许相对像素移动，允许你设计符号，所以它只需要一个单一的初始绝对移动&rsquo;M&rsquo;，然后再给出'移动'和'线'的序列来绘制符号。正因为如此，你实际上根本不需要任何浮点计算，因为IM draw会完成所需的定位数学。</p>
<blockquote>
<p>相对移动SVG路径项&rsquo;m'在IM v6.4.3-5之前被破坏了。如果你的IM比这更老，上面（和下一个）的例子可能什么也画不出来。您可以通过将上面的相对移动&rsquo;m'替换为适当的相对线序列&rsquo;l'来解决旧版本的问题。</p>
</blockquote>
<p>现在你可以更进一步，将一个完整的MVG文件，包括画布规格，直接作为一个绘画命令的流水线输入到IM中。这次让我们做一个'十字&rsquo;，这和上面第一个'加'的例子类似，需要大量的计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="c1"># Define a string of X and Y coordinates</span>
  <span class="c1"># comma between values, space between coordinates.</span>
  <span class="nv">points</span><span class="o">=</span><span class="s2">&#34;6.6,7.7  25.0,75.0 42.2,85.4 75.8,94.7 51.5,39.3  92.5,66.6&#34;</span>

  <span class="c1"># Generate a MVG file for IM to draw all components</span>
  <span class="o">(</span> <span class="nb">echo</span> <span class="s2">&#34;viewbox 0 0 100 100   fill white  rectangle 0,0 100 100&#34;</span>
    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">fill none stroke red   path &#39;M </span><span class="nv">$points</span><span class="s2">&#39;</span><span class="s2">&#34;</span>
    <span class="nb">echo</span> <span class="s2">&#34;fill none stroke blue  path &#39;&#34;</span>
    <span class="k">for</span> point in <span class="nv">$points</span><span class="p">;</span> <span class="k">do</span>
      <span class="nb">echo</span> <span class="s2">&#34;</span><span class="s2">  M </span><span class="nv">$point</span><span class="s2">  m -2,-2 +4,+4  m -4,0 +4,-4</span><span class="s2">&#34;</span>
    <span class="k">done</span>
    <span class="nb">echo</span> <span class="s2">&#34;&#39;&#34;</span>
  <span class="o">)</span> <span class="p">|</span> convert mvg:- points_cross.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_cross.gif" alt="img"></p>
<p>这使用了特殊的shell编程技术，在shell括号中 &ldquo;echo&rdquo; 的任何东西都将作为MVG文件被输入到最终的&quot;转换&quot;命令中。第一个 &ldquo;echo&rdquo; 定义并填充图像的绘图画布，而 &ldquo;while&rdquo; 循环则将每个 &ldquo;点&rdquo; 转换为一个给定半径的圆。</p>
<p>这种方法的优点是，你不会受到任何字符串的限制，而使用其他两种方法可能会受到限制。</p>
<p>其他你可以生成的符号包括方框、钻石、错误条等。</p>
<p>也请参见下面的&quot;绘制圆圈&rdquo;，了解其他圆圈方法，包括不计算相对 &ldquo;路径&quot;的圆圈绘制。</p>
<h4 id="绘制符号的替代方法">绘制符号的替代方法</h4>
<p>除了直接绘制符号外，还有其他的方法可以将符号添加到图像中。</p>
<h5 id="符号字体">符号字体</h5>
<p>您可以从 <a href="https://imagemagick.org/Usage/text/#symbol">Symbol Font</a> 中提取符号，并将其保存为一个小位图。你也可以使用小的预定义但色彩丰富的图像来做这件事。</p>
<p>然而这样做可能会出现问题，无法准确定位字体相对于特定像素的位置。也就是说这不是一个非常精确的技术。但是你可以在任何像素位置组成任何图像。例如这些符号是从一些字体中提取出来的，用于这些示例页面的具体使用。</p>
<pre><code>&lt;=   =&gt;   x   +   +   +   o   o   o   o
</code></pre><p>在<a href="https://imagemagick.org/Usage/layers/#composite">分层图像</a>一节中给出了将图像合成到大背景上的例子。然而，循环的方法可能更有用，例如在<a href="https://imagemagick.org/Usage/layers/#layer_prog">分层图像</a>的程序化定位中给出了。</p>
<p>未来：使用坐标对图像进行分层的例子</p>
<h4 id="形态学">形态学</h4>
<p>另一种选择是使用<a href="https://imagemagick.org/Usage/morphology/#intro">形态学</a>，使用特殊的&quot;形状&quot;内核，如 &ldquo;磁盘&rdquo;、&ldquo;环形 &ldquo;和 &ldquo;加&rdquo;，甚至是你自己的用户定义内核，来 &ldquo;稀释&quot;单个像素。</p>
<p>例如&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 80x80 xc:black -fill white <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;point 20,15 point 55,30 point 40,60&#39;</span>  points_pixels.gif

  convert points_pixels.gif -morphology Dilate Ring    points_rings.gif

  convert points_pixels.gif -morphology Dilate Plus:4  points_pluses.gif

  convert points_pixels.gif -morphology Dilate Cross:3 points_crosses.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_pixels.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/points_rings.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/points_pluses.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/points_crosses.gif" alt="img"></p>
<p>然后可以通过使用 <a href="https://imagemagick.org/Usage/masking/#alpha_shape">Alpha Shape Operator</a> 将结果直接转换为彩色叠加。</p>
<p>这样做的最大好处是，你其实不需要知道每个符号的单独位置。或者有多少个符号。但这也可能是一个缺点。一个主要的缺点是，位置只在整数位置。你不能使用浮点 &ldquo;子像素&quot;定位来&quot;绘制&rdquo;。</p>
<h4 id="卷积">卷积</h4>
<p>一个几乎相同的技术是使用 <a href="https://imagemagick.org/Usage/convolve/#convolve">Convolve</a>，使用专门设计的内核，它允许你设置不同的灰度，而不仅仅是一个简单的开/关结果，如上所述。</p>
<p>通过使用不同的<a href="https://imagemagick.org/Usage/morphology/#user">用户定义内核</a>，为图像的每一个通道（红、绿、蓝和阿尔法），甚至可以从每个像素坐标创建多色符号。</p>
<p>为此，我使用了一个我写的特殊脚本 <a href="https://imagemagick.org/Usage/scripts/image2kernel">image2kernel</a> 来将彩色图像（见右图）转换为每个通道的独立浮点卷积核。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  image2kernel -q marker.png marker.dat
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/marker.png" alt="img"></p>
<p>这将生成四个文件，比如 <a href="https://imagemagick.org/Usage/draw/marker_R.dat">marker_R.dat</a>，每个通道都有一个非常小的输入图像，这是<a href="https://imagemagick.org/Usage/morphology/#user">用户定义</a>的图像表示（原点在图像中心）。</p>
<p>现在使用这些内核数据文件，我们可以将这些单点在透明的背景上 <a href="https://imagemagick.org/Usage/convolve/#convolve">Convolve</a> 成我们彩色的标记图像。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert points_pixels.gif -alpha off <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_R.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_G.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_B.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -clone <span class="m">0</span> -morphology Convolve @marker_A.dat <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          -delete <span class="m">0</span> -channel RGBA -combine point_markers.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/points_pixels.gif" alt="img">
<img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/point_markers.png" alt="img"></p>
<blockquote>
<p>在IM v6.7.6-9之前，Combine Operator 要求图像的透明度通道以 &ldquo;哑光&quot;值而不是alpha值的形式给出，因此，由此产生的alpha通道需要被否定。EG:</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  ... <span class="s2">&#34;`cat marker_A.dat`&#34;</span> -negate <span class="se">\)</span> <span class="se">\
</span></code></pre></div><p>只能使用小图像，像素点要足够分散，符号不要重叠。这是因为 <a href="https://imagemagick.org/Usage/convolve/#convolve">Convolve</a> 会将重叠的区域加在一起，使其比预期的更亮。</p>
<p>以上内容已被转换成UNIX shell脚本 <a href="https://imagemagick.org/Usage/scripts/convolve_image">convolve_image</a>，以方便使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convolve_image  points_pixels.gif marker.png   point_markers.png
</code></pre></div><p>这个技术源于IM论坛上的一个讨论-<a href="https://imagemagick.org/Usage/forum_link.cgi?t=17259&amp;p=64696">IM 的有趣体验</a>。用户希望在足球场的背景图上放置小人，让他们的位置在图片中拼出一个人的名字。</p>
<h4 id="分层">分层</h4>
<p>一种不同的技术，如<a href="https://imagemagick.org/Usage/layers/">图像层</a>，使用你从源图像中提取的像素列表进行定位，可能是更好的方法。你可以先叠加更远的符号图像，然后再叠加前景图像，你可以通过编程选择或随机选择什么符号替换什么点。</p>
<p>关于这个例子，请看<a href="https://imagemagick.org/Usage/layers/#layer_pins">地图中的图钉</a>。</p>
<h4 id="绘制圆圈">绘制圆圈</h4>
<p>绘制选项为您提供了许多方法来完成一些非常基本的工作。绘制圆。</p>
<p>例如，您可以在圆周上的任何一点上画一个圆，因此您需要计算一个中心点和一个半径为25像素的第二点。因此，您需要计算一个中心点和第二个点，这个点的半径（例如25像素）离第一个点的距离。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Firebrick  -fill tomato  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;circle 50,30 50,55&#39;</span>    circle_circle.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_circle.gif" alt="img"></p>
<p><a href="http://www.fmwconcepts.com/fmw/fmw.html">Fred Weinhaus</a> 指出，通过使用平移，你可以消除计算圆边坐标的需要，而直接给出半径即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke SeaGreen  -fill PaleGreen  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;translate 50,30 circle 0,0 25,0&#39;</span>    circle_circle_trans.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_circle_trans.gif" alt="img"></p>
<p>但是当绘制多个圆时，上述操作需要对每个圆进行单独的 <code>-draw</code> 操作，或者使用 <a href="https://imagemagick.org/Usage/draw/#push_context">Context Pushing</a>。</p>
<p>使用椭圆可以直接指定半径为轴长</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Sienna  -fill Wheat  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;ellipse 50,30 25,25 0,360&#39;</span>    circle_ellipse.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_ellipse.gif" alt="img"></p>
<p>你也可以用 <code>stroke-lineecap round</code> 画一条非常非常短的线来生成一个圆。描边的宽度可以设置圆的直径。注意线条必须有一定的长度（无论多小），否则画不出任何东西。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Blue  -strokewidth <span class="m">50</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;stroke-linecap round line 50,30 50,30.0001&#39;</span> <span class="se">\
</span><span class="se"></span>          circle_line.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_line.gif" alt="img"></p>
<p>这种技术，不幸的是不能勾勒出生成的圆，但对于覆盖大面积的区域，大笔触宽度是有用的。请看下面一些简单的例子。</p>
<p>这种方法利用了 <a href="https://imagemagick.org/Usage/draw/#paths">SVG 路径</a>的绘制方法，所以可以在不需要计算任何额外坐标的情况下绘制圆形。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Blue  -fill DodgerBlue  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;path &#39;M 50,30  m 0,25  a 1,1 0 0,0 0,-50  a 1,1 0 1,0 0,50&#39;&#34;</span> <span class="se">\
</span><span class="se"></span>          circle_path.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_path.gif" alt="img"></p>
<p>只有最初的绝对移动 &lsquo;M&rsquo; 是用来定义中心的，接下来的路径组件中的 &lsquo;25&rsquo; 和 &lsquo;50&rsquo; 是定义相对于这个中心的圆的半径和直径。</p>
<blockquote>
<p>在IM v6.4.3-5之前，相对移动SVG路径项 &lsquo;m&rsquo; 是被破坏的。 如果您的IM比这更早，圆可能只显示为一个像素。您可以通过将上面的 &lsquo;m&rsquo; 替换为 &lsquo;l&rsquo; 来修复旧版本的问题。</p>
</blockquote>
<p><a href="http://www.fmwconcepts.com/fmw/fmw.html">Fred Weinhaus</a> 添加了以下贝塞尔圆的方法。它非常接近真实的圆（虽然不精确），并且需要进行浮点计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">r</span><span class="o">=</span>25<span class="p">;</span>  <span class="nv">cx</span><span class="o">=</span>50<span class="p">;</span>  <span class="nv">cy</span><span class="o">=</span>30<span class="p">;</span>
  <span class="nv">x1</span><span class="o">=</span>25<span class="p">;</span>     <span class="nv">x2</span><span class="o">=</span>75<span class="p">;</span>      <span class="c1"># = cx ± radius</span>
  <span class="nv">y1</span><span class="o">=</span>-3.25<span class="p">;</span>  <span class="nv">y2</span><span class="o">=</span>63.25<span class="p">;</span>   <span class="c1"># = cy ± radius*1.275</span>

  convert -size 100x60 xc:  -stroke Purple  -fill Violet  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">bezier </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2">  </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">bezier </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2">  </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2"> </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          circle_bezier.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_bezier.gif" alt="img"></p>
<p>如果画一个精确的圆并不重要，你可以使用这个4 Bezier段 SVG 路径，它只使用圆的X和Y边界进行计算。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">r</span><span class="o">=</span>25<span class="p">;</span>  <span class="nv">cx</span><span class="o">=</span>50<span class="p">;</span>  <span class="nv">cy</span><span class="o">=</span>30<span class="p">;</span>
  <span class="nv">x1</span><span class="o">=</span>25<span class="p">;</span>    <span class="nv">x2</span><span class="o">=</span>75<span class="p">;</span>      <span class="c1"># X bounds = cx ± radius</span>
  <span class="nv">y1</span><span class="o">=</span>5<span class="p">;</span>     <span class="nv">y2</span><span class="o">=</span>55<span class="p">;</span>      <span class="c1"># Y bounds = cy ± radius</span>

  convert -size 100x60 xc:  -stroke Tomato  -fill Gold  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>     -draw <span class="s2">&#34;</span><span class="s2">path &#39;M </span><span class="nv">$cx</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> Q </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> </span><span class="nv">$x1</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> T </span><span class="nv">$cx</span><span class="s2">,</span><span class="nv">$y2</span><span class="s2"> </span><span class="nv">$x2</span><span class="s2">,</span><span class="nv">$cy</span><span class="s2"> </span><span class="nv">$cx</span><span class="s2">,</span><span class="nv">$y1</span><span class="s2"> z&#39;</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>     circle_bezier_path.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_bezier_path.gif" alt="img"></p>
<p>如果你喜欢一个完全相对于中心起点绘制的，你可以使用这种技术。只使用半径值，使其生成简单，只使用 API 中的字符串函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x60 xc:  -stroke Orange  -fill LemonChiffon  -strokewidth <span class="m">2</span> <span class="se">\
</span><span class="se"></span>     -draw <span class="s2">&#34;path &#39;M 50,30  m 0,25  q 25,0 25,-25  t -25,-25  -25,25  25,25 z&#39;&#34;</span><span class="se">\
</span><span class="se"></span>     circle_bezier_path_rel.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/circle_bezier_path_rel.gif" alt="img"></p>
<p>你能想到其他画圆的方法吗？</p>
<h3 id="绘制箭头-定位旋转和缩放符号">绘制箭头-定位、旋转和缩放符号</h3>
<p>使用上述技术，你可以创建一个特殊的符号，如箭头，你可以定位，使其点在线的最末端，并画在它上面。如果你画的箭头后的线（典型的情况），那么箭头将被绘制在该行的顶部。</p>
<p>然而，他们有三种类型的箭头，可以定义，每个类型的定义在不同的方式取决于它的使用。</p>
<ul>
<li>测量时，你只是想用箭头头标记线的两端，以指示一些工程图中的测量极限。非常简单。</li>
<li>矢量，显示一些数值的方向和强度。例如在天气风图中。需要一个尾巴，0,0点就是尾巴的末端。通常情况下，这样的向量会形成一个大网格。</li>
<li>指标，指出一些细节。对于这个0,0点可能应该是箭尖，或者是箭头本身前面的一些距离。</li>
</ul>
<h4 id="测量箭头">测量箭头</h4>
<p>简单地在一条线的末端添加一个箭头是比较容易做到的。基本上，您可以创建一个 &lsquo;arrow head&rsquo; <a href="https://imagemagick.org/Usage/draw/#symbols">符号</a>，并将其画在正确的位置。</p>
<p>例如&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;l -15,-5  +5,+5  -5,+5  +15,-5 z&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 10,30 80,30&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke blue fill skyblue
</span><span class="s2">                 path &#39;M 80,30  </span><span class="nv">$arrow_head</span><span class="s2">&#39; </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_horizontal.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_horizontal.gif" alt="img"></p>
<p>请注意，我画的符号，使其起点是线的最末端。这样一来，它就可以在之前画好的线上面向后画，形成一个非常漂亮的整齐的符号。</p>
<p>箭头却有一个相关的方向。你可以在许多不同的角度创建大量的箭头定义，许多程序都这样做。但是既然箭头是一个矢量，那么为什么不把箭头作为一个矢量进行旋转呢。IM绘图命令内置了绘图旋转（<a href="https://imagemagick.org/Usage/draw/#transform">Canvas Warping</a>），所以让我们使用它们。</p>
<p>这样做还有一个好处，就是把位置从箭头头的 <code>path</code> 定义中移出来，让你把整个路径指定为 <code>constant</code>&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 25,55 70,10&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke blue fill skyblue
</span><span class="s2">                 translate 70,10 rotate -45
</span><span class="s2">                 </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_rotate.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_rotate.gif" alt="img"></p>
<p>如果你喜欢改变箭头的大小，可以在旋转后增加一个 <code>scale</code> 绘制选项。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 25,55 70,10&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke blue fill skyblue
</span><span class="s2">                 translate 70,10 rotate -45 scale 2,2
</span><span class="s2">                 </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_scale.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_scale.gif" alt="img"></p>
<p>请注意，它是如何放大离开箭头的&quot;尖端&rdquo;，你指定的地方。这是处理箭头的一个非常重要的方面，因为它是唯一的终点，和角度的线，你正在添加箭头的事项。</p>
<p><code>transforms</code> 的顺序是很重要的，而且实际上与它们实际被处理的顺序是相反的。也就是先将比例尺应用于座标，然后是旋转，再是平移。如果座标变换不是按照这个顺序进行的，我们最终也会对箭头的最终位置进行缩放，而不是我们期望的位置。</p>
<p>另外由于比例尺有两个数字，而原来的箭头头符号是水平设计的（角度为零），所以可以分别将箭头的宽度与高度进行比例。同时注意笔画宽度也随着箭头的大小而缩放，保持一致。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: -draw <span class="s1">&#39;line 25,55 70,10&#39;</span> <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke blue fill skyblue
</span><span class="s2">                 translate 70,10 rotate -45 scale 2,1
</span><span class="s2">                 </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_scale_aspect.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_scale_aspect.gif" alt="img"></p>
<p>现在，当你在画布上翘起一个个箭头时，也许还有许多其他的绘画操作，你可能喜欢在一次 <code>[&quot;-draw&quot;](https://imagemagick.org/Usage/option_link.cgi?draw)</code> 操作中把它们全部画完。说要画线，然后在两端添加箭头，需要不同的颜色、位置、旋转，甚至可能是不同的比例。这意味着我们需要将画布翘曲的范围限制在每个单独箭头头的绘制上。如果你不限制范围，你可能会在以后开始影响到其他后面的绘制操作，永远不能很确定你生成的是什么。</p>
<p>为了限制翘曲的范围（以及所有其他的绘图属性），您将涉及到的部分包裹在一个 <code>graphic-context</code>&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">arrow_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>

  convert -size 100x60 xc: <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke black fill none
</span><span class="s2">                 path &#39;M 10,40 A 50,50 0 0,1 90,40&#39;
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke blue fill skyblue
</span><span class="s2">                   translate 10,40 rotate 135
</span><span class="s2">                   </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke firebrick fill tomato
</span><span class="s2">                   translate 90,40 rotate 45
</span><span class="s2">                   </span><span class="nv">$arrow_head</span><span class="s2">
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_context.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_context.gif" alt="img"></p>
<p><code>push</code> 主要是将当前所有的绘图属性保存起来，以备将来使用，而 <code>pop</code> 则恢复这些属性，用之前保存的设置替换任何设置（颜色、扭曲、位置等）。这意味着在 &lsquo;popping&rsquo; 之后，&lsquo;canvas warp&rsquo; 会被取消，画图会回到修改之前的状态。</p>
<p>上述技术只是生成箭头的一种方法，在绘制箭头作为测量距离的一部分时，如在技术图纸中，是一种很好的方法。</p>
<h4 id="矢量箭头">矢量箭头</h4>
<p>如前所述，矢量既显示方向，又显示某个数值的强度。这意味着箭头的长度是可变的，箭头头可以在任何位置远离向量的起点。</p>
<p>现在，你可以做一些沉重的数学计算的位置，箭头头应该是地方给定的向量的长度和角度，但他们是一个更好的方法，这让 ImageMagick 为你做这些计算。</p>
<p>解决的办法是在 <a href="https://imagemagick.org/Usage/draw/#transform">Warped Canvas Space</a> 中画一条长度合适的水平线作为向量长度。当这条线画好后，只需将绘图空间再次转换到线的末端，而画布仍然是&quot;扭曲的&rdquo;(<code>warped</code>)。现在你的位置已经正确了，只要正确的旋转就可以像正常的那样画出矢量的 <code>'arrow head'</code>。</p>
<p>例如，这里我以-35度角生成一个70像素长的矢量。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  <span class="nv">vector_head</span><span class="o">=</span><span class="s2">&#34;path &#39;M 0,0  l -15,-5  +5,+5  -5,+5  +15,-5 z&#39;&#34;</span>
  <span class="nv">indicator</span><span class="o">=</span><span class="s2">&#34;path &#39;M 10,0  l +15,+5  -5,-5  +5,-5  -15,+5  m +10,0 +20,0 &#39;&#34;</span>

  convert -size 100x100 xc: <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;</span><span class="s2">stroke black fill none  circle 20,50 23,50
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke blue fill skyblue
</span><span class="s2">                   translate 20,50 rotate -35
</span><span class="s2">                   line 0,0  70,0
</span><span class="s2">                   translate 70,0
</span><span class="s2">                   </span><span class="nv">$vector_head</span><span class="s2">
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                 push graphic-context
</span><span class="s2">                   stroke firebrick fill tomato
</span><span class="s2">                   translate 20,50 rotate 40
</span><span class="s2">                   </span><span class="nv">$indicator</span><span class="s2">
</span><span class="s2">                   translate 40,0 rotate -40
</span><span class="s2">                   stroke none fill firebrick
</span><span class="s2">                   text 3,6 &#39;Center&#39;
</span><span class="s2">                 pop graphic-context
</span><span class="s2">                </span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>          arrow_with_tails.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arrow_with_tails.gif" alt="img"></p>
<h4 id="指示箭头">指示箭头</h4>
<p>在上面我还演示了一个指示箭头，指向之前矢量箭头的起点。</p>
<p>然而我没有像之前那样画箭头，而是将它创建为一个反向的箭头符号，它的起始点距离原点（或起始点）10像素。这是一个符号位于我想要指示的位置，所以我实际上并不希望箭头直接在那个位置上面，而是离它稍微远一点。</p>
<p>现在，虽然指示符比向量处理起来更简单，通常不需要可变长度，但你通常要在指示符的远端添加文字来指定指示的内容。和之前一样，计算这个位置可能很困难，何必呢。</p>
<p>文字定位的解决方法也和向量一样。保留原来用于绘制指示箭头的翘曲空间，并将原点转换到该箭头的尾端（在翘曲空间中水平40像素）。现在我们已经重新定位了，我们可以围绕这个新的位置解除扭曲，这样你就可以像正常的那样绘制文本（有轻微的偏移）。</p>
<p>不幸的是，虽然默认的文字对齐方式是&quot;左&rdquo;，但目前你不能在 MVG 中指定文字对齐方式，作为重力的单独设置。如果这是一个问题，请在 IM bugs 论坛上提出请求，希望文本对齐（作为独立于重力定位）能够成为现实，尤其是它实际上是 SVG 规范的一部分。</p>
<h3 id="绘制对象">绘制对象</h3>
<h4 id="宽广的色彩笔触">宽广的色彩笔触</h4>
<p>你不需要用路径或轮廓完全封闭填充区域，就能创造出各种形状。使用非常大和宽的<a href="https://imagemagick.org/Usage/draw/#stroke">笔触</a>，你可以在画布上生成大面积的颜色和色块。</p>
<p>例如，一个宽阔的笔触椭圆弧形可以生成一个漂亮的颜色区域，我实际上已经看到用于创建海报。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x100 xc: -fill none -stroke powderblue <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;stroke-width 70 ellipse -30,0 90,90 10,50&#39;</span> <span class="se">\
</span><span class="se"></span>          -rotate <span class="m">180</span>  arc_background.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/arc_background.gif" alt="img"></p>
<p>或者你可以生成一个小丑相当复杂的笑容。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 100x100 xc: <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;fill none stroke-linecap round
</span><span class="s1">             stroke-width 40 stroke tomato ellipse 50,0 70,70 65,115
</span><span class="s1">             stroke-width 2  stroke black  ellipse 50,0 70,70 60,120
</span><span class="s1">             stroke-width 40 stroke palegreen line 50,40 50,40.01&#39;</span> clown.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/clown.gif" alt="img"></p>
<p>你能想出什么办法？请告诉我们。</p>
<h4 id="圆柱体">圆柱体</h4>
<p>在 <a href="https://imagemagick.org/Usage/forum_link.cgi?t=17550">IM 论坛的讨论</a>中，有一个关于使用 ImageMagick 绘制命令绘制圆柱体（特别是阴影圆柱体）的重要讨论。</p>
<p>绘制圆柱体的诀窍是绘制 <code>roundrectangle</code> 原语，使其末端形成椭圆形。也就是说，如果圆柱体的宽度为 50 像素，则将矩形的角分别舍去 25 和 12 像素。这就是矩形宽度的一半，然后再减半。</p>
<p>这样，一个圆柱体就变成了两个相互叠加的圆角矩形。第二个颜色填充的 <code>'end oval'</code> 的大小正好是两个角的两倍。例如&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 60x100 xc:white -stroke snow4 <span class="se">\
</span><span class="se"></span>          -fill chartreuse3    -draw <span class="s1">&#39;roundrectangle 5,5 55,95 25,12&#39;</span> <span class="se">\
</span><span class="se"></span>          -fill chartreuse2    -draw <span class="s1">&#39;roundrectangle 5,5 55,29 25,12&#39;</span> <span class="se">\
</span><span class="se"></span>          cylinder.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/cylinder.gif" alt="img"></p>
<p>通过将第一种填充色替换为渐变色（使用<a href="https://imagemagick.org/Usage/canvas/#tile_memory">记忆中的平铺技术</a>），你可以让圆柱体看起来更像3D&hellip;&hellip;。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 60x100 xc:white -stroke snow4 <span class="se">\
</span><span class="se"></span>          <span class="se">\(</span> -size 1x60 gradient:chartreuse1-chartreuse4 -rotate -90 <span class="se">\
</span><span class="se"></span>             -write mpr:shading +delete <span class="se">\)</span> <span class="se">\
</span><span class="se"></span>          -tile mpr:shading  -draw <span class="s1">&#39;roundrectangle 5,5 55,95 25,12&#39;</span> +tile <span class="se">\
</span><span class="se"></span>          -fill chartreuse2  -draw <span class="s1">&#39;roundrectangle 5,5 55,29 25,12&#39;</span> <span class="se">\
</span><span class="se"></span>          cylinder_shade.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/cylinder_shade.gif" alt="img"></p>
<p>通过慢慢完善圆柱体的绘制（如IM论坛中讨论的那样），你可以走很长的路来生成非常复杂和具有视觉吸引力的圆柱体。这包括增加封闭半透明玻璃圆柱体、阴影效果和标签。</p>
<p>该讨论的最终结果是一个脚本 &ldquo;<a href="https://imagemagick.org/Usage/scripts/cylinder_bar">cylinder_bar</a>&quot;，生成一个圆柱体百分比条&hellip;&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  cylinder_bar <span class="m">95</span> cylinder_95.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/cylinder_95.png" alt="img"></p>
<p>该脚本可以生成任何尺寸的图像，根据该尺寸和脚本顶部定义的其他设置适当调整所有参数。还包括 <code>glass thickness</code> 的概念，在一个封闭的半透明玻璃圆柱体和内部的彩色圆柱体之间创造一个间隙。</p>
<p>请注意圆柱体非常微妙的阴影，特别是当绿色圆柱体的末端与玻璃圆柱体的末端重叠时。只要稍加预想，就能做出惊人的效果。</p>
<h3 id="在文字串中绘制特殊字符">在文字串中绘制特殊字符</h3>
<h4 id="引号还是反斜杠">引号还是反斜杠？</h4>
<p>人们在使用 <code>-draw</code> 时遇到的最大的问题之一是绘制字符，这些字符对 UNIX shell 和 DOS 命令行甚至其他语言如 C、Perl、PHP、R 或 Visual Basic 都有特殊意义。</p>
<p>在这方面最大的罪魁祸首是两种类型的引号字符，以及变量替换字符，如美元 <code>'$'</code> 和 shell 和 ImageMagick 的转义字符，反斜杠 <code>'\'</code>。</p>
<p>基本上作为 <code>-draw</code> 的MVG参数需要加引号，而里面的 <code>'text'</code> 字符串参数也可能需要一些额外的引号。</p>
<p>为了解决这个问题，用户通常会使用两个不同的引号字符，一个用于 shell，另一个用于 MVG 文本字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">-draw <span class="s1">&#39;... text 0,0 &#34;string&#34; ...&#39;</span>
</code></pre></div><p>需要注意的是，对于 windows 用户来说，这是唯一真正的选择，它有自己的引号问题和方法。或者他们会交换引号，用&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">-draw <span class="s2">&#34;... text 0,0 &#39;string&#39; ...&#34;</span>
</code></pre></div><p>它允许你包含 shell 变量替换(使用 <code>'$'</code> 而不进行转义。)</p>
<p>选择正确的形式可以解决大多数问题，但有些字符仍然存在困难，每个解决方案都取决于你到底使用哪一组引号，因为它们也定义了特殊字符应该如何转义。</p>
<p>以下是四种情况下的引号，以及特殊字符的处理&hellip;</p>
<ul>
<li>对 shell 参数使用单引号，对 MVG 文本字符串周围使用双引号。</li>
</ul>
<p>处理绘制文本字符串的最简单的技术是为包装 shell 参数使用单引号。然而，这意味着要在绘制的字符串中包含一个撇号，你需要离开 shell 的&quot;单引号模式&rdquo;，并在 shell 的单引号之外提供撇号。</p>
<p>例如，这里是如何处理我提到的四个特殊字符。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;text 0,0 &#34;  &#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  \&#34;  $  \\  &#34; &#39;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_sd.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_sd.gif" alt="img"></p>
<p>请注意，由于美元符号不需要转义，你也不能用它来替代 shell 变量的内容。</p>
<p>重要的是要记住，反斜杠是IM绘图字符串处理的唯一特殊字符。同时，它存在的原因也纯粹是为了让你可以转义任何&quot;IM 绘制字符串引号&rdquo;，比如我们在上面使用的双引号。除此以外，其他所有的怪异都是由 UNIX 命令行 shell 引起的，而不是 IM。</p>
<p>PC-DOS 有它自己的怪异之处，我希望在使用环境中的IM时，能对特殊字符进行转义。</p>
<ul>
<li>在 shell 参数中使用双引号。
在 MVG 文本字符串周围使用单引号。</li>
</ul>
<p>如果你确实想在绘制的字符串中插入一个 &lsquo;shell variable&rsquo;，那么你将不得不在 shell 参数的外面使用双引号。这使得整个事情变得更加复杂，因为你失去了 shell 的保护，你现在不仅要转义美元 <code>'$'</code> 符号，而且还要转义反斜杠 <code>'\'</code>。</p>
<p>另一方面，shell 将不需要使用单引号字符作为它的参数结束限制字符，所以这方面被简化了。让我们总结一下我们的特殊字符短名单的结果。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;text 0,0 &#39;  \\&#39;  \&#34;  \$  \\\\  &#39; &#34;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_ds.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_ds.gif" alt="img"></p>
<p>请注意，如果你想画一个反斜线本身，MVG 文本字符串需要将反斜线加倍（如前面的例子），但是 shell 本身也需要将每个反斜线加倍，总共产生四个反斜线才能产生一个这样的字符。</p>
<p>这种翻倍很快就会让人不知所措，需要大量的反斜杠才能达到你想要的效果。只要采取的是慢慢的、简单的方法，你就会针对自己的情况想出办法。</p>
<ul>
<li>使用单引号进行 shell 论证。
与 MVG 文本字符串周围的单引号。</li>
</ul>
<p>最后，让我们总结一下最后两种引号组合。我将让你去弄清楚它们是如何被 shell 和 MVG 解码的。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s1">&#39;text 0,0 &#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  \&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  &#34;  $  \\  &#39;</span><span class="se">\&#39;</span><span class="s1">&#39; &#39;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_ss.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_ss.gif" alt="img"></p>
<ul>
<li>在shell参数中使用双引号。</li>
</ul>
<p>在 MVG 文本字符串周围加上双引号。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 250x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>          -draw <span class="s2">&#34;text 0,0 \&#34;  &#39;  \\\&#34;  \$  \\\\  \&#34;&#34;</span> <span class="se">\
</span><span class="se"></span>          -trim +repage  text_special_dd.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_special_dd.gif" alt="img"></p>
<p>正如你所看到的，来自命令行的 <code>-draw</code> 参数既要处理命令行 shell，也要处理 MVG 文本字符串中的反斜杠和引号转义。其结果可能会让人感到困惑和棘手。只要记住，shell 对这两种引号的处理方式不同，而 MVG 文本字符串则不同。</p>
<p>当然，在复杂的脚本中，更好的方法可能是完全避免 shell 和任何脚本问题。你可以通过读取 MVG 绘图文件中的 <code>-draw</code> 参数来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">-draw @drawfile.mvg
</code></pre></div><p>当然，你仍然需要对你使用的任何引号字符进行反斜杠处理，以及对文本中的任何反斜杠进行处理。然而，这比起同时处理 shell 自己的引号和转义系统要简单得多。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -size 500x50 xc:lightblue  -font Candice -pointsize <span class="m">36</span> <span class="se">\
</span><span class="se"></span>          -gravity center     -draw @text_quotes.mvg      text_quotes.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/img_www/right.gif" alt="img"><img src="https://imagemagick.org/Usage/draw/text_quotes.gif" alt="img"></p>
<p>第一张图片来自我使用的一个 &ldquo;MVG&rdquo; 文本文件。它不包含转义符或引号。因此，只有 MVG 引号和转义符是存在的。</p>
<p>请注意，在上面的例子中，如果我对 MVG 文本字符串使用了单引号，唯一的变化是我需要对字符串中的单引号字符进行反斜杠处理，而不是双引号字符。</p>
<h4 id="关于百分比字符">关于百分比字符</h4>
<p>最后一点是关于 <code>&quot;-draw text&quot;</code> 操作符中的特殊 <code>escape</code> 字符。百分号字符 <code>&quot;%&quot;</code> 应该&quot;按原样&quot;绘制。你不需要做任何特殊的操作来绘制它们。如果它们不能&quot;按原样&quot;绘制，那么你的IM版本较旧，应该尽快升级。</p>
<blockquote>
<p>直到IM 6.2.4版本，<code>&quot;%&quot;</code> 字符被用作转义字符，在绘制的文本字符串中包含额外的图像信息。现在不再是这样了，因为当SVG图像也试图绘制百分数字符时，这种转义符是混乱和不正确的。
百分号 &ldquo;转义符 &ldquo;的使用（以及&rdquo;/n &ldquo;换行符）被认为与 <code>-draw</code> 操作符和MVG格式处理SVG图像格式的预期用途不兼容。因此，从 IM 6.2.4 版本开始，%转义就不适用了，反斜杠只能转义自己和周围的引号。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 250x50 xc:none -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -draw <span class="s1">&#39;text 0,0 &#34;%w\n%h&#34;&#39;</span>    -trim +repage text_escapes.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/text_escapes.gif" alt="img"></p>
<p>关于&quot;百分比错误&quot;的更多细节，以及在旧版 ImageMagick 中使用 <code>-draw</code> 时避免该错误的方法，请参见 <a href="https://imagemagick.org/Usage/bugs/draw_percent/">Drawing a Percent Bug</a> 页面。</p>
<h4 id="用注释代替绘制">用注释代替绘制</h4>
<p>避免这类问题的较好方法是使用 <code>[-annotate](https://imagemagick.org/Usage/option_link.cgi?annotate)</code> 而不是  <code>draw</code> 来绘制文本。这个操作符是 <code>draw</code> 操作符的一个封装器，可以使用 <code>draw</code> 的所有功能，但形式更简单。</p>
<p>基本上这个操作符只需要一组引号（对于 shell）。这使得处理特殊字符变得更加简单。</p>
<p>不幸的是，虽然你不再需要为 IM 转义引号，但你现在有百分比转义，如 <code>'@'</code> 文件读取，<code>'\n'</code> 换行，以及其他<a href="https://imagemagick.org/Usage/basics/#arg_percent">百分号转义</a>扩展。</p>
<p>例如，使用单引号&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 200x50 xc:none  -box white  -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -annotate <span class="m">0</span> <span class="s1">&#39;\@  &#39;</span><span class="se">\&#39;</span><span class="s1">&#39;  &#34;  $  \\  %% &#39;</span> <span class="se">\
</span><span class="se"></span>            -trim +repage  annotate_s.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/annotate_s.gif" alt="img"></p>
<p>而对于双引号&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 200x50 xc:none -box white -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -annotate <span class="m">0</span> <span class="s2">&#34;\@  &#39;  \&#34;  \$  \\\\  %% &#34;</span> <span class="se">\
</span><span class="se"></span>            -trim +repage  annotate_d.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/annotate_d.gif" alt="img"></p>
<p>然而，如果你使用 <code>'@'</code> 转义符从文件中读取字符串，所有的注释引号和转义符将被完全忽略。</p>
<p>例如，我们在这里包含了一个图像的宽度和高度的信息!</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    convert -size 200x50 xc:none -box white -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>            -annotate <span class="m">0</span> <span class="s1">&#39;%w\n%h&#39;</span> -trim +repage    annotate_percents.gif
</code></pre></div><p>然而，当从文件中读取注释字符串时，所有的转义都会被完全忽略。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">    <span class="nb">echo</span> -n <span class="s1">&#39;@ %w\n%h&#39;</span> <span class="p">|</span><span class="se">\
</span><span class="se"></span>      convert -size 200x50 xc:none -box white -pointsize <span class="m">20</span> -gravity center <span class="se">\
</span><span class="se"></span>              -annotate <span class="m">0</span> <span class="s1">&#39;@-&#39;</span>  -trim +repage  annotate_file.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/annotate_file.gif" alt="img"></p>
<p>更多信息请参见 <a href="https://imagemagick.org/Usage/text/#annotate">Annotate Text Drawing Operator</a>，特别是 <a href="https://imagemagick.org/Usage/text/#escape_chars">Annotate Escape Characters</a>。</p>
<h2 id="im-和-svg-处理">IM 和 SVG 处理</h2>
<h3 id="svg-输入驱动rsvg-与-msvg">SVG 输入驱动。RSVG 与 MSVG</h3>
<p>处理实际的 SVG 图像格式是一项非常复杂的工作。引擎需要处理 <a href="http://www.w3.org/TR/SVG/">SVG&ndash;可缩放矢量图形</a>文档所定义的所有方面。这需要大量的编程工作和时间。</p>
<p>因此，ImageMagick 在 SVG 格式图像的处理上提供了两种方法。第一种是使用一个开源的 RSV G库，将 SVG 格式转换成 IM 没有问题的光栅图像。这个引擎几乎在 SVG 处理的所有方面都是完整的。</p>
<p>第二种方法是IM尝试将 SVG 转换为 MVG，使用一个名为 MSVG 的内置IM方法。MSVG 试图将SVG图像转换成IM的 <code>-draw</code> 运算符 &ldquo;MVG&quot;绘图语言。绘制 MVG 的很多功能都是专门为此而创建的。不幸的是，虽然基本的线条绘制和着色功能是存在的，但它远不是一个完整的 SVG 转换器。</p>
<p>你可以通过使用特殊的输入格式 &ldquo;MSVG:&quot;（IM v6.3.4新增）读取 SVG 图像来强制使用内部的 MSVG 转换器。但如果 RSVG 库存在，大多数 ImageMagick 将使用它来渲染 <code>SVG</code> 图像。</p>
<p>要找出你的 IM 会做什么，请用&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -list format <span class="p">|</span> grep SVG
</code></pre></div><p>从括号中的 &ldquo;RSVG&rdquo; 可以看出，我自己的 IM 将使用我电脑上的 RSVG 库，并给出了版本。</p>
<p>在这里，我&quot;绘制&quot;了一个小的、手工制作的 SVG 图像 &ldquo;<a href="https://imagemagick.org/Usage/draw/diagonal.svg">diagonal.svg</a>&quot;（由论坛用户 <a href="https://imagemagick.org/Usage/forum_link.cgi?u=8538">penciledin</a> 贡献），它在白色背景上创建了一个简单的对角线渐变的矩形。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert diagonal.svg  diagonal_rsvg.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/diagonal_rsvg.gif" alt="img"></p>
<p>完美的。一个正确的对角线梯度被生成。</p>
<p>然而，如果你使用内部的 MSVG（如果没有 RSVG 库，则为默认值）来渲染&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert msvg:diagonal.svg  diagonal_msvg.gif
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/diagonal_msvg.gif" alt="img"></p>
<p>正如你所看到的，内部 MSVG 转换失败，返回的是垂直梯度而不是对角线。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert msvg:diagonal.svg diagonal.mvg
</code></pre></div><p>你大概可以看到MSVG转换器是如何尝试将 SVG 转换为 MVG 绘图命令的。</p>
<p>当前内部 MSVG 已知失败的地方包括&hellip;</p>
<ul>
<li>非垂直梯度(没有转换到新的MVG梯度处理)</li>
<li>沿着弯曲路径的文字</li>
<li>文本对齐（与重力分开）。</li>
</ul>
<p>然而大多数基本的绘图动作都被处理了。</p>
<p>还请记住，MVG 语言实际上可以处理 SVG 不能处理的事情，包括使用重力来定位图像和文本。重力不是 SVG 规范的一部分，尽管它是 IM 文本和字体处理的一个组成部分。</p>
<p>另外请记住，MVG 没有 SVG 所拥有的容器机制。内部的 MSVG 转换器用图形上下文的推送和弹出代替了 XML 容器（见上面的 MVG  输出），效果是一样的。
SVG 的设置</p>
<p>SVG 图像格式是一种矢量格式（请参见<a href="https://imagemagick.org/Usage/formats/#vector">关于矢量图像格式的一句话</a>），因此图像通常没有一个默认的&quot;大小&rdquo;，而是以特定的 <code> &quot;-density&quot;</code> 来 &ldquo;绘制&quot;或&quot;渲染&rdquo;，就像 postscript 一样（默认密度是72dpi）。</p>
<p>另外，如果 SVG 没有 &ldquo;绘制&quot;背景，您可以通过使用 <code>-background</code> 设置指定要使用的背景颜色。</p>
<p>例如这里是另一个小的 SVG 图像 &ldquo;home.svg&rdquo;，它已经使用3种不同的密度，3种不同的背景进行&quot;渲染&rdquo;，包括一个透明的背景。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -density <span class="m">36</span>                      home.svg  home_1.gif

  convert              -background skyblue home.svg  home_2.gif

  convert -density <span class="m">144</span> -background none    home.svg  home_3.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/home_1.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/home_2.gif" alt="img">
<img src="https://imagemagick.org/Usage/draw/home_3.png" alt="img"></p>
<p>请注意，我使用了 PNG 格式的图片来制作上面例子中较大的透明背景版本。由于半透明的边缘像素，这产生的图像比 GIF 图像格式产生的图像更干净。当最终图像中涉及到透明度时，总是建议使用 PNG。</p>
<blockquote>
<p>我发现有些 SVG 图像不能缩放。也就是说，它们被定义为&quot;像素&rdquo;，而不是现实世界中的长度，如&quot;点&rdquo;、&ldquo;英寸&quot;或&quot;毫米&rdquo;。因此，虽然 <code>-density</code> 设置可能会改变图像的整体大小（以现实世界为单位），但 &ldquo;像素 &ldquo;的大小不会改变，因此图像本身的大小也不会改变。然而这样的SVG图像是相当罕见的。</p>
</blockquote>
<p>更糟糕的是，一些 SVG 图像使用了&quot;像素&quot;和 &ldquo;点&quot;的混合测量，除非作者故意这样做，否则你可能会得到一个真正的混乱，你可以尝试使用不同的密度，而不是作者想要的。幸运的是，这种情况更加罕见。</p>
<p>一个简单的解决方法就是将 SVG 中所有的 &ldquo;像素&quot;单位改成&quot;点&rdquo;，但也不能盲目的使用，以防故意使用&quot;像素&rdquo;。</p>
<h2 id="svg-输出处理">SVG 输出处理</h2>
<p>从 IM v6.4.2 开始，IM 可以将任何位图图像转换为 SVG 矢量图! 转换并不总是成功的，但较大和/或较简单的图像（如位图蒙版）会转换得很好。</p>
<p>例如，我在这里将一个可怕的位图形状转换为SVG图像，然后再将其转换回来，以便将位图平滑为一个适当的反锯齿形状。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert -pointsize <span class="m">72</span> -font Candice label:A -threshold 50% <span class="se">\
</span><span class="se"></span>          -trim +repage -bordercolor white -border 5x5 A.gif

  convert A.gif  A.svg

  convert A.svg  A.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/A.gif" alt="img"> -&gt; <img src="https://imagemagick.org/Usage/draw/A.png" alt="img"></p>
<p>然而，要使之工作，必须安装&quot;开发&quot;的 <a href="http://autotrace.sourceforge.net/">AutoTrace</a> 库，并在IM中配置 <code>-with-autotrace</code> 开关。</p>
<p>如果没有安装 <a href="http://autotrace.sourceforge.net/">AutoTrace</a> 库并将其编译到 IM 中，那么生成的 SVG 输出将是大量的单像素圆圈，生成一个二进制结果，而不是一个平滑的 SVG 轮廓图像。这样的图像比较巨大，通过 SVG 渲染往往需要很长的时间来渲染。</p>
<p>其实需要一种更好的默认栅格到矢量的技术，可能会使用 Morphology skeletion 和 MAT 技术。</p>
<p>有一个 <code>autotrace:</code> <a href="https://imagemagick.org/Usage/files/#delegates">输入代理</a>，来&quot;平滑输入位图图像&rdquo;，直接使用 &ldquo;autotrace&rdquo; 命令一次性完成上述所有步骤。然而我最后一次看到这个代理已经消失了。</p>
<p>你应该这样使用它&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">  convert autotrace:A.gif  A_traced.png
</code></pre></div><p><img src="https://imagemagick.org/Usage/draw/A_traced.png" alt="img"></p>
<p>当然这并不能让你从 &ldquo;autotrace&rdquo; 命令中得到 SVG 输出，只是通过 SVG 过滤输入的图像来平滑它。</p>
<p>作为一种替代方法，你可以直接使用 &ldquo;autotrace&rdquo; 命令，如 <a href="https://imagemagick.org/Usage/transform/#edge_vector">Raster to Vector Edging</a> 和 <a href="https://imagemagick.org/Usage/morphology/#autotrace_skeleton">Skeleton using Autotrace</a> 示例所示。</p>
<p>你也可以看看 <a href="https://imagemagick.org/Usage/forum_link.cgi?u=39994">cancerberosgx</a> 的结果，在<a href="https://imagemagick.org/Usage/forum_link.cgi?p=167161">生成 SVG 图像</a>，他研究了转换照片的解决方案。</p>
<h2 id="非im矢量图形编辑器">非IM矢量图形编辑器</h2>
<p>ImageMagick 是一个像素数组处理器，它一般不会保存矢量图像（&lsquo;MVG&rsquo; 是唯一的例外），只会读取图像并将其转换为像素数组。</p>
<p>其他像素图像编辑器也是如此，如 Gimp、Photoshop 等。</p>
<p>对于编辑和处理基于矢量的图像，可以使用以下程序，如</p>
<ul>
<li>Sodipodi 基于SVG的矢量图形编辑器。</li>
<li>Xfig 简单但非常好的矢量对象编辑器。(适用于标志、地图和在页面上排列照片)</li>
<li>Dia</li>
<li>AutoTrace 将位图数组中的形状转换为矢量轮廓。</li>
<li>Sketch 基于 Python 的曲线文字矢量编辑器。</li>
</ul>
<p>当然，这不是一个完整的列表。即使是许多文字处理程序，如 OpenOffice、Word 和 TeX，一般都有各种简单的，虽然往往难以使用的对象编辑器。</p>
<p>然而对于一般将矢量图形格式转换为不同的矢量格式，不要使用 ImageMagick。ImageMagick 本质上是一个光栅图像或位图图形转换器和操作器，而且永远都是这样。更多信息请参见 <a href="https://imagemagick.org/Usage/formats/#vector">A word about Vector Image formats</a>。</p>
<ul>
<li>创建于: 24 March 2004</li>
<li>更新于: 14 March 2011</li>
<li>作者: Anthony Thyssen, <a href="mailto:Anthony.Thyssen@gmail.com">Anthony.Thyssen@gmail.com</a></li>
<li>Examples Generated with:  [version image]</li>
<li>URL: <a href="http://www.imagemagick.org/Usage/draw/">http://www.imagemagick.org/Usage/draw/</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/imagemagick" term="imagemagick" label="imagemagick" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/image" term="image" label="image" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[ImageMagick - Transform]]></title>
            <link href="https://ohmyweekly.github.io/notes/imagemagick-transform/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/imagemagick-drawing/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick - Drawing" />
                <link href="https://ohmyweekly.github.io/notes/imagemagick-notes/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick 笔记" />
            
                <id>https://ohmyweekly.github.io/notes/imagemagick-transform/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-05T00:00:00+08:00</published>
            <updated>2020-07-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>ImageMagick Transform</blockquote><p><a href="https://imagemagick.org/Usage/transform/index.html">https://imagemagick.org/Usage/transform/index.html</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/imagemagick" term="imagemagick" label="imagemagick" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/transform" term="transform" label="transform" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[ImageMagick 笔记]]></title>
            <link href="https://ohmyweekly.github.io/notes/imagemagick-notes/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/imagemagick-drawing/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick - Drawing" />
                <link href="https://ohmyweekly.github.io/notes/imagemagick-transform/?utm_source=atom_feed" rel="related" type="text/html" title="ImageMagick - Transform" />
            
                <id>https://ohmyweekly.github.io/notes/imagemagick-notes/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-07-05T00:00:00+08:00</published>
            <updated>2020-07-05T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>ImageMagick</blockquote><h2 id="几个有意思的-imagemagick-脚本">几个有意思的 ImageMagick 脚本</h2>
<p><a href="http://www.fmwconcepts.com/imagemagick/randomclipart/index.php">http://www.fmwconcepts.com/imagemagick/randomclipart/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/sketching/index.php">http://www.fmwconcepts.com/imagemagick/sketching/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/sphericalpano2cube/index.php">http://www.fmwconcepts.com/imagemagick/sphericalpano2cube/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/surroundblur/index.php">http://www.fmwconcepts.com/imagemagick/surroundblur/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/transfercolor/index.php">http://www.fmwconcepts.com/imagemagick/transfercolor/index.php</a>
<a href="http://www.fmwconcepts.com/imagemagick/colorcells/index.php">http://www.fmwconcepts.com/imagemagick/colorcells/index.php</a></p>
<h2 id="给图片添加网格线">给图片添加网格线</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./glasseffects -e none -k simple -o <span class="s1">&#39;#FFDAB9&#39;</span> -t single -m overlay -c <span class="m">200</span> -w <span class="m">1</span> -s <span class="m">20</span> -r <span class="m">10</span> in.jpeg out.jpg
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./grid -o 0.3 -s <span class="m">200</span> -c white in.jpeg out.jpeg
</code></pre></div><h2 id="折叠图片">折叠图片</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./picturefold -o <span class="m">80</span> -h <span class="m">50</span> in.jpeg out.jpeg
</code></pre></div><h2 id="给图片添加心形图片">给图片添加心形图片</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./randomclipart -d <span class="s2">&#34;64,16&#34;</span> -a <span class="s2">&#34;45,-45&#34;</span> -p <span class="m">50</span> -c random in.jpeg heart.png out.jpeg
</code></pre></div><h2 id="给图片分成带颜色的方块">给图片分成带颜色的方块</h2>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">./colorcells -n 8,8 -d 100,100 in.jpeg out.jpeg
</code></pre></div>]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/imagemagick" term="imagemagick" label="imagemagick" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/image" term="image" label="image" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[创建包]]></title>
            <link href="https://ohmyweekly.github.io/notes/creating-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/publishing-packages/?utm_source=atom_feed" rel="related" type="text/html" title="发布包" />
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-http-clients/?utm_source=atom_feed" rel="related" type="text/html" title="编写HTTP客户端和服务器" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/creating-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-30T00:00:00+08:00</published>
            <updated>2020-06-30T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Creating packages</blockquote><p>Dart 生态系统使用<a href="https://dart.dev/guides/packages">包</a>来共享软件，如库和工具。本页告诉你如何创建一个包，重点是最常见的一种包，<a href="https://dart.dev/tools/pub/glossary#library-package">库包</a>。</p>
<h2 id="是什么造就了一个库包">是什么造就了一个库包</h2>
<p>下图是最简单的库包的布局:</p>
<p><img src="https://dart.dev/assets/libraries/simple-lib2-81ebdc20fdb53d3abbc4364956141eb0f6f8f275d1636064fc3e1db959b93c1a.png" alt="img"></p>
<p>一个库的最低要求是</p>
<p><strong>pubspec 文件</strong></p>
<p>库的 <code>pubspec.yaml</code> 文件和应用程序包的文件是一样的-没有特别的名称来表示这个包是一个库。</p>
<p><strong>lib 目录</strong></p>
<p>正如你所期望的那样，库代码存在于 <code>lib</code> 目录下，对其他包是公开的。你可以根据需要在 <code>lib</code> 下创建任何层次结构。按照惯例，实现代码被放在 <code>lib/src</code> 下。<code>lib/src</code> 下的代码被认为是私有的；其他包不应该需要导入 <code>src/...</code>。要使 <code>lib/src</code> 下的 API 公开，您可以从直接位于 <code>lib</code> 下的文件导出 <code>lib/src</code> 文件。</p>
<p>注意：当没有指定 <code>library</code> 指令时，会根据每个库的路径和文件名为其生成一个唯一的标签。因此，我们建议您从代码中省略 <code>library</code> 指令，除非您计划<a href="https://dart.dev/guides/libraries/create-library-packages#documenting-a-library">生成库级文档</a>。</p>
<h2 id="组织一个库包">组织一个库包</h2>
<p>当你创建小的、单独的库（称为迷你库）时，库包的维护、扩展和测试是最容易的。在大多数情况下，每个类都应该在自己的迷你库中，除非你有两个类是紧密耦合的情况。</p>
<p>注意：你可能听说过 <code>part</code> 指令，它允许你将一个库分割成多个 Dart 文件。我们建议你避免使用 <code>part</code> 指令，而是创建迷你库。</p>
<p>直接在 <code>lib</code> 下创建一个&quot;主&quot;库文件，<code>lib/&lt;package-name&gt;.dart</code>，导出所有的公共 API。这样用户就可以通过导入一个文件来获得一个库的所有功能。</p>
<p><code>lib</code> 目录也可能包含其他可导入的、非src的库。例如，也许你的主库可以跨平台使用，但是你创建了单独的库，这些库依赖于 <code>dart:io</code> 或者 <code>dart:html</code>。有些包有单独的库，这些库是要用前缀导入的，而主库不是。</p>
<p>让我们来看看一个现实世界中的库包的组织： shelf。<a href="https://github.com/dart-lang/shelf">shelf</a> 包提供了一种使用 Dart 创建 web 服务器的简单方法，它的布局结构是 Dart 库包常用的:</p>
<p><img src="https://dart.dev/assets/libraries/shelf-02e5fd43b660fcef7dbe6a883c40159e0379c8ee2088288ca60ed7dc8781bafd.png" alt="img"></p>
<p>直接在 <code>lib</code> 下，主库文件 <code>shelf.dart</code> 从 <code>lib/src</code> 导出几个文件:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/cascade.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/handler.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/handlers/logger.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/hijack_exception.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/middleware.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/pipeline.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/request.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/response.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/server.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/server_handler.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>shelf 包还包含一个迷你库： <code>shelf_io</code>。这个适配器处理来自 <code>dart:io</code> 的 <code>HttpRequest</code> 对象。</p>
<p>对网络应用的提示: 为了在使用 <a href="https://dart.dev/tools/dartdevc">dartdevc</a> 开发时获得最佳性能，请将<a href="https://dart.dev/tools/pub/package-layout#implementation-files">实现文件</a>放在 <code>/lib/src</code> 下，而不是放在 <code>/lib</code> 下的其他地方。同时，避免导入 <code>package:package_name/src/...</code> 的文件。</p>
<h2 id="导入库文件">导入库文件</h2>
<p>当从其他包中导入一个库文件时，使用 <code>package:</code> 指令来指定该文件的 URI。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:utilities/utilities.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>当从自己的包中导入一个库文件时，当两个文件都在 lib 内，或者两个文件都在 lib 外时，使用相对路径。使用 <code>:package</code> 当导入的文件在 lib 内，而导入者在 lib 外时。</p>
<p>下图显示了如何从 lib 和 web 中导入 <code>lib/foo/a.dart</code>。</p>
<p><img src="https://dart.dev/assets/libraries/import-lib-rules-e1777e235dd56aa23f770babcccedb6a12be80af2c3e63065640b889d78be595.png" alt="img"></p>
<h2 id="有条件地导入和导出库文件">有条件地导入和导出库文件</h2>
<p>如果你的库支持多个平台，那么你可能需要有条件地导入或导出库文件。一个常见的用例是一个同时支持 web 和原生平台的库。</p>
<p>要有条件的导入或导出，你需要检查 <code>dart:*</code> 库的存在。下面是一个有条件导出代码的例子，它检查 <code>dart:io</code> 和 <code>dart:html</code> 的存在:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">export</span> <span class="s1">&#39;</span><span class="s1">src/hw_none.dart</span><span class="s1">&#39;</span> <span class="err">/</span><span class="err">/</span> <span class="n">Stub</span> <span class="n">implementation</span>
    <span class="n">if</span> <span class="err">(</span><span class="n">dart</span><span class="err">.</span><span class="n">library</span><span class="err">.</span><span class="n">io</span><span class="err">)</span> <span class="s1">&#39;</span><span class="s1">src/hw_io.dart</span><span class="s1">&#39;</span> <span class="err">/</span><span class="err">/</span> <span class="n">dart</span><span class="err">:</span><span class="n">io</span> <span class="n">implementation</span>
    <span class="n">if</span> <span class="err">(</span><span class="n">dart</span><span class="err">.</span><span class="n">library</span><span class="err">.</span><span class="n">html</span><span class="err">)</span> <span class="s1">&#39;</span><span class="s1">src/hw_html.dart</span><span class="s1">&#39;</span><span class="p">;</span> <span class="c1">// dart:html implementation
</span></code></pre></div><p>下面是这段代码的作用。</p>
<ul>
<li>在一个可以使用 <code>dart:io</code> 的应用程序中(例如，一个命令行应用程序)，导出 <code>src/hw_io.dart</code></li>
<li>在一个可以使用 <code>dart:html</code> 的应用程序中(一个 web 应用程序)，导出 <code>src/hw_html.dart</code></li>
<li>否则，导出 <code>src/hw_none.dart</code></li>
</ul>
<p>要有条件地导入一个文件，使用与上面相同的代码，但将 <code>exporrt</code> 改为 <code>import</code>。</p>
<p>注意：有条件的导入或导出只检查库在当前平台上是否可用，而不是检查是否实际导入或使用。</p>
<p>所有有条件导出的库都必须实现相同的 API。例如，这里是 <code>dart:io</code> 的实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">alarm</span><span class="p">(</span><span class="p">[</span><span class="kt">String</span> <span class="n">text</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">stderr</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span><span class="n">text</span> <span class="o">?</span><span class="o">?</span> <span class="n">message</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">String</span> <span class="kd">get</span> <span class="n">message</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">Hello World from the VM!</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>这里是默认的实现，它是一个抛出 UnsupportedErrors 的 stub。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">alarm</span><span class="p">(</span><span class="p">[</span><span class="kt">String</span> <span class="n">text</span><span class="p">]</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="k">throw</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">hw_none alarm</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="kt">String</span> <span class="kd">get</span> <span class="n">message</span> <span class="o">=</span><span class="o">&gt;</span> <span class="k">throw</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">hw_none message</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>在任何平台上，你都可以导入有条件导出代码的库。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:hw_mp/hw_mp.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="提供补充文件">提供补充文件</h2>
<p>一个设计良好的库包是很容易测试的。我们建议你使用 <a href="https://github.com/dart-lang/test">test</a> 包来编写测试，将测试代码放在测试包顶部的 <code>test</code> 目录中。</p>
<p>如果你创建了任何旨在供公众使用的命令行工具，请将这些工具放在 <code>bin</code> 目录下，这是公共的。启用从命令行运行工具，使用 <a href="https://dart.dev/tools/pub/cmd/pub-global#activating-a-package">pub global activate</a>。将工具列在 pubspec 的<a href="https://dart.dev/tools/pub/pubspec#executables">可执行文件部分</a>，允许用户直接运行它，而无需调用 <a href="https://dart.dev/tools/pub/cmd/pub-global#running-a-script-using-pub-global-run">pub global run</a>。</p>
<p>如果你包含了一个如何使用你的库的例子，这将会很有帮助。这将被放入软件包顶部的 <code>example</code> 目录中。</p>
<p>你在开发过程中创建的任何工具或可执行文件，如果不是公开使用的，都会进入 <code>tool</code> 目录。</p>
<p>如果你把你的库发布到 pub.dev 站点，其他需要的文件，如 <code>README.md</code> 和 <code>CHANGELOG.md</code>，将在<a href="https://dart.dev/tools/pub/publishing">发布软件包</a>中描述。有关如何组织包目录的更多信息，请参见 <a href="https://dart.dev/tools/pub/package-layout">pub 包布局惯例</a>。</p>
<h2 id="编写库文档">编写库文档</h2>
<p>你可以使用 <a href="https://github.com/dart-lang/dartdoc#dartdoc">dartdoc</a> 工具为你的库生成 API 文档。Dartdoc 解析源码寻找<a href="https://dart.dev/guides/language/effective-dart/documentation#doc-comments">文档注释</a>，其中使用了 <code>///</code> 语法:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">/// The event handler responsible for updating the badge in the UI.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">updateBadge</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>关于生成文档的例子，请看 <a href="https://pub.dev/documentation/shelf/latest">shelf 文档</a>。</p>
<p>注意：要在生成的文档中包含任何库级文档，你必须指定 <code>library</code> 指令。请参阅 <a href="https://github.com/dart-lang/dartdoc/issues/1082">问题 1082</a>。</p>
<h2 id="分发一个开源库">分发一个开源库</h2>
<p>如果你的库是开源的，我们建议在 <a href="https://pub.dev/">pub.dev</a> 站点上分享它。要发布或更新库，请使用 <a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a>，它可以上传您的包并创建或更新其页面。例如，请看 <a href="https://pub.dev/packages/shelf">shelf 包</a>的页面。有关如何准备发布软件包的详细信息，请参见<a href="https://dart.dev/tools/pub/publishing">发布包</a>。</p>
<p>pub.dev 站点不仅托管您的软件包，而且还生成和托管您软件包的 API 参考文档。最新生成的文档的链接在软件包的 <strong>About</strong> 框中；例如，请看 shelf 包的 <a href="https://pub.dev/documentation/shelf">API 文档</a>。到以前版本的文档的链接在软件包页面的版本选项卡中。</p>
<p>要确保你的软件包的 API 文档在 pub.dev 网站上看起来不错，请按照以下步骤进行。</p>
<ul>
<li>在发布你的软件包之前，运行 <a href="https://github.com/dart-lang/dartdoc#dartdoc">dartdoc</a> 工具，以确保你的 docs 成功生成，并且看起来符合预期。</li>
<li>发布软件包后，检查 <strong>Versions</strong> 选项卡以确保文档成功生成。</li>
<li>如果文档根本没有生成，点击 <strong>Verrsions</strong> 选项卡中的 <strong>failed</strong>，查看 dartdoc 的输出。</li>
</ul>
<h2 id="资源">资源</h2>
<p>使用以下资源了解更多关于库包的信息。</p>
<ul>
<li><a href="https://dart.dev/guides/language/language-tour">语言之旅</a>中的<a href="https://dart.dev/guides/language/language-tour#libraries-and-visibility">库和可见性</a>包括使用库文件。</li>
<li><a href="https://dart.dev/guides/packages">包</a>文档很有用，特别是<a href="https://dart.dev/tools/pub/package-layout">包的布局约定</a>。</li>
<li><a href="https://dart.dev/guides/libraries/private-files">不应提交的内容</a>涵盖了哪些不应该被检查到源代码库中。</li>
<li><a href="https://github.com/dart-lang">dart-lang</a> 组织下的较新的库包倾向于展示最佳实践。可以考虑研究这些例子：<a href="https://github.com/dart-lang/dart_style">dart_style</a>、<a href="https://github.com/dart-lang/path">path</a>、<a href="https://github.com/dart-lang/shelf">shelf</a>、<a href="https://github.com/dart-lang/source_gen">source_gen</a> 和 <a href="https://github.com/dart-lang/test">test</a>。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[发布包]]></title>
            <link href="https://ohmyweekly.github.io/notes/publishing-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/creating-packages/?utm_source=atom_feed" rel="related" type="text/html" title="创建包" />
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-http-clients/?utm_source=atom_feed" rel="related" type="text/html" title="编写HTTP客户端和服务器" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/publishing-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-30T00:00:00+08:00</published>
            <updated>2020-06-30T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Publishing packages</blockquote><p><a href="https://dart.dev/guides/packages">pub 软件包管理器</a>不仅仅是用来使用别人的软件包。它还允许你与世界分享你的软件包。如果您有一个有用的项目，并且您希望其他人能够使用它，请使用 <code>pub publish</code> 命令。</p>
<p>注意: 如果要发布到 pub.dev 以外的其他位置，或者要防止在任何地方发布，请使用 <a href="https://dart.dev/tools/pub/pubspec">pubspec</a> 中定义的  <code>publish_to</code> 字段。</p>
<h2 id="发布是永远的">发布是永远的</h2>
<p>请记住，发布是永远的。只要你发布你的包，用户就可以依赖它。一旦他们开始这样做，删除包就会破坏他们的包。为了避免这种情况，<a href="https://pub.dev/policy">pub.dev 政策</a>不允许取消发布软件包，除非是极少数情况。</p>
<p>你可以随时上传你的包的新版本，但旧的包将继续为那些还没有准备好升级的用户提供服务。</p>
<p>对于已经发布的包，如果不再相关或正在维护，你可以<a href="https://dart.dev/tools/pub/publishing#discontinue">将其标记为停止发布</a>。</p>
<h2 id="准备发布">准备发布</h2>
<p>当发布一个软件包时，遵循 <a href="https://dart.dev/tools/pub/pubspec">pubspec 格式</a>和<a href="https://dart.dev/tools/pub/package-layout">包布局惯例</a>是很重要的。其中有些是必须的，以便其他人能够使用你的软件包。另一些则是为了帮助用户更容易理解和使用您的软件包而提出的建议。在这两种情况下，pub 都会尝试帮助你，指出哪些改变会帮助你的软件包在 Dart 生态系统中发挥得更好。上传包有一些额外的要求:</p>
<ul>
<li>
<p>你必须包含一个包含<a href="https://opensource.org/">开源许可证</a>的 <code>LICENSE</code> 文件。我们推荐 <a href="https://opensource.org/licenses/BSD-3-Clause">BSD 许可证</a>，这是 Dart 自己使用的。你也必须有合法的权利来重新发布你上传的任何东西作为你的包的一部分。</p>
</li>
<li>
<p>你的软件包在经过 gzip 压缩后必须小于 10 MB。如果太大，可以考虑将其分割成多个包，或者减少包含的资源或例子的数量。</p>
</li>
<li>
<p>你的包应该只依赖托管的依赖项(来自默认的 pub 包服务器)和 SDK 依赖项(<code>sdk: flutter</code>)。这些限制确保了你的包的依赖性不会在未来变得不可用。</p>
</li>
<li>
<p>您必须有一个 <a href="https://support.google.com/accounts/answer/27441">Google 帐户</a>，pub 用来管理包的上传权限。您的 Google 账户可以与 Gmail 地址或任何其他电子邮件地址关联。</p>
</li>
</ul>
<p>注意：除非您使用<a href="https://dart.dev/tools/pub/verified-publishers">已验证的发布者</a>发布，否则 pub.dev 会显示与您的 Google 帐户关联的电子邮件地址。</p>
<h3 id="重要文件">重要文件</h3>
<p>Pub 使用一些文件的内容为你的包创建一个页面，地址是 <code>pub.dev/packages/&lt;your_package&gt;</code>。以下是影响你的包的页面外观的文件。</p>
<ul>
<li>README.md: <code>README.md</code> 文件是你的包页面中的主要内容。该文件的内容以 <a href="https://pub.dev/packages/markdown">Markdown</a> 的形式呈现。</li>
<li>CHANGELOG.md：<code>CHANGELOG.md</code> 文件是你的包页面中的主要内容。你的包的 <code>CHANGELOG.md</code> 文件，如果找到的话，也会在你的包页面的一个标签中显示，这样开发者就可以直接从 pub.dev 中读取它。该文件的内容会以 <a href="https://pub.dev/packages/markdown">Markdown</a> 的形式呈现。</li>
<li>pubspec: 你的包的 <code>pubspec.yaml</code> 文件用来在你的包的页面右侧填写关于你的包的详细信息，比如它的描述、主页等。</li>
</ul>
<h3 id="使用经过验证的发布者的优势">使用经过验证的发布者的优势</h3>
<p>您可以使用已验证的发布者（推荐）或独立的谷歌账户发布软件包。使用经过验证的发布者有以下优势。</p>
<ul>
<li>您的包的消费者知道发布者的域名已经被验证。</li>
<li>您可以避免让 pub.dev 显示您的个人电子邮件地址。取而代之的是，pub.dev会显示发布者的域名和联系地址。</li>
<li>经验证的发布者徽章 pub.dev 经验证的发布者标识会在搜索页面和单个软件包页面上显示在您的软件包名称旁边。</li>
</ul>
<h3 id="创建一个验证过的发布者">创建一个验证过的发布者</h3>
<p>要创建一个已验证的发布者，请按照以下步骤进行。</p>
<ol>
<li>进入 <a href="https://pub.dev/">pub.dev</a>。</li>
<li>使用 Google 账户登录 pub.dev。</li>
<li>在右上角的用户菜单中，选择创建发布者。</li>
<li>输入您要与您的发布者相关联的域名(例如，<code>dart.dev</code>)，然后单击&quot;创建发布者&rdquo;。</li>
<li>在确认对话框中，选择&quot;确定&rdquo;。</li>
<li>如果提示，完成验证流程，这将打开 <a href="https://search.google.com/search-console/about">Google 搜索控制台</a>。</li>
</ol>
<ul>
<li>在添加 DNS 记录时，可能需要几个小时后，搜索控制台才会反映出变化。</li>
<li>验证流程完成后，返回步骤4。</li>
</ul>
<h2 id="发布你的包">发布你的包</h2>
<p>使用 <a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a> 命令来首次发布您的软件包，或将其更新到新版本。</p>
<h3 id="执行-dry-run">执行 dry run</h3>
<p>为了测试 <code>pub publish</code> 的工作情况，你可以进行一次 dry run:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ pub publish --dry-run
</code></pre></div><p>Pub 会确保你的软件包遵循 <a href="https://dart.dev/tools/pub/pubspec">pubspec 格式</a>和<a href="https://dart.dev/tools/pub/package-layout">包布局约定</a>，然后将你的软件包上传到 <a href="https://pub.dev/">pub.dev</a>。Pub 还会向你展示它打算发布的所有文件。下面是一个发布名为 <code>transmogrify</code> 的软件包的例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">Publishing<span class="w"> </span>transmogrify<span class="w"> </span><span class="m">1.0</span><span class="m">.0</span><span class="w">
</span><span class="w">    </span>.gitignore<span class="w">
</span><span class="w">    </span>CHANGELOG.md<span class="w">
</span><span class="w">    </span>README.md<span class="w">
</span><span class="w">    </span>lib<span class="w">
</span><span class="w">        </span>transmogrify.dart<span class="w">
</span><span class="w">        </span>src<span class="w">
</span><span class="w">            </span>transmogrifier.dart<span class="w">
</span><span class="w">            </span>transmogrification.dart<span class="w">
</span><span class="w">    </span>pubspec.yaml<span class="w">
</span><span class="w">    </span>test<span class="w">
</span><span class="w">        </span>transmogrify_test.dart<span class="w">
</span><span class="w">
</span><span class="w"></span>Package<span class="w"> </span>has<span class="w"> </span><span class="m">0</span><span class="w"> </span>warnings.<span class="w">
</span></code></pre></div><h3 id="发布">发布</h3>
<p>当你准备好发布你的包时，请删除 <code>--dry-run</code> 参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ pub publish
</code></pre></div><p>注意: pub 命令目前不支持直接将新软件包发布到已验证的发布者。作为一个临时的变通方法，可以将新的软件包发布到Google账户，然后将包<a href="https://dart.dev/tools/pub/publishing#transferring-a-package-to-a-verified-publisher">转移到发布者</a>。</p>
<p>一旦软件包被转移到发布者，你就可以使用 <code>pub publish</code> 更新软件包。</p>
<p>当你的包成功上传到 pub.dev 后，任何 pub 用户都可以下载它或在他们的项目中依赖它。例如，如果你刚刚发布了 1.0.0 版本的 <code>transmogrify</code> 包，那么另一个 Dart 开发者可以在他们的 <code>pubspec.yaml</code> 中添加它作为依赖:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">dependencies</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">transmogrify</span><span class="p">:</span><span class="w"> </span>^<span class="m">1.0</span><span class="m">.0</span><span class="w">
</span></code></pre></div><h3 id="将软件包传输给已验证的发布者">将软件包传输给已验证的发布者</h3>
<p>要将一个软件包转移到已验证的发布者，您必须是该软件包的<a href="https://dart.dev/tools/pub/publishing#uploaders">上传者</a>和已验证发布者的管理员。</p>
<p>注意：这个过程是不可逆的。一旦你将一个软件包转移到一个发布者，你不能将它转移回个人账户。</p>
<p>以下是如何将软件包转移到已验证的发布者:</p>
<ol>
<li>用一个被列为软件包上传者的 Google 账户登录到 <a href="https://pub.dev/">pub.dev</a>。</li>
<li>进入软件包的详细信息页面(例如，<code>https://pub.dev/packages/http</code>)。</li>
<li>选择&quot;管理&quot;选项卡。</li>
<li>输入发布者的名称，然后单击&quot;传输到发布者&rdquo;。</li>
</ol>
<h3 id="哪些文件会被发布">哪些文件会被发布？</h3>
<p>您的软件包中的<strong>所有</strong>文件都包含在已发布的软件包中，但有以下例外:</p>
<ul>
<li>任何包的目录。</li>
<li>您的软件包的 <a href="https://dart.dev/tools/pub/glossary#lockfile">lockfile</a> 文件。</li>
<li>如果你没有使用 Git，所有隐藏的文件（也就是名字以 <code>.</code> 开头的文件）。</li>
<li>如果使用 Git，则是所有被 <code>.gitignore</code> 文件忽略的文件。</li>
</ul>
<p>请确保删除任何你不想包含的文件(或将它们添加到 <code>.gitignore</code> 中)。 <code>pub publish</code> 在上传你的包之前列出了它要发布的所有文件，所以在完成上传之前要仔细检查列表。</p>
<h2 id="上传者">上传者</h2>
<p>谁发布了软件包的第一个版本，谁就会自动成为第一个也是唯一一个被授权上传该软件包其他版本的人。要允许或不允许其他人上传版本，请使用 <a href="https://dart.dev/tools/pub/cmd/pub-uploader">pub uploader</a> 命令或将软件包转移到<a href="https://dart.dev/tools/pub/verified-publishers">已验证的发布者</a>那里。</p>
<p>如果一个软件包有一个经过验证的发布者，那么该软件包的 pub.dev 页面会显示发布者的域名。否则，该页面将显示该软件包的授权上传者的电子邮件地址。</p>
<h2 id="发布预发包">发布预发包</h2>
<p>当你在做一个包的时候，考虑把它作为一个预发布。当以下任何一种情况发生时，预发布都是有用的。</p>
<ul>
<li>你正在积极开发软件包的下一个主要版本。</li>
<li>你想为软件包的下一个发行候选版本招募测试者。</li>
<li>该包依赖于 Dart 或 Flutter SDK 的不稳定版本。</li>
</ul>
<p>正如在<a href="https://semver.org/spec/v2.0.0-rc.1.html">语义版本化</a>中所描述的那样，为了使一个版本的预发布，你要给版本附加一个后缀。例如，要对 <code>2.0.0</code> 版本进行预发布，你可以使用 <code>2.0.0-dev.1</code> 版本。以后，当你发布 <code>2.0.0</code> 版本时，它将优先于所有 <code>2.0.0-XXX</code> 预发布版本。</p>
<p>因为 pub 更倾向于在可用的时候发布稳定版，所以一个预发布包的用户可能需要改变他们的依赖约束。例如，如果用户想要测试 2.1 版本的预发布包，那么他们可以指定 <code>^2.1.0-dev.1</code>，而不是 <code>^2.0.0</code> 或 <code>^2.1.0</code>。</p>
<p>注意: 如果依赖关系图中的稳定包依赖于一个 prerelease，那么 pub 会选择那个 prerelease 而不是稳定版本。</p>
<p>当一个 prerelease 被发布到 pub.dev 时，软件包页面会同时显示到 prerelease 和稳定版的链接。prerelease 不会影响分析得分，不会出现在搜索结果中，也不会替换包的 <code>README.md</code> 和文档。</p>
<h2 id="将软件包标记为已停产的软件包">将软件包标记为已停产的软件包</h2>
<p>尽管软件包总是保持发布，但向开发者发出信号，表明一个软件包不再被积极维护，是很有用的。为此，您可以将一个软件包标记为 <code>discontinued</code>。一个已停用的软件包仍然可以在 pub.dev 上发布和查看，但它有一个清晰的 DISCONTINUED 徽章，并且不会出现在 pub.dev 的搜索结果中。</p>
<p>要将软件包标记为已停用，请使用该软件包的上传者或已验证的发布者管理员的 Google 帐户登录 pub.dev。然后使用单个软件包的管理选项卡将该软件包标记为已停用。</p>
<h2 id="资源">资源</h2>
<p>有关更多信息，请参见以下 pub 命令的参考页面。</p>
<ul>
<li><a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-uploader">pub uploader</a></li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[编写HTTP客户端和服务器]]></title>
            <link href="https://ohmyweekly.github.io/notes/write-http-clients/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/creating-packages/?utm_source=atom_feed" rel="related" type="text/html" title="创建包" />
                <link href="https://ohmyweekly.github.io/notes/publishing-packages/?utm_source=atom_feed" rel="related" type="text/html" title="发布包" />
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/write-http-clients/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-30T00:00:00+08:00</published>
            <updated>2020-06-30T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Write HTTP clients &amp; servers</blockquote><p>有什么意义呢？</p>
<ul>
<li>HTTP 协议允许客户端和服务器进行通信。</li>
<li>dart:io 包有编写 HTTP 程序的类。</li>
<li>服务器监听主机和端口上的请求。</li>
<li>客户端使用 HTTP 方法请求发送请求。</li>
<li>http_server 包提供了更高级别的构件。</li>
</ul>
<p>前提条件: HTTP 服务器和客户端严重依赖 future 和流，本教程中没有解释这些内容。你可以从<a href="https://dart.dev/codelabs/async-await">异步编程 codelab</a>和<a href="https://dart.dev/tutorials/language/streams">流教程</a>中了解它们。</p>
<p>HTTP（超文本传输协议）是一种通信协议，用于通过互联网将数据从一个程序发送到另一个程序。数据传输的一端是服务器，另一端是客户端。客户端通常是基于浏览器的（用户在浏览器中输入或在浏览器中运行的脚本），但也可能是一个独立的程序。</p>
<p>服务器与主机和端口绑定（它与一个IP地址和一个端口号建立专属连接）。然后服务器监听请求。由于 Dart 的异步性，服务器可以同时处理很多请求，具体如下。</p>
<ul>
<li>服务器监听</li>
<li>客户端连接</li>
<li>服务器接受并接收请求(并继续监听)</li>
<li>服务器可以继续接受其他请求</li>
<li>服务器写入请求的响应或几个请求，可能是交错的请求</li>
<li>服务器最终结束(关闭)响应</li>
</ul>
<p>在 Dart 中，<a href="https://api.dart.dev/stable/dart-io/dart-io-library.html">dart:io</a> 库包含了编写 HTTP 客户端和服务器所需的类和函数。此外，<a href="https://pub.dev/packages/http_server">http_server</a> 包包含了一些更高层次的类，使其更容易编写客户端和服务器。</p>
<p>重要：基于浏览器的程序不能使用 dart:io 库。</p>
<p>dart:io 库中的 API 只适用于独立的命令行程序。它们不能在浏览器中工作。要从基于浏览器的客户端发出 HTTP 请求，请参考 <a href="https://api.dart.dev/stable/dart-html/HttpRequest-class.html">dart:html HttpRequest</a> 类。</p>
<p>本教程提供了几个例子，说明编写 Dart HTTP 服务器和客户端是多么容易。从服务器的 <code>hello world</code> 开始，你将学习如何编写服务器的代码，从绑定和监听到响应请求。你还可以学习到客户端：提出不同类型的请求(GET 和 POST)，编写基于浏览器和命令行的客户端。</p>
<h2 id="获取源码">获取源码</h2>
<ul>
<li>获取 Dart 教程的<a href="https://github.com/dart-lang/dart-tutorials-samples/archive/master.zip">示例代码</a>。</li>
<li>查看 <code>httpserver</code> 目录，其中包含本教程所需的源码。</li>
</ul>
<h2 id="运行-hello-world-服务器">运行 hello world 服务器</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/hello_world_server.dart">hello_world_server.dart</a>。</p>
<p>让我们从一个小型的服务器开始，用字符串 <code>Hello, world</code> 来响应所有的请求。</p>
<p>在命令行中，运行 <code>hello_world_server.dart</code> 脚本:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">$</span> <span class="n">cd</span> <span class="n">httpserver</span>
<span class="n">$</span> <span class="n">dart</span> <span class="n">bin</span><span class="o">/</span><span class="n">hello_world_server</span><span class="p">.</span><span class="n">dart</span>
<span class="n">listening</span> <span class="n">on</span> <span class="n">localhost</span><span class="p">,</span> <span class="n">port</span> <span class="m">4040</span>
</code></pre></div><p>在任何浏览器中，访问 <a href="http://localhost:4040/">localhost:4040</a>。浏览器会显示 <code>Hello, world!</code>。</p>
<p><img src="https://dart.dev/tutorials/server/images/hello_world_response.png" alt="img"></p>
<p>在这种情况下，服务器是一个 Dart 程序，客户端是你使用的浏览器。然而，你可以用 Dart 编写客户端程序-无论是基于浏览器的客户端脚本，还是独立的程序。</p>
<h3 id="快速浏览一下代码">快速浏览一下代码</h3>
<p>在 <code>hello world</code> 服务器的代码中，一个 HTTP 服务器与主机和端口绑定，监听 HTTP 请求，并写入响应。需要注意的是，该程序导入了 <a href="https://api.dart.dev/stable/dart-io/dart-io-library.html">dart:io</a> 库，其中包含了服务器端程序和客户端程序的 HTTP 相关类(但不包含 Web 应用)。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span>
    <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span>
    <span class="m">4040</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Listening on localhost:</span><span class="si">${</span><span class="n">server</span><span class="p">.</span><span class="n">port</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello, world!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>接下来的几节内容包括服务器端绑定、发出客户端 GET 请求、监听和响应。</p>
<h2 id="将服务器绑定到主机和端口">将服务器绑定到主机和端口</h2>
<p>本节示例：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/hello_world_server.dart">hello_world_server.dart</a>。</p>
<p><code>main()</code> 中的第一条语句使用 <code>HttpServer.bind()</code> 创建一个 <a href="https://api.dart.dev/stable/dart-io/HttpServer-class.html">HttpServer</a> 对象，并将其绑定到主机和端口。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span>
  <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span>
  <span class="m">4040</span><span class="p">,</span>
<span class="p">)</span><span class="p">;</span>
</code></pre></div><p>该代码使用 <code>await</code> 异步调用 <code>bind</code> 方法。</p>
<h3 id="主机名">主机名</h3>
<p><code>bind()</code> 的第一个参数是指定主机名。你可以用一个字符串来指定一个特定的主机名或IP地址，也可以用 <a href="https://api.dart.dev/stable/dart-io/InternetAddress-class.html">InternetAddress</a> 类提供的这些预定义的值来指定主机。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">用例</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">回环 IPv4 或 loopbackIPv6</td>
<td align="left">服务器在 loopback 地址上监听客户端活动，该地址实际上是 localhost。使用IP协议的4或6版本。这些主要用于测试。我们建议您使用这些值而不是 <code>localhost</code> 或 <code>127.0.0.1</code>。</td>
</tr>
<tr>
<td align="left">任何 IPv4 或 anyIPv6</td>
<td align="left">服务器监听任何 IP 地址上指定端口上的客户端活动。使用IP协议的4或6版本。</td>
</tr>
</tbody>
</table>
<p>默认情况下，当使用V6互联网地址时，也会使用V4监听器。</p>
<h3 id="端口">端口</h3>
<p><code>bind()</code> 的第二个参数是指定端口的整数。端口唯一地标识主机上的服务。1024 以下的端口号为标准服务保留(0除外)。例如，FTP 数据传输通常在端口20上运行，每日报价在端口17上运行，HTTP 在端口80上运行。你的程序应该使用1024以上的端口号。如果端口已经在使用中，你的服务器的连接将被拒绝。</p>
<h3 id="侦听请求">侦听请求</h3>
<p>服务器使用 <code>await for</code> 开始监听 HTTP 请求。每收到一个请求，代码就会发送一个 &ldquo;Hello, world!&rdquo; 的响应。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello, world!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>你将在<a href="https://dart.dev/tutorials/server/httpserver#httprequest-object">监听和处理请求</a>一节中了解更多关于 <a href="https://api.dart.dev/stable/dart-io/HttpRequest-class.html">HttpRequest</a> 对象包含的内容以及如何编写响应。但首先，让我们看看客户端产生请求的一种方式。</p>
<h2 id="使用-html-表单发出-get-请求">使用 HTML 表单发出 GET 请求</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/number_thinker.dart">number_thinker.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/make_a_guess.html">make_a_guess.html</a>。</p>
<p>本节介绍了一个命令行服务器，它可以随机选择一个0到9之间的数字。客户端是一个基本的 HTML 网页，<code>make_a_guess.html</code>，你可以用它来猜数字。</p>
<p>试试吧</p>
<ol>
<li>运行数字思考者服务器</li>
</ol>
<p>在命令行，运行 <code>number_thinker.dart</code> server。你应该看到类似下面的东西:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/number_thinker.dart
I<span class="err">&#39;</span>m thinking of a number: <span class="m">6</span>
</code></pre></div><ol start="2">
<li>启动网络服务器</li>
</ol>
<p>从应用程序的顶部目录运行 <code>webdev serve</code>。</p>
<p>更多信息：<a href="https://dart.dev/tools/webdev">webdev 文档</a></p>
<ol start="3">
<li>打开 HTML 页面</li>
</ol>
<p>在浏览器中，进入 <a href="http://localhost:8080/make_a_guess.html">localhost:8080/make_a_guess.html</a>。</p>
<ol start="4">
<li>做一个猜测</li>
</ol>
<p>选择一个数字，然后按猜测按钮。</p>
<p><img src="https://dart.dev/tutorials/server/images/guessing.png" alt="img"></p>
<p>在客户端中没有涉及到 Dart 代码。客户端请求是通过浏览器向 Dart 服务器发出的，在 <code>make_a_guess.html</code> 中的 HTML 表单，它提供了一个自动制定和发送客户端 HTTP 请求的方法。该表单包含下拉列表和按钮。该表单还指定了 URL，其中包括端口号，以及请求的种类（请求方法）。它还可能包含建立查询字符串的元素。</p>
<p>下面是 <code>make_a_guess.html</code> 中的表单 HTML。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;http://localhost:4041&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;GET&#34;</span><span class="p"></span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">select</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;q&#34;</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;0&#34;</span><span class="p"></span><span class="p">&gt;</span>0<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;1&#34;</span><span class="p"></span><span class="p">&gt;</span>1<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;2&#34;</span><span class="p"></span><span class="p">&gt;</span>2<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="c">&lt;!--</span><span class="c"> ··· </span><span class="c">--&gt;</span>
    <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;9&#34;</span><span class="p"></span><span class="p">&gt;</span>9<span class="p">&lt;</span><span class="p">/</span><span class="nt">option</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">select</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;submit&#34;</span> <span class="na">value</span><span class="o">=</span><span class="s">&#34;Guess&#34;</span><span class="p"></span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="p">/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div><p>下面是表单的工作原理:</p>
<ul>
<li>表单的 <code>action</code> 属性被分配给发送请求的 URL</li>
<li>表单的 <code>method</code> 属性定义了请求的类型，这里是 <code>GET</code>。其他常见的请求类型包括 POST、PUT 和 DELETE。</li>
<li>表单中任何有名称(<code>name</code>)的元素，比如 <code>&lt;select&gt;</code> 元素，都会成为查询字符串中的一个参数。</li>
<li>当按下提交按钮(<code>&lt;input type=&quot;submit&quot;...&gt;</code>)时，提交按钮会根据表单的内容制定请求并发送。</li>
</ul>
<h3 id="一个-restful-get-请求">一个 RESTful GET 请求</h3>
<p>REST(REpresentational State Transfer)是一套设计 Web 服务的原则。乖巧的 HTTP 客户端和服务器遵守为 GET 请求定义的 REST 原则。</p>
<p>一个 GET 请求:</p>
<ul>
<li>只检索数据</li>
<li>不会改变服务器的状态</li>
<li>有长度限制</li>
<li>可以在请求的 URL 中发送查询字符串</li>
</ul>
<p>在这个例子中，客户端发出了一个符合 REST 的 GET 请求。</p>
<h2 id="监听和处理请求">监听和处理请求</h2>
<p>本节的示例文件: <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/number_thinker.dart">number_thinker.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/make_a_guess.html">make_a_guess.html</a>。</p>
<p>现在你已经看到这个基于浏览器的客户端的例子，让我们看看数字思维服务器的 Dart 代码，从 <code>main()</code> 开始。</p>
<p>再一次，服务器绑定了一个主机和端口。在这里，每收到一个请求都会调用顶层的 <code>handleRequest()</code> 方法。因为 HttpServer 实现了 <a href="https://api.dart.dev/stable/dart-async/Stream-class.html">Stream</a>，所以可以使用 <code>await for</code> 来处理请求。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:math</span><span class="s1">&#39;</span> <span class="k">show</span> <span class="n">Random</span><span class="p">;</span>

<span class="n">Random</span> <span class="n">intGenerator</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">myNumber</span> <span class="o">=</span> <span class="n">intGenerator</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">I&#39;m thinking of a number: </span><span class="si">$</span><span class="n">myNumber</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">HttpServer</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span>
    <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span>
    <span class="m">4041</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">handleRequest</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>当一个 <code>GET</code> 请求到达时，<code>handleRequest()</code> 方法会调用 <code>handleGet()</code> 来处理该请求。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleRequest</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">GET</span><span class="s1">&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">handleGet</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// ···
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Exception in handleRequest: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Request handled.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>一个 <a href="https://api.dart.dev/stable/dart-io/HttpRequest-class.html">HttpRequest</a> 对象有很多属性，提供了关于请求的信息。下表列出了一些有用的属性。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">信息</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">method</td>
<td align="left">&lsquo;GET&rsquo;, &lsquo;POST&rsquo;, &lsquo;PUT&rsquo; 等方法中的一个。</td>
</tr>
<tr>
<td align="left">uri</td>
<td align="left">一个 <a href="https://api.dart.dev/stable/dart-core/Uri-class.html">Uri</a> 对象：scheme、host、port、query string 和其他关于请求资源的信息。</td>
</tr>
<tr>
<td align="left">response</td>
<td align="left">一个 <a href="https://api.dart.dev/stable/dart-io/HttpResponse-class.html">HttpResponse</a> 对象：服务器将其响应写入其中。</td>
</tr>
<tr>
<td align="left">headers</td>
<td align="left">一个 <a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a> 对象：请求的头信息，包括 <a href="https://api.dart.dev/stable/dart-io/ContentType-class.html">ContentType</a>、内容长度、日期等。</td>
</tr>
</tbody>
</table>
<h3 id="使用方法属性">使用方法属性</h3>
<p>下面的数想器例子中的代码使用 HttpRequest 的 <code>method</code> 属性来确定收到了什么样的请求。这个服务器只处理 GET 请求。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">GET</span><span class="s1">&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">handleGet</span><span class="p">(</span><span class="n">request</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">request</span><span class="p">.</span><span class="n">response</span>
    <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">methodNotAllowed</span>
    <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Unsupported request: </span><span class="si">${</span><span class="n">request</span><span class="p">.</span><span class="n">method</span><span class="si">}</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="p">.</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="使用-uri-属性">使用 uri 属性</h3>
<p>在浏览器中输入一个 URL 会产生一个 GET 请求，它只是简单地从指定的资源中请求数据。它可以通过附加在 URI 上的查询字符串随请求发送少量数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleGet</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">uri</span><span class="p">.</span><span class="n">queryParameters</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">q</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
  <span class="c1">// ···
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>使用 HttpRequest 对象的 <code>uri</code> 属性来获取一个 <a href="https://api.dart.dev/stable/dart-core/Uri-class.html">Uri</a> 对象，这个 Uri 对象包含了用户输入的 URL 的信息。Uri 对象的 <code>queryParameters</code> 属性是一个 Map，包含查询字符串的组件。通过名称来引用所需的参数。本例使用 <code>q</code> 来标识猜测的数字。</p>
<h3 id="设置响应的状态码">设置响应的状态码</h3>
<p>服务器应该设置状态码来表示请求的成功或失败。前面看到数想家将状态码设置为 <code>methodNotAllowed</code> 来拒绝非 GET 请求。在后面的代码中，为了表示请求成功，响应完成，数想家服务器将 <code>HttpResponse</code> 状态码设置为 <code>HttpStatus.ok</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleGet</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">uri</span><span class="p">.</span><span class="n">queryParameters</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">q</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
  <span class="kd">final</span> <span class="n">response</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">;</span>
  <span class="n">response</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">ok</span><span class="p">;</span>
  <span class="c1">// ···
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>HttpStatus.ok</code> 和 <code>HttpStatus.methodNotAllowed</code> 是 <a href="https://api.dart.dev/stable/dart-io/HttpStatus-class.html">HttpStatus</a> 类中许多预定义状态码中的两个。另一个有用的预定义状态码是 <code>HttpStatus.notFound</code>(经典的 404）。</p>
<p>除了状态码(<code>statusCode</code>)，HttpResponse 对象还有其他有用的属性:</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">信息</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">contentLength</td>
<td align="left">响应的长度，-1 表示事先不知道长度。</td>
</tr>
<tr>
<td align="left">cookies</td>
<td align="left">要在客户端设置的 <a href="https://api.dart.dev/stable/dart-io/Cookie-class.html">Cookies</a> 列表。</td>
</tr>
<tr>
<td align="left">encoding</td>
<td align="left">编写字符串时使用的<a href="https://api.dart.dev/stable/dart-convert/Encoding-class.html">编码</a>，如 JSON 和 UTF-8。</td>
</tr>
<tr>
<td align="left">headers</td>
<td align="left">响应头，是一个 <a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a> 对象。</td>
</tr>
</tbody>
</table>
<h3 id="将响应写到-httpresponse-对象">将响应写到 HttpResponse 对象</h3>
<p>每个 HttpRequest 对象都有一个对应的 HttpResponse 对象。服务器通过响应对象将数据发回给客户端。</p>
<p>使用 HttpResponse 写方法之一(<code>write()</code>、<code>writeln()</code>、<code>writeAll()</code> 或 <code>writeCharCodes()</code>)将响应数据写入 HttpResponse 对象。或者通过 <code>addStream</code> 将 <code>HttpResponse</code> 对象连接到一个流，并写入流。响应完成后关闭对象。关闭 HttpResponse 对象会将数据发回给客户端。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">handleGet</span><span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ···
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">guess</span> <span class="o">=</span><span class="o">=</span> <span class="n">myNumber</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">response</span>
      <span class="p">.</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">true</span><span class="s1">&#39;</span><span class="p">)</span>
      <span class="p">.</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">I&#39;m thinking of another number.</span><span class="s2">&#34;</span><span class="p">)</span>
      <span class="p">.</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="c1">// ···
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="从独立的客户端进行-post-请求">从独立的客户端进行 POST 请求</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_server.dart">basic_writer_server.dart</a> 和  <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_client.dart">basic_writer_client.dart</a>。</p>
<p>在 <code>hello world</code> 和 <code>number thinker</code> 的例子中，浏览器生成了简单的 GET 请求，对于更复杂的 GET 请求和其他类型的请求，如 POST、PUT 或 DELETE，你需要写一个客户端程序，其中有两种。</p>
<ul>
<li>一个独立的客户端程序，它使用 <code>dart:io</code> 的 <a href="https://api.dart.dev/stable/dart-io/HttpClient-class.html">HttpClient</a> 类。</li>
<li>基于浏览器的客户端，使用 <a href="https://api.dart.dev/stable/dart-html/dart-html-library.html">dart:html</a> 中的 API。本教程不涉及基于浏览器的客户端。要查看基于浏览器的客户端和相关服务器的代码，请参见 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/note_client.dart">note_client.dart</a>、<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/note_server.dart">note_server.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/web/note_taker.html">note_taker.html</a>。</li>
</ul>
<p>让我们看看一个独立的客户端，<code>basic_writer_client.dart</code> 和它的服务器 <code>basic_writer_server.dart</code>。客户端发出一个 POST 请求，将 JSON 数据保存到服务器端的文件中。服务器接受请求并保存文件。</p>
<h4 id="试试吧">试试吧</h4>
<p>在命令行上运行服务器和客户端。</p>
<ol>
<li>首先，运行服务器:</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> httpserver
$ dart bin/basic_writer_server.dart
</code></pre></div><ol start="2">
<li>在一个新的终端中，运行客户端:</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/basic_writer_client.dart
Wrote data <span class="k">for</span> Han Solo.
</code></pre></div><p>看看服务器写入 <code>file.txt</code> 的 JSON 数据:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;Han Solo&#34;</span><span class="p">,</span><span class="nt">&#34;job&#34;</span><span class="p">:</span><span class="s2">&#34;reluctant hero&#34;</span><span class="p">,</span><span class="nt">&#34;BFF&#34;</span><span class="p">:</span><span class="s2">&#34;Chewbacca&#34;</span><span class="p">,</span><span class="nt">&#34;ship&#34;</span><span class="p">:</span><span class="s2">&#34;Millennium Falcon&#34;</span><span class="p">,</span><span class="nt">&#34;weakness&#34;</span><span class="p">:</span><span class="s2">&#34;smuggling debts&#34;</span><span class="p">}</span>
</code></pre></div><p>客户端创建一个 HttpClient 对象，并使用 <code>post()</code> 方法进行请求。发起一个请求涉及两个 Future。</p>
<ul>
<li><code>post()</code> 方法建立与服务器的网络连接并完成第一个 Future，返回一个 HttpClientRequest 对象。</li>
<li>客户端组成请求对象并关闭它。<code>close()</code> 方法将请求发送到服务器并返回第二个 Future，它以一个 HttpClientResponse 对象完成。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:convert</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">String</span> <span class="n">_host</span> <span class="o">=</span> <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">.</span><span class="n">host</span><span class="p">;</span>
<span class="kt">String</span> <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">file.txt</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Map</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;</span><span class="s1">name</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">Han Solo</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">job</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">reluctant hero</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">BFF</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">Chewbacca</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">ship</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">Millennium Falcon</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">weakness</span><span class="s1">&#39;</span><span class="o">:</span> <span class="s1">&#39;</span><span class="s1">smuggling debts</span><span class="s1">&#39;</span>
<span class="p">}</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">HttpClientRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpClient</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">_host</span><span class="p">,</span> <span class="m">4049</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="cm">/*1*/</span>
    <span class="p">.</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">contentType</span> <span class="o">=</span> <span class="n">ContentType</span><span class="p">.</span><span class="n">json</span> <span class="cm">/*2*/</span>
    <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">jsonEncode</span><span class="p">(</span><span class="n">jsonData</span><span class="p">)</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*3*/</span>
  <span class="n">HttpClientResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*4*/</span>
  <span class="kd">await</span> <span class="n">utf8</span><span class="p">.</span><span class="n">decoder</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">response</span> <span class="cm">/*5*/</span><span class="p">)</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">print</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ <code>post()</code> 方法需要主机、端口和请求资源的路径。除了 <code>post()</code> 之外，<a href="https://api.dart.dev/stable/dart-io/HttpClient-class.html">HttpClient</a> 类还提供了其他类型的请求函数，包括 <code>postUrl()</code>、<code>get()</code> 和 <code>open()</code>。</p>
<p>/<em>2</em>/ 一个 <a href="https://api.dart.dev/stable/dart-io/HttpClientRequest-class.html">HttpClientRequest</a> 对象有一个 <a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a> 对象，它包含了请求头的信息。对于一些请求头，比如 <code>contentType</code>，HttpHeaders 有一个针对该请求头的属性。对于其他的请求头，使用 <code>set()</code> 方法将该请求头放入 HttpHeaders 对象中。</p>
<p>/<em>3</em>/ 客户端使用 <code>write()</code> 向请求对象写入数据。编码，在这个例子中是 JSON，与 <a href="https://api.dart.dev/stable/dart-io/ContentType-class.html">ContentType</a> 头中指定的类型相匹配。</p>
<p>/<em>4</em>/ <code>close()</code> 方法将请求发送到服务器，完成后返回一个 <a href="https://api.dart.dev/stable/dart-io/HttpClientResponse-class.html">HttpClientResponse</a> 对象。</p>
<p>/<em>5</em>/ 来自服务器的 UTF-8 响应将被解码。使用在 <a href="https://api.dart.dev/stable/dart-convert/dart-convert-library.html">dart:convert</a> 库中定义的转换器将数据转换为常规的 Dart 字符串格式。</p>
<h3 id="一个-restful-post-请求">一个 RESTful POST 请求</h3>
<p>与 GET 请求类似，REST 为 POST 请求提供了指导方针。</p>
<p>一个 POST 请求:</p>
<ul>
<li>创建一个资源(在这个例子中，一个文件)</li>
<li>使用一个 URI，其结构与文件和目录路径名相似；例如，URI 没有查询字符串。</li>
<li>以 JSON 或 XML 格式传输数据</li>
<li>没有状态，也不会改变服务器的状态。</li>
<li>无长度限制</li>
</ul>
<p>这个例子中的客户端发出 REST 兼容的 POST 请求。</p>
<p>要想看到使 REST 兼容的 GET 请求的客户端代码，请看 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/number_guesser.dart">number_guesser.dart</a>。它是一个独立的客户端，用于数字思考者服务器，定期进行猜测，直到猜对为止。</p>
<h2 id="在服务器中处理一个-post-请求">在服务器中处理一个 POST 请求</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_server.dart">basic_writer_server.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_writer_client.dart">basic_writer_client.dart</a>。</p>
<p>一个 HttpRequest 对象是一个字节列表流(<code>Stream&lt;List&lt;int&gt;</code>)。要获得客户端发送的数据，就要监听 HttpRequest 对象上的数据。</p>
<p>如果来自客户端的请求包含了大量的数据，数据可能会以多个分块的形式到达。你可以使用 Stream 中的 <code>join()</code> 方法来连接这些分块的字符串值。</p>
<p><img src="https://dart.dev/tutorials/server/images/flowchart.png" alt="img"></p>
<p><code>basic_writer_server.dart</code> 文件实现了一个遵循这种模式的服务器。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:convert</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">String</span> <span class="n">_host</span> <span class="o">=</span> <span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">.</span><span class="n">host</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">_host</span><span class="p">,</span> <span class="m">4049</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">req</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ContentType</span> <span class="n">contentType</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">contentType</span><span class="p">;</span>
    <span class="n">HttpResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">POST</span><span class="s1">&#39;</span> <span class="o">&amp;</span><span class="o">&amp;</span>
        <span class="n">contentType</span><span class="o">?</span><span class="p">.</span><span class="n">mimeType</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">application/json</span><span class="s1">&#39;</span> <span class="cm">/*1*/</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="kt">String</span> <span class="n">content</span> <span class="o">=</span>
            <span class="kd">await</span> <span class="n">utf8</span><span class="p">.</span><span class="n">decoder</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*2*/</span>
        <span class="kd">var</span> <span class="n">data</span> <span class="o">=</span> <span class="n">jsonDecode</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">as</span> <span class="n">Map</span><span class="p">;</span> <span class="cm">/*3*/</span>
        <span class="kd">var</span> <span class="n">fileName</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">uri</span><span class="p">.</span><span class="n">pathSegments</span><span class="p">.</span><span class="n">last</span><span class="p">;</span> <span class="cm">/*4*/</span>
        <span class="kd">await</span> <span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="p">.</span><span class="n">writeAsString</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="nl">mode:</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">write</span><span class="p">)</span><span class="p">;</span>
        <span class="n">req</span><span class="p">.</span><span class="n">response</span>
          <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">ok</span>
          <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Wrote data for </span><span class="si">${</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">name</span><span class="s1">&#39;</span><span class="p">]</span><span class="si">}</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">response</span>
          <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">internalServerError</span>
          <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Exception during file I/O: </span><span class="si">$</span><span class="n">e</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">response</span>
        <span class="p">.</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">methodNotAllowed</span>
        <span class="p">.</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Unsupported request: </span><span class="si">${</span><span class="n">req</span><span class="p">.</span><span class="n">method</span><span class="si">}</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">await</span> <span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ 该请求有一个 HttpHeaders 对象。记得客户端将 <code>contentType</code> 头设置为 JSON(application/json)。该服务器拒绝不是 JSON 编码的请求。</p>
<p>/<em>2</em>/ 一个 POST 请求对它可以发送的数据量没有限制，数据可能会以多块形式发送。此外，JSON 是 UTF-8，而 UTF-8 字符可以在多个字节上进行编码。<code>join()</code> 方法将这些分块放在一起。</p>
<p>/<em>3</em>/ 客户端发送的数据是 JSON 格式的。服务器使用 <a href="https://api.dart.dev/stable/dart-convert/dart-convert-library.html">dart:convert</a> 库中的 JSON 编解码器对其进行解码。</p>
<p>/<em>4</em>/ 请求的 URL 是 <a href="http://localhost:4049/file.txt">localhost:4049/file.txt</a>。代码 <code>req.uri.pathSegments.last</code> 从 URI 中提取文件名: <code>file.txt</code>。</p>
<h3 id="关于-cors-头的说明">关于 CORS 头的说明</h3>
<p>如果你想为运行在不同源头（不同主机或端口）的客户端提供服务，你需要添加 CORS 头。下面的代码，取自 note_server.dart，允许从任何来源的 POST 和 OPTIONS 请求。谨慎使用 CORS 头文件，因为它们会给你的网络带来安全风险。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">addCorsHeaders</span><span class="p">(</span><span class="n">HttpResponse</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">response</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Access-Control-Allow-Origin</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">*</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">response</span><span class="p">.</span><span class="n">headers</span>
      <span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Access-Control-Allow-Methods</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">POST, OPTIONS</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">response</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Access-Control-Allow-Headers</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="s1">&#39;</span><span class="s1">Origin, X-Requested-With, Content-Type, Accept</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>更多信息，请参考维基百科的<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨源资源共享</a>一文。</p>
<h2 id="使用-http_server-包">使用 http_server 包</h2>
<p>本节的示例文件：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/mini_file_server.dart">mini_file_server.dart</a> 和 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/static_file_server.dart">static_file_server.dart</a>。</p>
<p>对于一些更高层次的构件，我们推荐你尝试 <a href="https://pub.dev/packages/http_server">http_server</a> pub 包，它包含了一组类，与 <code>dart:io</code> 库中的 HttpServer 类一起，使得实现 HTTP 务器更加容易。</p>
<p>在本节中，我们比较了一个只使用 <code>dart:io</code> 的 API 编写的服务器和一个使用 dart:io 和 http_server 一起编写的具有相同功能的服务器。</p>
<p>你可以在 <code>mini_file_server.dart</code> 中找到第一个服务器。它通过从 <code>web</code> 目录返回 <code>index.html</code> 文件的内容来响应所有请求。</p>
<h3 id="试试吧-1">试试吧</h3>
<p>在命令行中运行服务器:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/mini_file_server.dart
</code></pre></div><p>在浏览器中输入 <a href="http://localhost:4044/">localhost:4044</a>。服务器会显示一个 HTML 文件。</p>
<p><img src="https://dart.dev/tutorials/server/images/index_file.png" alt="img"></p>
<p>这是迷你文件服务器的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">File</span> <span class="n">targetFile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">web/index.html</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">Stream</span><span class="o">&lt;</span><span class="n">HttpRequest</span><span class="o">&gt;</span> <span class="n">server</span><span class="p">;</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span> <span class="m">4044</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Couldn&#39;t bind to port 4044: </span><span class="si">$</span><span class="n">e</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">req</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kd">await</span> <span class="n">targetFile</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Serving </span><span class="si">${</span><span class="n">targetFile</span><span class="p">.</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
      <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">contentType</span> <span class="o">=</span> <span class="n">ContentType</span><span class="p">.</span><span class="n">html</span><span class="p">;</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="kd">await</span> <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">addStream</span><span class="p">(</span><span class="n">targetFile</span><span class="p">.</span><span class="n">openRead</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Couldn&#39;t read file: </span><span class="si">$</span><span class="n">e</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="m">1</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="s2">Can&#39;t open </span><span class="si">${</span><span class="n">targetFile</span><span class="p">.</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="s2">&#34;</span><span class="p">)</span><span class="p">;</span>
      <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">statusCode</span> <span class="o">=</span> <span class="n">HttpStatus</span><span class="p">.</span><span class="n">notFound</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">await</span> <span class="n">req</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这段代码确定文件是否存在，如果存在，则打开文件，并将文件内容管道化到HttpResponse对象。</p>
<p>第二个服务器，你可以在 <a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/basic_file_server.dart">basic_file_server.dart</a> 中找到它的代码，使用 <a href="https://pub.dev/packages/http_server">http_server</a> 包。</p>
<h3 id="试试吧-2">试试吧</h3>
<p>在命令行中运行服务器:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> httpserver
$ dart bin/basic_file_server.dart
</code></pre></div><p>在浏览器中输入 <a href="http://localhost:4046/">localhost:4046</a>。服务器显示与之前相同的 index.html 文件。</p>
<p><img src="https://dart.dev/tutorials/server/images/index_file_4046.png" alt="img"></p>
<p>在这个服务器中，处理请求的代码要短得多，因为 <a href="https://pub.dev/documentation/http_server/latest/http_server/VirtualDirectory-class.html">VirtualDirectory</a> 类处理服务文件的细节。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:http_server/http_server.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">File</span> <span class="n">targetFile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">web/index.html</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">VirtualDirectory</span> <span class="n">staticFiles</span> <span class="o">=</span> <span class="n">VirtualDirectory</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

  <span class="kd">var</span> <span class="n">serverRequests</span> <span class="o">=</span>
      <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span> <span class="m">4046</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">request</span> <span class="k">in</span> <span class="n">serverRequests</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">staticFiles</span><span class="p">.</span><span class="n">serveFile</span><span class="p">(</span><span class="n">targetFile</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里，请求的资源 index.html 是由 VirtualDirectory 类中的 <code>serviceFile()</code> 方法提供的。你不需要写代码来打开一个文件并将其内容用管道传送到请求中。</p>
<p>另一个文件服务器 <code>static_file_server.dart</code> 也使用 http_server 包。这个服务器可以服务于服务器目录或子目录中的任何文件。</p>
<p>运行 <code>static_file_server.dart</code>，用 <a href="http://localhost:4048/">localhost:4048</a> 这个 URL 进行测试。</p>
<p>下面是 <code>static_file_server.dart</code> 的代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:http_server/http_server.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">staticFiles</span> <span class="o">=</span> <span class="n">VirtualDirectory</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">web</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">staticFiles</span><span class="p">.</span><span class="n">allowDirectoryListing</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="cm">/*1*/</span>
  <span class="n">staticFiles</span><span class="p">.</span><span class="n">directoryHandler</span> <span class="o">=</span> <span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span> <span class="cm">/*2*/</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">indexUri</span> <span class="o">=</span> <span class="n">Uri</span><span class="p">.</span><span class="n">file</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="n">path</span><span class="p">)</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">index.html</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="n">staticFiles</span><span class="p">.</span><span class="n">serveFile</span><span class="p">(</span><span class="n">File</span><span class="p">(</span><span class="n">indexUri</span><span class="p">.</span><span class="n">toFilePath</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span> <span class="n">request</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*3*/</span>
  <span class="p">}</span><span class="p">;</span>

  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">InternetAddress</span><span class="p">.</span><span class="n">loopbackIPv4</span><span class="p">,</span> <span class="m">4048</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Listening on port 4048</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="n">server</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">staticFiles</span><span class="p">.</span><span class="n">serveRequest</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*4*/</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ 允许客户端请求服务器目录内的文件。</p>
<p>/<em>2</em>/ 一个匿名函数，处理对目录本身的请求，即 URL 不包含文件名。该函数将这些请求重定向到 <code>index.html</code>。</p>
<p>/<em>3</em>/ <code>serveFile</code> 方法为一个文件提供服务，在这个例子中，它为目录请求服务index.html。</p>
<p>/<em>4</em>/ VirtualDirectory 类提供的 <code>serviceRequest</code> 方法处理指定文件的请求。</p>
<h2 id="使用-bindsecure-的-https-方法">使用 bindSecure() 的 https 方法</h2>
<p>本节的示例：<a href="https://github.com/dart-lang/site-www/blob/master/examples/httpserver/bin/hello_world_server_secure.dart">hello_world_server_secure.dart</a>。</p>
<p>你可能已经注意到，HttpServer 类定义了一个叫做 <code>bindSecure()</code> 的方法，它使用 HTTPS(Hyper Text Transfer Protocol with Secure Sockets Layer)提供安全连接。要使用 <code>bindSecure()</code> 方法，你需要一个证书，这个证书由证书颁发机构(CA)提供。有关证书的更多信息，请参考<a href="https://www.tldp.org/HOWTO/SSL-Certificates-HOWTO/x64.html">什么是 SSL 和什么是证书</a>？</p>
<p>为了说明问题，下面的服务器 <code>hello_world_server_secure.dart</code> 使用 Dart 团队创建的证书调用 <code>bindSecure()</code> 进行测试。你必须为你的服务器提供自己的证书。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">dart:io</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">String</span> <span class="n">certificateChain</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">server_chain.pem</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="kt">String</span> <span class="n">serverKey</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">server_key.pem</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">serverContext</span> <span class="o">=</span> <span class="n">SecurityContext</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*1*/</span>
  <span class="n">serverContext</span><span class="p">.</span><span class="n">useCertificateChain</span><span class="p">(</span><span class="n">certificateChain</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*2*/</span>
  <span class="n">serverContext</span><span class="p">.</span><span class="n">usePrivateKey</span><span class="p">(</span><span class="n">serverKey</span><span class="p">,</span> <span class="nl">password:</span> <span class="s1">&#39;</span><span class="s1">dartdart</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span> <span class="cm">/*3*/</span>

  <span class="kd">var</span> <span class="n">server</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">HttpServer</span><span class="p">.</span><span class="n">bindSecure</span><span class="p">(</span>
    <span class="s1">&#39;</span><span class="s1">localhost</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="m">4047</span><span class="p">,</span>
    <span class="n">serverContext</span><span class="p">,</span> <span class="cm">/*4*/</span>
  <span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Listening on localhost:</span><span class="si">${</span><span class="n">server</span><span class="p">.</span><span class="n">port</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="k">for</span> <span class="p">(</span><span class="n">HttpRequest</span> <span class="n">request</span> <span class="k">in</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello, world!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="kd">await</span> <span class="n">request</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>/<em>1</em>/ 安全网络连接的可选设置在 SecurityContext 对象中指定，有一个默认的对象 SecurityContext.defaultContext，包括知名证书机构的可信根证书。</p>
<p>/<em>2</em>/ 一个包含从服务器证书到签名机关根证书链的文件，<a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">格式为 PEM</a>。</p>
<p>/<em>3</em>/ 一个包含（加密的）服务器证书私钥的文件，<a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">PEM 格式</a>。</p>
<p>/<em>4</em>/ 在服务器上，上下文参数是必需的，对客户端来说是可选的。如果省略它，则使用默认的内置可信根的上下文。</p>
<h2 id="其他资源">其他资源</h2>
<p>请访问这些 API 文档，了解本教程中讨论的类和库的更多细节。</p>
<table>
<thead>
<tr>
<th align="left">Dart 类</th>
<th align="left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpServer-class.html">HttpServer</a></td>
<td align="left">一个 HTTP 服务器</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpClient-class.html">HttpClient</a></td>
<td align="left">一个 HTTP 客户端</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpRequest-class.html">HttpRequest</a></td>
<td align="left">一个服务器端请求对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpResponse-class.html">HttpResponse</a></td>
<td align="left">一个服务器端响应对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpClientRequest-class.html">HttpClientRequest</a></td>
<td align="left">一个客户端请求对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpClientResponse-class.html">HttpClientResponse</a></td>
<td align="left">一个客户端响应对象</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpHeaders-class.html">HttpHeaders</a></td>
<td align="left">请求头</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/HttpStatus-class.html">HttpStatus</a></td>
<td align="left">响应的状态</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/InternetAddress-class.html">InternetAddress</a></td>
<td align="left">一个互联网地址</td>
</tr>
<tr>
<td align="left"><a href="https://api.dart.dev/stable/dart-io/SecurityContext-class.html">SecurityContext</a></td>
<td align="left">包含安全连接的证书、密钥和信任信息。</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/http_server">http_server</a> 包</td>
<td align="left">一个具有较高级别的 HTTP 类的包</td>
</tr>
</tbody>
</table>
<h2 id="下一步该怎么做">下一步该怎么做？</h2>
<ul>
<li>如果你还没有尝试过服务器端的 codelab，可以尝试<a href="https://dart-lang.github.io/server/codelab/">编写一个服务器应用程序</a>。</li>
<li><a href="https://dart-lang.github.io/server/">Servers with Dart</a> 链接到编写独立 Dart 应用程序的资源，包括服务器。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/client" term="client" label="client" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[如何使用包]]></title>
            <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="related" type="text/html" title="常用的包" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第二部分" />
            
                <id>https://ohmyweekly.github.io/notes/how-to-use-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-29T00:00:00+08:00</published>
            <updated>2020-06-29T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Dart 包管理工具 - pub</blockquote><p>Dart 生态系统使用包来管理共享软件，如库和工具。要获得 Dart 包，你可以使用 <code>pub</code> 包管理器。你可以在 <a href="https://pub.dev/">pub.dev</a> 网站上找到公开的包，也可以从本地文件系统或其他地方加载包，比如 Git 仓库。无论你的包来自哪里，pub 都会管理版本依赖关系，帮助你获得相互之间以及与 SDK 版本兼容的包版本。</p>
<p>大多数精通 Dart 的 <a href="https://dart.dev/tools#ides-and-editors">IDE</a> 都提供了对 pub 的支持，包括创建、下载、更新和发布包。或者你可以<a href="https://dart.dev/tools/pub/cmd">在命令行中使用 pub</a>。</p>
<p>至少，一个 Dart 包是一个包含 <a href="https://dart.dev/tools/pub/pubspec">pubspec 文件</a>的目录。pubspec 包含一些关于包的元数据。此外，一个包可以包含依赖关系(在 pubspec 中列出)，Dart 库，应用程序，资源，测试，图像和例子。</p>
<p>要使用一个包，请执行以下操作:</p>
<ul>
<li>创建一个 pubspec(一个名为 <code>pubspec.yaml</code> 的文件，它列出了软件包的依赖关系，并包含其他元数据，如版本号)。</li>
<li>使用 <code>pub</code> 来获取你的包的依赖关系。</li>
<li>如果你的 Dart 代码依赖于软件包中的一个库，则导入该库。</li>
</ul>
<h2 id="创建一个-pubspec">创建一个 pubspec</h2>
<p>pubspec 是一个名为 <code>pubspec.yaml</code> 的文件，它位于你的应用程序的顶级目录中。最简单的 pubspec 只列出了包名:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="nl">name:</span> <span class="n">my_app</span>
</code></pre></div><p>下面是一个 pubspec 的例子，它声明了两个包(<code>js</code> 和 <code>intl</code>)的依赖关系，这两个包都托管在 pub.dev 站点上:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="nl">name:</span> <span class="n">my_app</span>
<span class="nl">dependencies:</span>
  <span class="nl">js:</span> <span class="o">^</span><span class="m">0.6</span><span class="p">.</span><span class="m">0</span>
  <span class="nl">intl:</span> <span class="o">^</span><span class="m">0.15</span><span class="p">.</span><span class="m">8</span>
</code></pre></div><p>关于创建 pubspec 的详细信息，请参见 <a href="https://dart.dev/tools/pub/pubspec">pubspec 文档</a>和你要使用的包的文档。</p>
<h2 id="获取软件包">获取软件包</h2>
<p>一旦你有了 pubspec，你就可以从你的应用程序的顶级目录中运行 <code>pub get</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ <span class="nb">cd</span> &lt;path-to-my_app&gt;
$ pub get
</code></pre></div><p>这个过程被称为获取依赖关系。</p>
<p><code>pub get</code> 命令可以确定您的应用程序依赖于哪些软件包，并将它们放在中央<a href="https://dart.dev/tools/pub/glossary#system-cache">系统缓存</a>中。如果您的应用程序依赖于已发布的包，pub 会从 <a href="https://pub.dev/">pub.dev</a> 站点下载该包。对于  <a href="https://dart.dev/tools/pub/dependencies#git-packages">Git 依赖</a>，pub 会克隆 Git 仓库。还包括了过渡性依赖。例如，如果 <code>js</code> 包依赖于 <code>test</code> 包，<code>pub</code> 会同时抓取 <code>js</code> 包和 <code>test</code> 包。</p>
<p>Pub 会创建一个 <code>.packages</code> 文件(在你的应用程序的顶层目录下)，将你的应用程序所依赖的每个包名映射到系统缓存中的对应包。</p>
<h2 id="从包中导入库">从包中导入库</h2>
<p>要导入在包中找到的库，使用 <code>package:</code> 前缀:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:js/js.dart</span><span class="s1">&#39;</span> <span class="k">as</span> <span class="n">js</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:intl/intl.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>Dart 运行时在 <code>package:</code> 之后的所有内容都会在应用程序的 <code>.package</code> 文件中进行查找。</p>
<p>你也可以使用这种风格从你自己的包中导入库。比方说，<code>transmogrify</code> 包的布局如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">transmogrify/
  lib/
    transmogrify.dart
    parser.dart
  test/
    parser/
      parser_test.dart
</code></pre></div><p><code>parser_test.dart</code> 文件可以这样导入 <code>parser.dart</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:transmogrify/parser.dart</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><h2 id="升级依赖关系">升级依赖关系</h2>
<p>当你第一次为你的软件包获取一个新的依赖关系时，pub 会下载与你的其他依赖关系兼容的最新版本。然后，它通过创建一个 <strong>lockfile</strong> 锁文件来锁定您的软件包，使其始终使用该版本。这是一个名为 <code>pubspec.lock</code> 的文件，由 pub 创建并存储在 pubspec 的旁边。它列出了您的软件包所使用的每个依赖关系的特定版本 (即时的和过渡的)。</p>
<p>如果你的包是一个应用程序包，你应该把这个文件检查到<a href="https://dart.dev/guides/libraries/private-files">源代码控制</a>中。这样，在你的应用程序上工作的每个人都会使用所有包的相同版本。在 lockfile 文件中检查也可以确保你部署的应用使用相同版本的代码。</p>
<p>当你准备好将你的依赖项升级到最新版本时，使用 <a href="https://dart.dev/tools/pub/cmd/pub-upgrade">pub upgrade</a> 命令:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">$</span> <span class="n">pub</span> <span class="n">upgrade</span>
</code></pre></div><p><code>pub upgrade</code> 命令告诉 pub 使用你的包的依赖关系的最新版本来重新生成 lockfile 文件。如果你只想升级一个依赖关系，你可以指定要升级的软件包:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">$</span> <span class="n">pub</span> <span class="n">upgrade</span> <span class="n">transmogrify</span>
</code></pre></div><p>该命令将 <code>transmogrify</code> 升级到最新版本，但其他一切都保持不变。</p>
<p>由于 pubspec 中有冲突的版本限制，<a href="https://dart.dev/tools/pub/cmd/pub-upgrade">pub upgrade</a> 命令并不能总是将每个软件包升级到最新版本。要识别需要编辑 pubspec 的过期软件包，请使用 <a href="https://dart.dev/tools/pub/cmd/pub-outdated">pub outdated</a>。</p>
<h2 id="更多信息">更多信息</h2>
<p>下面的页面有更多关于软件包和 pub 包管理器的信息。</p>
<p>如何使用</p>
<ul>
<li><a href="https://dart.dev/guides/libraries/create-library-packages">创建包</a></li>
<li><a href="https://dart.dev/tools/pub/publishing">发布包</a></li>
</ul>
<p>参考</p>
<ul>
<li><a href="https://dart.dev/tools/pub/dependencies">Pub 依赖</a></li>
<li><a href="https://dart.dev/tools/pub/environment-variables">Pub 环境变量</a></li>
<li><a href="https://dart.dev/tools/pub/glossary">Pub 词汇表</a></li>
<li><a href="https://dart.dev/tools/pub/package-layout">Pub 包布局约定</a></li>
<li><a href="https://dart.dev/tools/pub/versioning">Pub 版本哲学</a></li>
<li><a href="https://dart.dev/tools/pub/pubspec">Pubspec 格式化</a></li>
</ul>
<p>Pub 命令</p>
<p><code>pub</code> 工具提供了以下命令:</p>
<ul>
<li><a href="https://dart.dev/tools/pub/cmd/pub-cache">pub cache</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-deps">pub deps</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-downgrade">pub downgrade</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-get">pub get</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-global">pub global</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-outdated">pub outdated</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-lish">pub publish</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-run">pub run</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-upgrade">pub upgrade</a></li>
<li><a href="https://dart.dev/tools/pub/cmd/pub-uploader">pub uploader</a></li>
</ul>
<p>有关所有 pub 命令的概述，请参阅 <a href="https://dart.dev/tools/pub/cmd">pub 工具文档</a>。</p>
<p>疑难解答</p>
<p><a href="https://dart.dev/tools/pub/troubleshoot">故障排除 pub</a> 提供了使用 pub 时可能遇到的问题的解决方案。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[常用的包]]></title>
            <link href="https://ohmyweekly.github.io/notes/commonly-used-packages/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/how-to-use-packages/?utm_source=atom_feed" rel="related" type="text/html" title="如何使用包" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第二部分" />
            
                <id>https://ohmyweekly.github.io/notes/commonly-used-packages/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-29T00:00:00+08:00</published>
            <updated>2020-06-29T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Commonly used packages</blockquote><p>本页列出了一些  Dart 开发者发布的最流行和最有用的<a href="https://dart.dev/guides/packages">包</a>。要找到更多的软件包&ndash;也可以搜索<a href="https://dart.dev/guides/libraries">核心库</a>&ndash;请使用 <a href="https://pub.dev/">pub.dev</a> 网站。</p>
<p>常用的软件包可分为三类:</p>
<ul>
<li><a href="https://dart.dev/guides/libraries/useful-libraries#general-purpose-packages">通用包</a></li>
<li><a href="https://dart.dev/guides/libraries/useful-libraries#packages-that-correspond-to-sdk-libraries">扩展 Dart 核心库的包</a></li>
<li><a href="https://dart.dev/guides/libraries/useful-libraries#specialized-packages">特定的包</a></li>
</ul>
<h2 id="通用包">通用包</h2>
<p>以下包对各种项目都很有用:</p>
<table>
<thead>
<tr>
<th align="left">包</th>
<th align="left">描述</th>
<th align="left">常用的 API</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="https://pub.dev/packages/archive">archive</a></td>
<td align="left">对各种档案和压缩格式进行编码和解码。</td>
<td align="left">Archive, ArchiveFile, TarEncoder, TarDecoder, ZipEncoder, ZipDecoder</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/characters">characters</a></td>
<td align="left">对用户感知的字符进行字符串操作(Unicode 字符簇)</td>
<td align="left">String.characters, Characters, CharacterRange</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/http">http</a></td>
<td align="left">一组高级的函数和类，使其易于消费 HTTP 资源</td>
<td align="left">delete(), get(), post(), read()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/intl">intl</a></td>
<td align="left">国际化和本地化设施，支持复数和性别、日期和数字格式化和解析以及双向文本</td>
<td align="left">Bidi, DateFormat, MicroMoney, TextDirection</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/json_serializable">json_serializable</a></td>
<td align="left">一个易于使用的代码生成包。更多信息，请参阅 <a href="https://dart.dev/guides/json">JSON 支持</a></td>
<td align="left">@JsonSerializable</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/logging">logging</a></td>
<td align="left">一个可配置的机制，为你的应用程序添加消息记录</td>
<td align="left">LoggerHandler, Level, LogRecord</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/mockito">mockito</a></td>
<td align="left">一个在测试中模拟对象的流行框架。如果你正在编写依赖注入的测试，特别有用。与 <a href="https://pub.dev/packages/test">test</a> 包一起使用</td>
<td align="left">Answering, Expectation, Verification</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/path">path</a></td>
<td align="left">操作不同类型路径的常用操作。更多信息，请参见<a href="https://news.dartlang.org/2016/06/unboxing-packages-path.html">拆包: path</a></td>
<td align="left">absolute(), basename(), extension(), join(), normalize(), relative(), split()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/quiver">quiver</a></td>
<td align="left">实用工具，使 Dart 核心库的使用更加方便。Quiver 提供额外支持的一些库包括 async、cache、collection、core、iterables、pattern 和 测试</td>
<td align="left">CountdownTimer (quiver.async); MapCache (quiver.cache); MultiMap, TreeSet (quiver.collection); EnumerateIterable (quiver.iterables); center(), compareIgnoreCase(), isWhiteSpace() (quiver.strings)</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/shelf">shelf</a></td>
<td align="left">Dart 的 Web 服务器中间件。Shelf 使它能轻松地创建和组成 Web 服务器，以及 Web 服务器的一部分</td>
<td align="left">Cascade, Pipeline, Request, Response, Server</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/stack_trace">stack_trace</a></td>
<td align="left">用于解析、检查和处理由底层 Dart 实现产生的堆栈痕迹的方法。还提供了以比原生 StackTrace 实现更可读的格式生成堆栈跟踪的字符串表示的函数,  更多信息，请参见<a href="https://news.dartlang.org/2016/01/unboxing-packages-stacktrace.html">拆包: stack_trace</a></td>
<td align="left">Trace.current(), Trace.format(), Trace.from()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/stagehand">stagehand</a></td>
<td align="left">一个 Dart 项目生成器。当你创建一个新的应用程序时，WebStorm 和 IntelliJ 使用 Stagehand 模板，但你也可以从命令行使用模板</td>
<td align="left">一般通过 IDE 或 <code>stagehand</code> 命令来使用</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/test">test</a></td>
<td align="left">在 Dart 中编写和运行测试的标准方法</td>
<td align="left">expect(), group(), test()</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/yaml">yaml</a></td>
<td align="left">YAML 解析器</td>
<td align="left">loadYaml(), loadYamlStream()</td>
</tr>
</tbody>
</table>
<h2 id="扩展-dart-核心库的包">扩展 Dart 核心库的包</h2>
<p>以下每个包都建立在一个<a href="https://dart.dev/guides/libraries">核心库</a>的基础上，增加了功能并填补了缺失的功能:</p>
<table>
<thead>
<tr>
<th align="left">包</th>
<th align="left">描述</th>
<th align="left">常用的 API</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="https://pub.dev/packages/async">async</a></td>
<td align="left">在 dart:async 的基础上进行了扩展，增加了实用类来处理异步计算。更多信息，请参见<a href="https://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html">拆包: async 第1部分</a>、<a href="https://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html">第2部分</a>和<a href="https://news.dartlang.org/2016/04/unboxing-packages-async-part-3.html">第3部分</a></td>
<td align="left">AsyncMemoizer, CancelableOperation, FutureGroup, LazyStream, Result, StreamCompleter, StreamGroup, StreamSplitter</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/collection">collection</a></td>
<td align="left">在 dart:collection 的基础上进行了扩展，增加了实用函数和类，使处理集合的工作变得更加容易。更多信息，请看<a href="https://news.dartlang.org/2016/01/unboxing-packages-collection.html">拆包：collection</a></td>
<td align="left">Equality, CanonicalizedMap, MapKeySet, MapValueSet, PriorityQueue, QueueList</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/convert">convert</a></td>
<td align="left">在 dart:convert 的基础上，增加了编码器和解码器，用于在不同的数据表现形式之间进行转换。其中一种数据表示方式是百分比编码，也被称为 URL 编码</td>
<td align="left">HexDecoder, PercentDecoder</td>
</tr>
<tr>
<td align="left"><a href="https://pub.dev/packages/io">io</a></td>
<td align="left">包含两个库，ansi和io，以简化对文件、标准流和进程的处理。使用 ansi 库可以自定义终端输出。io 库有处理进程、stdin 和文件复制的 API</td>
<td align="left">copyPath(), isExecutable(), ExitCode, ProcessManager, sharedStdIn</td>
</tr>
</tbody>
</table>
<h2 id="专用包">专用包</h2>
<p>下面是一些寻找比较专业的包的技巧，比如手机的包(Flutter)和网页开发的包。</p>
<h3 id="flutter-包">Flutter 包</h3>
<p>请看 Flutter 网站上的<a href="https://flutter.dev/docs/development/packages-and-plugins/using-packages">使用包</a>。或者使用 pub.dev 网站<a href="https://pub.dev/flutter">搜索 Flutter 包</a>。</p>
<h3 id="网络包">网络包</h3>
<p>参见<a href="https://dart.dev/web/libraries">网络库和包</a>。或者使用 pub.dev 站点<a href="https://pub.dev/web">搜索 web 包</a>。</p>
<h3 id="命令行和服务器软件包">命令行和服务器软件包</h3>
<p>参见<a href="https://dart.dev/server/libraries">命令行和服务器库和包</a>。或者使用 pub.dev 站点<a href="https://pub.dev/">搜索其他包</a>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/packages" term="packages" label="packages" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[异步编程：futures、async、await。]]></title>
            <link href="https://ohmyweekly.github.io/notes/futures-async-await/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 入门" />
                <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 可迭代集合" />
                <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 语言速查表" />
            
                <id>https://ohmyweekly.github.io/notes/futures-async-await/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-27T00:00:00+08:00</published>
            <updated>2020-06-27T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>这个 codelab 教你如何使用 <code>futures</code>、<code>async</code> 和 <code>await</code> 关键字编写异步代码。使用内嵌的 DartPad 编辑器，你可以通过运行示例代码和完成练习来测试你的知识。</blockquote><p><a href="https://dart.dev/codelabs/async-await">async-await</a></p>
<p>这个 codelab 教你如何使用 <code>futures</code>、<code>async</code> 和 <code>await</code> 关键字编写异步代码。使用内嵌的 DartPad 编辑器，你可以通过运行示例代码和完成练习来测试你的知识。</p>
<p>要想从这个 codelab 中获得最大的收获，你应该具备以下条件。</p>
<ul>
<li>掌握<a href="https://dart.dev/samples">基本的 Dart 语法</a></li>
<li>有用其他语言编写异步代码的经验。</li>
</ul>
<p>这个 codelab 包括以下材料。</p>
<ul>
<li>如何以及何时使用 <code>async</code> 和 <code>await</code> 关键字。</li>
<li>使用 <code>async</code> 和 <code>await</code> 如何影响执行顺序。</li>
<li>如何在 <code>async</code> 函数中使用 <code>try-catch</code> 表达式处理异步调用中的错误。</li>
</ul>
<p>估计完成这个代码实验的时间。40-60分钟</p>
<p>注意：本页面使用嵌入式 DartPads 来显示示例和练习。如果你看到的是空框而不是 DartPads，请转到 <a href="https://dart.dev/tools/dartpad/troubleshoot">DartPad 故障排除页面</a>。</p>
<h2 id="为什么异步代码很重要">为什么异步代码很重要</h2>
<p>异步操作让你的程序在等待另一个操作完成时完成工作。下面是一些常见的异步操作。</p>
<ul>
<li>通过网络获取数据。</li>
<li>写入数据库。</li>
<li>从文件中读取数据。</li>
</ul>
<p>要在 Dart 中执行异步操作，你可以使用 <code>Future</code> 类以及 <code>async</code> 和 <code>await</code> 关键字。</p>
<h3 id="例子-错误地使用异步函数">例子: 错误地使用异步函数</h3>
<p>下面的例子显示了使用异步函数(<code>fetchUserOrder()</code>)的错误方法。稍后你将使用 <code>async</code> 和 <code>await</code> 来修复这个例子。在运行这个例子之前，试着发现这个问题-你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// This example shows how *not* to write asynchronous Dart code.
</span><span class="c1"></span>
<span class="kt">String</span> <span class="n">createOrderMessage</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;</span><span class="s1">Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span>
    <span class="c1">// Imagine that this function is more complex and slow.
</span><span class="c1"></span>    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">)</span><span class="p">,</span>
      <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">Large Latte</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">createOrderMessage</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>下面是这个例子为什么不能打印 <code>fetchUserOrder()</code> 最终产生的值。</p>
<ul>
<li><code>fetchUserOrder()</code> 是一个异步函数，在延迟之后，提供一个描述用户订单的字符串：&ldquo;Large Latte&rdquo;。</li>
<li>为了得到用户的订单，<code>createOrderMessage()</code> 应该调用 <code>fetchUserOrder()</code>，并等待其完成。由于 <code>createOrderMessage()</code> 没有等待 <code>fetchUserOrder()</code> 完成，<code>createOrderMessage()</code> 无法获得 <code>fetchUserOrder()</code> 最终提供的字符串值。</li>
<li>取而代之的是，<code>createOrderMessage()</code> 得到的是待完成工作的表示：一个未完成的未来。您将在下一节了解更多关于未来的信息。</li>
<li>因为 <code>createOrderMessage()</code> 没有得到描述用户订单的值，所以这个例子没有打印 &ldquo;Large Latte&rdquo; 到控制台，而是打印 &ldquo;Your order is: Instance of &lsquo;_Future&rsquo;&quot;。</li>
</ul>
<p>在接下来的章节中，你将学习关于 futures 和关于使用 futures 的工作（使用 <code>async</code> 和 <code>await</code>），这样你就能编写必要的代码，使 <code>fetchUserOrder()</code> 向控制台打印所需的值(&ldquo;Large Latte&rdquo;)。</p>
<p>关键术语:</p>
<ul>
<li>同步操作: 同步操作会阻止其他操作的执行，直到它完成。</li>
<li>同步函数：同步函数只执行同步操作。</li>
<li>异步操作：异步操作一旦启动，就允许其他操作在它完成之前执行。</li>
<li>异步函数：异步函数至少执行一个异步操作，也可以执行同步操作。</li>
</ul>
<h2 id="什么是未来">什么是未来？</h2>
<p>future(小写 &ldquo;f&rdquo;)是 <a href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a>（大写 &ldquo;F&rdquo;）类的一个实例。一个 future 代表异步操作的结果，可以有两种状态：未完成或完成。</p>
<p>注意：未完成是一个 Dart 术语，指的是一个未来的状态，在它产生一个值之前。</p>
<h3 id="未完成的">未完成的</h3>
<p>当你调用一个异步函数时，它会返回一个未完成的未来。这个未来正在等待函数的异步操作完成或抛出一个错误。</p>
<h3 id="已完成的">已完成的</h3>
<p>如果异步操作成功，未来就以一个值完成。否则它将以一个错误完成。</p>
<h3 id="用一个值来完成">用一个值来完成</h3>
<p>类型为 <code>Future&lt;T&gt;</code> 的 future 用一个类型为 <code>T</code> 的值来完成。例如，一个类型为 <code>Future&lt;String&gt;</code> 的 future 会产生一个字符串值。如果一个 future 没有产生一个可用的值，那么 future 的类型是 <code>Future&lt;void&gt;</code>。</p>
<h3 id="用一个错误来完成">用一个错误来完成</h3>
<p>如果函数执行的异步操作因为任何原因而失败，future 就会以错误的方式完成。</p>
<h3 id="例子-介绍-future">例子: 介绍 future</h3>
<p>在下面的例子中，<code>fetchUserOrder()</code> 返回一个在打印到控制台后完成的 future。因为它没有返回一个可用的值，<code>fetchUserOrder()</code> 的类型是 <code>Future&lt;void&gt;</code>。在运行这个例子之前，试着预测一下哪个会先打印：&ldquo;Large Latte&rdquo; 或 &ldquo;Fetching user order&hellip;&quot;。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Imagine that this function is fetching user info from another service or database.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">)</span><span class="p">,</span> <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Large Latte</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Fetching user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>在前面的例子中，尽管 <code>fetchUserOrder()</code> 在第8行的 <code>print()</code> 调用之前执行，控制台还是在 <code>fetchUserOrder()</code> 的输出 (&ldquo;Large Latte&rdquo;) 之前显示了第8行的输出 (&ldquo;Fetching user order&hellip;&quot;)。这是因为 <code>fetchUserOrder()</code> 在打印 &ldquo;Large Latte&rdquo; 之前会有延迟。</p>
<h3 id="例子-完成时出现错误">例子: 完成时出现错误</h3>
<p>运行下面的例子，看看未来如何完成一个错误。稍后你将学习如何处理错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// Imagine that this function is fetching user info but encounters a bug
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">)</span><span class="p">,</span>
      <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Logout failed: user ID is invalid</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Fetching user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，<code>fetchUserOrder()</code> 完成时出现错误，表明用户ID无效。</p>
<p>你已经学习了 future 和它们如何完成，但你如何使用异步函数的结果呢？在下一节中，你将学习如何使用 <code>async</code> 和 <code>await</code> 关键字来获取结果。</p>
<p>快速回顾:</p>
<ul>
<li>一个 <code>Future&lt;T&gt;</code> 实例会产生一个 <code>T</code> 类型的值。</li>
<li>如果一个 future 没有产生一个可用的值，那么 future 的类型是 <code>Future&lt;void&gt;</code>。</li>
<li>一个 future 可以处于两种状态之一：未完成或完成。</li>
<li>当你调用一个返回 future 的函数时，函数会把要做的工作排队，并返回一个未完成的 future。</li>
<li>当一个 future 的操作完成时，future 以一个值或以一个错误完成。</li>
</ul>
<p>关键术语:</p>
<ul>
<li>Future: Dart <a href="https://api.dart.dev/stable/dart-async/Future-class.html">Future</a> 类。</li>
<li>future：Dart <code>Future</code> 类的一个实例。</li>
</ul>
<h2 id="使用-futureasync-和-await">使用 future：async 和 await</h2>
<p><code>async</code> 和 <code>await</code> 关键字提供了一种声明式的方式来定义异步函数并使用它们的结果。在使用 <code>async</code> 和 <code>await</code> 时，请记住以下两个基本准则。</p>
<ul>
<li>要定义一个异步函数，请在函数主体前添加 <code>async</code>。</li>
<li><code>await</code> 关键字只能在 <code>async</code> 函数中使用。</li>
</ul>
<p>下面是一个将 <code>main()</code> 从同步函数转换为异步函数的例子。</p>
<p>首先，在函数体前添加 <code>async</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span> <span class="err">·</span><span class="err">·</span><span class="err">·</span> <span class="p">}</span>
</code></pre></div><p>如果函数有声明的返回类型，那么更新类型为 <code>Future&lt;T&gt;</code>，其中 T 是函数返回的值的类型。如果函数没有明确返回值，那么返回类型为 <code>Future&lt;void&gt;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span> <span class="err">·</span><span class="err">·</span><span class="err">·</span> <span class="p">}</span>
</code></pre></div><p>现在你已经有了一个 <code>async</code> 函数，你可以使用 <code>await</code> 关键字来等待一个 future 的完成:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">print</span><span class="p">(</span><span class="kd">await</span> <span class="n">createOrderMessage</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>正如下面两个例子所显示的，<code>async</code> 和a <code>wait</code> 关键字导致异步代码看起来很像同步代码。唯一的区别在异步示例中突出显示，如果你的窗口足够宽，它就在同步示例的右边。</p>
<p>示例：同步函数</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">createOrderMessage</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;</span><span class="s1">Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span>
    <span class="c1">// Imagine that this function is
</span><span class="c1"></span>    <span class="c1">// more complex and slow.
</span><span class="c1"></span>    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">)</span><span class="p">,</span>
      <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">Large Latte</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Fetching user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">createOrderMessage</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Fetching user order...
Your order is: Instance of _Future&lt;String&gt;
</code></pre></div><p>例子：异步函数</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">createOrderMessage</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;</span><span class="s1">Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span>
    <span class="c1">// Imagine that this function is
</span><span class="c1"></span>    <span class="c1">// more complex and slow.
</span><span class="c1"></span>    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">)</span><span class="p">,</span>
      <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">Large Latte</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Fetching user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="kd">await</span> <span class="n">createOrderMessage</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Fetching user order...
Your order is: Large Latte
</code></pre></div><p>异步示例在三个方面有所不同。</p>
<ul>
<li><code>createOrderMessage()</code> 的返回类型从 <code>String</code> 变为 <code>Future&lt;String&gt;</code>。</li>
<li><code>async</code> 关键字出现在 <code>createOrderMessage()</code> 和 <code>main()</code> 的函数体之前。</li>
<li><code>await</code> 关键字出现在调用异步函数 <code>fetchUserOrder()</code> 和 <code>createOrderMessage()</code> 之前。</li>
</ul>
<p>关键术语:</p>
<ul>
<li>async: 你可以在一个函数的主体前使用 <code>async</code> 关键字来标记它为异步函数。</li>
<li>async 函数: <code>async</code> 函数是一个标有 <code>async</code> 关键字的函数。</li>
<li>await：可以使用 <code>await</code> 关键字来获取异步表达式的完成结果。<code>await</code> 关键字只在 <code>async</code> 函数中起作用。</li>
</ul>
<h3 id="使用-async-和-await-的执行流程">使用 async 和 await 的执行流程</h3>
<p>一个异步函数在第一个 <code>await</code> 关键字之前是同步运行的。这意味着在一个 <code>async</code> 函数体中，第一个 <code>await</code> 关键字之前的所有同步代码都会立即执行。</p>
<p>版本说明：在 Dart 2.0 之前，一个异步函数立即返回，而不会在异步函数体中执行任何代码。</p>
<h3 id="例子在异步函数内执行在异步函数中执行">例子：在异步函数内执行。在异步函数中执行</h3>
<p>运行下面的例子，看看如何在异步函数体中执行。你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">printOrderMessage</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Awaiting user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Your order is: </span><span class="si">$</span><span class="n">order</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Imagine that this function is more complex and slow.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">4</span><span class="p">)</span><span class="p">,</span> <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">Large Latte</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="n">countSeconds</span><span class="p">(</span><span class="m">4</span><span class="p">)</span><span class="p">;</span>
  <span class="kd">await</span> <span class="n">printOrderMessage</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// You can ignore this function - it&#39;s here to visualize delay time in this example.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">countSeconds</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="n">i</span><span class="p">)</span><span class="p">,</span> <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>运行上例中的代码后，尝试将第2行和第3行反过来。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Awaiting user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>注意到输出的时间发生了变化，现在 <code>print('Awaiting user order')</code> 出现在 <code>printOrderMessage()</code> 中第一个 <code>await</code> 关键字之后。</p>
<h3 id="练习-练习使用-async-和-await">练习: 练习使用 async 和 await</h3>
<p>下面的练习是一个失败的单元测试，其中包含部分完成的代码片段。你的任务是通过编写代码使测试通过来完成练习。你不需要实现 <code>main()</code>。</p>
<p>为了模拟异步操作，调用以下函数，这些函数是为你提供的。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">类型签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">fetchRole()</td>
<td align="left">Future<!-- raw HTML omitted --> fetchRole()</td>
<td align="left">获取用户角色的简短描述。</td>
</tr>
<tr>
<td align="left">fetchLoginAmount()</td>
<td align="left">Future<!-- raw HTML omitted --> fetchLoginAmount()</td>
<td align="left">获取用户的登录次数。</td>
</tr>
</tbody>
</table>
<p>第1部分：<code>reportUserRole()</code></p>
<p>为 <code>reportUserRole()</code> 函数添加代码，使其执行以下操作。</p>
<ul>
<li>返回一个以下列字符串完成的 future： <code>&quot;User role: &lt;user role&gt;&quot;</code>。
<ul>
<li>注意：你必须使用 <code>fetchRole()</code> 返回的实际值；复制和粘贴示例返回值不会使测试通过。</li>
<li>示例返回值: &ldquo;User role: tester&rdquo;</li>
</ul>
</li>
<li>通过调用提供的函数 <code>fetchRole()</code> 获取用户角色。</li>
</ul>
<p>第二部分：<code>reportLogins()</code></p>
<p>实现一个异步函数 <code>reportLogins()</code>，使其执行以下操作。</p>
<ul>
<li>返回字符串 &ldquo;Total number of logins: &lt;# of logins&gt;&rdquo;。
<ul>
<li>注意：你必须使用 <code>fetchLoginAmount()</code> 返回的实际值；复制和粘贴示例返回值不会使测试通过。</li>
<li><code>reportLogins()</code> 的返回值示例: <code>&quot;Total number of logins: 57&quot;</code>。</li>
</ul>
</li>
<li>通过调用提供的函数 <code>fetchLoginAmount()</code> 来获取登录次数。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">reportUserRole</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">username</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchRole</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;</span><span class="s1">User role: </span><span class="si">$</span><span class="n">username</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">reportLogins</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">logins</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchLoginAmount</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="s1">&#39;</span><span class="s1">Total number of logins: </span><span class="si">$</span><span class="n">logins</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>注意：如果你的代码通过了测试，你可以忽略信息级的消息。</p>
<h2 id="处理错误">处理错误</h2>
<p>要处理 <code>async</code> 函数中的错误，使用 <code>try-catch</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Awaiting user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Caught error: </span><span class="si">$</span><span class="n">err</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>在一个 <code>async</code> 函数中，你可以像在同步代码中一样编写 <code>try-catch</code> 子句。</p>
<h3 id="例子async-和-await-的-try-catch-子句">例子：<code>async</code> 和 <code>await</code> 的 <code>try-catch</code> 子句</h3>
<p>运行下面的例子，看看如何处理一个异步函数的错误。你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">printOrderMessage</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">order</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Awaiting user order...</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="n">print</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Caught error: </span><span class="si">$</span><span class="n">err</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">fetchUserOrder</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Imagine that this function is more complex.
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">str</span> <span class="o">=</span> <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span>
      <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">4</span><span class="p">)</span><span class="p">,</span>
      <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="k">throw</span> <span class="s1">&#39;</span><span class="s1">Cannot locate user order</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">await</span> <span class="n">printOrderMessage</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="练习-练习处理错误">练习: 练习处理错误</h3>
<p>下面的练习提供了使用异步代码处理错误的练习，使用上一节中描述的方法。为了模拟异步操作，你的代码将调用以下函数，该函数为你提供。</p>
<p>| 函数                | 类型签名 | 描述 |
| fetchNewUsername() | Future<!-- raw HTML omitted --> fetchNewUsername() |	返回你可以用来替换旧用户名的新用户名。|</p>
<p>使用 <code>async</code> 和 <code>await</code> 来实现一个异步的 <code>changeUsername()</code> 函数，该函数执行以下操作。</p>
<ul>
<li>调用提供的异步函数 <code>fetchNewUsername()</code> 并返回其结果。
<ul>
<li><code>changeUsername()</code> 的返回值示例: &ldquo;jane_smith_92&rdquo;</li>
</ul>
</li>
<li>捕获任何发生的错误并返回错误的字符串值。
<ul>
<li>你可以使用 <a href="https://api.dart.dev/stable/dart-core/ArgumentError/toString.html">toString()</a> 方法对 <a href="https://api.dart.dev/stable/dart-core/Exception-class.html">Exceptions</a> 和<a href="https://api.dart.dev/stable/dart-core/Error-class.html">Errors</a> 进行字符串化。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">changeUsername</span> <span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">await</span> <span class="n">fetchNewUsername</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="练习-把所有的东西放在一起">练习: 把所有的东西放在一起</h3>
<p>现在是时候在最后一个练习中练习所学的知识了。为了模拟异步操作，本练习提供了异步函数 <code>fetchUsername()</code> 和 <code>logoutUser()</code>:</p>
<p>| 函数             | 类型签名                        | 描述 |
| fetchUsername() |	Future<!-- raw HTML omitted --> fetchUsername() | 返回与当前用户相关联的名称。 |
| logoutUser()	  | Future<!-- raw HTML omitted --> logoutUser()	   | 执行当前用户的注销，并返回被注销的用户名。 |</p>
<p>编写以下内容。</p>
<p>第一部分：<code>addHello()</code></p>
<ul>
<li>编写一个函数 <code>addHello()</code>，它接受一个单一的 <code>String</code> 参数。</li>
<li><code>addHello()</code> 返回它的 <code>String</code> 参数，前面加 &lsquo;Hello&rsquo;。
例如：<code>addHello('Jon')</code> 返回 &lsquo;Hello Jon&rsquo;。</li>
</ul>
<p>第二部分：<code>greetUser()</code></p>
<ul>
<li>编写一个不接受参数的函数 <code>greetUser()</code>。</li>
<li>为了得到用户名，<code>greetUser()</code> 调用提供的异步函数 <code>fetchUsername()</code>。</li>
<li><code>greetUser()</code> 通过调用 <code>addHello()</code> 为用户创建一个问候语，传递用户名，并返回结果。
例子: 如果 <code>fetchUsername()</code> 返回 &lsquo;Jenny&rsquo;, 那么 <code>greetUser()</code> 返回 &lsquo;Hello Jenny&rsquo;.</li>
</ul>
<p>第三部分：<code>sayGoodbye()</code></p>
<ul>
<li>
<p>编写一个函数 <code>sayGoodbye()</code>，它的功能如下。</p>
<ul>
<li>不接受任何参数</li>
<li>捕获任何错误。</li>
<li>调用所提供的异步函数 logoutUser().</li>
</ul>
</li>
<li>
<p>如果 <code>logoutUser()</code> 失败，<code>sayGoodbye()</code> 返回任何你喜欢的字符串。</p>
</li>
<li>
<p>如果 <code>logoutUser()</code> 成功，<code>sayGoodbye()</code> 返回字符串 <code>'&lt;result&gt; Thanks, see you next time'</code>，其中 <code>&lt;result&gt;</code> 是调用 <code>logoutUser()</code> 返回的字符串值。</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">addHello</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">Hello </span><span class="si">$</span><span class="n">user</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">greetUser</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">username</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">fetchUsername</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">addHello</span><span class="p">(</span><span class="n">username</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">sayGoodbye</span><span class="p">(</span><span class="p">)</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">result</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">logoutUser</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">$</span><span class="n">result</span><span class="s1"> Thanks, see you next time</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="s1">Failed to logout user: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="下一步是什么">下一步是什么？</h2>
<p>恭喜你，你已经完成了 codelab 的学习！如果你还想了解更多，这里有一些下一步的建议。</p>
<ul>
<li>玩玩 <a href="https://dartpad.dev/">DartPad</a>。</li>
<li>尝试另一个 <a href="https://dart.dev/codelabs">codelab</a>。</li>
<li>学习更多关于 futures 和异步的知识。
<ul>
<li><a href="https://dart.dev/tutorials/language/streams">Streams tutorial</a>: 学习如何使用异步事件的序列。</li>
<li><a href="https://www.youtube.com/playlist?list=PLjxrf2q8roU0Net_g1NT5_vOO3s_FR02J">来自 Google 的 Dart视频</a>: 观看一个或多个关于异步编码的视频。或者，如果你喜欢，阅读基于这些视频的文章。(从<a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a">隔离和事件循环</a>开始。)</li>
</ul>
</li>
<li><a href="https://dart.dev/get-dart">获取 Dart SDK</a>。</li>
</ul>
<p>如果你对使用嵌入式 DartPads 感兴趣，就像这个 codelab 一样，请看<a href="https://dart.dev/resources/dartpad-best-practices">教程中使用 DartPad 的最佳实践</a>。</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/async" term="async" label="async" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/futures" term="futures" label="futures" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/await" term="await" label="await" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[编写你的第一个 Flutter 应用，第一部分]]></title>
            <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第二部分" />
            
                <id>https://ohmyweekly.github.io/notes/write-your-first-flutter-app/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-26T00:00:00+08:00</published>
            <updated>2020-06-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为手机、网页和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起使用，被世界各地的开发者和组织使用，并且是免费和开源的。</blockquote><h2 id="介绍">介绍</h2>
<p>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为手机、网页和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起工作，被世界各地的开发者和组织使用，并且是免费和开源的。</p>
<p>在这个代码实验室中，你将创建一个简单的手机 Flutter 应用。如果你熟悉面向对象的代码和基本的编程概念-如变量、循环和条件, 那么你就可以完成这个 codelab。你不需要以前有 Dart、手机或 Web 编程的经验。</p>
<h3 id="你将在第1部分学到什么">你将在第1部分学到什么</h3>
<ul>
<li>如何编写一款在 iOS、Android 和 Web 上看起来很自然的 Flutter 应用？</li>
<li>Flutter 应用程序的基本结构。</li>
<li>寻找和使用包来扩展功能。</li>
<li>使用热重装来加快开发周期。</li>
<li>如何实现一个有状态的小组件。</li>
<li>如何创建一个无限的、懒加载的列表。</li>
</ul>
<p>在这个 codelab 的<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/index.html?index=..%2F..%2Findex#0">第2部分</a>中，你将添加交互性，修改应用程序的主题，并添加导航到新页面的能力(在 Flutter 中称为路由)。</p>
<h3 id="你将在第1部分中构建什么">你将在第1部分中构建什么</h3>
<p>你将实现一个移动应用，为一家创业公司生成建议的名字。用户可以选择和取消选择名字，保存最好的名字。代码一次懒惰地生成10个名字。随着用户的滚动，会生成更多的名字。用户可以滚动的范围没有限制。</p>
<p>下面的 GIF 动画显示了应用程序在完成部分时的工作情况。</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/6556f8b61acd6a89.gif" alt="img"></p>
<h2 id="设置你的-flutter-环境">设置你的 Flutter 环境</h2>
<p>你需要两个软件来完成这个实验室-<a href="https://flutter.io/get-started/install/">Flutter SDK</a>和<a href="https://flutter.io/get-started/editor/">一个编辑器</a>。(codelab 假设你使用 Android Studio，但你可以使用你的首选编辑器。)</p>
<p>你可以通过使用以下任何设备来运行 codelab。</p>
<ul>
<li>一个物理的 <a href="https://flutter.io/setup-macos/#set-up-your-android-device">Android</a> 或 <a href="https://flutter.io/setup-macos/#deploy-to-ios-devices">iOS</a> 设备连接到你的计算机并设置为开发者模式。</li>
<li><a href="https://flutter.io/setup-macos/#set-up-the-ios-simulator">iOS 模拟器</a>(需要安装 Xcode 工具)</li>
<li><a href="https://flutter.io/setup-macos/#set-up-the-android-emulator">安卓模拟器</a>(需要在 Android Studio 中进行设置)</li>
<li>浏览器(调试时需要使用 Chrome 浏览器)</li>
</ul>
<p>如果你想编译你的应用程序以在 web 上运行，你必须启用此功能（目前处于测试阶段）。要启用 web 支持，请使用以下说明。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">flutter channel beta
flutter upgrade
flutter config --enable-web
</code></pre></div><p>你只需要运行一次 <code>config</code> 命令。启用 Web 支持后，你创建的每个 Flutter 应用也会为 Web 编译。在你的 IDE 的<strong>设备</strong>下拉菜单下面，或者在命令行使用 <code>flutter devices</code>，你现在应该看到 Chrome 和 Web 服务器被列出。<strong>Chrome</strong> 设备会自动启动 Chrome。Web 服务器会启动一个托管应用程序的服务器，这样你就可以从任何浏览器加载它。在开发过程中使用 <strong>Chrome</strong> 设备，以便你可以使用 DevTools，而当你要在其他浏览器上进行测试时使用 Web 服务器。有关更多信息，请参阅<a href="https://flutter.dev/docs/get-started/web">使用 Flutter 构建 Web 应用程序</a>和<a href="https://flutter.dev/docs/get-started/codelab-web">在 Web 上编写你的第一个 Flutter 应用程序</a>。</p>
<h2 id="创建-flutter-应用程序的启动器">创建 Flutter 应用程序的启动器</h2>
<p>通过使用<a href="https://flutter.dev/docs/get-started/test-drive#androidstudio">创建应用程序</a>中的说明来创建一个简单的、模板化的 Flutter 应用程序。输入 <code>startup_namer</code>(而不是 <code>flutter_app</code>)作为项目名称。您将修改启动器应用程序来创建完成的应用程序。</p>
<p>提示：如果你在 IDE 中没有看到能够启动一个新的 Flutter 项目作为一个选项，那么请确保你已经<a href="https://flutter.io/get-started/editor/#androidstudio">安装了 Flutter 和 Dart 的插件</a>。</p>
<p>你将主要编辑 <code>lib/main.dart</code>，Dart 的代码就在这里。</p>
<p>替换 <code>lib/main.dart</code> 的内容。
删除 <code>lib/main.dart</code> 中的所有代码，并用下面的代码替换，在屏幕中央显示 &ldquo;Hello World&rdquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:flutter/material.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">runApp</span><span class="p">(</span><span class="n">MyApp</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">Scaffold</span><span class="p">(</span>
        <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
          <span class="nl">title:</span> <span class="kd">const</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
        <span class="nl">body:</span> <span class="kd">const</span> <span class="n">Center</span><span class="p">(</span>
          <span class="nl">child:</span> <span class="kd">const</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Hello World</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>提示：当把代码粘贴到你的应用程序中时，缩进会变得歪斜。你可以用以下 Flutter 工具来解决。</p>
<ul>
<li>Android Studio/IntelliJ IDEA: 右键点击 Dart 代码，选择<strong>用 dartfmt 重格式代码</strong>。</li>
<li>VS code: 右键点击并选择<strong>格式化文档</strong>。</li>
<li>终端: 运行 <code>flutter format &lt;文件名&gt;</code>。</li>
</ul>
<p><a href="https://flutter.io/get-started/test-drive/#androidstudio">运行应用程序</a>。您应该看到 Android，iOS 或 Web 输出，取决于您的设备。</p>
<p>安卓系统:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/f9df7832965ede9f.png" alt="img"></p>
<p>iOS:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/20374605026d582.png" alt="img"></p>
<p>小贴士：第一次在物理设备上运行时，可能需要一段时间来加载。之后，你可以使用热重载来快速更新。在支持的 IDE 中，如果应用正在运行，<strong>Save</strong> 也会执行热重载。当使用 <code>flutter run</code> 直接从控制台运行应用程序时，输入 <code>r</code> 来执行热重载。</p>
<p>观察:</p>
<ul>
<li>这个例子创建了一个 Material 应用。<a href="https://material.io/guidelines/">Material</a> 是一种视觉设计语言，是移动和 Web 的标准。Flutter 提供了一套丰富的 Material 部件。</li>
<li><code>main</code> 方法使用箭头(<code>=&gt;</code>)符号。对单行函数或方法使用箭头符号。</li>
<li>应用程序扩展了 <code>StatelessWidget</code>，这使得应用程序本身成为一个组件。在 Flutter 中，几乎所有的东西都是组件，包括对齐、填充和布局。</li>
<li><code>Scaffold</code> 组件来自 Material 库，它提供了一个默认的应用栏、一个标题和一个 body 属性，其中存放着主屏幕的组件树。组件子树可以相当复杂。</li>
<li>组件的主要工作是提供一个 <code>build</code> 方法，描述如何用其他低级组件来显示该组件。</li>
<li>本例的主体由包含 <code>Text</code> 子部件的 <code>Center</code> 部件组成。<code>Center</code> 组件将其组件子树对齐到屏幕的中心。</li>
</ul>
<h2 id="使用外部软件包">使用外部软件包</h2>
<p>在这一步中，您将开始使用一个名为 <code>english_words</code> 的开源包，它包含了几千个最常用的英语单词，还有一些实用函数。</p>
<p>你可以在 <a href="https://pub.dev/">pub.dev</a> 找到 <code>english_words</code> 包，以及许多其他开源包。</p>
<p>pubspec 文件管理着 Flutter 应用的资产。在 <code>pubspec.yaml</code> 中，附加 <code>english_words: ^3.1.5</code>(<code>english_words</code> 3.1.5 或更高)到依赖列表中。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">dependencies</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">flutter</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">sdk</span><span class="p">:</span><span class="w"> </span>flutter<span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">cupertino_icons</span><span class="p">:</span><span class="w"> </span>^<span class="m">0.1</span><span class="m">.2</span><span class="w">
</span><span class="w">  </span><span class="k">english_words</span><span class="p">:</span><span class="w"> </span>^<span class="m">3.1</span><span class="m">.5</span><span class="w">   </span><span class="c"># add this line</span><span class="w">
</span></code></pre></div><p>在 Android Studio 的编辑器视图中查看 pubspec 时，点击 <strong>Packages get</strong>。这将把包拉到你的项目中。你应该在控制台中看到以下内容。</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">flutter packages get
Running &#34;flutter packages get&#34; in startup_namer...
Process finished with exit code 0
</code></pre></div><p>执行 <code>Pub get</code> 也会自动生成 &ldquo;pubspec.lock&rdquo; 文件，其中包含所有拉入项目的包的列表和它们的版本号。</p>
<p>在 <code>lib/main.dart</code> 中，导入新包:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:flutter/material.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:english_words/english_words.dart</span><span class="s1">&#39;</span><span class="p">;</span>  <span class="c1">// Add this line.
</span></code></pre></div><p>当你输入时，Android Studio 会给你建议导入的库。然后，它将导入的字符串渲染成灰色，让你知道导入的库是未使用的（到目前为止）。</p>
<p>接下来，你将使用 <code>english_words</code> 包来生成文本，而不是使用 &ldquo;Hello World&rdquo;。</p>
<p>做以下修改。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:flutter/material.dart</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">&#39;</span><span class="s1">package:english_words/english_words.dart</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">runApp</span><span class="p">(</span><span class="n">MyApp</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="n">wordPair</span> <span class="o">=</span> <span class="n">WordPair</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// Add this line.
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">Scaffold</span><span class="p">(</span>
        <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
          <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
        <span class="nl">body:</span> <span class="n">Center</span><span class="p">(</span>
          <span class="c1">//child: Text(&#39;Hello World&#39;),   // Replace this text...
</span><span class="c1"></span>          <span class="nl">child:</span> <span class="n">Text</span><span class="p">(</span><span class="n">wordPair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">)</span><span class="p">,</span>  <span class="c1">// With this text.
</span><span class="c1"></span>        <span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>提示: Pascal 大小写(也称为上驼形大小写)意味着字符串中的每个单词，包括第一个单词，都以大写字母开头。所以，<code>uppercamelcase</code> 就变成了 <code>UpperCamelCase</code>。</p>
<p>如果应用程序正在运行，热重载来更新正在运行的应用程序。(在命令行中，你可以输入 <code>r</code> 来热重载。)每次点击热重载或保存项目时，你应该会在运行中的应用程序中看到一个不同的单词对，随机选择。这是因为单词对是在 <code>build</code> 方法里面生成的，每次 <code>MaterialApp</code> 需要渲染时，或者在 Flutter Inspector 中切换 <strong>Platform</strong> 时，都会运行该方法。</p>
<p>Android:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/57cfbac8f2b50e5b.png" alt="img"></p>
<p>iOS:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/30ed7f83a1500fa9.png" alt="img"></p>
<h3 id="有问题">有问题？</h3>
<p>如果您的应用程序没有正确运行，请查找错别字。如果需要，请使用以下链接中的代码来恢复正常。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step2_use_package/pubspec.yaml">pubspec.yaml</a></li>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step2_use_package/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="添加一个有状态的组件">添加一个有状态的组件</h2>
<p>无状态组件是不可改变的，这意味着它们的属性不能改变-所有值都是最终值。</p>
<p>有状态组件维护的状态可能在组件的生命周期内发生变化。实现一个有状态的组件至少需要两个类。1) 一个 <a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html">StatefulWidget</a>，它可以创建一个 <a href="https://docs.flutter.io/flutter/widgets/State-class.html">State</a> 类的实例。<code>StatefulWidget</code> 对象本身是不可变的，可以被丢弃和再生，但 <code>State</code> 对象会在 widget 的生命周期内持久存在。</p>
<p>在这一步骤中，您将添加一个有状态的组件 <code>RandomWords</code>，并创建其 <code>State</code> 类 <code>_RandomWordsState</code>。然后，您将在现有的 MyApp 无状态组件中使用 <code>RandomWords</code> 作为子类。</p>
<p>为有状态组件创建模板代码。</p>
<p>它可以放在 <code>MyApp</code> 以外的文件中的任何位置，但解决方案将其放在文件的底部。在 <code>lib/main.dart</code> 中，将光标定位在所有代码之后，输入回车键几次，重新开始一行。在你的 IDE 中，开始输入 <code>stful</code>。编辑器会询问你是否要创建一个 <code>Stateful</code> 的组件。按回车键接受。两个类的模板代码出现了，光标定位让你输入无状态组件的名称。</p>
<p>输入 <code>RandomWords</code> 作为您的小组件的名称。</p>
<p>正如您在下面的代码中所看到的，<code>RandomWords</code> 组件除了创建它的 <code>State</code> 类之外，几乎没有其他的功能。</p>
<p>一旦您输入 <code>RandomWords</code> 作为有状态组件的名称，IDE 会自动更新相应的 <code>State</code> 类，将其命名为 <code>_RandomWordState</code>。默认情况下，<code>State</code> 类的名称是以下划线为前缀的。在标识符前加上下划线可以加强 Dart 语言的<a href="https://dart.dev/guides/language/language-tour#libraries-and-visibility">隐私性</a>，也是 <code>State</code> 对象的最佳实践。</p>
<p>IDE 也会自动更新 State 类以扩展 <code>State&lt;RandomWords&gt;</code>，表明你正在使用一个专门用于 <code>RandomWords</code> 的通用 <a href="https://api.flutter.dev/flutter/widgets/State-class.html">State</a> 类。应用程序的大部分逻辑都在这里-它为 <code>RandomWords</code> 组件维护状态。这个类保存了生成的词对列表，随着用户的滚动而无限增长，在本实验室的第二部分中，当用户通过切换心形图标从列表中添加或删除这些词对时，该类会对其进行收藏。</p>
<p>现在两个类的外观如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">RandomWords</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">_RandomWordsState</span> <span class="n">createState</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">_RandomWordsState</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Container</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>更新 <code>_RandomWordsState</code> 中的 <code>build()</code> 方法。</p>
<p>用以下两行替换 <code>return Container();</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>                                  
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="n">wordPair</span> <span class="o">=</span> <span class="n">WordPair</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>      <span class="c1">// NEW
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">Text</span><span class="p">(</span><span class="n">wordPair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">)</span><span class="p">;</span>      <span class="c1">// NEW
</span><span class="c1"></span>  <span class="p">}</span>                                         
<span class="p">}</span>
</code></pre></div><p>通过以下修改，删除 <code>MyApp</code> 中的文字生成代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">final</span> <span class="n">wordPair</span> <span class="o">=</span> <span class="n">WordPair</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// DELETE
</span><span class="c1"></span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">Scaffold</span><span class="p">(</span>
        <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
          <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Welcome to Flutter</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="p">)</span><span class="p">,</span>
        <span class="nl">body:</span> <span class="n">Center</span><span class="p">(</span>
          <span class="c1">//child: Text(wordPair.asPascalCase), // REPLACE with... 
</span><span class="c1"></span>          <span class="nl">child:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>                 <span class="c1">// ...this line
</span><span class="c1"></span>        <span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>热重载应用程序。应用程序应该像以前一样，每次热重载或保存应用程序时都会显示一个单词配对。</p>
<p>提示：如果您在热重载时看到警告，表明您可能需要重新启动应用程序，您应该考虑重新启动应用程序。这可能是一个假阳性，但重启可以确保您的更改反映在应用程序的 UI 中。</p>
<h3 id="遇到问题了">遇到问题了？</h3>
<p>如果您的应用程序没有正确运行，您可以使用以下链接中的代码来恢复正常。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step3_stateful_widget/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="创建一个无限滚动的-listview">创建一个无限滚动的 ListView</h2>
<p>在这一步中，您将展开 <code>_RandomWordsState</code> 来生成并显示单词配对列表。随着用户的滚动，列表（显示在 ListView 小组件中）会无限增长。ListView 中的构建器工厂构造函数允许你按需懒惰地构建一个列表视图。</p>
<p>在 <code>_RandomWordState</code> 类中添加一些状态变量。</p>
<p>增加一个 <code>_suggestions</code> 列表，用于保存建议的单词配对。另外，添加一个 <code>_biggerFont</code> 变量，用于使字体大小变大。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span> <span class="n">_suggestions</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span><span class="p">[</span><span class="p">]</span><span class="p">;</span>            <span class="c1">// NEW
</span><span class="c1"></span>  <span class="kd">final</span> <span class="n">TextStyle</span> <span class="n">_biggerFont</span> <span class="o">=</span> <span class="kd">const</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">18</span><span class="p">)</span><span class="p">;</span> <span class="c1">// NEW
</span><span class="c1"></span>  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>接下来，你将在 <code>_RandomWordsState</code> 类中添加一个 <code>_buildSuggestions()</code> 函数。这个方法可以构建显示建议词对的 <code>ListView</code>。</p>
<p><code>ListView</code> 类提供了一个构建器属性 <code>itemBuilder</code>，它是一个工厂构建器和回调函数，指定为一个匿名函数。两个参数被传递给函数&ndash;<code>BuildContext</code> 和行迭代器 <code>i</code>。迭代器从0开始，每次调用函数时递增，每一个建议的单词配对都会递增一次。这个模型允许建议列表在用户滚动时继续增长。</p>
<p>添加整个 <code>_buildSuggestions</code> 函数。</p>
<p>在 <code>_RandomWordsState</code> 类中，添加以下函数，如果你喜欢，请删除注释:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildSuggestions</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ListView</span><span class="p">.</span><span class="n">builder</span><span class="p">(</span>
      <span class="nl">padding:</span> <span class="kd">const</span> <span class="n">EdgeInsets</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="m">16</span><span class="p">)</span><span class="p">,</span>
      <span class="c1">// The itemBuilder callback is called once per suggested 
</span><span class="c1"></span>      <span class="c1">// word pairing, and places each suggestion into a ListTile
</span><span class="c1"></span>      <span class="c1">// row. For even rows, the function adds a ListTile row for
</span><span class="c1"></span>      <span class="c1">// the word pairing. For odd rows, the function adds a 
</span><span class="c1"></span>      <span class="c1">// Divider widget to visually separate the entries. Note that
</span><span class="c1"></span>      <span class="c1">// the divider may be difficult to see on smaller devices.
</span><span class="c1"></span>      <span class="nl">itemBuilder:</span> <span class="p">(</span><span class="n">BuildContext</span> <span class="n">_context</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Add a one-pixel-high divider widget before each row 
</span><span class="c1"></span>        <span class="c1">// in the ListView.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">isOdd</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">Divider</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// The syntax &#34;i ~/ 2&#34; divides i by 2 and returns an 
</span><span class="c1"></span>        <span class="c1">// integer result.
</span><span class="c1"></span>        <span class="c1">// For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.
</span><span class="c1"></span>        <span class="c1">// This calculates the actual number of word pairings 
</span><span class="c1"></span>        <span class="c1">// in the ListView,minus the divider widgets.
</span><span class="c1"></span>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">~</span><span class="o">/</span> <span class="m">2</span><span class="p">;</span>
        <span class="c1">// If you&#39;ve reached the end of the available word
</span><span class="c1"></span>        <span class="c1">// pairings...
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">_suggestions</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// ...then generate 10 more and add them to the 
</span><span class="c1"></span>          <span class="c1">// suggestions list.
</span><span class="c1"></span>          <span class="n">_suggestions</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">generateWordPairs</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">_suggestions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p><code>_buildSuggestions</code> 函数对每个词对调用一次 <code>_buildRow</code>。该函数在 <code>ListTile</code> 中显示每一个新的词对，这使得你可以在<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/index.html?index=..%2F..index#0">第2部分</a>中使行更有吸引力。</p>
<p>在 <code>_RandomWordsState</code> 中添加一个 <code>_buildRow</code> 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
        <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
        <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p>更新 <code>_RandomWordsState</code> 的构建方法。</p>
<p>将其改为使用 <code>_buildSuggestions()</code>，而不是直接调用单词生成库。(<code>Scaffold</code> 实现了基本的 Material Design 视觉布局。)</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="err">@</span><span class="n">override</span>
<span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//final wordPair = WordPair.random(); // Delete these... 
</span><span class="c1"></span>    <span class="c1">//return Text(wordPair.asPascalCase); // ... two lines.
</span><span class="c1"></span>
    <span class="k">return</span> <span class="n">Scaffold</span> <span class="p">(</span>                     <span class="c1">// Add from here... 
</span><span class="c1"></span>      <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
        <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>
      <span class="nl">body:</span> <span class="n">_buildSuggestions</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>                                      <span class="c1">// ... to here.
</span><span class="c1"></span>  <span class="p">}</span>
</code></pre></div><p>更新 <code>MyApp</code> 的构建方法，更改标题，删除 <code>AppBar</code>，并将 home 属性改为 <code>RandomWords</code> 部件。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="err">@</span><span class="n">override</span>
<span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><p>重新启动应用程序。无论你滚动多远，你都应该看到一个单词配对的列表。</p>
<p>Android:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/df2b3cb779e0020e.png" alt="img"></p>
<p>iOS:</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/ae47ef0ac2f492b8.png" alt="img"></p>
<h3 id="遇到问题了-1">遇到问题了？</h3>
<p>如果你的应用程序不能正常运行，你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step4_infinite_list/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="今后的步骤">今后的步骤</h2>
<p><strong>恭喜你！</strong></p>
<p>你已经完成了这个代码实验室的第一部分! 如果你想扩展这款应用，请进入<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/#0">第二部分</a>，你将对应用进行如下修改。</p>
<ul>
<li>增加互动性</li>
<li>增加导航到新路由的功能。</li>
<li>修改主题颜色。</li>
</ul>
<p>当第2部分完成后，应用程序将是这样的：</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/img/7fcab088cd22cff7.gif" alt="img"></p>
<h3 id="其他后续步骤">其他后续步骤</h3>
<p>通过以下资源了解更多关于 Flutter SDK 的信息。</p>
<ul>
<li><a href="https://flutter.dev/docs/development/ui/layout">Flutter 中的布局</a></li>
<li><a href="https://flutter.dev/docs/development/ui/interactive">增加互动性教程</a></li>
<li><a href="https://flutter.dev/docs/development/ui/widgets-intro">组件介绍</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/android-devs">为 Android 开发者提供的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/react-native-devs">针对 React Native 开发者的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/web-devs">Web 开发人员的 Flutter</a></li>
<li><a href="https://www.youtube.com/flutterdev">Flutter YouTube 频道</a></li>
</ul>
<p>其他资源包括以下几点:</p>
<ul>
<li><a href="https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905">用 Flutter 构建本地移动应用</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/from-java-to-dart/#1">从 Java 到 Dart codelab</a></li>
<li><a href="https://flutter.dev/cookbook/">Flutter cookbook</a></li>
<li><a href="https://flutter.dev/bootstrap-into-dart/">融入 Dart 的 Bootstrap：了解更多关于这门语言的信息</a></li>
</ul>
<p>同时，<a href="https://flutter.dev/community">与 Flutter 社区联系起来!</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/app" term="app" label="app" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[编写你的第一个 Flutter 应用，第二部分]]></title>
            <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/write-your-first-flutter-app/?utm_source=atom_feed" rel="related" type="text/html" title="编写你的第一个 Flutter 应用，第一部分" />
            
                <id>https://ohmyweekly.github.io/notes/write-your-first-flutter-app-part-two/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-26T00:00:00+08:00</published>
            <updated>2020-06-26T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为手机、网页和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起使用，被世界各地的开发者和组织使用，并且是免费和开源的。</blockquote><h2 id="介绍">介绍</h2>
<p>Flutter 是 Google 的 UI 工具包，用于从单一代码库中为移动、Web 和桌面构建漂亮的、原生编译的应用程序。Flutter 可以与现有的代码一起工作，被世界各地的开发者和组织使用，并且是免费和开源的。</p>
<p>在这个代码实验室中，您将扩展一个基本的、移动的 Flutter 应用程序，以包含交互性。您还将创建一个用户可以导航到的第二个页面（称为路由）。最后，您将修改应用程序的主题（颜色）。这个代码实验室扩展了第1部分，在这部分中，你将<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/">创建一个无限的懒惰加载的列表</a>，但如果你想从第2部分开始，我们将提供起始代码。</p>
<h3 id="你将在第二部分学到什么">你将在第二部分学到什么</h3>
<ul>
<li>如何编写一款在 iOS、Android 和 Web 上看起来很自然的 Flutter 应用？</li>
<li>如何使用热重装，加快开发周期？</li>
<li>如何为有状态的 widget 添加交互性？</li>
<li>如何创建并导航到第二个屏幕？</li>
<li>如何使用主题来改变应用程序的外观？</li>
</ul>
<h3 id="你将在第二部分建立什么">你将在第二部分建立什么</h3>
<p>您将从一个简单的移动应用程序开始，为创业公司生成一个无尽的建议名称列表。在代码实验室结束时，您的最终用户可以选择和取消选择名称，保存最好的名称。点击应用栏右上角的列表图标可以导航到一个新的页面（称为路由），该页面只列出了最喜欢的名字。</p>
<p>下面的 GIF 动画显示了完成的应用程序将如何工作。</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/7fcab088cd22cff7.gif" alt="img"></p>
<h2 id="设置您的-flutter-环境">设置您的 Flutter 环境</h2>
<p>如果你还没有完成第1部分，请看<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/#1">设置你的 Flutter 环境</a>，在<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1/">编写你的第一个Flutter应用，第1部分</a>，设置你的 Flutter 开发环境。</p>
<h2 id="获取启动应用程序">获取启动应用程序</h2>
<p>如果你已经完成了这个 codelab 的第一部分，你已经有了启动应用程序，<code>startup_namer</code>。你可以进行下一步。</p>
<p>如果你没有 <code>startup_namer</code>，不要害怕，你可以使用下面的说明得到它。</p>
<p>使用<a href="https://flutter.dev/get-started/test-drive/#create-app">创建应用程序</a>中的说明创建一个简单的模板化 Flutter 应用程序。将项目命名为 <code>startup_namer</code>（而不是 <code>flutter_app</code>）。</p>
<p>删除 <code>lib/main.dart</code> 中的所有代码。用这个<a href="https://github.com/flutter/codelabs/blob/b3293b5bb0c0187bdbe8112f7759f4d75f4c040a/startup_namer/step4_infinite_list/lib/main.dart">文件</a>中的代码替换，它显示了一个无限的，懒惰加载的建议启动名称列表。</p>
<p>更新 <code>pubspec.yaml</code>，加入英文单词包。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">dependencies</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">  </span><span class="k">flutter</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="w">    </span><span class="k">sdk</span><span class="p">:</span><span class="w"> </span>flutter<span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="k">cupertino_icons</span><span class="p">:</span><span class="w"> </span>^<span class="m">0.1</span><span class="m">.2</span><span class="w">
</span><span class="w">  </span><span class="k">english_words</span><span class="p">:</span><span class="w"> </span>^<span class="m">3.1</span><span class="m">.5</span><span class="w">    </span>//<span class="w"> </span>NEW<span class="w">
</span></code></pre></div><p>英文单词包会生成一对随机的单词，作为潜在的启动名称。</p>
<p>在 Android Studio 的编辑器视图中查看 pubspec 时，点击右上角的 <strong>Pub get</strong>，这将包拉到你的项目中。你应该在控制台中看到以下内容:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">flutter pub get
Running <span class="s2">&#34;flutter pub get&#34;</span> in startup_namer...
Process finished with <span class="nb">exit</span> code <span class="m">0</span>
</code></pre></div><p>运行该应用。</p>
<p>随意滚动，查看持续供应的拟创业公司名称。</p>
<h2 id="将图标添加到列表中">将图标添加到列表中</h2>
<p>在这一步中，你将为每一行添加心形图标。在下一步中，您将使它们可点击并保存收藏夹。</p>
<p>在 <code>_RandomWordsState</code> 中添加一个 <code>_saved</code> Set。这个 <code>Set</code> 存储了用户收藏的单词配对。<code>Set</code> 比 <code>List</code> 更受欢迎，因为一个正确实现的 <code>Set</code> 不允许重复的条目。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">_suggestions</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span><span class="p">[</span><span class="p">]</span><span class="p">;</span>
  <span class="kd">final</span> <span class="n">_saved</span> <span class="o">=</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">WordPair</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>     <span class="c1">// NEW
</span><span class="c1"></span>  <span class="kd">final</span> <span class="n">_biggerFont</span> <span class="o">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">fontSize:</span> <span class="m">18.0</span><span class="p">)</span><span class="p">;</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>在 <code>_buildRow</code> 函数中，添加一个 <code>alreadySaved</code> 检查，以确保一个单词配对还没有被添加到收藏夹中。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">alreadySaved</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// NEW
</span><span class="c1"></span>  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>在 <code>_buildRow()</code> 中，你还将为 <code>ListTile</code> 对象添加心形图标以实现收藏夹。在下一步中，你将添加与心形图标交互的功能。</p>
<p>在文本之后添加图标，如下图所示。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">alreadySaved</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
    <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
      <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
      <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>
    <span class="nl">trailing:</span> <span class="n">Icon</span><span class="p">(</span>   <span class="c1">// NEW from here... 
</span><span class="c1"></span>      <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite</span> <span class="o">:</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite_border</span><span class="p">,</span>
      <span class="nl">color:</span> <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Colors</span><span class="p">.</span><span class="n">red</span> <span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>                <span class="c1">// ... to here.
</span><span class="c1"></span>  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>热重新加载应用程序。</p>
<p>你现在应该看到每一行都有空心，但它们还没有互动。</p>
<p>Android</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/819e2ff89da9421a.png" alt="img"></p>
<p>iOS</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/4df48933551e7c48.png" alt="img"></p>
<h3 id="遇到问题了">遇到问题了？</h3>
<p>如果你的应用程序不能正常运行，你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step5_add_icons/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="增加互动性">增加互动性</h2>
<p>在这一步中，你将使心形图标可以点击。当用户点击列表中的一个条目，切换其收藏状态时，该词对就会从一组保存的收藏夹中添加或删除。</p>
<p>要做到这一点，你将修改 <code>_buildRow</code> 函数。如果一个词条已经被添加到收藏夹中，再次点击它就会将其从收藏夹中删除。当一个磁贴被点击后，函数会调用 <code>setState()</code> 来通知框架状态已经改变。</p>
<p>在 <code>_buildRow</code> 方法中加入 <code>onTap</code>，如下图所示:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Widget</span> <span class="n">_buildRow</span><span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">alreadySaved</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
    <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
      <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
      <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>
    <span class="nl">trailing:</span> <span class="n">Icon</span><span class="p">(</span>
      <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite</span> <span class="o">:</span> <span class="n">Icons</span><span class="p">.</span><span class="n">favorite_border</span><span class="p">,</span>
      <span class="nl">color:</span> <span class="n">alreadySaved</span> <span class="o">?</span> <span class="n">Colors</span><span class="p">.</span><span class="n">red</span> <span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">)</span><span class="p">,</span>
    <span class="nl">onTap:</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>      <span class="c1">// NEW lines from here...
</span><span class="c1"></span>      <span class="n">setState</span><span class="p">(</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">alreadySaved</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">_saved</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
          <span class="n">_saved</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span><span class="p">;</span> 
        <span class="p">}</span> 
      <span class="p">}</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">,</span>               <span class="c1">// ... to here.
</span><span class="c1"></span>  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>提示：在 Flutter 的反应式框架中，调用 <code>setState()</code> 会触发对 <code>State</code> 对象的 <code>build()</code> 方法的调用，导致 UI 的更新。</p>
<p>热重载应用。</p>
<p>你应该能够点击任何磁贴来收藏或不收藏该条目。点击瓷砖会产生一个隐含的从点击点发出的泼墨动画。</p>
<p>Android</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/43dfc7ba5f728e8f.png" alt="img"></p>
<p>iOS</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/e7a99a1b94bea7d4.png" alt="img"></p>
<h3 id="遇到问题了-1">遇到问题了？</h3>
<p>如果你的应用程序不能正常运行，你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step6_add_interactivity/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="导航到一个新的屏幕">导航到一个新的屏幕</h2>
<p>在这一步中，您将添加一个新的页面（在 Flutter 中称为路由），显示收藏夹。您将学习如何在主页路线和新路由之间进行导航。</p>
<p>在 Flutter 中，<code>Navigator</code> 管理着一个包含应用程序路由的堆栈。将一个路由推到 <code>Navigator</code> 的堆栈上，会将显示更新到该路由。从 <code>Navigator</code> 的堆栈中弹出一条路由，会将显示返回到之前的路由。</p>
<p>接下来，您将在 <code>_RandomWordsState</code> 的 <code>build</code> 方法中为 <code>AppBar</code> 添加一个列表图标。当用户点击列表图标时，一个包含保存的收藏夹的新路由会被推送到 <code>Navigator</code>，显示图标。</p>
<p>在 <code>build</code> 方法中添加图标及其对应的操作:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">_RandomWordsState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">RandomWords</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Scaffold</span><span class="p">(</span>
      <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
        <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
        <span class="nl">actions:</span> <span class="p">[</span>              <span class="c1">// NEW lines from here...
</span><span class="c1"></span>          <span class="n">IconButton</span><span class="p">(</span><span class="nl">icon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">list</span><span class="p">)</span><span class="p">,</span> <span class="nl">onPressed:</span> <span class="n">_pushSaved</span><span class="p">)</span><span class="p">,</span>
        <span class="p">]</span><span class="p">,</span>                      <span class="c1">// ... to here.
</span><span class="c1"></span>      <span class="p">)</span><span class="p">,</span>
      <span class="nl">home:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>提示：一些小组件属性会取一个小组件(<code>child</code>)，而其他属性，如 <code>action</code>，会取一组小组件(<code>children</code>), 如方括号(<code>[]</code>)所示。</p>
<p>在 <code>_RandomWordsState</code> 类中添加一个 <code>_pushSaved()</code> 函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">_pushSaved</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div><p>热重新加载应用程序。<a href="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/a114478ae13b853.png">列表图标</a>出现在应用栏中。点击它还没有任何作用，因为 <code>_pushSaved</code> 函数是空的。</p>
<p>接下来，你将建立一条路由，并将其推送到 <code>Navigator</code> 的栈中。这个操作会改变屏幕以显示新的路由。新页面的内容是在 <code>MaterialPageRoute</code> 的构建器属性中以匿名函数的方式构建的。</p>
<p>调用 <code>Navigator.push</code>，如下图所示，它将路由推送到 <code>Navigator</code> 的堆栈中。IDE 会抱怨无效代码，但你会在下一节中解决这个问题。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">_pushSaved</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Navigator</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">)</span><span class="p">.</span><span class="n">push</span><span class="p">(</span>
  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>接下来，你将添加 <code>MaterialPageRoute</code> 和它的构建器。现在，添加生成 <code>ListTile</code> 行的代码。<code>ListTile</code> 的 <code>divideTiles()</code> 方法在每个 <code>ListTile</code> 之间增加了水平间距。被划分的变量持有通过方便函数 <code>toList()</code> 转换为列表的最终行。</p>
<p>添加代码，如下面的代码片段所示:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">_pushSaved</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Navigator</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">)</span><span class="p">.</span><span class="n">push</span><span class="p">(</span>
      <span class="n">MaterialPageRoute</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="c1">// NEW lines from here...
</span><span class="c1"></span>        <span class="nl">builder:</span> <span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">final</span> <span class="n">tiles</span> <span class="o">=</span> <span class="n">_saved</span><span class="p">.</span><span class="n">map</span><span class="p">(</span>
            <span class="p">(</span><span class="n">WordPair</span> <span class="n">pair</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="n">ListTile</span><span class="p">(</span>
                <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span>
                  <span class="n">pair</span><span class="p">.</span><span class="n">asPascalCase</span><span class="p">,</span>
                  <span class="nl">style:</span> <span class="n">_biggerFont</span><span class="p">,</span>
                <span class="p">)</span><span class="p">,</span>
              <span class="p">)</span><span class="p">;</span>
            <span class="p">}</span><span class="p">,</span>
          <span class="p">)</span><span class="p">;</span>
          <span class="kd">final</span> <span class="n">divided</span> <span class="o">=</span> <span class="n">ListTile</span><span class="p">.</span><span class="n">divideTiles</span><span class="p">(</span>
            <span class="nl">context:</span> <span class="n">context</span><span class="p">,</span>
            <span class="nl">tiles:</span> <span class="n">tiles</span><span class="p">,</span>
          <span class="p">)</span><span class="p">.</span><span class="n">toList</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

          <span class="k">return</span> <span class="n">Scaffold</span><span class="p">(</span>
            <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
              <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Saved Suggestions</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">,</span>
            <span class="p">)</span><span class="p">,</span>
            <span class="nl">body:</span> <span class="n">ListView</span><span class="p">(</span><span class="nl">children:</span> <span class="n">divided</span><span class="p">)</span><span class="p">,</span>
          <span class="p">)</span><span class="p">;</span>
        <span class="p">}</span><span class="p">,</span> <span class="c1">// ...to here.
</span><span class="c1"></span>      <span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><code>builder</code> 属性返回一个 <code>Scaffold</code>，包含名为 <code>SavedSuggestions</code> 的新路由的应用栏。新路由的主体由一个包含 <code>ListTiles</code> 行的 <code>ListView</code> 组成。每一行都由一个分隔符隔开。</p>
<p>热重载应用。将一些选择收藏起来，然后点击应用栏中的列表图标。新的路由出现，包含收藏夹。请注意，Navigator 在应用栏中增加了一个&quot;返回&quot;按钮。你不必明确地实现 <code>Navigator.pop</code>。点击&quot;返回&quot;按钮就可以返回到主路由。</p>
<p>iOS - Main route</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/928693968b8e482a.png" alt="img"></p>
<p>iOS - Saved suggestions route</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/2245376356747d5a.png" alt="img"></p>
<h3 id="遇到问题了-2">遇到问题了？</h3>
<p>如果你的应用程序没有正确运行，那么你可以使用下面链接中的代码来回到正轨。</p>
<ul>
<li><a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step7_navigate_route/lib/main.dart">lib/main.dart</a></li>
</ul>
<h2 id="使用主题改变用户界面">使用主题改变用户界面</h2>
<p>在这一步中，您将修改应用程序的主题。主题控制你的应用程序的外观和感觉。您可以使用默认主题，这取决于物理设备或模拟器，或者自定义主题以反映您的品牌。</p>
<p>您可以通过配置 <a href="https://docs.flutter.io/flutter/material/ThemeData-class.html">ThemeData</a> 类轻松更改应用程序的主题。应用程序使用默认主题，但你会将应用程序的主色调改为白色。</p>
<p>在 <code>MyApp</code> 类中更改颜色:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyApp</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="p">{</span>
  <span class="err">@</span><span class="n">override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MaterialApp</span><span class="p">(</span>
      <span class="nl">title:</span> <span class="s1">&#39;</span><span class="s1">Startup Name Generator</span><span class="s1">&#39;</span><span class="p">,</span>
      <span class="nl">theme:</span> <span class="n">ThemeData</span><span class="p">(</span>          <span class="c1">// Add the 3 lines from here... 
</span><span class="c1"></span>        <span class="nl">primaryColor:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">white</span><span class="p">,</span>
      <span class="p">)</span><span class="p">,</span>                         <span class="c1">// ... to here.
</span><span class="c1"></span>      <span class="nl">home:</span> <span class="n">RandomWords</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>热重载应用。现在整个背景都是白色的，甚至应用栏也是白色的。</p>
<p>作为一个练习，使用 <code>ThemeData</code> 来改变 UI 的其他方面。Material 库中的 <a href="https://docs.flutter.io/flutter/material/Colors-class.html">Colors</a> 类提供了许多你可以玩的颜色常量。热重载使得对 UI 的实验变得快速而简单。</p>
<p>Android</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/5d4ed8aeea9e4d0a.png" alt="img"></p>
<p>iOS</p>
<p><img src="https://codelabs.developers.google.com/codelabs/first-flutter-app-pt2/img/c325151f1ae4820d.png" alt="img"></p>
<h3 id="遇到问题了-3">遇到问题了？</h3>
<p>如果你已经偏离了轨道，那么使用下面链接中的代码来查看最终应用的代码。</p>
<p>= <a href="https://github.com/flutter/codelabs/blob/master/startup_namer/step8_themes/lib/main.darts">lib/main.dart</a></p>
<h2 id="做得很好">做得很好！</h2>
<p>你写了一个交互式的 Flutter 应用，可以在 iOS 和 Android 上运行，具体做法如下</p>
<ul>
<li>编写 Dart 代码。</li>
<li>使用热重载来加快开发周期。</li>
<li>实现一个有状态的 widget，为你的应用添加交互性。</li>
<li>创建途径并添加在原途径和新途径之间移动的逻辑。</li>
<li>学习如何使用主题改变你的应用程序的 UI 外观。</li>
</ul>
<h2 id="今后的步骤">今后的步骤</h2>
<p>从以下资源中了解更多关于 Flutter SDK 的信息。</p>
<ul>
<li><a href="https://flutter.dev/docs/development/ui/layout">Flutter 中的布局</a></li>
<li><a href="https://flutter.dev/docs/development/ui/interactive">增加互动性教程</a></li>
<li><a href="https://flutter.dev/docs/development/ui/widgets-intro">组件介绍</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/android-devs">为 Android 开发者提供的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/react-native-devs">针对 React Native 开发者的 Flutter</a></li>
<li><a href="https://flutter.dev/docs/get-started/flutter-for/web-devs">Web 开发人员的 Flutter</a></li>
<li><a href="https://www.youtube.com/flutterdev">Flutter YouTube 频道</a></li>
</ul>
<p>其他资源包括以下几点:</p>
<ul>
<li><a href="https://www.udacity.com/course/build-native-mobile-apps-with-flutter--ud905">用 Flutter 构建本地移动应用</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/from-java-to-dart/#1">从 Java 到 Dart codelab</a></li>
<li><a href="https://flutter.dev/cookbook/">Flutter cookbook</a></li>
<li><a href="https://flutter.dev/bootstrap-into-dart/">融入 Dart 的 Bootstrap：了解更多关于这门语言的信息</a></li>
</ul>
<p>同时，<a href="https://flutter.dev/community">与 Flutter 社区联系起来!</a></p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/flutter" term="flutter" label="flutter" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/app" term="app" label="app" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Dart 入门]]></title>
            <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 可迭代集合" />
                <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 语言速查表" />
            
                <id>https://ohmyweekly.github.io/notes/dart/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-25T00:00:00+08:00</published>
            <updated>2020-06-25T16:02:46-04:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote><a href="https://www.dartcn.com/">Dart</a>入门指南。</blockquote><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="dart-help">重要的概念</h2>
<p>与 Java 不同，Dart 没有关键字 &ldquo;public&rdquo;, &ldquo;protected&rdquo; 和 &ldquo;private&rdquo;。 如果标识符以下划线（<code>_</code>）开头，则它相对于库是私有的。 有关更多信息，参考<a href="https://www.dartcn.com/guides/language/language-tour#%E5%BA%93%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7">库和可见性</a>。</p>
<h2 id="变量">变量</h2>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Bob</span><span class="s1">&#39;</span><span class="p">;</span>     <span class="c1">// 类型推断
</span><span class="c1"></span>
<span class="kt">dynamic</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Bob</span><span class="s1">&#39;</span><span class="p">;</span> <span class="c1">// 动态类型
</span><span class="c1"></span><span class="kt">String</span>  <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Bob</span><span class="s1">&#39;</span><span class="p">;</span> <span class="c1">// 显式声明
</span></code></pre></div><h3 id="默认值">默认值</h3>
<p>未初始化的变量默认值是 <code>null</code>。即使变量是数字, 类型默认值也是 null, 因为在 Dart 中一切都是对象，数字类型也不例外。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">lineCount</span><span class="p">;</span>
<span class="k">assert</span><span class="p">(</span><span class="n">lineCount</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><h3 id="final-和-const">final 和 const</h3>
<p>使用 <code>final</code> 关键字声明的变量, 其值只能被设置一次, 使用 <code>const</code> 关键字声明的变量, 其值在编译时就已固定:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Bob</span><span class="s1">&#39;</span><span class="p">;</span> <span class="c1">// 不使用类型注解
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">String</span> <span class="n">nickname</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Bobby</span><span class="s1">&#39;</span><span class="p">;</span>

<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Alice</span><span class="s1">&#39;</span><span class="p">;</span>     <span class="c1">// Error: final 变量只能被设置一次
</span></code></pre></div><p><code>const</code> 声明一个在<strong>编译</strong>时就固定不变的值, 例如数字字面量、字符串字面量:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">const</span> <span class="n">bar</span> <span class="o">=</span> <span class="m">1000000</span><span class="p">;</span>              <span class="c1">// 压力单位(dynes/cm2)
</span><span class="c1"></span><span class="kd">const</span> <span class="kt">double</span> <span class="n">atm</span> <span class="o">=</span> <span class="m">1.01325</span> <span class="o">*</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// 一个标准大气压强
</span></code></pre></div><h2 id="内置类型">内置类型</h2>
<p>Dart 语言支持以下内置类型:</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">字面量</th>
<th align="left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Number</td>
<td align="left">2⁶³ -1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">&lsquo;Hello&rsquo;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">true,false</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">[1,2,3]</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left">{&lsquo;raku&rsquo;,&lsquo;perl&rsquo;}</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">{&lsquo;lan&rsquo;: &lsquo;raku&rsquo;}</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Rune</td>
<td align="left">\u2665, \u{1f600}</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Symbol</td>
<td align="left">#dadix, #bar</td>
<td align="left"></td>
</tr>
</tbody>
</table>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/examples" term="examples" label="examples" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Dart 可迭代集合]]></title>
            <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 入门" />
                <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 语言速查表" />
            
                <id>https://ohmyweekly.github.io/notes/dart-iterable-collections/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-25T00:00:00+08:00</published>
            <updated>2020-06-25T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote><a href="https://dart.dev/codelabs/iterables">Dart</a>可迭代集合。</blockquote><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>这个代码实验室教你如何使用实现 <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a>类的集合-例如 <a href="https://api.dart.dev/stable/dart-core/List-class.html">List</a>和 <a href="https://api.dart.dev/stable/dart-core/Set-class.html">Set</a>。迭代类是各种 Dart 应用程序的基本构建模块，你可能已经在使用它们，甚至没有注意到。这个代码实验室将帮助你充分利用它们。</p>
<p>使用嵌入式 DartPad 编辑器，你可以通过运行示例代码和完成练习来测试你的知识。</p>
<p>要想从这个 codelab 中获得最大的收获，你应该具备基本的 <a href="https://dart.dev/samples">Dart 语法知识</a>。</p>
<p>本课程包括以下内容。</p>
<ul>
<li>如何读取一个 Iterable 的元素。</li>
<li>如何检查一个 Iterable 的元素是否满足一个条件。</li>
<li>如何过滤一个 Iterable 的内容。</li>
<li>如何将一个 Iterable 的内容映射到不同的值。</li>
</ul>
<p>估计完成这个代码实验所需的时间: 60分钟。</p>
<h2 id="什么是集合">什么是集合?</h2>
<p>集合是代表一组对象的对象，这些对象称为元素。迭代元素是集合的一种。</p>
<p>集合可以是空的，也可以包含许多元素。根据不同的目的，集合可以有不同的结构和实现。这些是一些最常见的集合类型:</p>
<ul>
<li><a href="https://api.dart.dev/stable/dart-core/List-class.html">List</a>: 用来通过索引读取元素。</li>
<li><a href="https://api.dart.dev/stable/dart-core/Set-class.html">Set</a>: 用于包含只能出现一次的元素。</li>
<li><a href="https://api.dart.dev/stable/dart-core/Map-class.html">Map</a>：用于通过键来读取元素。</li>
</ul>
<h2 id="什么是iterable">什么是Iterable?</h2>
<p><code>Iterable</code> 是一个元素的集合，它可以被依次访问。</p>
<p>在 Dart 中，<code>Iterable</code> 是一个抽象类，这意味着你不能直接实例化它。然而，你可以通过创建一个新的 <code>List</code> 或 <code>Set</code> 来创建一个新的 <code>Iterable</code>。</p>
<p><code>List</code> 和 <code>Set</code> 都是 <code>Iterable</code>，所以它们和 <code>Iterable</code> 类有相同的方法和属性。</p>
<p><code>Map</code> 在内部使用不同的数据结构，这取决于它的实现。例如，<a href="https://api.dart.dev/stable/dart-collection/HashMap-class.html">HashMap</a> 使用了一个哈希表，其中的元素(也称为值)是通过一个键获得的。通过使用 <code>Map</code> 的 <code>entries</code> 或 <code>values</code> 属性，<code>Map</code> 的元素也可以作为 <code>Iterable</code> 对象读取。</p>
<p>这个例子显示了一个 <code>int</code> 的 <code>List</code>，它也是一个 <code>int</code> 的 <code>Iterable</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span><span class="p">;</span>
</code></pre></div><p>与 <code>List</code> 的区别在于，使用 <code>Iterable</code>，你无法保证按索引读取元素的效率。<code>Iterable</code> 与 <code>List</code> 相比，没有 <code>[]</code> 操作符。</p>
<p>例如，考虑以下代码，这是<strong>无效的</strong>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="p">;</span>
</code></pre></div><p>如果你用 <code>[]</code> 读取元素，编译器会告诉你 <code>'[]'</code> 这个运算符没有为 <code>Iterable</code> 类定义，这意味着在这种情况下你不能使用 <code>[index]</code>。</p>
<p>你可以用 <code>elementAt()</code> 来读取元素，它可以遍历迭代的元素，直到它到达那个位置。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>继续下一节，了解更多关于如何访问 <code>Iterable</code> 的元素。</p>
<h2 id="读取元素">读取元素</h2>
<p>你可以使用 <code>for-in</code> 循环，依次读取一个迭代元素。</p>
<h3 id="例子-使用-for-in-循环">例子: 使用 for-in 循环</h3>
<p>下面的例子展示了如何使用 <code>for-in</code> 循环读取元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="s1">Salad</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Popcorn</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Toast</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">element</span> <span class="k">in</span> <span class="n">iterable</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在幕后，<code>for-in</code> 循环使用了一个迭代器。然而，你很少看到直接使用迭代器 API，因为 <code>for-in</code> 更容易阅读和理解，而且不容易出错。</p>
<p>关键术语:</p>
<ul>
<li><strong>Iterable</strong>: Dart <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable</a> 类。</li>
<li><strong>Iterator</strong>: <code>for-in</code> 用来从一个 Iterable 对象中读取元素的对象。</li>
<li><code>for-in</code> 循环: 从一个 Iterable 对象中依次读取元素的简单方法。</li>
</ul>
<h3 id="例子使用第一个和最后一个元素">例子：使用第一个和最后一个元素</h3>
<p>在某些情况下，你只想访问一个 <code>Iterable</code> 的第一个或最后一个元素。</p>
<p>在 <code>Iterable</code> 类中，你不能直接访问元素，所以你不能调用 <code>iterable[0]</code> 来访问第一个元素。相反，你可以使用 <code>first</code>，它可以获取第一个元素。</p>
<p>另外，使用 Iterable 类，你不能使用操作符 <code>[]</code> 来访问最后一个元素，但是你可以使用 <code>last</code> 属性。</p>
<p>因为访问一个 Iterable 的最后一个元素需要踏过所有其他元素，所以 <code>last</code> 可能会很慢。在一个空的 <code>Iterable</code> 上使用 <code>first</code> 或 <code>last</code> 会导致一个 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Iterable</span> <span class="n">iterable</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="s1">Salad</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Popcorn</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Toast</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">The first element is </span><span class="si">${</span><span class="n">iterable</span><span class="p">.</span><span class="n">first</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">The last element is </span><span class="si">${</span><span class="n">iterable</span><span class="p">.</span><span class="n">last</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，你看到了如何使用 <code>first</code> 和 <code>last</code> 来获得一个 <code>Iterable</code> 的第一个和最后一个元素。也可以找到满足条件的第一个元素。下一节将展示如何使用名为 <code>firstWhere()</code> 的方法来实现这一目标。</p>
<h3 id="例子-使用-firstwhere">例子: 使用 firstWhere()</h3>
<p>你已经看到，你可以依次访问一个 <code>Iterable</code> 的元素，你可以很容易地得到第一个或最后一个元素。</p>
<p>现在，你要学习如何使用 <code>firstWhere()</code> 来寻找满足某些条件的第一个元素。这个方法需要你传递一个谓词，它是一个函数，如果输入满足一定的条件就返回 true。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">element</span> <span class="o">=</span> <span class="n">iterable</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>例如，如果你想找到第一个超过 5 个字符的 <code>String</code>，你必须传递一个当元素大小大于 5 时返回 true 的谓词。</p>
<p>运行下面的例子，看看 <code>firstWhere()</code> 是如何工作的。你认为所有的函数都会给出相同的结果吗？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">predicate</span><span class="p">(</span><span class="kt">String</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="s1">Salad</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Popcorn</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Toast</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Lasagne</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>

  <span class="c1">// You can find with a simple expression:
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element1</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element1</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// Or try using a function block:
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element2</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">5</span><span class="p">;</span>
  <span class="p">}</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element2</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// Or even pass in a function reference:
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element3</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element3</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// You can also use an `orElse` function in case no value is found!
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">element4</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">firstWhere</span><span class="p">(</span>
    <span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="m">10</span><span class="p">,</span>
    <span class="nl">orElse:</span> <span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="s1">None!</span><span class="s1">&#39;</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">element4</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，你可以看到三种不同的方式来写一个谓词。</p>
<ul>
<li><strong>作为一个表达式</strong>: 测试代码中有一行使用了箭头语法(<code>=&gt;</code>)。</li>
<li><strong>作为一个块</strong>: 测试代码在括号和返回语句之间有多行。</li>
<li><strong>作为一个函数</strong>: 测试代码在一个外部函数中，作为参数传递给 <code>firstWhere()</code> 方法。</li>
</ul>
<p>没有正确或错误的方式。使用最适合你的方式，并且让你的代码更容易阅读和理解。</p>
<p>在这个例子中，<code>firstWhereWithOrElse()</code> 调用 <code>firstWhere()</code> 时，使用了可选的命名参数 <code>orElse</code>，它在没有找到元素时提供了一个替代方案。在这种情况下，返回文本 &ldquo;None!&quot;，因为没有元素满足提供的条件。</p>
<p>注意：如果没有元素满足测试谓词，并且没有提供 <code>orElse</code> 参数，那么 <code>firstWhere()</code> 会抛出一个 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a>。</p>
<p>快速回顾。</p>
<ul>
<li><code>Iterable</code> 的元素必须按顺序访问。</li>
<li>迭代所有元素的最简单方法是使用 <code>for-in</code> 循环。</li>
<li>你可以使用 <code>first</code> 和 <code>last</code> getters 来获取第一个和最后一个元素。</li>
<li>你也可以用 <code>firstWhere()</code> 找到满足条件的第一个元素。</li>
<li>你可以把测试谓词写成表达式、块或函数。</li>
</ul>
<p>关键术语。</p>
<p>谓词: 当某个条件被满足时，返回 <code>true</code> 的函数。</p>
<h3 id="练习-练习写一个测试谓词">练习: 练习写一个测试谓词</h3>
<p>下面的练习是一个失败的单元测试，其中包含一个部分完整的代码片段。你的任务是通过编写代码使测试通过来完成练习。你不需要实现 <code>main()</code>。</p>
<p>这个练习介绍了 <code>singleWhere()</code> 这个方法的工作原理类似于 <code>firstWhere()</code>，但在这种情况下，它只期望 <code>Iterable</code> 中的一个元素满足谓词。如果 <code>Iterable</code> 中超过一个或没有元素满足谓词条件，那么该方法会抛出一个 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a> 异常。</p>
<p><code>singleWhere()</code> 对整个 <code>Iterable</code> 进行步进，直到最后一个元素，如果  <code>Iterable</code> 是无限的或包含一个大的元素集合，这可能会引起问题。</p>
<p>你的目标是实现满足以下条件的 <code>singleWhere()</code> 谓词。</p>
<ul>
<li>元素包含字符 &lsquo;a&rsquo;。</li>
<li>该元素以字符 &lsquo;M&rsquo; 开头。</li>
</ul>
<p>测试数据中的所有元素都是<a href="https://api.dart.dev/stable/dart-core/String-class.html">字符串</a>，你可以查看类文档以获得帮助。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">singleWhere</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">singleWhere</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">startsWith</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">M</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">a</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="检查条件">检查条件</h2>
<p>在使用 <code>Iterable</code> 时，有时你需要验证一个集合的所有元素是否满足某些条件。</p>
<p>你可能会想用 <code>for-in</code> 循环来写一个解决方案，比如这个:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div><p>然而，你可以使用 <code>every()</code> 方法实现同样的目的:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">every</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span><span class="o">=</span> <span class="m">5</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>使用 <code>every()</code> 方法可以使代码更易读、更紧凑、更不容易出错。</p>
<h3 id="例子-使用-any-和-every">例子: 使用 any() 和 every()</h3>
<p><code>Iterable</code> 类提供了两个可以用来验证条件的方法。</p>
<ul>
<li><code>any()</code>: 如果至少有一个元素满足条件，则返回 true。</li>
<li><code>every()</code>: 如果所有元素都满足条件，则返回 true。</li>
</ul>
<p>运行这个练习来看看它们的作用。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="s1">Salad</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Popcorn</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Toast</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">a</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">At least one element contains &#34;a&#34;</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">every</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span><span class="o">=</span> <span class="m">5</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">All elements have length &gt;= 5</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，<code>any()</code> 验证了至少一个元素包含字符 a，<code>every()</code> 验证了所有元素的长度等于或大于 5。</p>
<p>运行代码后，尝试更改 <code>any()</code> 的谓词，使其返回 false:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Z</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">At least one element contains &#34;Z&#34;</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">No element contains &#34;Z&#34;</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>你也可以使用 <code>any()</code> 来验证一个 <code>Iterable</code> 中没有元素满足某个条件。</p>
<h3 id="练习-验证一个-iterable-是否满足一个条件">练习： 验证一个 Iterable 是否满足一个条件</h3>
<p>下面的练习提供了使用前面例子中描述的 <code>any()</code> 和 <code>every()</code> 方法的练习。在本例中，你的工作对象是一组用户，由具有成员字段 <code>age</code> 的 <code>User</code> 对象表示。</p>
<p>使用 <code>any()</code> 和 <code>every()</code> 实现两个函数。</p>
<ul>
<li>第1部分：实现 <code>anyUserUnder18()</code>。
<ul>
<li>如果至少有一个用户是17岁或更小，则返回 true。</li>
</ul>
</li>
<li>第2部分：实现 <code>everyUserOver13()</code>。
<ul>
<li>如果所有用户都是14岁或以上，则返回 true。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">anyUserUnder18</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;</span> <span class="m">18</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">everyUserOver13</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">every</span><span class="p">(</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="m">13</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

  <span class="n">User</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>快速回顾:</p>
<ul>
<li>虽然你可以使用 <code>for-in</code> 循环来检查条件，但还有更好的方法。</li>
<li>方法 <code>any()</code> 可以让你检查任何元素是否满足条件。</li>
<li>方法 <code>every()</code> 可以让你验证所有元素是否满足条件。</li>
</ul>
<h2 id="过滤">过滤</h2>
<p>前面的章节介绍了 <code>firstWhere()</code> 或 <code>singleWhere()</code> 等方法，这些方法可以帮助你找到满足某个谓词的元素。</p>
<p>但是如果你想找到满足某个条件的所有元素呢？你可以使用 <code>where()</code> 方法来实现。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">evenNumbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isEven</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>在这个例子中，<code>numbers</code> 包含一个有多个 <code>int</code> 值的 <code>Iterable</code>，<code>where()</code> 可以找到所有偶数的数字。</p>
<p><code>where()</code> 的输出是另一个 <code>Iterable</code>，你可以用它来迭代它或应用其他 <code>Iterable</code> 方法。在下一个例子中，<code>where()</code> 的输出直接在 <code>for-in</code> 循环中使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">evenNumbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isEven</span><span class="p">)</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">number</span> <span class="k">in</span> <span class="n">evenNumbers</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">number</span><span class="s1"> is even</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="例子-使用-where">例子: 使用 where()</h3>
<p>运行这个例子，看看如何将 <code>where()</code> 与其他方法如 <code>any()</code> 一起使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">evenNumbers</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="o">-</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">42</span><span class="p">]</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isEven</span><span class="p">)</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="n">number</span> <span class="k">in</span> <span class="n">evenNumbers</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">number</span><span class="s1"> is even.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">evenNumbers</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">isNegative</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">evenNumbers contains negative numbers.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// If no element satisfies the predicate, the output is empty.
</span><span class="c1"></span>  <span class="kd">var</span> <span class="n">largeNumbers</span> <span class="o">=</span> <span class="n">evenNumbers</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="m">1000</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">largeNumbers</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">largeNumbers is empty!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在这个例子中，<code>where()</code> 用于查找所有偶数，然后用 <code>any()</code> 检查结果是否包含负数。</p>
<p>在本例的后面，再次使用 <code>where()</code> 来查找所有大于1000的数字，由于没有，结果是一个空的 <code>Iterable</code>。</p>
<p>注意：如果没有元素满足 <code>where()</code> 中的谓词，那么该方法返回一个空的 <code>Iterable</code>。与 <code>singleWhere()</code> 或 <code>firstWhere()</code> 不同，<code>where()</code> 不会抛出 <a href="https://api.dart.dev/stable/dart-core/StateError-class.html">StateError</a> 异常。</p>
<h3 id="例子-使用-takewhile">例子: 使用 takeWhile</h3>
<p>方法 <code>takeWhile()</code> 和 <code>skipWhile()</code> 也可以帮助你从一个 <code>Iterable</code> 中过滤元素。</p>
<p>运行这个例子，看看 <code>takeWhile()</code> 和 <code>skipWhile()</code> 如何分割一个包含数字的 <code>Iterable</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="o">-</span><span class="m">2</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">]</span><span class="p">;</span>

  <span class="kd">var</span> <span class="n">numbersUntilZero</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">takeWhile</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">!</span><span class="o">=</span> <span class="m">0</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Numbers until 0: </span><span class="si">$</span><span class="n">numbersUntilZero</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>

  <span class="kd">var</span> <span class="n">numbersAfterZero</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">skipWhile</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">!</span><span class="o">=</span> <span class="m">0</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Numbers after 0: </span><span class="si">$</span><span class="n">numbersAfterZero</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>输出如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">Numbers until 0: (1, 3, -2)
Numbers after 0: (0, 4, 5)
</code></pre></div><p>在这个例子中，<code>takeWhile()</code> 返回一个 <code>Iterable</code>，它包含了通往满足谓词的元素的所有元素。另一方面， <code>skipWhile()</code> 返回一个 <code>Iterable</code>，同时跳过满足谓词的元素之前的所有元素。请注意，满足谓词的元素也会被包含在内。</p>
<p>运行该示例后，将 <code>takeWhile()</code> 改为取元素，直到到达第一个负数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">numbersUntilNegative</span> <span class="o">=</span>
    <span class="n">numbers</span><span class="p">.</span><span class="n">takeWhile</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="o">!</span><span class="n">number</span><span class="p">.</span><span class="n">isNegative</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>注意，条件 <code>number.isNegative</code> 是用 <code>!</code> 否定的。</p>
<h3 id="练习-从列表中过滤元素">练习: 从列表中过滤元素</h3>
<p>下面的练习提供了使用上一练习中的 <code>User</code> 类的 <code>where()</code> 方法的练习。</p>
<p>使用 <code>where()</code> 实现两个函数。</p>
<ul>
<li>第1部分：实现 <code>filterUnder21()</code>。
<ul>
<li>返回一个包含所有21岁以上用户的 <code>Iterable</code>。</li>
</ul>
</li>
<li>第2部分：实现 <code>findShortNamed()</code>。
<ul>
<li>返回一个包含所有名字长度为 3 或更少的用户的 <code>Iterable</code>。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">filterUnder21</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;</span><span class="o">=</span> <span class="m">21</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">findShortNamed</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;</span><span class="o">=</span> <span class="m">3</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

  <span class="n">User</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>快速回顾:</p>
<ul>
<li>用 <code>where()</code> 过滤一个 <code>Iterable</code> 的元素。</li>
<li><code>where()</code> 的输出是另一个 <code>Iterable</code>。</li>
<li>使用 <code>takeWhile()</code> 和 <code>skipWhile()</code> 来获取元素，直到满足一个条件或之后。</li>
<li>这些方法的输出可以是一个空的 <code>Iterable</code>。</li>
</ul>
<h2 id="map">Map</h2>
<p>通过 <code>map()</code> 方法映射 <code>Iterables</code>，你可以在每个元素上应用一个函数，用一个新的元素替换每个元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">*</span> <span class="m">10</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>在这个例子中，<code>Iterable</code> 数字的每个元素都被乘以 10。</p>
<p>你也可以使用 <code>map()</code> 将一个元素转换为不同的对象-例如，将所有 <code>int</code> 转换为 <code>String</code>，在下面的例子中可以看到。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span><span class="p">.</span><span class="n">toString</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>注意：<code>map()</code> 返回一个懒惰的 <code>Iterable</code>，这意味着只有在元素被迭代时才会调用所提供的函数。</p>
<h3 id="例子-使用-map-改变元素">例子: 使用 map 改变元素</h3>
<p>运行这个例子，看看如何使用 <code>map()</code> 将一个 <code>Iterable</code> 中的所有元素乘以2，你认为输出会是什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">numbersByTwo</span> <span class="o">=</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="o">-</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">42</span><span class="p">]</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">*</span> <span class="m">2</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Numbers: </span><span class="si">$</span><span class="n">numbersByTwo</span><span class="s1">.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="练习-映射到不同类型">练习: 映射到不同类型</h3>
<p>在前面的例子中，你把一个 <code>Iterable</code> 的元素乘以2，输入和输出都是 <code>int</code> 的 <code>Iterable</code>。</p>
<p>在这个练习中，你的代码接收一个 <code>User</code>的 <code>Iterable</code>，你需要返回一个包含用户名和年龄的字符串的 <code>Iterable</code>。</p>
<p><code>Iterable</code> 中的每个字符串必须遵循这样的格式。<code>'{name} is {age}'</code>-例如 <code>'Alice is 21'</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">getNameAndAges</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">users</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="s1">&#39;</span><span class="si">${</span><span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> is </span><span class="si">${</span><span class="n">user</span><span class="p">.</span><span class="n">age</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

  <span class="n">User</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">,</span>
  <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>快速回顾:</p>
<ul>
<li><code>map()</code> 将一个函数应用于一个 <code>Iterable</code> 的所有元素。</li>
<li><code>map()</code> 的输出是另一个 <code>Iterable</code>。</li>
<li>在 <code>Iterable</code> 被迭代之前，函数不会被计算。</li>
</ul>
<h2 id="练习-把所有的东西放在一起">练习: 把所有的东西放在一起</h2>
<p>现在是练习所学知识的时候了，在最后一个练习中。</p>
<p>这个练习提供了类 <code>EmailAddress</code>，它有一个构造函数，接收一个字符串。另一个提供的函数是 <code>isValidEmailAddress()</code>，它测试一个电子邮件地址是否有效。</p>
<table>
<thead>
<tr>
<th align="left">构造函数/函数</th>
<th>类型签名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">EmailAddress()</td>
<td>EmailAddress(String address)</td>
<td align="left">为指定的地址创建一个 EmailAddress。</td>
</tr>
<tr>
<td align="left">isValidEmailAddress()</td>
<td>bool isValidEmailAddress(EmailAddress)</td>
<td align="left">如果提供的 EmailAddress 有效，返回 true。</td>
</tr>
</tbody>
</table>
<p>编写以下代码。</p>
<p>第1部分：实现 <code>parseEmailAddresses()</code>。</p>
<ul>
<li>编写函数 <code>parseEmailAddresses()</code>，它接收一个包含电子邮件地址的 <code>Iterable&lt;String&gt;</code>，并返回一个 <code>Iterable&lt;EmailAddress&gt;</code>。</li>
<li>使用方法 <code>map()</code> 从 <code>String</code> 映射到 <code>EmailAddress</code>。</li>
<li>使用构造函数 <code>EmailAddress(String)</code> 创建 <code>EmailAddress</code> 对象。</li>
</ul>
<p>第二部分：实现 <code>anyInvalidEmailAddress()</code>。</p>
<ul>
<li>编写函数 <code>anyInvalidEmailAddress()</code>，它接收一个 <code>Iterable&lt;EmailAddress&gt;</code>，并在 <code>Iterable</code> 中的任何 <code>EmailAddress</code> 无效时返回 true。</li>
<li>使用方法 <code>any()</code> 和提供的函 <code>isValidEmailAddress()</code>。</li>
</ul>
<p>第3部分：实现 <code>validEmailAddresses()</code>。</p>
<ul>
<li>编写函数 <code>validEmailAddresses()</code>，它接收一个 <code>Iterable&lt;EmailAddress&gt;</code> 并返回另一个只包含有效地址的 <code>Iterable&lt;EmailAddress&gt;</code>。</li>
<li>使用方法 <code>where()</code> 来过滤 <code>Iterable&lt;EmailAddress&gt;</code>。</li>
<li>使用提供的函数 <code>isValidEmailAddress()</code> 来评估一个 <code>EmailAddress</code> 是否有效。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">parseEmailAddresses</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">strings</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">EmailAddress</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">anyInvalidEmailAddress</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">emails</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">emails</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">email</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="o">!</span><span class="n">isValidEmailAddress</span><span class="p">(</span><span class="n">email</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">validEmailAddresses</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">EmailAddress</span><span class="o">&gt;</span> <span class="n">emails</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">emails</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="p">(</span><span class="n">email</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">isValidEmailAddress</span><span class="p">(</span><span class="n">email</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">EmailAddress</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">address</span><span class="p">;</span>

  <span class="n">EmailAddress</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">address</span><span class="p">)</span><span class="p">;</span>

  <span class="err">@</span><span class="n">override</span>
  <span class="kt">bool</span> <span class="kd">operator</span> <span class="o">=</span><span class="o">=</span><span class="p">(</span><span class="kt">Object</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span>
      <span class="n">identical</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">|</span><span class="o">|</span>
          <span class="n">other</span> <span class="k">is</span> <span class="n">EmailAddress</span> <span class="o">&amp;</span><span class="o">&amp;</span>
              <span class="n">runtimeType</span> <span class="o">=</span><span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">runtimeType</span> <span class="o">&amp;</span><span class="o">&amp;</span>
              <span class="n">address</span> <span class="o">=</span><span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">address</span><span class="p">;</span>

  <span class="err">@</span><span class="n">override</span>
  <span class="kt">int</span> <span class="kd">get</span> <span class="n">hashCode</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">address</span><span class="p">.</span><span class="n">hashCode</span><span class="p">;</span>

  <span class="err">@</span><span class="n">override</span>
  <span class="kt">String</span> <span class="n">toString</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="s1">EmailAddress{address: </span><span class="si">$</span><span class="n">address</span><span class="s1">}</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="下一步是什么">下一步是什么?</h2>
<p>恭喜你，你完成了 codelab 的学习! 如果你想了解更多，这里有一些下一步的建议。</p>
<ul>
<li>玩玩 <a href="https://dartpad.dev/">DartPad</a>。</li>
<li>试试另一个<a href="https://dart.dev/codelabs">代码实验</a>。</li>
<li>阅读 <a href="https://api.dart.dev/stable/dart-core/Iterable-class.html">Iterable API</a> 参考资料，了解本 codelab 未涉及的方法。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/iterable" term="iterable" label="iterable" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/collection" term="collection" label="collection" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[Dart 语言速查表]]></title>
            <link href="https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
                <link href="https://ohmyweekly.github.io/notes/dart/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 入门" />
                <link href="https://ohmyweekly.github.io/notes/dart-iterable-collections/?utm_source=atom_feed" rel="related" type="text/html" title="Dart 可迭代集合" />
            
                <id>https://ohmyweekly.github.io/notes/dart-cheatsheet-codelab/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-25T00:00:00+08:00</published>
            <updated>2020-06-25T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote><a href="https://www.dartcn.com/">Dart</a>速查表。</blockquote><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="字符串插值">字符串插值</h2>
<p>使用 <code>${expression}</code> 将表达式的值放到字符串里面。如果表达式是一个标识符, 就可以省略 <code>{}</code>。</p>
<p>下面是字符串插值的例子:</p>
<table>
<thead>
<tr>
<th align="left">字符串</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">&lsquo;${3 + 2}&rsquo;</td>
<td align="left">&lsquo;5&rsquo;</td>
</tr>
<tr>
<td align="left">&lsquo;${&ldquo;word&rdquo;.toUpperCase()}&rsquo;</td>
<td align="left">&lsquo;WORD&rsquo;</td>
</tr>
<tr>
<td align="left">&lsquo;$myObject&rsquo;</td>
<td align="left">The value of myObject.toString()</td>
</tr>
</tbody>
</table>
<h3 id="代码示例">代码示例</h3>
<p>下面的函数接收两个整数作为参数。使其返回一个包含两个整数的字符串，并以空格分隔。例如 <code>stringify(2, 3)</code> 应该返回 &lsquo;2 3&rsquo;。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">stringify</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">$</span><span class="n">x</span><span class="s1"> </span><span class="si">$</span><span class="n">y</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="null-无感知操作符">Null 无感知操作符</h2>
<p>Dart 提供了一些方便的操作符来处理可能为空的值。其中一个是 <code>??=</code> 赋值运算符，只有当一个变量当前为空时，它才会给这个变量赋值:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>    <span class="c1">// a 的初始值为 null
</span><span class="c1"></span><span class="n">a</span> <span class="o">?</span><span class="o">?</span><span class="o">=</span> <span class="m">3</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 打印 3
</span><span class="c1"></span>
<span class="n">a</span> <span class="o">?</span><span class="o">?</span><span class="o">=</span> <span class="m">5</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 仍然打印 3
</span></code></pre></div><p>另一个 null-aware 操作符是 <code>??</code>，它返回其左边的表达式，除非该表达式的值为 null，在这种情况下，它计算并返回其右边的表达式:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">print</span><span class="p">(</span><span class="m">1</span> <span class="o">?</span><span class="o">?</span> <span class="m">3</span><span class="p">)</span><span class="p">;</span>     <span class="c1">// 打印 1
</span><span class="c1"></span><span class="n">print</span><span class="p">(</span><span class="kc">null</span> <span class="o">?</span><span class="o">?</span> <span class="m">12</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 打印 12 
</span></code></pre></div><h3 id="代码示例-1">代码示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">String</span> <span class="n">foo</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">a string</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="kt">String</span> <span class="n">bar</span><span class="p">;</span> <span class="c1">// Unassigned objects are null by default.
</span><span class="c1"></span>
<span class="c1">// makes &#39;a string&#39; be assigned to baz.
</span><span class="c1"></span><span class="kt">String</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">?</span><span class="o">?</span> <span class="n">bar</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">updateSomeVars</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// makes &#39;a string&#39; be assigned to bar.
</span><span class="c1"></span>  <span class="n">bar</span> <span class="o">?</span><span class="o">?</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">a string</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="有条件的属性访问">有条件的属性访问</h2>
<p>要保护对对象的一个可能为空的属性或方法的访问，请在点(.)前加上一个问号(?):</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="o">?</span><span class="p">.</span><span class="n">someProperty</span>
</code></pre></div><p>上述代码等同于以下代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="p">(</span><span class="n">myObject</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="o">?</span> <span class="n">myObject</span><span class="p">.</span><span class="n">someProperty</span> <span class="o">:</span> <span class="kc">null</span>
</code></pre></div><p>你可以在一个表达式中把 <code>?.</code> 的多个使用链接在一起:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="o">?</span><span class="p">.</span><span class="n">someProperty</span><span class="o">?</span><span class="p">.</span><span class="n">someMethod</span><span class="p">(</span><span class="p">)</span>
</code></pre></div><p>如果 <code>myObject</code> 或 <code>myObject.someProperty</code> 为 null，前面的代码将返回 null(并且从不调用 <code>someMethod()</code>)。</p>
<h3 id="代码示例-2">代码示例</h3>
<p>尝试使用条件属性访问来完成下面的代码片段。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// This method should return the uppercase version of `str`
</span><span class="c1"></span><span class="c1">// or null if `str` is null.
</span><span class="c1"></span><span class="kt">String</span> <span class="n">upperCaseIt</span><span class="p">(</span><span class="kt">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Try conditionally accessing the `toUpperCase` method here.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">str</span><span class="o">?</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="集合字面量">集合字面量</h2>
<p>Dart 内置了对列表、映射和集合的支持。你可以使用字面量创建它们:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">aListOfStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="s1">one</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">two</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">three</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>
<span class="kd">final</span> <span class="n">aSetOfStrings</span>  <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;</span><span class="s1">one</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">two</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">three</span><span class="s1">&#39;</span><span class="p">}</span><span class="p">;</span>
<span class="kd">final</span> <span class="n">aMapOfStringsToInts</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;</span><span class="s1">one</span><span class="s1">&#39;</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">two</span><span class="s1">&#39;</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span>
  <span class="s1">&#39;</span><span class="s1">three</span><span class="s1">&#39;</span><span class="o">:</span> <span class="m">3</span><span class="p">,</span>  
<span class="p">}</span>
</code></pre></div><p>Dart 的类型推理可以为你分配类型给这些变量。在本例中，推断的类型是 <code>List&lt;String&gt;</code>、<code>Set&lt;String&gt;</code> 和 <code>Map&lt;String, int&gt;</code>。</p>
<p>或者你可以自己指定类型:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">aListOfInts</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">[</span><span class="p">]</span><span class="p">;</span>
<span class="kd">final</span> <span class="n">aSetOfInts</span>  <span class="o">=</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="p">}</span><span class="p">;</span>
<span class="kd">final</span> <span class="n">aMapOfIntToDouble</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="p">}</span><span class="p">;</span>
</code></pre></div><p>当你用子类型的内容初始化一个列表，但仍然希望列表是 <code>List&lt;BaseType&gt;</code> 时，指定类型是很方便的:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">aListOfBaseType</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">BaseType</span><span class="o">&gt;</span><span class="p">[</span><span class="n">SubType</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">SubType</span><span class="p">(</span><span class="p">)</span><span class="p">]</span><span class="p">;</span>
</code></pre></div><h3 id="代码示例-3">代码示例</h3>
<p>尝试将以下变量设置为指定的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="c1">// Assign this a list containing &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; in that order:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">aListOfStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="s1">a</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">b</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">c</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">;</span>

<span class="c1">// Assign this a set containing 3, 4, and 5:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">aSetOfInts</span> <span class="o">=</span> <span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span><span class="p">;</span>

<span class="c1">// Assign this a map of String to int so that aMapOfStringsToInts[&#39;myKey&#39;] returns 12:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">aMapOfStringsToInts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;</span><span class="s1">myKey</span><span class="s1">&#39;</span><span class="o">:</span> <span class="m">12</span><span class="p">}</span><span class="p">;</span>

<span class="c1">// Assign this an empty List&lt;double&gt;:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">anEmptyListOfDouble</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">[</span><span class="p">]</span><span class="p">;</span>

<span class="c1">// Assign this an empty Set&lt;String&gt;:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">anEmptySetOfString</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">{</span><span class="p">}</span><span class="p">;</span>

<span class="c1">// Assign this an empty Map of double to int:
</span><span class="c1"></span><span class="kd">final</span> <span class="n">anEmptyMapOfDoublesToInts</span> <span class="o">=</span> <span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="p">}</span><span class="p">;</span>
</code></pre></div><h2 id="箭头语法">箭头语法</h2>
<p>你可能在 Dart 代码中看到过 <code>=&gt;</code> 符号。这种箭头语法是一种定义函数的方式，该函数执行其右边的表达式并返回其值。</p>
<p>例如，考虑这个对 <code>List</code> 类的 <code>any()</code> 方法的调用:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">hasEmpty</span> <span class="o">=</span> <span class="n">aListOfStrings</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>这里有一个更简单的方法来写这个代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">bool</span> <span class="n">hasEmpty</span> <span class="o">=</span> <span class="n">aListOfStrings</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><h3 id="代码示例-4">代码示例</h3>
<p>试着完成以下使用箭头语法的语句:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_value1</span> <span class="o">=</span> <span class="m">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_value2</span> <span class="o">=</span> <span class="m">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_value3</span> <span class="o">=</span> <span class="m">5</span><span class="p">;</span>

  <span class="c1">// Returns the product of the above values:
</span><span class="c1"></span>  <span class="kt">int</span> <span class="kd">get</span> <span class="n">product</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">_value1</span> <span class="o">*</span> <span class="n">_value2</span> <span class="o">*</span> <span class="n">_value3</span><span class="p">;</span>
  
  <span class="c1">// Adds one to _value1:
</span><span class="c1"></span>  <span class="kt">void</span> <span class="n">incrementValue1</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">_value1</span><span class="o">+</span><span class="o">+</span><span class="p">;</span> 
  
  <span class="c1">// Returns a string containing each item in the
</span><span class="c1"></span>  <span class="c1">// list, separated by commas (e.g. &#39;a,b,c&#39;): 
</span><span class="c1"></span>  <span class="kt">String</span> <span class="n">joinWithCommas</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">strings</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">,</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="级联">级联</h2>
<p>要对同一对象进行一系列操作，可以使用级联(<code>...</code>)。我们都见过这样的表达式:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="p">.</span><span class="n">someMethod</span><span class="p">(</span><span class="p">)</span>
</code></pre></div><p>它在 <code>myObject</code> 上调用 <code>someMethod()</code>，表达式的结果是 <code>someMethod()</code> 的返回值。</p>
<p>下面是同样的表达式，有一个级联:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">myObject</span><span class="p">.</span><span class="p">.</span><span class="n">someMethod</span><span class="p">(</span><span class="p">)</span>
</code></pre></div><p>虽然它仍然在 <code>myObject</code> 上调用 <code>someMethod()</code>，但表达式的结果并不是返回值-它是对 <code>myObject</code> 的引用! 使用级联，你可以将原本需要单独语句的操作串联起来。例如，请看以下代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">var</span> <span class="n">button</span> <span class="o">=</span> <span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">#confirm</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="n">button</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Confirm</span><span class="s1">&#39;</span><span class="p">;</span>
<span class="n">button</span><span class="p">.</span><span class="n">classes</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">important</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="n">button</span><span class="p">.</span><span class="n">onClick</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">.</span><span class="n">alert</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Confirmed!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>有了级联，代码就会变得短得多，而且你也不需要 <code>button</code> 变量:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">querySelector</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">#confirm</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Confirm</span><span class="s1">&#39;</span>
<span class="p">.</span><span class="p">.</span><span class="n">class</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">important</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="p">.</span><span class="p">.</span><span class="n">onClick</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">.</span><span class="n">alert</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Confirmed!</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><h3 id="代码示例-5">代码示例</h3>
<p>使用级联来创建一个单一的语句，将一个 <code>BigObject</code> 的 <code>anInt</code>、<code>aString</code> 和 <code>aList</code> 属性设置为 1、&lsquo;String!&rsquo; 和 <code>[3.0]</code>(分别地)，然后调用 <code>allDone()</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">BigObject</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">anInt</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="kt">String</span> <span class="n">aString</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">aList</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">_done</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">allDone</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">_done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>    
<span class="p">}</span>

<span class="n">BigObject</span> <span class="n">fillBigObject</span><span class="p">(</span><span class="n">BigObject</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">obj</span>
      <span class="p">.</span><span class="p">.</span><span class="n">anInt</span> <span class="o">=</span> <span class="m">1</span>
      <span class="p">.</span><span class="p">.</span><span class="n">aString</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">String!</span><span class="s1">&#39;</span>
      <span class="p">.</span><span class="p">.</span><span class="n">aList</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
      <span class="p">.</span><span class="p">.</span><span class="n">allDone</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="getters-和-setters">getters 和 setters</h2>
<p>当你需要对一个属性进行更多的控制时，你可以定义 getter 和 setter，而不是简单的字段。</p>
<p>例如，你可以确保一个属性的值是有效的:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_aProperty</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="kd">get</span> <span class="n">aProperty</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">_aProperty</span><span class="p">;</span>

  <span class="kd">set</span> <span class="n">aProperty</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span><span class="o">=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">_aProperty</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>    
    <span class="p">}</span>    
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>你也可以使用 getter 来定义计算属性:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">_values</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">addValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_values</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="p">;</span>    
  <span class="p">}</span>

  <span class="c1">// 一个计算属性
</span><span class="c1"></span>  <span class="kt">int</span> <span class="kd">get</span> <span class="n">count</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_values</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-6">代码示例</h3>
<p>想象一下，你有一个购物车类，它保存了一个私有的 <code>List&lt;double&gt;</code> 的价格。添加以下内容:</p>
<ul>
<li>一个叫做 <code>total</code> 的 getter，返回价格的总和。</li>
<li>用一个新的列表替换列表的 setter，只要新的列表不包含任何负价格(在这种情况下，setter 应该抛出一个 <code>InvalidPriceException</code>)。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">InvalidPriceException</span> <span class="p">{</span><span class="p">}</span>

<span class="kd">class</span> <span class="nc">ShoppingCart</span> <span class="p">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">_prices</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">;</span>
  
  <span class="kt">double</span> <span class="kd">get</span> <span class="n">total</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">_prices</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span><span class="p">;</span>
  
  <span class="kd">set</span> <span class="n">prices</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">any</span><span class="p">(</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="m">0</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">InvalidPriceException</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">_prices</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="可选位置参数">可选位置参数</h2>
<p>Dart 有两种函数参数：位置参数和命名参数。位置参数是你可能熟悉的那种:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">sumUp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>  <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...
</span><span class="c1"></span><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">sumUp</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>在 Dart 中，你可以将这些位置参数用括号包裹起来，使其成为可选的参数:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">d</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">e</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...
</span><span class="c1"></span><span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">otherTotal</span> <span class="o">=</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>可选的位置参数在函数的参数列表中总是最后一个。它们的默认值是空的，除非你提供了另一个默认值:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">int</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="m">2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="m">3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="m">4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="m">5</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// ···
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// ···
</span><span class="c1"></span><span class="kt">int</span> <span class="n">newTotal</span> <span class="o">=</span> <span class="n">sumUpToFive</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">newTotal</span><span class="p">)</span><span class="p">;</span> <span class="c1">// &lt;-- prints 15
</span></code></pre></div><h3 id="代码示例-7">代码示例</h3>
<p>实现一个名为 <code>joinWithCommas()</code> 的函数，接受 1 到 5 个整数，然后返回一个用逗号分隔的数字字符串。下面是一些函数调用和返回值的例子:</p>
<table>
<thead>
<tr>
<th align="left">函数调用</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">joinWithCommas(1)</td>
<td align="left">&lsquo;1&rsquo;</td>
</tr>
<tr>
<td align="left">joinWithCommas(1, 2, 3)</td>
<td align="left">&lsquo;1,2,3&rsquo;</td>
</tr>
<tr>
<td align="left">joinWithCommas(1, 1, 1, 1, 1)</td>
<td align="left">&lsquo;1,1,1,1,1&rsquo;</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">res</span> <span class="o">=</span> <span class="n">joinWithCommas</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">)</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">String</span> <span class="n">joinWithCommas</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">;</span>
  <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="p">)</span> <span class="n">sum</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">,</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="可选命名参数">可选命名参数</h2>
<p>使用大括号语法，你可以定义有名称的可选参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">printName</span><span class="p">(</span><span class="kt">String</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">String</span> <span class="n">lastName</span><span class="p">,</span> <span class="p">{</span><span class="kt">String</span> <span class="n">suffix</span><span class="p">}</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">firstName</span><span class="s1"> </span><span class="si">$</span><span class="n">lastName</span><span class="s1"> </span><span class="si">${</span><span class="n">suffix</span> <span class="o">?</span><span class="o">?</span> <span class="s1">&#39;</span><span class="s1">&#39;</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ···
</span><span class="c1"></span><span class="n">printName</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Avinash</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Gupta</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="n">printName</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Poshmeister</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Moneybuckets</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nl">suffix:</span> <span class="s1">&#39;</span><span class="s1">IV</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>正如你所期望的，这些参数的值默认为空，但你可以提供默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kt">void</span> <span class="n">printName</span><span class="p">(</span><span class="kt">String</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">String</span> <span class="n">lastName</span><span class="p">,</span> <span class="p">{</span><span class="kt">String</span> <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">&#39;</span><span class="p">}</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">$</span><span class="n">firstName</span><span class="s1"> </span><span class="si">$</span><span class="n">lastName</span><span class="s1"> </span><span class="si">$</span><span class="n">suffix</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>一个函数不能同时拥有可选的位置参数和可选的命名参数。</p>
<h3 id="代码示例-8">代码示例</h3>
<p>为 <code>MyDataObject</code> 类添加一个 <code>copyWith()</code> 实例方法。它应该接受三个命名参数:</p>
<ul>
<li>int newInt</li>
<li>String newString</li>
<li>double newDouble</li>
</ul>
<p>当调用时，<code>copyWith()</code> 应该基于当前实例返回一个新的 <code>MyDataObject</code>，并将前面参数（如果有的话）的数据复制到对象的属性中。例如，如果 <code>newInt</code> 是非空的，那么将其值复制到 <code>anInt</code> 中。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyDataObject</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">anInt</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">aString</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">aDouble</span><span class="p">;</span>

  <span class="n">MyDataObject</span><span class="p">(</span><span class="p">{</span>
     <span class="k">this</span><span class="p">.</span><span class="n">anInt</span> <span class="o">=</span> <span class="m">1</span><span class="p">,</span>
     <span class="k">this</span><span class="p">.</span><span class="n">aString</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="s1">Old!</span><span class="s1">&#39;</span><span class="p">,</span>
     <span class="k">this</span><span class="p">.</span><span class="n">aDouble</span> <span class="o">=</span> <span class="m">2.0</span><span class="p">,</span>
  <span class="p">}</span><span class="p">)</span><span class="p">;</span>

  <span class="n">MyDataObject</span> <span class="n">copyWith</span><span class="p">(</span><span class="p">{</span><span class="kt">int</span> <span class="n">newInt</span><span class="p">,</span> <span class="kt">String</span> <span class="n">newString</span><span class="p">,</span> <span class="kt">double</span> <span class="n">newDouble</span><span class="p">}</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MyDataObject</span><span class="p">(</span>
      <span class="nl">anInt:</span>      <span class="n">newInt</span> <span class="o">?</span><span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="n">anInt</span><span class="p">,</span>
      <span class="nl">aString:</span> <span class="n">newString</span> <span class="o">?</span><span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="n">aString</span><span class="p">,</span>
      <span class="nl">aDouble:</span> <span class="n">newDouble</span> <span class="o">?</span><span class="o">?</span> <span class="k">this</span><span class="p">.</span><span class="n">aDouble</span><span class="p">,</span>
    <span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="异常">异常</h2>
<p>Dart 代码可以抛出和捕获异常。与 Java 相比，Dart 的所有异常都是未检查的异常。方法不声明它们可能会抛出哪些异常，你也不需要捕捉任何异常。</p>
<p>Dart 提供了 <code>Exception</code> 和 <code>Error</code> 类型，但你可以抛出任何非空对象:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Something bad happened.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="k">throw</span> <span class="s1">&#39;</span><span class="s1">Waaaaaaah!</span><span class="s1">&#39;</span><span class="p">;</span>
</code></pre></div><p>在处理异常时使用 <code>try</code>、<code>on</code> 和 <code>catch</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="n">breedMoreLlamas</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="n">on</span> <span class="n">OutOfLlamasException</span> <span class="p">{</span>
  <span class="c1">// A specific exception
</span><span class="c1"></span>  <span class="n">buyMoreLlamas</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="n">on</span> <span class="n">Exception</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Anything else that is an exception
</span><span class="c1"></span>  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Unknown exception: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// No specified type, handles all
</span><span class="c1"></span>  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Something really unknown: </span><span class="si">$</span><span class="n">e</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><code>try</code> 关键字的工作原理和其他大多数语言一样。使用 <code>on</code> 关键字按类型过滤特定的异常，使用 <code>catch</code> 关键字获取异常对象的引用。</p>
<p>如果不能完全处理异常，可以使用 <code>rethrow</code> 关键字来传播异常:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="n">breedMoreLlamas</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">I was just trying to breed llamas!.</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">rethrow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>无论是否抛出异常，都要执行代码，使用 <code>final</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="k">try</span> <span class="p">{</span>
  <span class="n">breedMoreLlamas</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... handle exception ...
</span><span class="c1"></span><span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
  <span class="c1">// Always clean up, even if an exception is thrown.
</span><span class="c1"></span>  <span class="n">cleanLlamaStalls</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-9">代码示例</h3>
<p>实现下面的 <code>tryFunction()</code>。它应该执行一个不可信的方法，然后做如下操作:</p>
<ul>
<li>如果 <code>untrustworthy()</code> 抛出一个 <code>ExceptionWithMessage</code>，调用 <code>logger.logException</code>，并提供异常类型和消息(尝试使用 <code>on</code> 和 <code>catch</code>)。</li>
<li>如果 <code>untrustworthy()</code> 抛出一个 <code>Exceptio</code>n，调用 <code>logger.logException</code>，并注明异常类型(尝试使用 <code>on</code>)。</li>
<li>如果 <code>untrustworthy()</code> 抛出任何其他对象，不要捕获异常。</li>
<li>当所有的东西都被捕获和处理后，调用 <code>logger.doneLogging</code>(尝试使用 <code>finally</code>)。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">typedef</span> <span class="n">VoidFunction</span> <span class="o">=</span> <span class="kt">void</span> <span class="n">Function</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">ExceptionWithMessage</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">message</span><span class="p">;</span>
  <span class="kd">const</span> <span class="n">ExceptionWithMessage</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">message</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Logger</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">logException</span><span class="p">(</span><span class="n">Type</span> <span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span> <span class="n">msg</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">doneLogging</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">tryFunction</span><span class="p">(</span><span class="n">VoidFunction</span> <span class="n">untrustworthy</span><span class="p">,</span> <span class="n">Logger</span> <span class="n">logger</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">untrustworthy</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">on</span> <span class="n">ExceptionWithMessage</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">logException</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">runtimeType</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">on</span> <span class="n">Exception</span> <span class="p">{</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">logException</span><span class="p">(</span><span class="n">Exception</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="n">logger</span><span class="p">.</span><span class="n">doneLogging</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="在构造函数中使用-this">在构造函数中使用 <code>this</code></h2>
<p>Dart 提供了一个方便的快捷方式来为构造函数中的属性赋值：在声明构造函数时使用 <code>this.propertyName</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyColor</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">red</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">green</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">blue</span><span class="p">;</span>

  <span class="n">MyColor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">)</span>    
<span class="p">}</span>

<span class="kd">final</span> <span class="n">color</span> <span class="o">=</span> <span class="n">MyColor</span><span class="p">(</span><span class="m">80</span><span class="p">,</span> <span class="m">80</span><span class="p">,</span> <span class="m">128</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>这种技术也适用于命名参数。属性名成为参数的名称:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyColor</span> <span class="p">{</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>
  <span class="n">MyColor</span><span class="p">(</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">}</span><span class="p">)</span><span class="p">;</span>    
<span class="p">}</span>
<span class="kd">final</span> <span class="n">color</span> <span class="o">=</span> <span class="n">MyColor</span><span class="p">(</span><span class="nl">red:</span> <span class="m">80</span><span class="p">,</span> <span class="nl">green:</span> <span class="m">80</span><span class="p">,</span> <span class="nl">blue:</span> <span class="m">80</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>对于可选参数，默认值按预期工作:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">MyColor</span><span class="p">(</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="n">red</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span> <span class="o">=</span> <span class="m">0</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
<span class="c1">// or
</span><span class="c1"></span><span class="n">MyColor</span><span class="p">(</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="n">red</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span> <span class="o">=</span> <span class="m">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span> <span class="o">=</span> <span class="m">0</span><span class="p">}</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><h3 id="代码示例-10">代码示例</h3>
<p>为 <code>MyClass</code> 添加一个单行构造函数，使用 <code>this.</code> 语法来接收和分配类的三个属性的值:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">anInt</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">aString</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">aDouble</span><span class="p">;</span>
  
  <span class="n">MyClass</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">anInt</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">aString</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">aDouble</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="初始化器列表">初始化器列表</h2>
<p>有时候，当你实现一个构造函数时，你需要在构造函数体执行之前做一些设置。例如，在构造函数体执行之前，<code>final</code> 字段必须有值。在一个初始化器列表中做这些工作，它位于构造函数的签名和它的主体之间。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">Point</span><span class="p">.</span><span class="n">fromJson</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">num</span><span class="o">&gt;</span> <span class="n">json</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">x</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">x</span><span class="s1">&#39;</span><span class="p">]</span><span class="p">,</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">json</span><span class="p">[</span><span class="s1">&#39;</span><span class="s1">y</span><span class="s1">&#39;</span><span class="p">]</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">In Point.fromJson(): (</span><span class="si">$</span><span class="n">x</span><span class="s1">, </span><span class="si">$</span><span class="n">y</span><span class="s1">)</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div><p>初始化器列表也是一个方便放置断言的地方，它只在开发过程中运行:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="n">NonNegativePoint</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
    <span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span><span class="o">=</span> <span class="m">0</span><span class="p">)</span><span class="p">,</span>
      <span class="k">assert</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span><span class="o">=</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">I just made a NonNegativePoint: (</span><span class="si">$</span><span class="n">x</span><span class="s1">, </span><span class="si">$</span><span class="n">y</span><span class="s1">)</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>        
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-11">代码示例</h3>
<p>完成下面的 <code>FirstTwoLetters</code> 构造函数。使用初始化器列表将 <code>word</code> 中的前两个字符分配给 <code>letterOne</code> 和 <code>LetterTwo</code> 属性。为了获得额外的积分，可以添加一个断言来捕获少于两个字符的单词。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">FirstTwoLetters</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">letterOne</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">letterTwo</span><span class="p">;</span>

  <span class="c1">// Create a constructor with an initializer list here:
</span><span class="c1"></span>  <span class="n">FirstTwoLetters</span><span class="p">(</span><span class="kt">String</span> <span class="n">word</span><span class="p">)</span>
    <span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span><span class="o">=</span><span class="m">2</span><span class="p">)</span><span class="p">,</span>
      <span class="n">letterOne</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">,</span>
      <span class="n">letterTwo</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div><h2 id="命名构造器">命名构造器</h2>
<p>为了允许类有多个构造函数，Dart 支持命名构造函数:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="n">Point</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Point</span><span class="p">.</span><span class="n">origin</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>    
  <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div><p>要使用命名构造函数，请使用它的全名来调用它:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">final</span> <span class="n">myPoint</span> <span class="o">=</span> <span class="n">Point</span><span class="p">.</span><span class="n">origin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><h3 id="代码示例-12">代码示例</h3>
<p>给 <code>Color</code> 类一个名为 <code>Color.black</code> 的构造函数，将三个属性都设置为 0。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Color</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">red</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">green</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">blue</span><span class="p">;</span>
  
  <span class="n">Color</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">green</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div><h2 id="工厂构造函数">工厂构造函数</h2>
<p>Dart 支持工厂构造函数，它可以返回子类型甚至 null。要创建一个工厂构造函数，请使用 <code>factory</code> 关键字:</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="n">Shape</span> <span class="p">{</span><span class="p">}</span>

<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="n">Shape</span> <span class="p">{</span><span class="p">}</span>

<span class="kd">class</span> <span class="nc">Shape</span> <span class="p">{</span>
  <span class="n">Shape</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="kd">factory</span> <span class="n">Shape</span><span class="p">.</span><span class="n">fromTypeName</span><span class="p">(</span><span class="kt">String</span> <span class="n">typeName</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">typeName</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">square</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="n">Square</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">typeName</span> <span class="o">=</span><span class="o">=</span> <span class="s1">&#39;</span><span class="s1">circle</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">return</span> <span class="n">Circle</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

    <span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">I don</span><span class="se">\&#39;</span><span class="s1">t recognize </span><span class="si">$</span><span class="n">typeName</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="k">return</span> <span class="kc">null</span>
  <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-13">代码示例</h3>
<p>填入名为 <code>IntegerHolder.fromList</code> 的工厂构造函数，使其做以下工作:</p>
<ul>
<li>如果列表有一个值，就用这个值创建一个 <code>IntegerSingle</code>。</li>
<li>如果列表有两个值，则用该值依次创建一个 <code>IntegerDouble</code>。</li>
<li>如果列表有三个值，则按顺序创建一个 <code>IntegerTriple</code>。</li>
<li>否则，返回 null。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">IntegerHolder</span> <span class="p">{</span>
  <span class="n">IntegerHolder</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  
  <span class="kd">factory</span> <span class="n">IntegerHolder</span><span class="p">.</span><span class="n">fromList</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span><span class="o">=</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">IntegerSingle</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span><span class="o">=</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">IntegerDouble</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">?</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span><span class="o">=</span> <span class="m">3</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">IntegerTriple</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="m">2</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span> 
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">IntegerSingle</span> <span class="kd">extends</span> <span class="n">IntegerHolder</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">IntegerSingle</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">a</span><span class="p">)</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">IntegerDouble</span> <span class="kd">extends</span> <span class="n">IntegerHolder</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">IntegerDouble</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">IntegerTriple</span> <span class="kd">extends</span> <span class="n">IntegerHolder</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">IntegerTriple</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">c</span><span class="p">)</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div><h2 id="重定向构造函数">重定向构造函数</h2>
<p>有时，一个构造函数的唯一目的是重定向到同一类中的另一个构造函数。重定向构造函数的主体是空的，构造函数调用出现在冒号(:)之后。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Automobile</span> <span class="p">{</span>
  <span class="kt">String</span> <span class="n">make</span><span class="p">;</span>
  <span class="kt">String</span> <span class="n">model</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mpg</span><span class="p">;</span>

  <span class="c1">// 这个类的主构造函数
</span><span class="c1"></span>  <span class="n">Automobile</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">make</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">model</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">mpg</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 代理到主构造函数
</span><span class="c1"></span>  <span class="n">Automobile</span><span class="p">.</span><span class="n">hybrid</span><span class="p">(</span><span class="kt">String</span> <span class="n">make</span><span class="p">,</span> <span class="kt">String</span> <span class="n">model</span><span class="p">)</span> <span class="o">:</span> <span class="k">this</span><span class="p">(</span><span class="n">make</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="m">60</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 代理到命名构造函数
</span><span class="c1"></span>  <span class="n">Automobile</span><span class="p">.</span><span class="n">fancyHybrid</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="n">hybrid</span><span class="p">(</span><span class="s1">&#39;</span><span class="s1">Futurecar</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="s1">Mark 2</span><span class="s1">&#39;</span><span class="p">)</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-14">代码示例</h3>
<p>还记得上面的 <code>Color</code> 类吗？创建一个名为 <code>black</code> 的命名构造函数，但不是手动分配属性，而是将其重定向到默认构造函数，参数为 0。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Color</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">red</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">green</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">blue</span><span class="p">;</span>
  
  <span class="n">Color</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">red</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">green</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">blue</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Color</span><span class="p">.</span><span class="n">black</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="k">this</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="常量构造函数">常量构造函数</h2>
<p>如果你的类产生的对象永远不会改变，你可以让这些对象成为编译时常量。要做到这一点，请定义一个 <code>const</code> 构造函数，并确保所有的实例变量都是最终变量。</p>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">ImmutablePoint</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="n">ImmutablePoint</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="p">;</span>

  <span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>

  <span class="kd">static</span> <span class="kd">const</span> <span class="n">ImmutablePoint</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">ImmutablePoint</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="代码示例-15">代码示例</h3>
<p>修改 <code>Recipe</code> 类，使它的实例可以是常量，并创建一个常量构造函数，执行以下操作。</p>
<ul>
<li>有三个参数： <code>ingredients</code>, <code>calories</code> 和 <code>milligramsOfSodium</code>(按顺序)。</li>
<li>使用 <code>this.</code> 语法，自动将参数值分配给同名的对象属性。</li>
<li>是常量，在构造函数声明中，<code>const</code> 关键字就在 <code>Recipe</code> 前面。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-dart" data-lang="dart"><span class="kd">class</span> <span class="nc">Recipe</span> <span class="p">{</span>
  <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">ingredients</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">int</span> <span class="n">calories</span><span class="p">;</span>
  <span class="kd">final</span> <span class="kt">double</span> <span class="n">milligramsOfSodium</span><span class="p">;</span>

  <span class="kd">const</span> <span class="n">Recipe</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">ingredients</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">calories</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">milligramsOfSodium</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="下一步是什么">下一步是什么？</h2>
<p>我们希望你喜欢使用这个 codelab 来学习或测试你对 Dart 语言一些最有趣的功能的知识。这里有一些关于现在要做什么的建议。</p>
<ul>
<li>试试<a href="https://dart.dev/codelabs">其他的 Dart 代码实验室</a>.</li>
<li>阅读 <a href="https://dart.dev/guides/language/language-tour">Dart 语言之旅</a>。</li>
<li>玩 <a href="https://dartpad.dev/">DartPad</a>。</li>
<li>获取 <a href="https://dart.dev/get-dart">Dart SDK</a>。</li>
</ul>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/string" term="string" label="string" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/cheatsheet" term="cheatsheet" label="cheatsheet" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/dart" term="dart" label="dart" />
                            
                        
                    
                
            
        </entry>
    
        
        <entry>
            <title type="html"><![CDATA[一起爬山吗?]]></title>
            <link href="https://ohmyweekly.github.io/notes/go-hiking/?utm_source=atom_feed" rel="alternate" type="text/html" />
            
            
                <id>https://ohmyweekly.github.io/notes/go-hiking/</id>
            
            
                    <author>
                        <name>焉知非鱼</name>
                    </author>
            <published>2020-06-25T00:00:00+08:00</published>
            <updated>2020-06-25T00:00:00+08:00</updated>
            
            
            <content type="html"><![CDATA[<blockquote>端午佳节, 登高望远。</blockquote><p>端午节快乐, 一起爬山吗？</p>
]]></content>
            
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/categories/programming" term="programming" label="programming" />
                            
                        
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://ohmyweekly.github.io/tags/hiking" term="hiking" label="hiking" />
                             
                                <category scheme="https://ohmyweekly.github.io/tags/holiday" term="holiday" label="holiday" />
                            
                        
                    
                
            
        </entry>
    
</feed>
