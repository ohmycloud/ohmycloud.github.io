<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
    
    
    

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">

    
    <meta name="referrer" content="no-referrer">

    <title>
        
            焉知非鱼 ❚
        
    </title>

    
    


    
    
    
    

    
    
    
    

    
    
    

    
    
    
    <style>
     
     
     :root {
         --theme-color: #ac4142;
         --theme-color-light: rgba(172, 65, 66, 0.2);
     }
     
     html {
         line-height: 1.5;
     }
    </style>

    
    

    
    
    
    
    <link rel="stylesheet" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css">
    
    <link rel="preload" href="/css/refined.min.7f6d3ee611034e4ebcbc063f1db3bc042fecdc8901afbedad80ff02bae409204.css" as="style">

    



    
        <style>
         
         /* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%;background-color: #ffffcc }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }

         
         /* Overrides on top of the theme and Chroma CSS */
/* Chroma-based lines highlighting in code blocks */
.chroma .hl {
    background-color: #e8e8e8;
    /* Extend highlight up to 100 characters (assuming that the code blocks never have more than 100 characters in a line) */
    min-width: 100ch;
}
/* GenericHeading */ .chroma .gh { color: #999999; font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa; font-weight: bold }

         
        </style>
    

    

    
    
    

    
    <script src="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js"></script>
    
    <link rel="preload" href="/js/responsive-nav-orig.min.e2b5f2a956b488f466da513820636134defdc38b90ed566248960593f2bb4ba5.js" as="script">

    
    
    <script defer src="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js"></script>
    
    <link rel="preload" href="/js/libs/fa/fontawesome-all.min.08916ac0fd078adfb58edc890460e2c8990729aee02bca7586404b56805f5219.js" as="script">

    

    

    
    
    

    
    
<!-- rel="me" links for IndieAuth -->







    
 
<meta property="og:title" content="焉知非鱼" />
<meta property="og:description"
      content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ohmycloud.github.io/" />


    
        <meta property="og:updated_time" content="2022-12-27T00:00:00&#43;00:00"/>
    












     <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="焉知非鱼"/>
<meta name="twitter:description" content=""/>


    
    
    <link rel="alternate" type="application/rss+xml" href="https://ohmycloud.github.io/index.xml" title="Rss for 焉知非鱼" />
    <link rel="alternate" type="application/atom+xml" href="https://ohmycloud.github.io/atom.xml" title="Atom for 焉知非鱼" />
    <link rel="alternate" type="application/jf2feed+json" href="https://ohmycloud.github.io/jf2feed.json" title="Jf2feed for 焉知非鱼" />
    
     






    
    
    
    <meta name="hugo-build-date" content="2024-03-01T16:16:06Z"/>
    <meta name="hugo-commit-hash" content="312735366b20d64bd61bff8627f593749f86c964"/>
    <meta name="generator" content="Hugo 0.123.7">
</head>


    
        <body lang="en">
    

        
        <div class="border" id="home"></div>

        <div class="wrapper">   
            
<nav id="nav" class="nav-collapse opened" aria-hidden="false">
    <ul class="navbar">
        <li><a class="active" href="/">Home</a></li>
        
            
                <li><a class="" href="https://ohmycloud.github.io/posts/">Posts</a></li>
            
        
            
                <li><a class="" href="https://ohmycloud.github.io/notes/">Notes</a></li>
            
        
        
            <li><a class="" href="https://ohmycloud.github.io/search/">Search</a></li>
        
    </ul>
</nav>

            <div class="container">
                <header class="masthead">
                    <div class="masthead-title no-text-decoration">
                        <a href="/">焉知非鱼</a> <span class="blinking-cursor">❚</span>
                    </div>
                    <div class="masthead-tagline">
                        Wait the light to fall
                    </div>
                </header>

                

<div class="posts h-feed">
    <header>
        
        <data class="u-url" value="https://ohmycloud.github.io/"></data>
         





        <data class="p-name" value="焉知非鱼"></data>
    </header>
    
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/examples-for-buiding-stateful-streaming-applications-with-apache-flink/'> 用 Apache Flink 创建带状态的流式应用</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2020-02-16T20:06:04+0000" class="dt-published">Sun Feb 16, 2020</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>首先创建项目框架 在终端中执行如下命令:
curl https://flink.apache.org/q/quickstart-scala-SNAPSHOT.sh | bash -s 1.10.0 此例子中使用了 flink-table 依赖, 我们在 pom 文件中加入它:
&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-table-common --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-common&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; </p>

    </div>

    
    
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/why-you-might-be-misusing-spark-streaming-api/'> 为什么你可能会误用 Spark Streaming API</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-11-22T19:34:09+0000" class="dt-published">Fri Nov 22, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>免责声明：是的，我知道这个话题有些争议，而且我知道大多数信息都在 Spark 文档中针对其 Streaming API 进行了介绍，但是当我看到这个错误发生了很多遍之后，我感到写这篇博客的冲动很强烈。
我经常会看到来自 Spark Streaming 的新手在 StackOverflow 上提问，大致如下所示：
问题：“我正在尝试执行 XYZ，但无法正常工作，该怎么办？ 这是我的代码：”
val sparkContext = new SparkContext(&#34;MyApp&#34;) val streamingContext = new StreamingContext(sparkContext, Seconds(4)) val dataStream = streamingContext.socketTextStream(&#34;127.0.0.1&#34;, 1337) dataStream.foreachRDD { rdd =&gt; // Process RDD Here } 嗯，好吧，这是怎么了？ 当我开始学习 Spark 时，我的第一个着陆点是有关 RDD（弹性分布式数据集）如何工作的解释。通常的例子是单词统计，其中所有操作都在 RDD 上执行。我认为可以肯定的是，这是许多其他学习 Spark 的人的切入点（尽管如今 DataFrame\Sets 已成为初学者的首选方法）。
当人们飞跃使用 Spark Streaming 时，可能有点不清楚 DStream 的附加抽象意味着什么。这导致许多人寻求他们可以掌握的东西，他们遇到的最熟悉的方法是 foreachRDD，该方法将 RDD 作为输入并产生 Unit（典型的副作用方法的结果）。然后，他们可以再次在他们已经感到满意和理解的 RDD 级别上工作。这完全遗漏了 DStreams 的要点，这就是为什么我想简要了解一下我们可以在 DStream 本身上做些什么而无需探究底层 RDD 的原因。</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/why-you-might-be-misusing-spark-streaming-api/'
               title="Read more about 为什么你可能会误用 Spark Streaming API">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about 为什么你可能会误用 Spark Streaming API</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/exploring-stateful-streaming-with-apache-spark/'> 探索 Apache Spark 中的状态流</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-11-22T17:51:31+0000" class="dt-published">Fri Nov 22, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>更新(2017.08.01): Spark v2.2 最近推出了一个叫做 mapGroupsWithState 的有状态流的新抽象, 我最近有一篇博客也是关于它的。我强烈建议你检查一下。
介绍 Apache Spark 由几个模块组成，每个模块都有不同的用途。 它的功能强大的模块之一是 Streaming API，它使开发人员能够在称为 Discretized Stream 或 DStream 的抽象下使用连续流（或准确地说是微批次）。
在这篇文章中，我将深入探讨 Spark Streaming 的一个特殊属性，它是有状态的 Streaming API。 有状态流使我们能够维护微批之间的状态，从而使我们能够形成数据的会话化。
免责声明-为了遵循本文的流程，应该对 Spark 的工作原理有基本的了解，并对 DStream 抽象具有一般的了解。 如果没有，请继续阅读，不用担心，我会等你&hellip;
欢迎回来！ 让我们继续。
通过例子理解 为了了解如何使用 API​​，让我们创建一个简单的传入数据示例，该示例要求我们进行会话化。我们的输入数据流将是 UserEvent 类型：
case class UserEvent(id: Int, data: String, isLast: Boolean) 每个事件描述一个唯一的用户。我们通过用户 ID 标识用户，并用 String 表示发生的事件的内容。我们还想知道用户何时结束会话，因此我们提供了一个 isLast 标志来指示会话结束。
我们负责汇总所有用户事件的状态将是 UserSession 类型的状态：
case class UserSession(userEvents: Seq[UserEvent]) 其中包含特定用户发生的事件序列。在此示例中，我们假设数据源是来自于 Kafka 使用的 JSON 编码数据流。
我们的 Id 属性将用作键，而 UserEvent 将是我们的值。两个放在一块，我们得到一个 DStream[(Int, UserEvent)]。</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/exploring-stateful-streaming-with-apache-spark/'
               title="Read more about 探索 Apache Spark 中的状态流">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about 探索 Apache Spark 中的状态流</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/a-closer-look-at-ownership-in-rust/'> 细究 Rust 中的所有权</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-11-03T10:58:17+0000" class="dt-published">Sun Nov 3, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>所以，您想学习 Rust，并不断了解所有权和借用的概念，但不能完全了解它的含义。所有权至关重要，因此在学习 Rust 的过程中尽早理解它是很好的，而且还可以避免遇到导致您无法实现程序的编译器错误。
在上一篇文章中，我们已经从 JavaScript 开发人员的角度讨论了所有权模型。在本文中，我们将仔细研究 Rust 如何管理内存，以及为什么这最终会影响我们在 Rust 中编写代码并保持内存安全的方式。
那么什么是内存安全？ 首先，最重要的是要了解在讨论什么使 Rust 成为一种编程语言时，内存安全实际上意味着什么。特别是当来自非系统编程背景，或者主要具有垃圾回收语言的经验时，可能很难理解 Rust 的这一基本功能。
正如威尔·克里顿（Will Crichton）在他的伟大文章《Rust 的内存安全：C 语言案例研究》中所述：
“内存安全性是程序的属性，其中所使用的内存指针始终指向有效内存，即已分配的内存和正确的类型/大小。内存安全是一个正确性问题-内存不安全程序可能会崩溃，或者会由于错误而产生不确定的输出。”
实际上，这意味着存在允许我们编写“内存不安全”代码的语言，从某种意义上来说，引入错误非常容易。其中一些错误是：
悬空指针：指向无效数据的指针（一旦我们查看数据在内存中的存储方式，这将更有意义）。您可以在此处阅读有关悬空指针的更多信息。
两次释放：尝试两次释放相同的内存位置，这可能导致“未定义的行为”。在这里查看更多信息。
为了说明悬空指针的概念，让我们看一下下面的 C++ 代码及其在内存中的表示方式：
std::string s = &#34;Have a nice day&#34;; 初始化的字符串在内存中通常使用如下的栈和堆表示：
buffer / capacity / / length / / / +–––+––––+––––+ stack frame │ • │ 16 │ 15 │ &lt;– s +–│–+––––+––––+ │ [–│––––––––––––––––––––––––– capacity ––––––––––––––––––––––––––] │ +–V–+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+ heap │ H │ a │ v │ e │ │ a │ │ n │ i │ c │ e │ │ d │ a │ y │ │ +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+ [––––––––––––––––––––––––– length ––––––––––––––––––––––––––] 我们将在一秒钟之内介绍一下栈和堆的内容，但是现在很重要的一点是，要知道存储在栈中的是 std::string 对象本身，它的长度为三个字，固定大小。这些字段是指向堆分配缓冲区的指针，该缓冲区保存实际数据，缓冲区容量和文本长度。换句话说，std::string 拥有其缓冲区。程序销毁该字符串时，也会通过该字符串的析构函数释放相应的缓冲区。</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/a-closer-look-at-ownership-in-rust/'
               title="Read more about 细究 Rust 中的所有权">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about 细究 Rust 中的所有权</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/execute-shell-command-in-spark-streaming-application/'> 在 Spark Streaming 程序中执行 shell 命令</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-10-21T16:16:38+0000" class="dt-published">Mon Oct 21, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>我有个 Spark FileStreaming 程序，当监控到一个批次完成后，就执行 hdfs 的 mv 命令：
import scala.sys.process._ import org.apache.spark.streaming.StreamingContext import org.apache.spark.streaming.scheduler.{StreamingListener, StreamingListenerBatchCompleted} class StreamingMonitor(ssc: StreamingContext) extends StreamingListener { override def onBatchCompleted(batchCompleted: StreamingListenerBatchCompleted): Unit = { try { val day = Seq(&#34;sh&#34;, &#34;-c&#34;, &#34;hdfs dfs -cat /tmp/apps/days.txt | head -1&#34;).!!.trim // 取日期文本文件的第一行 Seq(&#34;sh&#34;, &#34;-c&#34;, s&#34;&#34;&#34; if hdfs dfs -test -e /a26_adapter_data/nation/vintype=A26/d=${day}; then hdfs dfs -mv /a26_adapter_data/nation/vintype=A26/d=${day} /daily_parquet/nation/vintype=A26 fi &#34;&#34;&#34;).!! Seq(&#34;sh&#34;, &#34;-c&#34;, s&#34;&#34;&#34; if hdfs dfs -test -e /a26_adapter_data/enterprise/vintype=A26/dt=${day}; then hdfs dfs -mv /a26_adapter_data/enterprise/vintype=A26/dt=${day} /daily_parquet/enterprise/vintype=A26 fi &#34;&#34;&#34;).</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/execute-shell-command-in-spark-streaming-application/'
               title="Read more about 在 Spark Streaming 程序中执行 shell 命令">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about 在 Spark Streaming 程序中执行 shell 命令</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/triggers-in-spark-structured-streaming/'> Spark Structured Streaming 中的触发器</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-10-04T12:55:38+0000" class="dt-published">Fri Oct 4, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>最近几周，我专注于 Apache Beam 项目。经过一番阅读之后，我发现了 Beam 和 Spark 结构化流之间的许多相似概念（或反之？）。相似之处之一就是触发器。
经过数月的休息后，本文介绍了另一个 Apache Spark 功能，即触发器。第一部分介绍了 Apache Spark 结构化流项目的上下文中的触发器。第二个显示了一些实现细节。最后一部分包含一些学习测试，显示了触发器如何工作。
触发器角色 Spark 触发器与 Apache Beam 中的触发器具有相似的作用，即，它们确定何时开始对累积数据进行处理。该处理的执行显然会向结果表发出新数据。关于 Apache Spark 中基于流的先前版本（基于 DStream），触发器的概念类似于批处理间隔属性。
在描述的版本（2.2.1）中，Spark 中有2种不同的触发器类型。第一种类型基于处理时间。它根据处理时间按固定间隔执行流查询。可以以任何单位时间（ms，s，min，&hellip;）定义此间隔。第二种类型称为once，因为它仅执行一次查询。执行后，查询终止，即使有新数据到达，查询也不会再次开始。
默认情况下，Apache Spark 结构化流以 0 ms的基于处理时间的触发器执行查询。这意味着 Spark 将在处理完之前的查询后尽快启动新查询。仅当存在新数据时，才会执行新的执行。
触发器内部 在内部，触发器分组在 org.apache.spark.sql.streaming.Trigger 类中，其中每种触发器类型都由一个或多个工厂方法表示。在处理时间的情况下，我们可以使用以下方法创建触发器：ProcessingTime（长间隔Ms），ProcessingTime（长间隔，TimeUnit timeUnit），ProcessingTime（持续时间间隔）或 ProcessingTime（字符串间隔）。它们全部都从 org.apache.spark.sql.streaming.ProcessingTime 对象调用幕后创建或应用方法。一次触发器由返回 OneTimeTrigger 案例对象的 Once() 表示。
如此创建的触发器实例稍后将在流查询中用作 org.apache.spark.sql.execution.streaming.StreamExecution 属性的一部分。在此实例中，触发器用于构建org.apache.spark.sql.execution.streaming.TriggerExecutor 实现的正确实例，该实现将是 ProcessingTimeExecutor 来处理基于时间的触发器，或者是 OneTimeExecutor 来执行一次触发器。
稍后，流查询由 TriggerExecutor的execute(triggerHandler: ()=&gt; Boolean) 方法执行。此方法的实现取决于触发器类型。对于一次执行的触发器，execute 方法仅启动一次 TriggerHandler 函数。对于ProcessingTimeExecutor，execute 方法是一个长时间运行的过程（while(true)循环），其中触发器在执行查询之前等待间隔时间。
触发器还与 org.apache.spark.sql.execution.streaming.ProgressReporter#finishTrigger(hasNewData: Boolean) 方法中定义的统计信息有关。
触发器范例 下面的学习测试显示了一些触发特性：
&#34;once trigger&#34; should &#34;execute the query only once&#34; in { val inputStream = new MemoryStream[Int](1, sparkSession.</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/triggers-in-spark-structured-streaming/'
               title="Read more about Spark Structured Streaming 中的触发器">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about Spark Structured Streaming 中的触发器</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/output-modes-in-spark-structured-streaming/'> Spark Structured Streaming 中的输出模式</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-10-04T12:05:27+0000" class="dt-published">Fri Oct 4, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>结构化流引入了许多有关基于 DStream 的流的新概念。其中之一是输出模式。
这篇文章介绍了 Spark 2.0.0 中引入的用于处理流数据输出的输出模式。第一部分通过简短的理论部分向他们展示。第二部分介绍了它们的 API。最后一部分显示了它们在某些学习测试中的工作方式。
输出模式定义 输出模式指定将数据写入结果表的方式。在可用的输出模式中，我们可以区分:
追加(append)-这里仅将新行写入输出接收器。此模式保留给处理，不进行任何汇总，非常适合不可变的结果。 需要注意的重要一点是与水位的关系。如果在聚合中定义了水位，则它控制何时将附加数据发送到结果表。它仅在“中间”状态（=处理期间更改的状态）完成之后才发生。仅当水位的新值在给定组中的最新条目之前通过时，才会发生这种情况。例如，假设水位设置为19:00:00，并且组“A”的记录的最新值来自 19:00:05。现在，当水位传递到 19:00:06时，组“A”的结果将被发送到结果表。引擎认为不会传递任何新的事件，因此可以安全地将结果发送到输出表。 完成(compelete)-在这种模式下，所有行每次都被写入输出接收器。当流有一些更新时，将进行写入。此模式专用于具有聚合的处理。 更新(update)-与上一个相似，不同之处在于仅将更新的行写入输出接收器。 输出模式 API 输出模式定义发生在 DataStreamWriter#outputMode（outputMode: String）方法中。因此，传递的名称稍后会从 InternalOutputModes 对象转换为相应的 case 对象。
解析的实例主要在 DataStreamWriter 类中使用。它从那里传递到 StreamingQueryManager#startQuery(userSpecifiedName: Option[String], userSpecifiedCheckpointLocation: Option[String], df: DataFrame, sink: Sink, outputMode: OutputMode, useTempCheckpointLocation: Boolean = false, recoverFromCheckpointLocation: Boolean = true, trigger: Trigger = ProcessingTime(0), triggerClock: Clock = new SystemClock()).。顾名思义，此方法开始执行流查询。
在物理执行方面，我们可以在 StateStoreSaveExec 中找到输出模式的轨迹。在那里存储中间状态结果。顺便说一下，我们可以找到许多有关水位的参考，有助于消除过时的结果。如果您想了解更多信息，请转到 Apache Spark 结构化流中有关 StateStore 的文章。
输出模式示例 下表总结了可用于给定类型的处理的模式。在每个测试之后，编写一些测试以显示使用情况和未使用情况:
带水位的聚合 附加模式: 受支持-但结果仅在超过水位后才发出（=输出完成）。如果未将汇总应用于水位的列，则该查询将不起作用。 完整模式: 受支持-与更新不同，不使用水位 更新模式: 支持-水位用于删除太旧的聚合 测试:</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/output-modes-in-spark-structured-streaming/'
               title="Read more about Spark Structured Streaming 中的输出模式">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about Spark Structured Streaming 中的输出模式</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/fault-tolerance-inspark-structured-streaming/'> Spark Structured Streaming 中的容错</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-10-04T11:34:28+0000" class="dt-published">Fri Oct 4, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>结构化流可通过应用于状态管理，数据源和数据接收器的语义来保证端到端的一次精确交付（以微批处理模式）。关于状态的帖子更详细地介绍了状态，但还有2个其他部分尚待发现。
这篇文章分为2个主要部分。第一部分着眼于数据源，并说明了在微批量处理的情况下，一旦交付，它们将如何对端到端做出贡献。第二部分是关于接收器的部分，而最后一部分则是在一个示例中总结了所有理论要点。
数据源 就正好一次处理而言，源必须是可重播的。也就是说，它必须允许跟踪当前的读取位置，还必须从上一个故障位置开始重新处理。这两个属性都有助于在任意失败（包括 driver 或 executor）后恢复处理状态。可重播源的一个很好的例子是 Apache Kafka 或其基于云的同事 Amazon Kinesis。两者都能够跟踪当前读取的元素-带偏移量的 Kafka 和带序列号的 Kinesis。不可重播源的一个很好的例子是 org.apache.spark.sql.execution.streaming.MemoryStream，在关闭应用程序后由于数据存储在易失性内存中而无法恢复。
借助检查点机制，可以跟踪已处理的偏移量。在结构化流中，检查点文件中存储的项主要是有关当前批次中处理的偏移量的元数据。检查点存储在 checkpointLocation 选项或 spark.sql.streaming.checkpointLocation 配置条目中指定的位置。
对于微批量执行，检查点将集成在以下架构中：
检查点位置通过 StreamingQueryManager的startQuery 和 createQuery 方法从 DataStreamWriter#startQuery() 方法传递到 StreamExecution 抽象类。 StreamExecution 初始化对象 org.apache.spark.sql.execution.streaming.OffsetSeqLog。该对象表示 WAL日志，该日志记录每个已处理批次中存在的偏移量。 该字段表示处理数据源中偏移量的逻辑。当前微批处理的偏移量（我们称其为 N）始终在处理完成之前写入。该事实还假定来自先前微批处理（N-1）的所有数据均已正确写入输出接收器。在以下来自 org.apache.spark.sql.execution.streaming.MicroBatchExecution#constructNextBatch() 的代码段中进行了表示： updateStatusMessage(&#34;Writing offsets to log&#34;) reportTimeTaken(&#34;walCommit&#34;) { assert(offsetLog.add( currentBatchId, availableOffsets.toOffsetSeq(sources, offsetSeqMetadata)), s&#34;Concurrent update to the log. Multiple streaming jobs detected for $currentBatchId&#34;) logInfo(s&#34;Committed offsets for batch $currentBatchId. &#34; + s&#34;Metadata ${offsetSeqMetadata.toString}&#34;) // NOTE: The following code is correct because runStream() processes exactly one // batch at a time.</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/fault-tolerance-inspark-structured-streaming/'
               title="Read more about Spark Structured Streaming 中的容错">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about Spark Structured Streaming 中的容错</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/inner-joins-between-streams-in-spark-structured-streaming/'> Spark Structured Streaming 中流之间的内连接</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-10-04T10:53:37+0000" class="dt-published">Fri Oct 4, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>Apache Kafka Streams 支持流之间的连接，社区对 Apache Spark 期望相同。此功能已在最新的 2.3.0 版本中实现并发布，在此之后的几个月后，现在是讨论该功能的好时机。
该帖子由 2 个部分组成。第一个介绍了流管道中的连接的想法。下一个讨论两种受支持的类型之一-内连接。
连接和流 在流上执行连接操作非常具有挑战性，这有很多原因。最明显的是延迟。对于有界数据源，要连接的所有数据都就位，而对于基于流的数据源，数据则在不断移动。有时（通常？）移动速度不同。可能是由于技术方面的问题（例如摄入管道问题），或者仅是由于功能要求，而相关事件并非总是在相似的时间段内生成。这种功能限制之一可能是在电子商务商店中的订购过程，在该过程中，订单很难很快完成。因此，连接操作必须以某种方式管理相关但非常异步的事件的情况。
解决的另一个重要点是状态管理。由于给定事件的数据可能随时（非常晚）到达，并且存储该事件的存储空间有限，因此引擎必须弄清楚如何处理累积状态，尤其是何时丢弃它。此特定时间对应于我们不希望为给定的连接键接收任何新事件的时刻。
Apache Spark 结构化流提供了连接 2 个或更多流的功能，从而解决了 2.3.0 版本中的两个问题。流到流的连接可以通过以下时间轴来表征：
连接语义与批连接相同 找到匹配元素后立即生成输出（内连接） 水位和时间范围查询用于连接较晚的数据，并确定何时不再发生给定键的其他事件（状态丢弃） 支持不同的连接类型：内连和外连 连接可以级联，即应用于两个以上的流 但是，从 Apache Spark 2.3.1 开始，流到流连接具有几个限制：
它只能与 append 输出模式一起使用（已计划支持其他模式） 连接之前仅支持类似 map 的操作，例如我们不能在连接之前进行聚合 流的内连接 支持的第一种流到流连接是内连接。由于当没有匹配的行不发出时是严格的连接，因此连接的列不需要任何时间限制。但是，这样做很危险，因为即使没有匹配的行也可能在状态存储中保留很长时间。这是因为建议使用一种条件来告知特定键的状态应保留多长时间。下面显示了不清除状态时内连接的最简单情况：
it should &#34;output the result as soon as it arrives without watermark&#34; in { val mainEventsStream = new MemoryStream[MainEvent](1, sparkSession.sqlContext) val joinedEventsStream = new MemoryStream[JoinedEvent](2, sparkSession.sqlContext) val stream = mainEventsStream.toDS().join(joinedEventsStream.toDS(), $&#34;mainKey&#34; === $&#34;joinedKey&#34;) val query = stream.</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/inner-joins-between-streams-in-spark-structured-streaming/'
               title="Read more about Spark Structured Streaming 中流之间的内连接">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about Spark Structured Streaming 中流之间的内连接</span>
            </a>
        </div>
    
</article>
      
    
        <article class="summary h-entry notes">
    <header>
        <h2 class="post-title p-name no-text-decoration"><a class="u-url" href='https://ohmycloud.github.io/notes/outer-joins-in-spark-structured-streaming/'> Spark Structured Streaming 中的外连接</a> </h2>
        
    <div class="taxo no-text-decoration">
         
            
                <ul class="no-bullets inline categories">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts categorized in ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/categories/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
         
            
                <ul class="no-bullets inline tags">
                    
                        
                        
                        
                            
                            
                            
                            
                            
                            <li class="__rakulang__"
                                
                                
                                title="See all 0 posts tagged with ‘rakulang’"
                                
                            >
                                <a class="p-category" href="https://ohmycloud.github.io/tags/rakulang/">rakulang</a>
                            </li>
                        
                    
                </ul>
            
        
    </div>


        


    
    
    <div class="post-date">
        
        <time datetime="2019-10-04T08:25:57+0000" class="dt-published">Fri Oct 4, 2019</time>
        
        
    </div>


    </header>

    <div class="post p-summary" >
        <p>以前，我们在 Apache Spark 中发现了流到流的内连接，但是它们不是唯一受支持的类型。另一个是外连接，使我们可以在不匹配行的情况下连接流。
这篇文章是关于结构化流模块中的外连接的。它的第一部分介绍了有关这种连接的一些理论观点。第二篇展示了如何通过一些 Scala 示例来实现它。
当匹配是可选的 流式外连接与经典的，类似批处理的连接没有什么不同。有了它们，我们总是从一侧获得所有行，即使其中一些行在连接数据集中没有匹配项也是如此。对于 RDBMS 之类的有限数据源，此类不匹配将直接返回，其中 null 表示另一侧的行。但是，无限来源的逻辑是不同的。由于不同的特性，例如网络延迟影响或脱机设备产生事件，因此在给定时刻我们可能没有所有连接的元素。因此，我们必须能够将物理连接推迟到我们确定要连接的大多数行都将到来的那一刻。为此，我们需要将一侧的行存储在某处。并且，如果您还记得 Apache Spark 结构化流中流之间的内连接的文章中的一些注释，则 Apache Spark 为此使用状态存储。下图从鸟瞰显示了这一点：
该图像清楚地表明，与内连接水位的情况一样，行被缓冲在状态存储中。 外连接还使用水位和范围查询条件的概念来确定何时不应在给定的行中接收第二个流中的任何新匹配。 这就是为什么完全没有水位的外连接是不可能的：
it should &#34;fail without watermark and range condition on watermark in the query&#34; in { val mainEventsStream = new MemoryStream[MainEvent](1, sparkSession.sqlContext) val joinedEventsStream = new MemoryStream[JoinedEvent](2, sparkSession.sqlContext) val mainEventsDataset = mainEventsStream.toDS().select($&#34;mainKey&#34;, $&#34;mainEventTime&#34;, $&#34;mainEventTimeWatermark&#34;) .withWatermark(&#34;mainEventTimeWatermark&#34;, &#34;2 seconds&#34;) val joinedEventsDataset = joinedEventsStream.toDS().select($&#34;joinedKey&#34;, $&#34;joinedEventTime&#34;, $&#34;joinedEventTimeWatermark&#34;) .withWatermark(&#34;joinedEventTimeWatermark&#34;, &#34;2 seconds&#34;) val stream = mainEventsDataset.</p>

    </div>

    
    
    
        <div class="readmore no-text-decoration">
            <a href='https://ohmycloud.github.io/notes/outer-joins-in-spark-structured-streaming/'
               title="Read more about Spark Structured Streaming 中的外连接">
                read <span class="more"> more</span>
                <span class="screen-readers-only" > about Spark Structured Streaming 中的外连接</span>
            </a>
        </div>
    
</article>
      
    
</div>



                <footer>
                    

<div class="pagination no-text-decoration">
    
        <a class="pagination-item newer" href="/page/27/">Newer</a>
    
    
        <a class="pagination-item older" href="/page/29/">Older</a>
    
</div>




                    <ul class="no-bullets feed right inline">
    
        
        
            <li class="inline no-text-decoration">
                <a href="https://ohmycloud.github.io/index.xml">RSS</a>
            </li>
        
    
        
        
            <li class="inline no-text-decoration">
                <a href="https://ohmycloud.github.io/atom.xml">ATOM</a>
            </li>
        
    
        
        
    
</ul>
<div class="clear-float"></div>

                </footer>
                <hr />
            </div>               

            <footer> 
                

<ul class="social no-text-decoration">
    
</ul>










 
    
    



<p class="generated no-text-decoration">
    Generated using  <a href="https://gitlab.com/kaushalmodi/hugo-theme-refined"><code class="nobr">hugo-theme-refined</code></a> + <span class="nobr">Hugo <a href="https://github.com/gohugoio/hugo/commit/312735366b20d64bd61bff8627f593749f86c964">0.123.7</a></span>
</p>

<p>
    
</p>




<div class="badges no-text-decoration">
    
    

    
</div>




<script type="application/javascript">var nav=responsiveNav("#nav");</script>




<script defer src="/js/libs/fragmentions/wrapper.min.e8c468c89edc4f5dccaa8c720c6b220b3088a16cd7b1e4a1e3345985788260c9.js"></script>









            </footer>
        </div> 
    </body>
</html>
